// define global GME variable
var GME = GME || {};

// property to access GME class definitions
GME.classes = GME.classes || {};

// property to access build in dependencies
GME.utils = GME.utils || {};

(function(){
/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.5 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.3.5',
        commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (isNormalized) {
                        normalizedName = name;
                    } else if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap,
                                                      true);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));

define("../node_modules/requirejs/require", function(){});

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('debug',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.debug = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],2:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":1}],3:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"debug":[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))
},{"./debug":2,"_process":3}]},{},[])("debug")
});

/*globals define, debug*/
/*eslint-env node*/
/*eslint no-console: 0*/

/**
 * @author pmeijer / https://github.com/pmeijer
 */

define('client/logger',['debug'], function (_debug) {
    'use strict';
    // Separate namespaces using ',' a leading '-' will disable the namespace.
    // Each part takes a regex.
    //      ex: localStorage.debug = '*,-socket\.io*,-engine\.io*'
    //      will log all but socket.io and engine.io
    function createLogger(name, options) {
        var log = typeof debug === 'undefined' ? _debug(name) : debug(name),
            level,
            levels = {
                silly: 0,
                input: 1,
                verbose: 2,
                prompt: 3,
                debug: 4,
                info: 5,
                data: 6,
                help: 7,
                warn: 8,
                error: 9
            };
        if (!options) {
            throw new Error('options required in logger');
        }
        if (options.hasOwnProperty('level') === false) {
            throw new Error('options.level required in logger');
        }
        level = levels[options.level];
        if (typeof level === 'undefined') {
            level = levels.info;
        }

        log.debug = function () {
            if (log.enabled && level <= levels.debug) {
                if (console.debug) {
                    log.log = console.debug.bind(console);
                } else {
                    log.log = console.log.bind(console);
                }
                log.apply(this, arguments);
            }
        };
        log.info = function () {
            if (log.enabled && level <= levels.info) {
                log.log = console.info.bind(console);
                log.apply(this, arguments);
            }
        };
        log.warn = function () {
            if (log.enabled && level <= levels.warn) {
                log.log = console.warn.bind(console);
                log.apply(this, arguments);
            }
        };
        log.error = function () {
            if (log.enabled && level <= levels.error) {
                log.log = console.error.bind(console);
                log.apply(this, arguments);
            } else {
                console.error.apply(console, arguments);
            }
        };

        log.fork = function (forkName, useForkName) {
            forkName = useForkName ? forkName : name + ':' + forkName;
            return createLogger(forkName, options);
        };

        log.forkWithOptions = function (_name, _options) {
            return createLogger(_name, _options);
        };

        return log;
    }

    function createWithGmeConfig(name, gmeConfig) {
        return createLogger(name, gmeConfig.client.log);
    }

    return {
        create: createLogger,
        createWithGmeConfig: createWithGmeConfig
    };
});
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('q',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.q = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":1,"timers":2}],"q":[function(require,module,exports){
(function (process,setImmediate){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2017 Kris Kowal under the terms of the MIT
 * license found at https://github.com/kriskowal/q/blob/v1/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        // Prefer window over self for add-on scripts. Use self for
        // non-windowed contexts.
        var global = typeof window !== "undefined" ? window : self;

        // Get the `window` object, save the previous Q global
        // and initialize Q as a global.
        var previousQ = global.Q;
        global.Q = definition();

        // Add a noConflict function so Q can be removed from the
        // global namespace.
        global.Q.noConflict = function () {
            global.Q = previousQ;
            return this;
        };

    } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];

    function flush() {
        /* jshint loopfunc: true */
        var task, domain;

        while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
            runSingle(task, domain);

        }
        while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
        }
        flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process === "object" &&
        process.toString() === "[object process]" && process.nextTick) {
        // Ensure Q is in a real Node environment, with a `process.nextTick`.
        // To see through fake Node environments:
        // * Mocha test runner - exposes a `process` global without a `nextTick`
        // * Browserify - exposes a `process.nexTick` function that uses
        //   `setTimeout`. In this case `setImmediate` is preferred because
        //    it is faster. Browserify's `process.toString()` yields
        //   "[object Object]", while in a real Node environment
        //   `process.toString()` yields "[object process]".
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
        laterQueue.push(task);
        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };
    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {
    obj[prop] = descriptor.value;
    return obj;
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
                object_defineProperty(error, "__minimumStackCounter__", {value: p.stackCounter, configurable: true});
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        var stack = filterStackString(concatedStacks);
        object_defineProperty(error, "stack", {value: stack, configurable: true});
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

/**
 * The counter is used to determine the stopping point for building
 * long stack traces. In makeStackTraceLong we walk backwards through
 * the linked list of promises, only stacks which were created before
 * the rejection are concatenated.
 */
var longStackCounter = 1;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
            promise.stackCounter = longStackCounter++;
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;

        if (Q.longStackSupport && hasStacks) {
            // Only hold a reference to the new promise if long stacks
            // are enabled to reduce memory usage
            promise.source = newPromise;
        }

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Q can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function (resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function (answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var reportedUnhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }
    if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
                process.emit("unhandledRejection", reason, promise);
                reportedUnhandledRejections.push(promise);
            }
        });
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                var atReport = array_indexOf(reportedUnhandledRejections, promise);
                if (atReport !== -1) {
                    process.emit("rejectionHandled", unhandledReasons[at], promise);
                    reportedUnhandledRejections.splice(atReport, 1);
                }
            });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++pendingCount;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (pendingCount === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */
Q.any = any;

function any(promises) {
    if (promises.length === 0) {
        return Q.resolve();
    }

    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
        var promise = promises[index];

        pendingCount++;

        when(promise, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
            deferred.resolve(result);
        }
        function onRejected(err) {
            pendingCount--;
            if (pendingCount === 0) {
                var rejection = err || new Error("" + err);

                rejection.message = ("Q can't get fulfillment value from any promise, all " +
                    "promises were rejected. Last error message: " + rejection.message);

                deferred.reject(rejection);
            }
        }
        function onProgress(progress) {
            deferred.notify({
                index: index,
                value: progress
            });
        }
    }, undefined);

    return deferred.promise;
}

Promise.prototype.any = function () {
    return any(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    if (!callback || typeof callback.apply !== "function") {
        throw new Error("Q can't apply finally callback");
    }
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    if (callback === undefined) {
        throw new Error("Q can't wrap an undefined function");
    }
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

Q.noConflict = function() {
    throw new Error("Q.noConflict only works when Q is used as a global");
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require('_process'),require("timers").setImmediate)
},{"_process":1,"timers":2}]},{},[])("q")
});

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('webgme-ot',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.webgmeOt = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// translation of https://github.com/djspiewak/cccp/blob/master/agent/src/main/scala/com/codecommit/cccp/agent/state.scala
var log = function (){};

function Client(revision) {
    this.revision = revision; // the next expected revision number
    this.state = synchronized_; // start state
}

Client.prototype.setState = function (state) {
    this.state = state;
    this.state.logState(this);
};

// Call this method when the user changes the document.
Client.prototype.applyClient = function (operation) {
    this.setState(this.state.applyClient(this, operation));
};

// Call this method with a new operation from the server
Client.prototype.applyServer = function (operation) {
    this.revision++;
    this.setState(this.state.applyServer(this, operation));
};

Client.prototype.serverAck = function () {
    this.revision++;
    this.setState(this.state.serverAck(this));
};

Client.prototype.serverReconnect = function () {
    if (typeof this.state.resend === 'function') {
        this.state.resend(this);
    }
};

// Transforms a selection from the latest known server state to the current
// client state. For example, if we get from the server the information that
// another user's cursor is at position 3, but the server hasn't yet received
// our newest operation, an insertion of 5 characters at the beginning of the
// document, the correct position of the other user's cursor in our current
// document is 8.
Client.prototype.transformSelection = function (selection) {
    return this.state.transformSelection(selection);
};

// Override this method.
Client.prototype.sendOperation = function (revision, operation) {
    throw new Error("sendOperation must be defined in child class");
};

// Override this method.
Client.prototype.applyOperation = function (operation) {
    throw new Error("applyOperation must be defined in child class");
};


// In the 'Synchronized' state, there is no pending operation that the client
// has sent to the server.
function Synchronized() {
}

Client.Synchronized = Synchronized;

Synchronized.prototype.applyClient = function (client, operation) {
    // When the user makes an edit, send the operation to the server and
    // switch to the 'AwaitingConfirm' state
    client.sendOperation(client.revision, operation);
    return new AwaitingConfirm(operation);
};

Synchronized.prototype.applyServer = function (client, operation) {
    // When we receive a new operation from the server, the operation can be
    // simply applied to the current document
    client.applyOperation(operation);
    return this;
};

Synchronized.prototype.serverAck = function (client) {
    throw new Error("There is no pending operation.");
};

// Nothing to do because the latest server state and client state are the same.
Synchronized.prototype.transformSelection = function (x) {
    return x;
};

Synchronized.prototype.logState = function (client) {
    log('Synchronized at revision', client.revision);
};

// Singleton
var synchronized_ = new Synchronized();


// In the 'AwaitingConfirm' state, there's one operation the client has sent
// to the server and is still waiting for an acknowledgement.
function AwaitingConfirm(outstanding) {
    // Save the pending operation
    this.outstanding = outstanding;
}

Client.AwaitingConfirm = AwaitingConfirm;

AwaitingConfirm.prototype.applyClient = function (client, operation) {
    // When the user makes an edit, don't send the operation immediately,
    // instead switch to 'AwaitingWithBuffer' state
    return new AwaitingWithBuffer(this.outstanding, operation);
};

AwaitingConfirm.prototype.applyServer = function (client, operation) {
    // This is another client's operation. Visualization:
    //
    //                   /\
    // this.outstanding /  \ operation
    //                 /    \
    //                 \    /
    //  pair[1]         \  / pair[0] (new outstanding)
    //  (can be applied  \/
    //  to the client's
    //  current document)
    var pair = operation.constructor.transform(this.outstanding, operation);
    client.applyOperation(pair[1]);
    return new AwaitingConfirm(pair[0]);
};

AwaitingConfirm.prototype.serverAck = function (client) {
    // The client's operation has been acknowledged
    // => switch to synchronized state
    return synchronized_;
};

AwaitingConfirm.prototype.transformSelection = function (selection) {
    return selection.transform(this.outstanding);
};

AwaitingConfirm.prototype.resend = function (client) {
    // The confirm didn't come because the client was disconnected.
    // Now that it has reconnected, we resend the outstanding operation.
    client.sendOperation(client.revision, this.outstanding);
};

AwaitingConfirm.prototype.logState = function (client) {
    log('AwaitingConfirm at revision', client.revision, '\noperation:', this.outstanding);
};


// In the 'AwaitingWithBuffer' state, the client is waiting for an operation
// to be acknowledged by the server while buffering the edits the user makes
function AwaitingWithBuffer(outstanding, buffer) {
    // Save the pending operation and the user's edits since then
    this.outstanding = outstanding;
    this.buffer = buffer;
}

Client.AwaitingWithBuffer = AwaitingWithBuffer;

AwaitingWithBuffer.prototype.applyClient = function (client, operation) {
    // Compose the user's changes onto the buffer
    var newBuffer = this.buffer.compose(operation);
    return new AwaitingWithBuffer(this.outstanding, newBuffer);
};

AwaitingWithBuffer.prototype.applyServer = function (client, operation) {
    // Operation comes from another client
    //
    //                       /\
    //     this.outstanding /  \ operation
    //                     /    \
    //                    /\    /
    //       this.buffer /  \* / pair1[0] (new outstanding)
    //                  /    \/
    //                  \    /
    //          pair2[1] \  / pair2[0] (new buffer)
    // the transformed    \/
    // operation -- can
    // be applied to the
    // client's current
    // document
    //
    // * pair1[1]
    var transform = operation.constructor.transform;
    var pair1 = transform(this.outstanding, operation);
    var pair2 = transform(this.buffer, pair1[1]);
    client.applyOperation(pair2[1]);
    return new AwaitingWithBuffer(pair1[0], pair2[0]);
};

AwaitingWithBuffer.prototype.serverAck = function (client) {
    // The pending operation has been acknowledged
    // => send buffer
    client.sendOperation(client.revision, this.buffer);
    return new AwaitingConfirm(this.buffer);
};

AwaitingWithBuffer.prototype.transformSelection = function (selection) {
    return selection.transform(this.outstanding).transform(this.buffer);
};

AwaitingWithBuffer.prototype.resend = function (client) {
    // The confirm didn't come because the client was disconnected.
    // Now that it has reconnected, we resend the outstanding operation.
    client.sendOperation(client.revision, this.outstanding);
};

AwaitingWithBuffer.prototype.logState = function (client) {
    log('AwaitingWithBuffer at revision', client.revision, '\noperation:', this.outstanding);
};


module.exports = Client;


},{}],2:[function(require,module,exports){
var TextOperation = require('./text-operation'),
    Selection = require('./selection'),
    added,
    styleSheet;

function CodeMirrorAdapter(cm) {
    this.cm = cm;
    this.ignoreNextChange = false;
    this.changeInProgress = false;
    this.selectionChanged = false;

    bind(this, 'onChanges');
    bind(this, 'onChange');
    bind(this, 'onCursorActivity');
    bind(this, 'onFocus');
    bind(this, 'onBlur');

    cm.on('changes', this.onChanges);
    cm.on('change', this.onChange);
    cm.on('cursorActivity', this.onCursorActivity);
    cm.on('focus', this.onFocus);
    cm.on('blur', this.onBlur);
}

// Removes all event listeners from the CodeMirror instance.
CodeMirrorAdapter.prototype.detach = function () {
    this.cm.off('changes', this.onChanges);
    this.cm.off('change', this.onChange);
    this.cm.off('cursorActivity', this.onCursorActivity);
    this.cm.off('focus', this.onFocus);
    this.cm.off('blur', this.onBlur);
};

function cmpPos(a, b) {
    if (a.line < b.line) {
        return -1;
    }
    if (a.line > b.line) {
        return 1;
    }
    if (a.ch < b.ch) {
        return -1;
    }
    if (a.ch > b.ch) {
        return 1;
    }
    return 0;
}
function posEq(a, b) {
    return cmpPos(a, b) === 0;
}
function posLe(a, b) {
    return cmpPos(a, b) <= 0;
}

function minPos(a, b) {
    return posLe(a, b) ? a : b;
}
function maxPos(a, b) {
    return posLe(a, b) ? b : a;
}

function codemirrorDocLength(doc) {
    return doc.indexFromPos({line: doc.lastLine(), ch: 0}) +
        doc.getLine(doc.lastLine()).length;
}

// Converts a CodeMirror change array (as obtained from the 'changes' event
// in CodeMirror v4) or single change or linked list of changes (as returned
// by the 'change' event in CodeMirror prior to version 4) into a
// TextOperation and its inverse and returns them as a two-element array.
CodeMirrorAdapter.operationFromCodeMirrorChanges = function (changes, doc) {
    // Approach: Replay the changes, beginning with the most recent one, and
    // construct the operation and its inverse. We have to convert the position
    // in the pre-change coordinate system to an index. We have a method to
    // convert a position in the coordinate system after all changes to an index,
    // namely CodeMirror's `indexFromPos` method. We can use the information of
    // a single change object to convert a post-change coordinate system to a
    // pre-change coordinate system. We can now proceed inductively to get a
    // pre-change coordinate system for all changes in the linked list.
    // A disadvantage of this approach is its complexity `O(n^2)` in the length
    // of the linked list of changes.

    var docEndLength = codemirrorDocLength(doc);
    var operation = new TextOperation().retain(docEndLength);
    var inverse = new TextOperation().retain(docEndLength);

    var indexFromPos = function (pos) {
        return doc.indexFromPos(pos);
    };

    function last(arr) {
        return arr[arr.length - 1];
    }

    function sumLengths(strArr) {
        if (strArr.length === 0) {
            return 0;
        }
        var sum = 0;
        for (var i = 0; i < strArr.length; i++) {
            sum += strArr[i].length;
        }
        return sum + strArr.length - 1;
    }

    function updateIndexFromPos(indexFromPos, change) {
        return function (pos) {
            if (posLe(pos, change.from)) {
                return indexFromPos(pos);
            }
            if (posLe(change.to, pos)) {
                return indexFromPos({
                        line: pos.line + change.text.length - 1 - (change.to.line - change.from.line),
                        ch: (change.to.line < pos.line) ?
                            pos.ch :
                            (change.text.length <= 1) ?
                            pos.ch - (change.to.ch - change.from.ch) + sumLengths(change.text) :
                            pos.ch - change.to.ch + last(change.text).length
                    }) + sumLengths(change.removed) - sumLengths(change.text);
            }
            if (change.from.line === pos.line) {
                return indexFromPos(change.from) + pos.ch - change.from.ch;
            }
            return indexFromPos(change.from) +
                sumLengths(change.removed.slice(0, pos.line - change.from.line)) +
                1 + pos.ch;
        };
    }

    for (var i = changes.length - 1; i >= 0; i--) {
        var change = changes[i];
        indexFromPos = updateIndexFromPos(indexFromPos, change);

        var fromIndex = indexFromPos(change.from);
        var restLength = docEndLength - fromIndex - sumLengths(change.text);

        operation = new TextOperation()
            .retain(fromIndex)
            ['delete'](sumLengths(change.removed))
            .insert(change.text.join('\n'))
            .retain(restLength)
            .compose(operation);

        inverse = inverse.compose(new TextOperation()
            .retain(fromIndex)
            ['delete'](sumLengths(change.text))
            .insert(change.removed.join('\n'))
            .retain(restLength)
        );

        docEndLength += sumLengths(change.removed) - sumLengths(change.text);
    }

    return [operation, inverse];
};

// Singular form for backwards compatibility.
CodeMirrorAdapter.operationFromCodeMirrorChange =
    CodeMirrorAdapter.operationFromCodeMirrorChanges;

// Apply an operation to a CodeMirror instance.
CodeMirrorAdapter.applyOperationToCodeMirror = function (operation, cm) {
    cm.operation(function () {
        var ops = operation.ops;
        var index = 0; // holds the current index into CodeMirror's content
        for (var i = 0, l = ops.length; i < l; i++) {
            var op = ops[i];
            if (TextOperation.isRetain(op)) {
                index += op;
            } else if (TextOperation.isInsert(op)) {
                cm.replaceRange(op, cm.posFromIndex(index));
                index += op.length;
            } else if (TextOperation.isDelete(op)) {
                var from = cm.posFromIndex(index);
                var to = cm.posFromIndex(index - op);
                cm.replaceRange('', from, to);
            }
        }
    });
};

CodeMirrorAdapter.prototype.registerCallbacks = function (cb) {
    this.callbacks = cb;
};

CodeMirrorAdapter.prototype.onChange = function () {
    // By default, CodeMirror's event order is the following:
    // 1. 'change', 2. 'cursorActivity', 3. 'changes'.
    // We want to fire the 'selectionChange' event after the 'change' event,
    // but need the information from the 'changes' event. Therefore, we detect
    // when a change is in progress by listening to the change event, setting
    // a flag that makes this adapter defer all 'cursorActivity' events.
    this.changeInProgress = true;
};

CodeMirrorAdapter.prototype.onChanges = function (_, changes) {
    if (!this.ignoreNextChange) {
        var pair = CodeMirrorAdapter.operationFromCodeMirrorChanges(changes, this.cm);
        this.trigger('change', pair[0], pair[1]);
    }
    if (this.selectionChanged) {
        this.trigger('selectionChange');
    }
    this.changeInProgress = false;
    this.ignoreNextChange = false;
};

CodeMirrorAdapter.prototype.onCursorActivity =
    CodeMirrorAdapter.prototype.onFocus = function () {
        if (this.changeInProgress) {
            this.selectionChanged = true;
        } else {
            this.trigger('selectionChange');
        }
    };

CodeMirrorAdapter.prototype.onBlur = function () {
    if (!this.cm.somethingSelected()) {
        this.trigger('blur');
    }
};

CodeMirrorAdapter.prototype.getValue = function () {
    return this.cm.getValue();
};

CodeMirrorAdapter.prototype.getSelection = function () {
    var cm = this.cm;

    var selectionList = cm.listSelections();
    var ranges = [];
    for (var i = 0; i < selectionList.length; i++) {
        ranges[i] = new Selection.Range(
            cm.indexFromPos(selectionList[i].anchor),
            cm.indexFromPos(selectionList[i].head)
        );
    }

    return new Selection(ranges);
};

CodeMirrorAdapter.prototype.setSelection = function (selection) {
    var ranges = [];
    for (var i = 0; i < selection.ranges.length; i++) {
        var range = selection.ranges[i];
        ranges[i] = {
            anchor: this.cm.posFromIndex(range.anchor),
            head: this.cm.posFromIndex(range.head)
        };
    }
    this.cm.setSelections(ranges);
};

CodeMirrorAdapter.addStyleRule = function (css) {
    var styleElement;

    if (!added) {
        added = {};
        styleElement = document.createElement('style');
        document.documentElement.getElementsByTagName('head')[0].appendChild(styleElement);
        styleSheet = styleElement.sheet;
    }

    if (!added[css]) {
        added[css] = true;
        styleSheet.insertRule(css, (styleSheet.cssRules || styleSheet.rules).length);
    }
};

CodeMirrorAdapter.prototype.setOtherCursor = function (position, color, clientId) {
    var cursorPos = this.cm.posFromIndex(position);
    //var cursorCoords = this.cm.cursorCoords(cursorPos);
    var cursorEl = document.createElement('span');
    cursorEl.title = clientId;
    cursorEl.className = 'other-client';
    cursorEl.style.display = 'inline-block';
    cursorEl.style.padding = '0';
    cursorEl.style.marginLeft = cursorEl.style.marginRight = '-1px';
    cursorEl.style.borderLeftWidth = '2px';
    cursorEl.style.borderLeftStyle = 'solid';
    cursorEl.style.borderLeftColor = color;
    cursorEl.style.height = 16 + 'px';
    cursorEl.style['margin-bottom'] = -4 + 'px';
    cursorEl.style.zIndex = 0;
    cursorEl.setAttribute('data-clientid', clientId);
    return this.cm.setBookmark(cursorPos, {widget: cursorEl, insertLeft: true});
};

CodeMirrorAdapter.prototype.setOtherSelectionRange = function (range, color, clientId) {
    var match = /^#([0-9a-fA-F]{6})$/.exec(color);
    if (!match) {
        throw new Error("only six-digit hex colors are allowed.");
    }
    var selectionClassName = 'selection-' + match[1];
    var rule = '.' + selectionClassName + ' { background: ' + color + '; }';

    CodeMirrorAdapter.addStyleRule(rule);

    var anchorPos = this.cm.posFromIndex(range.anchor);
    var headPos = this.cm.posFromIndex(range.head);

    return this.cm.markText(
        minPos(anchorPos, headPos),
        maxPos(anchorPos, headPos),
        {className: selectionClassName}
    );
};

CodeMirrorAdapter.prototype.setOtherSelection = function (selection, color, clientId) {
    var selectionObjects = [],
        cursorColor,
        rangeColor;

    if (typeof color === 'string') {
        cursorColor = rangeColor = color;
    } else {
        cursorColor = color.cursor;
        rangeColor = color.range;
    }

    for (var i = 0; i < selection.ranges.length; i++) {
        var range = selection.ranges[i];
        if (range.isEmpty()) {
            selectionObjects[i] = this.setOtherCursor(range.head, cursorColor, clientId);
        } else {
            selectionObjects[i] = this.setOtherSelectionRange(range, rangeColor, clientId);
        }
    }
    return {
        clear: function () {
            for (var i = 0; i < selectionObjects.length; i++) {
                selectionObjects[i].clear();
            }
        }
    };
};

CodeMirrorAdapter.prototype.trigger = function (event) {
    var args = Array.prototype.slice.call(arguments, 1);
    var action = this.callbacks && this.callbacks[event];
    if (action) {
        action.apply(this, args);
    }
};

CodeMirrorAdapter.prototype.applyOperation = function (operation) {
    this.ignoreNextChange = true;
    CodeMirrorAdapter.applyOperationToCodeMirror(operation, this.cm);
};

CodeMirrorAdapter.prototype.registerUndo = function (undoFn) {
    this.cm.undo = undoFn;
};

CodeMirrorAdapter.prototype.registerRedo = function (redoFn) {
    this.cm.redo = redoFn;
};

// Throws an error if the first argument is falsy. Useful for debugging.
function assert(b, msg) {
    if (!b) {
        throw new Error(msg || "assertion error");
    }
}

// Bind a method to an object, so it doesn't matter whether you call
// object.method() directly or pass object.method as a reference to another
// function.
function bind(obj, method) {
    var fn = obj[method];
    obj[method] = function () {
        fn.apply(obj, arguments);
    };
}

module.exports = CodeMirrorAdapter;

},{"./selection":3,"./text-operation":4}],3:[function(require,module,exports){
var TextOperation = require('./text-operation');

// Range has `anchor` and `head` properties, which are zero-based indices into
// the document. The `anchor` is the side of the selection that stays fixed,
// `head` is the side of the selection where the cursor is. When both are
// equal, the range represents a cursor.
function Range(anchor, head) {
    this.anchor = anchor;
    this.head = head;
}

Range.fromJSON = function (obj) {
    return new Range(obj.anchor, obj.head);
};

Range.prototype.equals = function (other) {
    return this.anchor === other.anchor && this.head === other.head;
};

Range.prototype.isEmpty = function () {
    return this.anchor === this.head;
};

Range.prototype.transform = function (other) {
    function transformIndex(index) {
        var newIndex = index;
        var ops = other.ops;
        for (var i = 0, l = other.ops.length; i < l; i++) {
            if (TextOperation.isRetain(ops[i])) {
                index -= ops[i];
            } else if (TextOperation.isInsert(ops[i])) {
                newIndex += ops[i].length;
            } else {
                newIndex -= Math.min(index, -ops[i]);
                index += ops[i];
            }
            if (index < 0) {
                break;
            }
        }
        return newIndex;
    }

    var newAnchor = transformIndex(this.anchor);
    if (this.anchor === this.head) {
        return new Range(newAnchor, newAnchor);
    }
    return new Range(newAnchor, transformIndex(this.head));
};

// A selection is basically an array of ranges. Every range represents a real
// selection or a cursor in the document (when the start position equals the
// end position of the range). The array must not be empty.
function Selection(ranges) {
    ranges = ranges || [];
    ranges = ranges instanceof Array ? ranges : [ranges];

    this.ranges = ranges.map(function (range) {
        return range instanceof Range ? range : Range.fromJSON(range);
    });
}

Selection.Range = Range;

// Convenience method for creating selections only containing a single cursor
// and no real selection range.
Selection.createCursor = function (position) {
    return new Selection([new Range(position, position)]);
};

Selection.fromJSON = function (obj) {
    var objRanges = obj.ranges || obj;
    for (var i = 0, ranges = []; i < objRanges.length; i++) {
        ranges[i] = Range.fromJSON(objRanges[i]);
    }
    return new Selection(ranges);
};

Selection.prototype.equals = function (other) {
    if (this.position !== other.position) {
        return false;
    }
    if (this.ranges.length !== other.ranges.length) {
        return false;
    }
    // FIXME: Sort ranges before comparing them?
    for (var i = 0; i < this.ranges.length; i++) {
        if (!this.ranges[i].equals(other.ranges[i])) {
            return false;
        }
    }
    return true;
};

Selection.prototype.somethingSelected = function () {
    for (var i = 0; i < this.ranges.length; i++) {
        if (!this.ranges[i].isEmpty()) {
            return true;
        }
    }
    return false;
};

// Return the more current selection information.
Selection.prototype.compose = function (other) {
    return other;
};

// Update the selection with respect to an operation.
Selection.prototype.transform = function (other) {
    for (var i = 0, newRanges = []; i < this.ranges.length; i++) {
        newRanges[i] = this.ranges[i].transform(other);
    }
    return new Selection(newRanges);
};


module.exports = Selection;

},{"./text-operation":4}],4:[function(require,module,exports){
if (typeof ot === 'undefined') {
  // Export for browsers
  var ot = {};
}

ot.TextOperation = (function () {
  'use strict';

  // Constructor for new operations.
  function TextOperation () {
    if (!this || this.constructor !== TextOperation) {
      // => function was called without 'new'
      return new TextOperation();
    }

    // When an operation is applied to an input string, you can think of this as
    // if an imaginary cursor runs over the entire string and skips over some
    // parts, deletes some parts and inserts characters at some positions. These
    // actions (skip/delete/insert) are stored as an array in the "ops" property.
    this.ops = [];
    // An operation's baseLength is the length of every string the operation
    // can be applied to.
    this.baseLength = 0;
    // The targetLength is the length of every string that results from applying
    // the operation on a valid input string.
    this.targetLength = 0;
  }

  TextOperation.prototype.equals = function (other) {
    if (this.baseLength !== other.baseLength) { return false; }
    if (this.targetLength !== other.targetLength) { return false; }
    if (this.ops.length !== other.ops.length) { return false; }
    for (var i = 0; i < this.ops.length; i++) {
      if (this.ops[i] !== other.ops[i]) { return false; }
    }
    return true;
  };

  // Operation are essentially lists of ops. There are three types of ops:
  //
  // * Retain ops: Advance the cursor position by a given number of characters.
  //   Represented by positive ints.
  // * Insert ops: Insert a given string at the current cursor position.
  //   Represented by strings.
  // * Delete ops: Delete the next n characters. Represented by negative ints.

  var isRetain = TextOperation.isRetain = function (op) {
    return typeof op === 'number' && op > 0;
  };

  var isInsert = TextOperation.isInsert = function (op) {
    return typeof op === 'string';
  };

  var isDelete = TextOperation.isDelete = function (op) {
    return typeof op === 'number' && op < 0;
  };


  // After an operation is constructed, the user of the library can specify the
  // actions of an operation (skip/insert/delete) with these three builder
  // methods. They all return the operation for convenient chaining.

  // Skip over a given number of characters.
  TextOperation.prototype.retain = function (n) {
    if (typeof n !== 'number') {
      throw new Error("retain expects an integer");
    }
    if (n === 0) { return this; }
    this.baseLength += n;
    this.targetLength += n;
    if (isRetain(this.ops[this.ops.length-1])) {
      // The last op is a retain op => we can merge them into one op.
      this.ops[this.ops.length-1] += n;
    } else {
      // Create a new op.
      this.ops.push(n);
    }
    return this;
  };

  // Insert a string at the current position.
  TextOperation.prototype.insert = function (str) {
    if (typeof str !== 'string') {
      throw new Error("insert expects a string");
    }
    if (str === '') { return this; }
    this.targetLength += str.length;
    var ops = this.ops;
    if (isInsert(ops[ops.length-1])) {
      // Merge insert op.
      ops[ops.length-1] += str;
    } else if (isDelete(ops[ops.length-1])) {
      // It doesn't matter when an operation is applied whether the operation
      // is delete(3), insert("something") or insert("something"), delete(3).
      // Here we enforce that in this case, the insert op always comes first.
      // This makes all operations that have the same effect when applied to
      // a document of the right length equal in respect to the `equals` method.
      if (isInsert(ops[ops.length-2])) {
        ops[ops.length-2] += str;
      } else {
        ops[ops.length] = ops[ops.length-1];
        ops[ops.length-2] = str;
      }
    } else {
      ops.push(str);
    }
    return this;
  };

  // Delete a string at the current position.
  TextOperation.prototype['delete'] = function (n) {
    if (typeof n === 'string') { n = n.length; }
    if (typeof n !== 'number') {
      throw new Error("delete expects an integer or a string");
    }
    if (n === 0) { return this; }
    if (n > 0) { n = -n; }
    this.baseLength -= n;
    if (isDelete(this.ops[this.ops.length-1])) {
      this.ops[this.ops.length-1] += n;
    } else {
      this.ops.push(n);
    }
    return this;
  };

  // Tests whether this operation has no effect.
  TextOperation.prototype.isNoop = function () {
    return this.ops.length === 0 || (this.ops.length === 1 && isRetain(this.ops[0]));
  };

  // Pretty printing.
  TextOperation.prototype.toString = function () {
    // map: build a new array by applying a function to every element in an old
    // array.
    var map = Array.prototype.map || function (fn) {
      var arr = this;
      var newArr = [];
      for (var i = 0, l = arr.length; i < l; i++) {
        newArr[i] = fn(arr[i]);
      }
      return newArr;
    };
    return map.call(this.ops, function (op) {
      if (isRetain(op)) {
        return "retain " + op;
      } else if (isInsert(op)) {
        return "insert '" + op + "'";
      } else {
        return "delete " + (-op);
      }
    }).join(', ');
  };

  // Converts operation into a JSON value.
  TextOperation.prototype.toJSON = function () {
    return this.ops;
  };

  // Converts a plain JS object into an operation and validates it.
  TextOperation.fromJSON = function (ops) {
    var o = new TextOperation();
    for (var i = 0, l = ops.length; i < l; i++) {
      var op = ops[i];
      if (isRetain(op)) {
        o.retain(op);
      } else if (isInsert(op)) {
        o.insert(op);
      } else if (isDelete(op)) {
        o['delete'](op);
      } else {
        throw new Error("unknown operation: " + JSON.stringify(op));
      }
    }
    return o;
  };

  // Apply an operation to a string, returning a new string. Throws an error if
  // there's a mismatch between the input string and the operation.
  TextOperation.prototype.apply = function (str) {
    var operation = this;
    if (str.length !== operation.baseLength) {
      throw new Error("The operation's base length must be equal to the string's length.");
    }
    var newStr = [], j = 0;
    var strIndex = 0;
    var ops = this.ops;
    for (var i = 0, l = ops.length; i < l; i++) {
      var op = ops[i];
      if (isRetain(op)) {
        if (strIndex + op > str.length) {
          throw new Error("Operation can't retain more characters than are left in the string.");
        }
        // Copy skipped part of the old string.
        newStr[j++] = str.slice(strIndex, strIndex + op);
        strIndex += op;
      } else if (isInsert(op)) {
        // Insert string.
        newStr[j++] = op;
      } else { // delete op
        strIndex -= op;
      }
    }
    if (strIndex !== str.length) {
      throw new Error("The operation didn't operate on the whole string.");
    }
    return newStr.join('');
  };

  // Computes the inverse of an operation. The inverse of an operation is the
  // operation that reverts the effects of the operation, e.g. when you have an
  // operation 'insert("hello "); skip(6);' then the inverse is 'delete("hello ");
  // skip(6);'. The inverse should be used for implementing undo.
  TextOperation.prototype.invert = function (str) {
    var strIndex = 0;
    var inverse = new TextOperation();
    var ops = this.ops;
    for (var i = 0, l = ops.length; i < l; i++) {
      var op = ops[i];
      if (isRetain(op)) {
        inverse.retain(op);
        strIndex += op;
      } else if (isInsert(op)) {
        inverse['delete'](op.length);
      } else { // delete op
        inverse.insert(str.slice(strIndex, strIndex - op));
        strIndex -= op;
      }
    }
    return inverse;
  };

  // Compose merges two consecutive operations into one operation, that
  // preserves the changes of both. Or, in other words, for each input string S
  // and a pair of consecutive operations A and B,
  // apply(apply(S, A), B) = apply(S, compose(A, B)) must hold.
  TextOperation.prototype.compose = function (operation2) {
    var operation1 = this;
    if (operation1.targetLength !== operation2.baseLength) {
      throw new Error("The base length of the second operation has to be the target length of the first operation");
    }

    var operation = new TextOperation(); // the combined operation
    var ops1 = operation1.ops, ops2 = operation2.ops; // for fast access
    var i1 = 0, i2 = 0; // current index into ops1 respectively ops2
    var op1 = ops1[i1++], op2 = ops2[i2++]; // current ops
    while (true) {
      // Dispatch on the type of op1 and op2
      if (typeof op1 === 'undefined' && typeof op2 === 'undefined') {
        // end condition: both ops1 and ops2 have been processed
        break;
      }

      if (isDelete(op1)) {
        operation['delete'](op1);
        op1 = ops1[i1++];
        continue;
      }
      if (isInsert(op2)) {
        operation.insert(op2);
        op2 = ops2[i2++];
        continue;
      }

      if (typeof op1 === 'undefined') {
        throw new Error("Cannot compose operations: first operation is too short.");
      }
      if (typeof op2 === 'undefined') {
        throw new Error("Cannot compose operations: first operation is too long.");
      }

      if (isRetain(op1) && isRetain(op2)) {
        if (op1 > op2) {
          operation.retain(op2);
          op1 = op1 - op2;
          op2 = ops2[i2++];
        } else if (op1 === op2) {
          operation.retain(op1);
          op1 = ops1[i1++];
          op2 = ops2[i2++];
        } else {
          operation.retain(op1);
          op2 = op2 - op1;
          op1 = ops1[i1++];
        }
      } else if (isInsert(op1) && isDelete(op2)) {
        if (op1.length > -op2) {
          op1 = op1.slice(-op2);
          op2 = ops2[i2++];
        } else if (op1.length === -op2) {
          op1 = ops1[i1++];
          op2 = ops2[i2++];
        } else {
          op2 = op2 + op1.length;
          op1 = ops1[i1++];
        }
      } else if (isInsert(op1) && isRetain(op2)) {
        if (op1.length > op2) {
          operation.insert(op1.slice(0, op2));
          op1 = op1.slice(op2);
          op2 = ops2[i2++];
        } else if (op1.length === op2) {
          operation.insert(op1);
          op1 = ops1[i1++];
          op2 = ops2[i2++];
        } else {
          operation.insert(op1);
          op2 = op2 - op1.length;
          op1 = ops1[i1++];
        }
      } else if (isRetain(op1) && isDelete(op2)) {
        if (op1 > -op2) {
          operation['delete'](op2);
          op1 = op1 + op2;
          op2 = ops2[i2++];
        } else if (op1 === -op2) {
          operation['delete'](op2);
          op1 = ops1[i1++];
          op2 = ops2[i2++];
        } else {
          operation['delete'](op1);
          op2 = op2 + op1;
          op1 = ops1[i1++];
        }
      } else {
        throw new Error(
          "This shouldn't happen: op1: " +
          JSON.stringify(op1) + ", op2: " +
          JSON.stringify(op2)
        );
      }
    }
    return operation;
  };

  function getSimpleOp (operation, fn) {
    var ops = operation.ops;
    var isRetain = TextOperation.isRetain;
    switch (ops.length) {
    case 1:
      return ops[0];
    case 2:
      return isRetain(ops[0]) ? ops[1] : (isRetain(ops[1]) ? ops[0] : null);
    case 3:
      if (isRetain(ops[0]) && isRetain(ops[2])) { return ops[1]; }
    }
    return null;
  }

  function getStartIndex (operation) {
    if (isRetain(operation.ops[0])) { return operation.ops[0]; }
    return 0;
  }

  // When you use ctrl-z to undo your latest changes, you expect the program not
  // to undo every single keystroke but to undo your last sentence you wrote at
  // a stretch or the deletion you did by holding the backspace key down. This
  // This can be implemented by composing operations on the undo stack. This
  // method can help decide whether two operations should be composed. It
  // returns true if the operations are consecutive insert operations or both
  // operations delete text at the same position. You may want to include other
  // factors like the time since the last change in your decision.
  TextOperation.prototype.shouldBeComposedWith = function (other) {
    if (this.isNoop() || other.isNoop()) { return true; }

    var startA = getStartIndex(this), startB = getStartIndex(other);
    var simpleA = getSimpleOp(this), simpleB = getSimpleOp(other);
    if (!simpleA || !simpleB) { return false; }

    if (isInsert(simpleA) && isInsert(simpleB)) {
      return startA + simpleA.length === startB;
    }

    if (isDelete(simpleA) && isDelete(simpleB)) {
      // there are two possibilities to delete: with backspace and with the
      // delete key.
      return (startB - simpleB === startA) || startA === startB;
    }

    return false;
  };

  // Decides whether two operations should be composed with each other
  // if they were inverted, that is
  // `shouldBeComposedWith(a, b) = shouldBeComposedWithInverted(b^{-1}, a^{-1})`.
  TextOperation.prototype.shouldBeComposedWithInverted = function (other) {
    if (this.isNoop() || other.isNoop()) { return true; }

    var startA = getStartIndex(this), startB = getStartIndex(other);
    var simpleA = getSimpleOp(this), simpleB = getSimpleOp(other);
    if (!simpleA || !simpleB) { return false; }

    if (isInsert(simpleA) && isInsert(simpleB)) {
      return startA + simpleA.length === startB || startA === startB;
    }

    if (isDelete(simpleA) && isDelete(simpleB)) {
      return startB - simpleB === startA;
    }

    return false;
  };

  // Transform takes two operations A and B that happened concurrently and
  // produces two operations A' and B' (in an array) such that
  // `apply(apply(S, A), B') = apply(apply(S, B), A')`. This function is the
  // heart of OT.
  TextOperation.transform = function (operation1, operation2) {
    if (operation1.baseLength !== operation2.baseLength) {
      throw new Error("Both operations have to have the same base length");
    }

    var operation1prime = new TextOperation();
    var operation2prime = new TextOperation();
    var ops1 = operation1.ops, ops2 = operation2.ops;
    var i1 = 0, i2 = 0;
    var op1 = ops1[i1++], op2 = ops2[i2++];
    while (true) {
      // At every iteration of the loop, the imaginary cursor that both
      // operation1 and operation2 have that operates on the input string must
      // have the same position in the input string.

      if (typeof op1 === 'undefined' && typeof op2 === 'undefined') {
        // end condition: both ops1 and ops2 have been processed
        break;
      }

      // next two cases: one or both ops are insert ops
      // => insert the string in the corresponding prime operation, skip it in
      // the other one. If both op1 and op2 are insert ops, prefer op1.
      if (isInsert(op1)) {
        operation1prime.insert(op1);
        operation2prime.retain(op1.length);
        op1 = ops1[i1++];
        continue;
      }
      if (isInsert(op2)) {
        operation1prime.retain(op2.length);
        operation2prime.insert(op2);
        op2 = ops2[i2++];
        continue;
      }

      if (typeof op1 === 'undefined') {
        throw new Error("Cannot compose operations: first operation is too short.");
      }
      if (typeof op2 === 'undefined') {
        throw new Error("Cannot compose operations: first operation is too long.");
      }

      var minl;
      if (isRetain(op1) && isRetain(op2)) {
        // Simple case: retain/retain
        if (op1 > op2) {
          minl = op2;
          op1 = op1 - op2;
          op2 = ops2[i2++];
        } else if (op1 === op2) {
          minl = op2;
          op1 = ops1[i1++];
          op2 = ops2[i2++];
        } else {
          minl = op1;
          op2 = op2 - op1;
          op1 = ops1[i1++];
        }
        operation1prime.retain(minl);
        operation2prime.retain(minl);
      } else if (isDelete(op1) && isDelete(op2)) {
        // Both operations delete the same string at the same position. We don't
        // need to produce any operations, we just skip over the delete ops and
        // handle the case that one operation deletes more than the other.
        if (-op1 > -op2) {
          op1 = op1 - op2;
          op2 = ops2[i2++];
        } else if (op1 === op2) {
          op1 = ops1[i1++];
          op2 = ops2[i2++];
        } else {
          op2 = op2 - op1;
          op1 = ops1[i1++];
        }
      // next two cases: delete/retain and retain/delete
      } else if (isDelete(op1) && isRetain(op2)) {
        if (-op1 > op2) {
          minl = op2;
          op1 = op1 + op2;
          op2 = ops2[i2++];
        } else if (-op1 === op2) {
          minl = op2;
          op1 = ops1[i1++];
          op2 = ops2[i2++];
        } else {
          minl = -op1;
          op2 = op2 + op1;
          op1 = ops1[i1++];
        }
        operation1prime['delete'](minl);
      } else if (isRetain(op1) && isDelete(op2)) {
        if (op1 > -op2) {
          minl = -op2;
          op1 = op1 + op2;
          op2 = ops2[i2++];
        } else if (op1 === -op2) {
          minl = op1;
          op1 = ops1[i1++];
          op2 = ops2[i2++];
        } else {
          minl = op1;
          op2 = op2 + op1;
          op1 = ops1[i1++];
        }
        operation2prime['delete'](minl);
      } else {
        throw new Error("The two operations aren't compatible");
      }
    }

    return [operation1prime, operation2prime];
  };

  return TextOperation;

}());

// Export for CommonJS
if (typeof module === 'object') {
  module.exports = ot.TextOperation;
}
},{}],5:[function(require,module,exports){
  'use strict';

  // A WrappedOperation contains an operation, selection and metadata.
  function WrappedOperation (operation, selection, metadata) {
    this.wrapped = operation;
    this.selection = selection;
    this.metadata = metadata;
  }

  WrappedOperation.prototype.apply = function () {
    return this.wrapped.apply.apply(this.wrapped, arguments);
  };

  WrappedOperation.prototype.invert = function () {
    var selection = this.selection;
    return new WrappedOperation(
      this.wrapped.invert.apply(this.wrapped, arguments),
      selection && typeof selection === 'object' && typeof selection.invert === 'function' ?
        selection.invert.apply(selection, arguments) : selection
    );
  };

  // Copy all properties from source to target.
  function copy (source, target) {
    for (var key in source) {
      if (source.hasOwnProperty(key)) {
        target[key] = source[key];
      }
    }
  }

  function composeSelection (a, b) {
    if (a && typeof a === 'object') {
      if (typeof a.compose === 'function') { return a.compose(b); }
      var selection = {};
      copy(a, selection);
      copy(b, selection);
      return selection;
    }
    return b;
  }

  WrappedOperation.prototype.compose = function (other) {
    return new WrappedOperation(
      this.wrapped.compose(other.wrapped),
      composeSelection(this.selection, other.selection)
    );
  };

  function transformSelection (selection, operation) {
    if (selection && typeof selection === 'object') {
      if (typeof selection.transform === 'function') {
        return selection.transform(operation);
      }
    }
    return selection;
  }

  WrappedOperation.transform = function (a, b) {
    var transform = a.wrapped.constructor.transform;
    var pair = transform(a.wrapped, b.wrapped);
    return [
      new WrappedOperation(pair[0], transformSelection(a.selection, b.wrapped)),
      new WrappedOperation(pair[1], transformSelection(b.selection, a.wrapped))
    ];
  };

module.exports = WrappedOperation;
},{}],"webgme-ot":[function(require,module,exports){
exports.version = '0.0.15';

exports.TextOperation        = require('./text-operation');
exports.WrappedOperation     = require('./wrapped-operation');
exports.Client               = require('./client');
exports.Selection            = require('./selection');
exports.CodeMirrorAdapter    = require('./codemirror-adapter');

},{"./client":1,"./codemirror-adapter":2,"./selection":3,"./text-operation":4,"./wrapped-operation":5}]},{},[])("webgme-ot")
});

/*globals define*/
/*eslint-env node, browser*/
/**
 * @author pmeijer / https://github.com/pmeijer
 * @module Storage
 */

/**
 * @typedef {string} CommitHash - Unique SHA-1 hash for commit object.
 * @example
 * '#5496cf226542fcceccf89056f0d27564abc88c99'
 */

/**
 * @typedef {object} CommitResult
 * @prop {module:Storage~CommitHash} hash - The commitHash for the commit.
 * @prop {string} status - 'SYNCED', 'FORKED', 'CANCELED', undefined
 *
 * @example
 * {
 *   status: 'SYNCED',
 *   hash: '#someHash'
 * }
 * @example
 * {
 *   hash: '<hash from makeCommit with no branch provided>'
 * }
 */

/**
 * @typedef {object} CommitObject
 * @prop {module:Storage~CommitHash} _id - Hash of the commit object, a.k.a commitHash.
 * @prop {module:Core~ObjectHash} root - Hash of the associated root object, a.k.a. rootHash.
 * @prop {module:Storage~CommitHash[]} parents - Commits from where this commit evolved.
 * @prop {number} time - When the commit object was created Date.now().
 * @prop {string} message - Commit message.
 * @prop {string[]} updater - Commit message.
 * @prop {string} type - 'commit'
 *
 * @example
 * {
 *   _id: '#5496cf226542fcceccf89056f0d27564abc88c99',
 *   root: '#04009ecd1e68117cd3e9d39c87aadd9ed1ee5cb3',
 *   parents: ['#87d9fd309ec6a5d84776d7731ce1f1ab2790aac2']
 *   updater: ['guest'],
 *   time: 1430169614741,
 *   message: "createChildren({\"/1008889918/1998840078\":\"/1182870936/737997118/1736829087/1966323860\"})",
 *   type: 'commit'
 * }
 */

/**
 * @typedef {object} PatchObject
 * @prop {module:Core~ObjectHash} _id - Hash of the expected result object.
 * @prop {module:Core~ObjectHash} base - Hash of the base object where the patch should be applied.
 * @prop {string} type - 'patch'.
 * @prop {object} patch - The patch instructions (based on [RFC6902]{@link http://tools.ietf.org/html/rfc6902}).
 *
 * @example
 * {
 *   _id: '#5496cf226542fcceccf89056f0d27564abc88c99',
 *   base: '#04009ecd1e68117cd3e9d39c87aadd9ed1ee5cb3',
 *   type: 'patch',
 *   patch: [{op: 'add', path: '/atr/new', value: 'value'}]
 * }
 */
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('common/storage/constants',[], factory);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = factory();
    }
}(function () {
    'use strict';

    return {
        //Version
        VERSION: '1.2.0',
        // Database related
        MONGO_ID: '_id',
        COMMIT_TYPE: 'commit',
        OVERLAY_SHARD_TYPE: 'shard',
        PROJECT_INFO_KEYS: [
            'createdAt',
            'creator',
            'viewedAt',
            'viewer',
            'modifiedAt',
            'modifier',
            'kind',
            'description',
            'icon'
        ],
        EMPTY_PROJECT_DATA: 'empty',
        PROJECT_ID_SEP: '+',
        PROJECT_DISPLAYED_NAME_SEP: '/',

        // Socket IO
        DATABASE_ROOM: 'database',
        ROOM_DIVIDER: '%',

        NETWORK_STATUS_CHANGED: 'NETWORK_STATUS_CHANGED',

        CONNECTED: 'CONNECTED',
        DISCONNECTED: 'DISCONNECTED',
        RECONNECTED: 'RECONNECTED',
        INCOMPATIBLE_CONNECTION: 'INCOMPATIBLE_CONNECTION',
        CONNECTION_ERROR: 'CONNECTION_ERROR',

        JWT_ABOUT_TO_EXPIRE: 'JWT_ABOUT_TO_EXPIRE',
        JWT_EXPIRED: 'JWT_EXPIRED',

        RECONNECTING: 'RECONNECTING', // Internal storage state where the websocket connection has been established,
        // but work is still be done to join branch and document rooms correctly.

        // Branch commit status - this is the status returned after setting the hash of a branch
        SYNCED: 'SYNCED', // The commitData was inserted in the database and the branchHash updated.
        FORKED: 'FORKED', // The commitData was inserted in the database, but the branchHash NOT updated.
        CANCELED: 'CANCELED', // The commitData was never inserted to the database.
        MERGED: 'MERGED', // The commit was initially forked, but successfully merged.

        BRANCH_STATUS: {
            SYNC: 'SYNC',
            AHEAD_SYNC: 'AHEAD_SYNC',
            AHEAD_NOT_SYNC: 'AHEAD_NOT_SYNC',
            PULLING: 'PULLING',
            MERGING: 'MERGING',
            ERROR: 'ERROR'
        },

        // Events

        PROJECT_DELETED: 'PROJECT_DELETED',
        PROJECT_CREATED: 'PROJECT_CREATED',

        BRANCH_DELETED: 'BRANCH_DELETED',
        BRANCH_CREATED: 'BRANCH_CREATED',
        BRANCH_HASH_UPDATED: 'BRANCH_HASH_UPDATED',
        TAG_DELETED: 'TAG_DELETED',
        TAG_CREATED: 'TAG_CREATED',
        COMMIT: 'COMMIT',

        BRANCH_UPDATED: 'BRANCH_UPDATED',

        BRANCH_JOINED: 'BRANCH_JOINED',
        BRANCH_LEFT: 'BRANCH_LEFT',

        NOTIFICATION: 'NOTIFICATION',

        DOCUMENT_OPERATION: 'DOCUMENT_OPERATION',
        DOCUMENT_SELECTION: 'DOCUMENT_SELECTION',
        // Types of notifications
        BRANCH_ROOM_SOCKETS: 'BRANCH_ROOM_SOCKETS',
        PLUGIN_NOTIFICATION: 'PLUGIN_NOTIFICATION',
        ADD_ON_NOTIFICATION: 'ADD_ON_NOTIFICATION',
        CLIENT_STATE_NOTIFICATION: 'CLIENT_STATE_NOTIFICATION',
        // Additional sub types for plugin notification
        PLUGIN_NOTIFICATION_TYPE: {
            INITIATED: 'INITIATED',
            ABORT: 'ABORT',
            MESSAGE: 'MESSAGE'
        },
        WEBSOCKET_ROUTER_ROOM_ID_PREFIX: 'wsr-room-',
        WEBSOCKET_ROUTER_MESSAGE_TYPES: {
            CONNECT: 'wsm-connect',
            DISCONNECT: 'wsm-disconnect',
            MESSAGE: 'wsm-message'
        }
    };
}));

/*globals define*/
/*eslint-env node, browser*/
/*eslint no-bitwise: 0*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/util/guid',[],function () {
    'use strict';

    var guid = function () {
        var s4 = function () {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        };

        //return GUID
        return s4() + [s4(), s4(), s4(), s4(), s4()].join('-') + s4() + s4();
    };

    return guid;
});
/*globals define*/
/*eslint-env node, browser*/

/**
 * @author rkereskenyi / https://github.com/rkereskenyi
 */

define('common/EventDispatcher',[], function () {
    'use strict';

    var EventDispatcher = function () {
        this._eventList = {};
    };

    EventDispatcher.prototype = {
        _eventList: null,
        _getEvent: function (eventName, create) {
            // Check if Array of Event Handlers has been created
            if (!this._eventList[eventName]) {

                // Check if the calling method wants to create the Array
                // if not created. This reduces unneeded memory usage.
                if (!create) {
                    return null;
                }

                // Create the Array of Event Handlers
                this._eventList[eventName] = [];
                // new Array
            }

            // return the Array of Event Handlers already added
            return this._eventList[eventName];
        },
        addEventListener: function (eventName, handler) {
            // Get the Array of Event Handlers
            var evt = this._getEvent(eventName, true);

            // Add the new Event Handler to the Array
            evt.push(handler);
        },
        removeEventListener: function (eventName, handler) {
            // Get the Array of Event Handlers
            var evt = this._getEvent(eventName);

            if (!evt) {
                return;
            }

            // Helper Method - an Array.indexOf equivalent
            var getArrayIndex = function (array, item) {
                for (var i = 0; i < array.length; i++) {
                    if (array[i] === item) {
                        return i;
                    }
                }
                return -1;
            };

            // Get the Array index of the Event Handler
            var index = getArrayIndex(evt, handler);

            if (index > -1) {
                // Remove Event Handler from Array
                evt.splice(index, 1);
            }
        },
        removeAllEventListeners: function (eventName) {
            // Get the Array of Event Handlers
            var evt = this._getEvent(eventName);

            if (!evt) {
                return;
            }

            evt.splice(0, evt.length);
        },
        dispatchEvent: function (eventName, eventArgs) {
            // Get a function that will call all the Event Handlers internally
            var handler = this._getEventHandler(eventName);
            if (handler) {
                // call the handler function
                // Pass in "sender" and "eventArgs" parameters
                handler(this, eventArgs);
            }
        },
        clearAllEvents: function () {
            this._eventList = {};
        },
        _getEventHandler: function (eventName) {
            // Get Event Handler Array for this Event
            var evt = this._getEvent(eventName, false);
            if (!evt || evt.length === 0) {
                return null;
            }

            // Create the Handler method that will use currying to
            // call all the Events Handlers internally
            var h = function (sender, args) {
                for (var i = 0; i < evt.length; i++) {
                    evt[i](sender, args);
                }
            };

            // Return this new Handler method
            return h;
        }
    };

    return EventDispatcher;
});
/*globals define*/
/*eslint-env node, browser*/
/**
 * Provides watching-functionality of the database and specific projects.
 * Keeps a state of the registered watchers.
 *
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/storageclasses/watchers',[
    'q',
    'webgme-ot',
    'common/storage/constants',
    'common/util/guid',
    'common/EventDispatcher'
], function (Q, ot, CONSTANTS, GUID, EventDispatcher) {
    'use strict';

    function StorageWatcher(webSocket, logger, gmeConfig) {
        EventDispatcher.call(this);
        // watcher counters determining when to join/leave a room on the sever
        this.watchers = {
            sessionId: GUID(), // Need at reconnect since socket.id changes.
            database: 0,
            projects: {},
            documents: {}
        };
        this.webSocket = webSocket;
        this.logger = this.logger || logger.fork('storage');
        this.gmeConfig = gmeConfig;
        this.logger.debug('StorageWatcher ctor');
        this.connected = false;
    }

    // Inherit from the EventDispatcher
    StorageWatcher.prototype = Object.create(EventDispatcher.prototype);
    StorageWatcher.prototype.constructor = StorageWatcher;

    function _splitDocId(docId) {
        var pieces = docId.split(CONSTANTS.ROOM_DIVIDER);

        return {
            projectId: pieces[0],
            branchName: pieces[1],
            nodeId: pieces[2],
            attrName: pieces[3]
        };
    }

    StorageWatcher.prototype.watchDatabase = function (eventHandler, callback) {
        this.logger.debug('watchDatabase - handler added');
        this.webSocket.addEventListener(CONSTANTS.PROJECT_DELETED, eventHandler);
        this.webSocket.addEventListener(CONSTANTS.PROJECT_CREATED, eventHandler);
        this.watchers.database += 1;
        this.logger.debug('Nbr of database watchers:', this.watchers.database);

        if (this.watchers.database === 1) {
            this.logger.debug('First watcher will enter database room.');
            return this.webSocket.watchDatabase({join: true}).nodeify(callback);
        } else {
            return Q().nodeify(callback);
        }
    };

    StorageWatcher.prototype.unwatchDatabase = function (eventHandler, callback) {
        var deferred = Q.defer();

        this.logger.debug('unwatchDatabase - handler will be removed');
        this.logger.debug('Nbr of database watchers (before removal):', this.watchers.database);
        this.webSocket.removeEventListener(CONSTANTS.PROJECT_DELETED, eventHandler);
        this.webSocket.removeEventListener(CONSTANTS.PROJECT_CREATED, eventHandler);
        this.watchers.database -= 1;

        if (this.watchers.database === 0) {
            this.logger.debug('No more watchers will exit database room.');
            if (this.connected) {
                this.webSocket.watchDatabase({join: false})
                    .then(deferred.resolve)
                    .catch(deferred.reject);
            } else {
                deferred.resolve();
            }
        } else if (this.watchers.database < 0) {
            this.logger.error('Number of database watchers became negative!');
            deferred.reject(new Error('Number of database watchers became negative!'));
        } else {
            deferred.resolve();
        }

        return deferred.promise.nodeify(callback);
    };

    StorageWatcher.prototype.watchProject = function (projectId, eventHandler, callback) {
        this.logger.debug('watchProject - handler added for project', projectId);
        this.webSocket.addEventListener(CONSTANTS.BRANCH_DELETED + projectId, eventHandler);
        this.webSocket.addEventListener(CONSTANTS.BRANCH_CREATED + projectId, eventHandler);
        this.webSocket.addEventListener(CONSTANTS.BRANCH_HASH_UPDATED + projectId, eventHandler);

        this.watchers.projects[projectId] = this.watchers.projects.hasOwnProperty(projectId) ?
            this.watchers.projects[projectId] + 1 : 1;
        this.logger.debug('Nbr of watchers for project:', projectId, this.watchers.projects[projectId]);
        if (this.watchers.projects[projectId] === 1) {
            this.logger.debug('First watcher will enter project room:', projectId);
            this.webSocket.watchProject({projectId: projectId, join: true})
                .nodeify(callback);
        } else {
            return Q().nodeify(callback);
        }
    };

    StorageWatcher.prototype.unwatchProject = function (projectId, eventHandler, callback) {
        var deferred = Q.defer();

        this.logger.debug('unwatchProject - handler will be removed', projectId);
        this.logger.debug('Nbr of database watchers (before removal):', projectId,
            this.watchers.projects[projectId]);
        this.webSocket.removeEventListener(CONSTANTS.BRANCH_DELETED + projectId, eventHandler);
        this.webSocket.removeEventListener(CONSTANTS.BRANCH_CREATED + projectId, eventHandler);
        this.webSocket.removeEventListener(CONSTANTS.BRANCH_HASH_UPDATED + projectId, eventHandler);

        this.watchers.projects[projectId] = this.watchers.projects.hasOwnProperty(projectId) ?
            this.watchers.projects[projectId] - 1 : -1;
        if (this.watchers.projects[projectId] === 0) {
            this.logger.debug('No more watchers will exit project room:', projectId);
            delete this.watchers.projects[projectId];
            if (this.connected) {
                this.webSocket.watchProject({projectId: projectId, join: false})
                    .then(deferred.resolve)
                    .catch(deferred.reject);
            } else {
                deferred.resolve();
            }
        } else if (this.watchers.projects[projectId] < 0) {
            this.logger.error('Number of project watchers became negative!:', projectId);
            deferred.reject(new Error('Number of project watchers became negative!'));
        } else {
            deferred.resolve();
        }

        return deferred.promise.nodeify(callback);
    };

    /**
     * Start watching the document at the provided context.
     * @param {object} data
     * @param {string} data.projectId
     * @param {string} data.branchName
     * @param {string} data.nodeId
     * @param {string} data.attrName
     * @param {string} data.attrValue - If the first client entering the document the value will be used
     * @param {function} atOperation - Triggered when other clients made changes
     * @param {ot.Operation} atOperation.operation - Triggered when other clients' operations were applied
     * @param {function} atSelection - Triggered when other clients send their selection info
     * @param {object} atSelection.data
     * @param {ot.Selection | null} atSelection.data.selection - null is passed when other client leaves
     * @param {string} atSelection.data.userId - name/id of other user
     * @param {string} atSelection.data.socketId - unique id of other user
     * @param {function} [callback]
     * @param {Error | null} callback.err - If failed to watch the document
     * @param {object} callback.data
     * @param {string} callback.data.docId - Id of document
     * @param {string} callback.data.document - Current document on server
     * @param {number} callback.data.revision - Revision at server when connecting
     * @param {object} callback.data.users - Users that were connected when connecting
     * @returns {Promise}
     */
    StorageWatcher.prototype.watchDocument = function (data, atOperation, atSelection, callback) {
        var self = this,
            docUpdateEventName = this.webSocket.getDocumentUpdatedEventName(data),
            docSelectionEventName = this.webSocket.getDocumentSelectionEventName(data),
            docId = docUpdateEventName.substring(CONSTANTS.DOCUMENT_OPERATION.length),
            watcherId = GUID();

        data = JSON.parse(JSON.stringify(data));
        this.logger.debug('watchDocument - handler added for project', data);
        this.watchers.documents[docId] = this.watchers.documents[docId] || {};
        this.watchers.documents[docId][watcherId] = {
            eventHandler: function (_ws, eData) {
                var otClient = self.watchers.documents[eData.docId][watcherId].otClient;
                self.logger.debug('eventHandler for document', {metadata: eData});

                if (eData.watcherId === watcherId) {
                    self.logger.info('event from same watcher, skipping...');
                    return;
                }

                if (eData.operation) {
                    if (self.reconnecting) {
                        // We are reconnecting.. Put these on the queue.
                        self.watchers.documents[docId][watcherId].applyBuffer.push(eData);
                    } else {
                        otClient.applyServer(ot.TextOperation.fromJSON(eData.operation));
                    }
                }

                if (eData.hasOwnProperty('selection') && !self.reconnecting) {
                    atSelection({
                        selection: eData.selection ?
                            otClient.transformSelection(ot.Selection.fromJSON(eData.selection)) : null,
                        socketId: eData.socketId,
                        userId: eData.userId
                    });
                }
            },
            applyBuffer: [],
            awaitingAck: null
        };

        this.webSocket.addEventListener(docUpdateEventName, this.watchers.documents[docId][watcherId].eventHandler);
        this.webSocket.addEventListener(docSelectionEventName, this.watchers.documents[docId][watcherId].eventHandler);

        data.join = true;
        data.sessionId = this.watchers.sessionId;
        data.watcherId = watcherId;

        return this.webSocket.watchDocument(data)
            .then(function (initData) {
                self.watchers.documents[initData.docId][watcherId].otClient = new ot.Client(initData.revision);

                self.watchers.documents[initData.docId][watcherId].otClient.sendOperation =
                    function (revision, operation) {
                        var sendData = {
                            docId: initData.docId,
                            projectId: initData.projectId,
                            branchName: initData.branchName,
                            revision: revision,
                            operation: operation,
                            selection: self.watchers.documents[initData.docId][watcherId].selection,
                            sessionId: self.watchers.sessionId,
                            watcherId: watcherId
                        };

                        self.watchers.documents[initData.docId][watcherId].awaitingAck = {
                            revision: revision,
                            operation: operation
                        };

                        self.webSocket.sendDocumentOperation(sendData, function (err) {
                            if (err) {
                                self.logger.error('Failed to sendDocument', err);
                                return;
                            }

                            if (self.watchers.documents.hasOwnProperty(initData.docId) &&
                                self.watchers.documents[initData.docId].hasOwnProperty(watcherId)) {
                                self.watchers.documents[initData.docId][watcherId].awaitingAck = null;
                                self.watchers.documents[initData.docId][watcherId].otClient.serverAck(revision);
                            } else {
                                self.logger.error(new Error('Received document acknowledgement ' +
                                    'after watcher left document ' + initData.docId));
                            }
                        });
                    };

                self.watchers.documents[initData.docId][watcherId].otClient.applyOperation = atOperation;

                return initData;
            })
            .nodeify(callback);
    };

    /**
     * Stop watching the document.
     * @param {object} data
     * @param {string} data.docId - document id, if not provided projectId, branchName, nodeId, attrName must be.
     * @param {string} data.watcherId
     * @param {string} [data.projectId]
     * @param {string} [data.branchName]
     * @param {string} [data.nodeId]
     * @param {string} [data.attrName]
     * @param {function} [callback]
     * @param {Error | null} callback.err - If failed to unwatch the document
     * @returns {Promise}
     */
    StorageWatcher.prototype.unwatchDocument = function (data, callback) {
        var deferred = Q.defer(),
            docUpdateEventName = this.webSocket.getDocumentUpdatedEventName(data),
            docSelectionEventName = this.webSocket.getDocumentSelectionEventName(data),
            pieces;

        if (typeof data.docId === 'string') {
            pieces = _splitDocId(data.docId);
            Object.keys(pieces)
                .forEach(function (key) {
                    data[key] = pieces[key];
                });
        } else {
            data.docId = docUpdateEventName.substring(CONSTANTS.DOCUMENT_OPERATION.length);
        }

        if (typeof data.watcherId !== 'string') {
            deferred.reject(new Error('data.watcherId not provided - use the one given at watchDocument.'));
        } else if (this.watchers.documents.hasOwnProperty(data.docId) === false ||
            this.watchers.documents[data.docId].hasOwnProperty(data.watcherId) === false) {
            deferred.reject(new Error('Document is not being watched ' + data.docId +
                ' by watcherId [' + data.watcherId + ']'));
        } else {
            // Remove handler from web-socket module.
            this.webSocket.removeEventListener(docUpdateEventName,
                this.watchers.documents[data.docId][data.watcherId].eventHandler);
            this.webSocket.removeEventListener(docSelectionEventName,
                this.watchers.documents[data.docId][data.watcherId].eventHandler);

            // "Remove" handlers attached to the otClient.
            this.watchers.documents[data.docId][data.watcherId].otClient.sendOperation =
                this.watchers.documents[data.docId][data.watcherId].otClient.applyOperation = function () {
                };

            delete this.watchers.documents[data.docId][data.watcherId];

            if (Object.keys(this.watchers.documents[data.docId]).length === 0) {
                delete this.watchers.documents[data.docId];
            }

            // Finally exit socket.io room on server if connected.
            if (this.connected) {
                data.join = false;
                this.webSocket.watchDocument(data)
                    .then(deferred.resolve)
                    .catch(deferred.reject);
            } else {
                deferred.resolve();
            }
        }

        return deferred.promise.nodeify(callback);
    };

    /**
     * Send operation made, and optionally selection, on document at docId.
     * @param {object} data
     * @param {string} data.docId
     * @param {string} data.watcherId
     * @param {ot.TextOperation} data.operation
     * @param {ot.Selection} [data.selection]
     */
    StorageWatcher.prototype.sendDocumentOperation = function (data) {
        // TODO: Do we need to add a callback for confirmation here?
        if (typeof data.watcherId !== 'string') {
            throw new Error('data.watcherId not provided - use the one given at watchDocument.');
        } else if (this.watchers.documents.hasOwnProperty(data.docId) &&
            this.watchers.documents[data.docId].hasOwnProperty(data.watcherId) &&
            this.watchers.documents[data.docId][data.watcherId].otClient instanceof ot.Client) {

            this.watchers.documents[data.docId][data.watcherId].selection = data.selection;
            this.watchers.documents[data.docId][data.watcherId].otClient.applyClient(data.operation);
        } else {
            throw new Error('Document not being watched ' + data.docId +
                '. (If "watchDocument" was initiated make sure to wait for the callback.)');
        }
    };

    /**
     * Send selection on document at docId. (Will only be transmitted if client is Synchronized.)
     * @param {object} data
     * @param {string} data.docId
     * @param {string} data.watcherId
     * @param {ot.Selection} data.selection
     */
    StorageWatcher.prototype.sendDocumentSelection = function (data) {
        var self = this,
            otClient;

        if (typeof data.watcherId !== 'string') {
            throw new Error('data.watcherId not provided - use the one given at watchDocument.');
        } else if (this.watchers.documents.hasOwnProperty(data.docId) &&
            this.watchers.documents[data.docId].hasOwnProperty(data.watcherId) &&
            this.watchers.documents[data.docId][data.watcherId].otClient instanceof ot.Client) {

            otClient = this.watchers.documents[data.docId][data.watcherId].otClient;

            if (otClient.state instanceof ot.Client.Synchronized) {
                // Only broadcast the selection when synchronized
                this.webSocket.sendDocumentSelection({
                    docId: data.docId,
                    watcherId: data.watcherId,
                    revision: otClient.revision,
                    selection: data.selection
                }, function (err) {
                    if (err) {
                        self.logger.error(err);
                    }
                });
            }

        } else {
            throw new Error('Document not being watched ' + data.docId +
                '. (If "watchDocument" was initiated make sure to wait for the callback.)');
        }
    };

    StorageWatcher.prototype._rejoinWatcherRooms = function (callback) {
        var self = this,
            promises = [],
            projectId;

        // When this is called were are in the self.reconnecting === true state until callback resolved.

        this.logger.debug('rejoinWatcherRooms');
        if (this.watchers.database > 0) {
            this.logger.debug('Rejoining database room.');
            promises.push(Q.ninvoke(this.webSocket, 'watchDatabase', {join: true}));
        }

        for (projectId in this.watchers.projects) {
            if (this.watchers.projects.hasOwnProperty(projectId) && this.watchers.projects[projectId] > 0) {
                this.logger.debug('Rejoining project room', projectId, this.watchers.projects[projectId]);
                promises.push(this.webSocket.watchProject({projectId: projectId, join: true}));
            }
        }

        function rejoinWatchers(docId, watcherIds) {
            var rejoinData = _splitDocId(docId),
                watcherId = watcherIds.pop();

            rejoinData.docId = docId;
            rejoinData.rejoin = true;
            rejoinData.revision = self.watchers.documents[docId][watcherId].otClient.revision;
            rejoinData.sessionId = self.watchers.sessionId;
            rejoinData.watcherId = watcherId;

            return self.webSocket.watchDocument(rejoinData)
                .then(function (joinData) {
                    var deferred = Q.defer(),
                        awaiting = self.watchers.documents[docId][watcherId].awaitingAck,
                        sendData;

                    function applyFromServer() {
                        joinData.operations.forEach(function (op) {
                            self.watchers.documents[docId][watcherId].otClient.applyServer(op.wrapped);
                        });

                        self.watchers.documents[docId][watcherId].applyBuffer.forEach(function (op) {
                            self.watchers.documents[docId][watcherId].otClient.applyServer(op);
                        });

                        self.watchers.documents[docId][watcherId].applyBuffer = [];
                    }

                    if (awaiting === null) {
                        // We had no outstanding operations - apply all from the server.
                        applyFromServer();
                        deferred.resolve();
                    } else {
                        // We were awaiting an acknowledgement, did it make it to the server?
                        if (joinData.operations.length > 0 &&
                            joinData.operations[0].metadata.sessionId === self.watchers.sessionId &&
                            joinData.operations[0].metadata.watcherId === watcherId) {
                            // It made it to the server - so send the acknowledgement to the otClient.
                            self.watchers.documents[docId][watcherId].awaitingAck = null;
                            self.watchers.documents[docId][watcherId].otClient.serverAck(awaiting.revision);

                            // Remove it from the operations and apply the other
                            joinData.operations.shift();
                            applyFromServer();
                            deferred.resolve();
                        } else {
                            applyFromServer();
                            sendData = {
                                docId: docId,
                                projectId: rejoinData.projectId,
                                branchName: rejoinData.branchName,
                                revision: awaiting.revision,
                                operation: awaiting.operation,
                                sessionId: self.watchers.sessionId,
                                watcherId: watcherId
                            };

                            self.webSocket.sendDocumentOperation(sendData, function (err) {
                                if (err) {
                                    deferred.reject(err);
                                    return;
                                }

                                if (self.watchers.documents.hasOwnProperty(docId) &&
                                    self.watchers.documents[docId].hasOwnProperty(watcherId)) {
                                    self.watchers.documents[docId][watcherId].awaitingAck = null;
                                    self.watchers.documents[docId][watcherId].otClient.serverAck(sendData.revision);
                                } else {
                                    self.logger.error(new Error('Received document acknowledgement ' +
                                        'after leaving document ' + docId));
                                }

                                deferred.resolve();
                            });
                        }
                    }

                    return deferred.promise;
                })
                .then(function () {
                    if (watcherIds.length > 0) {
                        rejoinWatchers(docId, watcherIds);
                    }
                });
        }

        Object.keys(this.watchers.documents).forEach(function (docId) {
            promises.push(rejoinWatchers(docId, Object.keys(self.watchers.documents[docId])));
        });

        return Q.all(promises).nodeify(callback);
    };

    return StorageWatcher;
});
/*globals define*/
/*eslint-env node, browser*/
/**
 * TODO: Come up with an appropriate name for this.
 * TODO: Proper implementation needed, e.g. error handling.
 *
 * Provides REST-like functionality of the database.
 *
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/storageclasses/simpleapi',['common/storage/storageclasses/watchers'], function (StorageWatcher) {
    'use strict';

    /**
     *
     * @param webSocket
     * @param logger
     * @param gmeConfig
     * @constructor
     * @class
     */
    function StorageSimpleAPI(webSocket, logger, gmeConfig) {
        // watcher counters determining when to join/leave a room on the sever
        this.logger = this.logger || logger.fork('storage');
        StorageWatcher.call(this, webSocket, logger, gmeConfig);
        this.webSocket = webSocket;
        this.gmeConfig = gmeConfig;
        this.logger.debug('StorageSimpleAPI ctor');
    }

    StorageSimpleAPI.prototype = Object.create(StorageWatcher.prototype);
    StorageSimpleAPI.prototype.constructor = StorageSimpleAPI;

    StorageSimpleAPI.prototype.getProjects = function (options, callback) {
        this.logger.debug('invoking getProjects', {metadata: options});
        return this.webSocket.getProjects(options).nodeify(callback);
    };

    StorageSimpleAPI.prototype.getProjectInfo = function (projectId, callback) {
        var data = {
            projectId: projectId,
            branches: true,
            info: true,
            hooks: true,
            rights: true
        };

        this.logger.debug('invoking getProjectInfo', {metadata: data});
        return this.webSocket.getProjects(data)
            .then(function (result) {
                return result[0];
            })
            .nodeify(callback);
    };

    StorageSimpleAPI.prototype.getBranches = function (projectId, callback) {
        var data = {
            projectId: projectId
        };
        this.logger.debug('invoking getBranches', {metadata: data});
        return this.webSocket.getBranches(data).nodeify(callback);
    };

    StorageSimpleAPI.prototype.getCommits = function (projectId, before, number, callback) {
        var data = {
            projectId: projectId,
            before: before,
            number: number
        };
        this.logger.debug('invoking getCommits', {metadata: data});
        return this.webSocket.getCommits(data).nodeify(callback);
    };

    StorageSimpleAPI.prototype.getHistory = function (projectId, start, number, callback) {
        var data = {
            projectId: projectId,
            start: start,
            number: number
        };
        this.logger.debug('invoking getHistory', {metadata: data});
        return this.webSocket.getHistory(data).nodeify(callback);
    };

    StorageSimpleAPI.prototype.squashCommits = function (projectId, fromCommit, toCommitOrBranch, msg, callback) {
        var data = {
            projectId: projectId,
            fromCommit: fromCommit,
            toCommitOrBranch: toCommitOrBranch,
            message: msg
        };
        this.logger.debug('invoking squashCommits', {metadata: data});
        return this.webSocket.squashCommits(data).nodeify(callback);
    };

    StorageSimpleAPI.prototype.getTags = function (projectId, callback) {
        var data = {
            projectId: projectId
        };
        this.logger.debug('invoking getTags', {metadata: data});
        return this.webSocket.getTags(data).nodeify(callback);
    };

    StorageSimpleAPI.prototype.getBranchHash = function (projectId, branchName, callback) {
        var data = {
            projectId: projectId,
            branchName: branchName
        };
        this.logger.debug('invoking getBranchHash', {metadata: data});
        return this.webSocket.getBranchHash(data).nodeify(callback);
    };

    StorageSimpleAPI.prototype.getLatestCommitData = function (projectId, branchName, callback) {
        var data = {
            projectId: projectId,
            branchName: branchName
        };
        this.logger.debug('invoking getLatestCommitData', {metadata: data});
        return this.webSocket.getLatestCommitData(data).nodeify(callback);
    };

    StorageSimpleAPI.prototype.getCommonAncestorCommit = function (projectId, commitA, commitB, callback) {
        var data = {
            commitA: commitA,
            commitB: commitB,
            projectId: projectId
        };
        this.logger.debug('invoking getCommonAncestorCommit', {metadata: data});
        return this.webSocket.getCommonAncestorCommit(data).nodeify(callback);
    };

    // Setters
    StorageSimpleAPI.prototype.createProject = function (projectName, ownerId, kind, callback) {
        var data = {
            projectName: projectName
        };

        if (callback === undefined) {
            if (typeof ownerId === 'function') {
                callback = ownerId;
            } else if (typeof kind === 'function') {
                data.ownerId = ownerId;
                callback = kind;
            } else {
                data.ownerId = ownerId;
                data.kind = kind;
            }
        } else {
            data.ownerId = ownerId;
            data.kind = kind;
        }

        this.logger.debug('invoking createProject', {metadata: data});

        return this.webSocket.createProject(data).nodeify(callback);
    };

    StorageSimpleAPI.prototype.deleteProject = function (projectId, callback) {
        var data = {
            projectId: projectId
        };
        this.logger.debug('invoking deleteProject', {metadata: data});
        return this.webSocket.deleteProject(data).nodeify(callback);
    };

    StorageSimpleAPI.prototype.transferProject = function (projectId, newOwnerId, callback) {
        var data = {
            projectId: projectId,
            newOwnerId: newOwnerId
        };
        this.logger.debug('invoking transferProject', {metadata: data});
        return this.webSocket.transferProject(data).nodeify(callback);
    };

    StorageSimpleAPI.prototype.duplicateProject = function (projectId, projectName, ownerId, callback) {
        var data = {
            projectId: projectId,
            projectName: projectName,
            ownerId: ownerId
        };

        if (callback === undefined && typeof ownerId === 'function') {
            callback = ownerId;
            data.ownerId = undefined;
        }

        this.logger.debug('invoking duplicateProject', {metadata: data});
        return this.webSocket.duplicateProject(data).nodeify(callback);
    };

    StorageSimpleAPI.prototype.setBranchHash = function (projectId, branchName, newHash, oldHash, callback) {
        var data = {
            projectId: projectId,
            branchName: branchName,
            newHash: newHash,
            oldHash: oldHash
        };

        this.logger.debug('invoking setBranchHash', {metadata: data});
        return this.webSocket.setBranchHash(data).nodeify(callback);
    };

    StorageSimpleAPI.prototype.createBranch = function (projectId, branchName, newHash, callback) {
        var data = {
            projectId: projectId,
            branchName: branchName,
            newHash: newHash,
            oldHash: ''
        };

        this.logger.debug('invoking createBranch', {metadata: data});
        return this.webSocket.setBranchHash(data).nodeify(callback);
    };

    StorageSimpleAPI.prototype.deleteBranch = function (projectId, branchName, oldHash, callback) {
        var data = {
            projectId: projectId,
            branchName: branchName,
            newHash: '',
            oldHash: oldHash
        };
        this.logger.debug('invoking deleteBranch', {metadata: data});
        return this.webSocket.setBranchHash(data).nodeify(callback);
    };

    StorageSimpleAPI.prototype.createTag = function (projectId, tagName, commitHash, callback) {
        var data = {
            projectId: projectId,
            tagName: tagName,
            commitHash: commitHash
        };
        this.logger.debug('invoking createTag', {metadata: data});
        return this.webSocket.createTag(data).nodeify(callback);
    };

    StorageSimpleAPI.prototype.deleteTag = function (projectId, tagName, callback) {
        var data = {
            projectId: projectId,
            tagName: tagName
        };
        this.logger.debug('invoking deleteTag', {metadata: data});
        return this.webSocket.deleteTag(data).nodeify(callback);
    };

    //temporary simple request and result functions
    StorageSimpleAPI.prototype.simpleRequest = function (parameters, callback) {
        this.logger.debug('invoking simpleRequest', {metadata: parameters});
        return this.webSocket.simpleRequest(parameters).nodeify(callback);
    };

    StorageSimpleAPI.prototype.simpleQuery = function (workerId, parameters, callback) {
        this.logger.debug('invoking simpleQuery; workerId, parameters', workerId, {metadata: parameters});
        return this.webSocket.simpleQuery(workerId, parameters).nodeify(callback);
    };

    StorageSimpleAPI.prototype.sendNotification = function (data, callback) {
        this.logger.debug('invoking sendNotification; ', {metadata: data});
        return this.webSocket.sendNotification(data).nodeify(callback);
    };

    StorageSimpleAPI.prototype.sendWsRouterMessage = function (routerId, messageType, payload, callback) {
        this.logger.debug('invoking sendWsRouterMessage', 
            {metadata: {routerId: routerId, messageType: messageType, payload: payload}});
        return this.webSocket.simpleRequest(routerId, messageType, payload).nodeify(callback);
    };

    return StorageSimpleAPI;
});
/*globals define*/
/*eslint-env node, browser*/
/**
 * Provides functionality (used by the project-cache) for loading objects.
 *
 * To avoid multiple round-trips to the server the loadObject requests are put in a bucket
 * that is loaded when the bucket is full (gmeConfig.storage.loadBucketSize) or when a
 * timeout is triggered (gmeConfig.storage.loadBucketTimer).
 *
 * N.B. when used directly, the user need to make sure that the same object (by hash) is not loaded within in the
 * same bucket, (see the project-cache for example).
 *
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/storageclasses/objectloaders',['common/storage/storageclasses/simpleapi'], function (SimpleAPI) {
    'use strict';

    function StorageObjectLoaders(webSocket, logger, gmeConfig) {
        // watcher counters determining when to join/leave a room on the sever
        this.logger = this.logger || logger.fork('storage');
        SimpleAPI.call(this, webSocket, logger, gmeConfig);
        this.webSocket = webSocket;
        this.gmeConfig = gmeConfig;
        // Bucket for loading objects
        this.loadBucket = [];
        this.loadBucketSize = 0;
        this.loadBucketTimer = null;
        this.logger.debug('StorageObjectLoaders ctor');
    }

    StorageObjectLoaders.prototype = Object.create(SimpleAPI.prototype);
    StorageObjectLoaders.prototype.constructor = StorageObjectLoaders;

    // Getters
    StorageObjectLoaders.prototype.loadObject = function (projectId, hash, callback) {
        var self = this;
        this.logger.debug('loadObject', projectId, hash);

        self.loadBucket.push({projectId: projectId, hash: hash, cb: callback});
        self.loadBucketSize += 1;

        function resetBucketAndLoadObjects() {
            var myBucket = self.loadBucket;
            self.loadBucket = [];
            self.loadBucketTimer = null;
            self.loadBucketSize = 0;
            self.loadObjects(projectId, myBucket);
        }

        if (self.loadBucketSize === 1) {
            self.logger.debug('loadBucket was empty starting timer [ms]', self.gmeConfig.storage.loadBucketTimer);
            self.loadBucketTimer = setTimeout(function () {
                self.logger.debug('loadBucketTimer triggered, bucketSize:', self.loadBucketSize);
                resetBucketAndLoadObjects();
            }, self.gmeConfig.storage.loadBucketTimer);
        }

        if (self.loadBucketSize === self.gmeConfig.storage.loadBucketSize) {
            self.logger.debug('loadBuckSize reached will loadObjects, bucketSize:', self.loadBucketSize);
            clearTimeout(self.loadBucketTimer);
            resetBucketAndLoadObjects();
        }
    };

    StorageObjectLoaders.prototype.loadObjects = function (projectId, hashedObjects) {
        var self = this,
            hashes = {},
            data,
            i;
        for (i = 0; i < hashedObjects.length; i++) {
            hashes[hashedObjects[i].hash] = true;
        }
        hashes = Object.keys(hashes);
        data = {
            hashes: hashes,
            projectId: projectId
        };

        this.webSocket.loadObjects(data, function (err, result) {
            //if (err) {
            //    throw new Error(err);
            //}
            self.logger.debug('loadObjects returned', {metadata: result});
            for (i = 0; i < hashedObjects.length; i++) {
                if (err) {
                    hashedObjects[i].cb(err);
                } else if (typeof result[hashedObjects[i].hash] === 'string') {
                    self.logger.error(result[hashedObjects[i].hash]);
                    hashedObjects[i].cb(new Error(result[hashedObjects[i].hash]));
                } else {
                    hashedObjects[i].cb(err, result[hashedObjects[i].hash]);
                }
            }
        });
    };

    StorageObjectLoaders.prototype.loadPaths = function (projectId, pathsInfo, excludes, callback) {
        var data = {
            projectId: projectId,
            pathsInfo: pathsInfo,
            excludes: excludes
        };

        this.webSocket.loadPaths(data, callback);
    };

    return StorageObjectLoaders;
});

/*globals define*/
/*eslint-env node, browser*/
/*eslint no-console: 0*/
/**
 * @author mmaroti / https://github.com/mmaroti
 */


define('common/util/assert',[],function () {
    'use strict';

    /**
     * Checks given condition and throws new Error if "falsy".
     * @param {boolean|*} cond
     * @param {string} [msg='ASSERT failed']
     */
    var assert = function (cond, msg) {
        if (!cond) {
            var error = new Error(msg || 'ASSERT failed');

            if (typeof TESTING === 'undefined') {
                console.log('Throwing', error.stack);
                console.log();
            }

            throw error;
        }
    };

    return assert;
});

/*eslint-disable*/
/* 2012 David Chambers <dc@hashify.me>  */
define('common/util/canon',[], function() {
    var CANON = {},
        keys, map, nativeMap, pad,
        __slice = [].slice,
        __hasProp = {}.hasOwnProperty;


    CANON.stringify = (function() {
        var canonicalize;
        canonicalize = function(value) {
            var pair, _ref;
            switch (Object.prototype.toString.call(value)) {
                case '[object Array]':
                    return ['Array'].concat(__slice.call(map(value, canonicalize)));
                case '[object Date]':
                    return ['Date'].concat(isFinite(+value) ? value.getUTCFullYear() + '-' + pad(value.getUTCMonth() + 1) + '-' + pad(value.getUTCDate()) + 'T' + pad(value.getUTCHours()) + ':' + pad(value.getUTCMinutes()) + ':' + pad(value.getUTCSeconds()) + '.' + pad(value.getUTCMilliseconds(), 3) + 'Z' : null);
                case '[object Function]':
                    throw new TypeError('functions cannot be serialized');
                    break;
                case '[object Number]':
                    if (isFinite(value)) {
                        return value;
                    } else {
                        return ['Number', "" + value];
                    }
                    break;
                case '[object Object]':
                    pair = function(key) {
                        return [key, canonicalize(value[key])];
                    };
                    return (_ref = ['Object']).concat.apply(_ref, map(keys(value).sort(), pair));
                case '[object RegExp]':
                    return ['RegExp', "" + value];
                case '[object Undefined]':
                    return ['Undefined'];
                default:
                    return value;
            }
        };
        return function(value) {
            return JSON.stringify(canonicalize(value));
        };
    })();

    CANON.parse = (function() {
        var canonicalize;
        canonicalize = function(value) {
            var element, elements, idx, object, what, _i, _ref;
            if (Object.prototype.toString.call(value) !== '[object Array]') {
                return value;
            }
            what = value[0], elements = 2 <= value.length ? __slice.call(value, 1) : [];
            element = elements[0];
            switch (what) {
                case 'Array':
                    return map(elements, canonicalize);
                case 'Date':
                    return new Date(element);
                case 'Number':
                    return +element;
                case 'Object':
                    object = {};
                    for (idx = _i = 0, _ref = elements.length; _i < _ref; idx = _i += 2) {
                        object[elements[idx]] = canonicalize(elements[idx + 1]);
                    }
                    return object;
                case 'RegExp':
                    return (function(func, args, ctor) {
                        ctor.prototype = func.prototype;
                        var child = new ctor, result = func.apply(child, args);
                        return Object(result) === result ? result : child;
                    })(RegExp, /^[/](.+)[/]([gimy]*)$/.exec(element).slice(1), function(){});
                case 'Undefined':
                    return void 0;
                default:
                    throw new Error('invalid input');
            }
        };
        return function(string) {
            return canonicalize(JSON.parse(string));
        };
    })();

    nativeMap = Array.prototype.map;

    map = function(array, iterator) {
        var el, _i, _len, _results;
        if (nativeMap && array.map === nativeMap) {
            return array.map(iterator);
        } else {
            _results = [];
            for (_i = 0, _len = array.length; _i < _len; _i++) {
                el = array[_i];
                _results.push(iterator(el));
            }
            return _results;
        }
    };

    keys = Object.keys || function(object) {
        var key, _results;
        _results = [];
        for (key in object) {
            if (!__hasProp.call(object, key)) continue;
            _results.push(key);
        }
        return _results;
    };

    pad = function(n, min) {
        if (min == null) {
            min = 2;
        }
        return ("" + (1000 + n)).substr(4 - min);
    };

    return CANON;

});

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('chance',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.chance = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],2:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":1,"ieee754":3}],3:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"chance":[function(require,module,exports){
(function (Buffer){
//  Chance.js 1.0.16
//  http://chancejs.com
//  (c) 2013 Victor Quinn
//  Chance may be freely distributed or modified under the MIT license.

(function () {

    // Constants
    var MAX_INT = 9007199254740992;
    var MIN_INT = -MAX_INT;
    var NUMBERS = '0123456789';
    var CHARS_LOWER = 'abcdefghijklmnopqrstuvwxyz';
    var CHARS_UPPER = CHARS_LOWER.toUpperCase();
    var HEX_POOL  = NUMBERS + "abcdef";

    // Errors
    function UnsupportedError(message) {
        this.name = 'UnsupportedError';
        this.message = message || 'This feature is not supported on this platform';
    }

    UnsupportedError.prototype = new Error();
    UnsupportedError.prototype.constructor = UnsupportedError;

    // Cached array helpers
    var slice = Array.prototype.slice;

    // Constructor
    function Chance (seed) {
        if (!(this instanceof Chance)) {
            if (!seed) { seed = null; } // handle other non-truthy seeds, as described in issue #322
            return seed === null ? new Chance() : new Chance(seed);
        }

        // if user has provided a function, use that as the generator
        if (typeof seed === 'function') {
            this.random = seed;
            return this;
        }

        if (arguments.length) {
            // set a starting value of zero so we can add to it
            this.seed = 0;
        }

        // otherwise, leave this.seed blank so that MT will receive a blank

        for (var i = 0; i < arguments.length; i++) {
            var seedling = 0;
            if (Object.prototype.toString.call(arguments[i]) === '[object String]') {
                for (var j = 0; j < arguments[i].length; j++) {
                    // create a numeric hash for each argument, add to seedling
                    var hash = 0;
                    for (var k = 0; k < arguments[i].length; k++) {
                        hash = arguments[i].charCodeAt(k) + (hash << 6) + (hash << 16) - hash;
                    }
                    seedling += hash;
                }
            } else {
                seedling = arguments[i];
            }
            this.seed += (arguments.length - i) * seedling;
        }

        // If no generator function was provided, use our MT
        this.mt = this.mersenne_twister(this.seed);
        this.bimd5 = this.blueimp_md5();
        this.random = function () {
            return this.mt.random(this.seed);
        };

        return this;
    }

    Chance.prototype.VERSION = "1.0.16";

    // Random helper functions
    function initOptions(options, defaults) {
        options = options || {};

        if (defaults) {
            for (var i in defaults) {
                if (typeof options[i] === 'undefined') {
                    options[i] = defaults[i];
                }
            }
        }

        return options;
    }

    function range(size) {
        return Array.apply(null, Array(size)).map(function (_, i) {return i;});
    }

    function testRange(test, errorMessage) {
        if (test) {
            throw new RangeError(errorMessage);
        }
    }

    /**
     * Encode the input string with Base64.
     */
    var base64 = function() {
        throw new Error('No Base64 encoder available.');
    };

    // Select proper Base64 encoder.
    (function determineBase64Encoder() {
        if (typeof btoa === 'function') {
            base64 = btoa;
        } else if (typeof Buffer === 'function') {
            base64 = function(input) {
                return new Buffer(input).toString('base64');
            };
        }
    })();

    // -- Basics --

    /**
     *  Return a random bool, either true or false
     *
     *  @param {Object} [options={ likelihood: 50 }] alter the likelihood of
     *    receiving a true or false value back.
     *  @throws {RangeError} if the likelihood is out of bounds
     *  @returns {Bool} either true or false
     */
    Chance.prototype.bool = function (options) {
        // likelihood of success (true)
        options = initOptions(options, {likelihood : 50});

        // Note, we could get some minor perf optimizations by checking range
        // prior to initializing defaults, but that makes code a bit messier
        // and the check more complicated as we have to check existence of
        // the object then existence of the key before checking constraints.
        // Since the options initialization should be minor computationally,
        // decision made for code cleanliness intentionally. This is mentioned
        // here as it's the first occurrence, will not be mentioned again.
        testRange(
            options.likelihood < 0 || options.likelihood > 100,
            "Chance: Likelihood accepts values from 0 to 100."
        );

        return this.random() * 100 < options.likelihood;
    };

    Chance.prototype.animal = function (options){
      //returns a random animal
      options = initOptions(options);

      if(typeof options.type !== 'undefined'){
        //if user does not put in a valid animal type, user will get an error
        testRange(
           !this.get("animals")[options.type.toLowerCase()],
           "Please pick from desert, ocean, grassland, forest, zoo, pets, farm."
         );
         //if user does put in valid animal type, will return a random animal of that type
          return this.pick(this.get("animals")[options.type.toLowerCase()]);
      }
       //if user does not put in any animal type, will return a random animal regardless
      animalTypeArray = ["desert","forest","ocean","zoo","farm","pet","grassland"];
      return this.pick(this.get("animals")[this.pick(animalTypeArray)]);
    };

    /**
     *  Return a random character.
     *
     *  @param {Object} [options={}] can specify a character pool, only alpha,
     *    only symbols, and casing (lower or upper)
     *  @returns {String} a single random character
     *  @throws {RangeError} Can only specify alpha or symbols, not both
     */
    Chance.prototype.character = function (options) {
        options = initOptions(options);
        testRange(
            options.alpha && options.symbols,
            "Chance: Cannot specify both alpha and symbols."
        );

        var symbols = "!@#$%^&*()[]",
            letters, pool;

        if (options.casing === 'lower') {
            letters = CHARS_LOWER;
        } else if (options.casing === 'upper') {
            letters = CHARS_UPPER;
        } else {
            letters = CHARS_LOWER + CHARS_UPPER;
        }

        if (options.pool) {
            pool = options.pool;
        } else if (options.alpha) {
            pool = letters;
        } else if (options.symbols) {
            pool = symbols;
        } else {
            pool = letters + NUMBERS + symbols;
        }

        return pool.charAt(this.natural({max: (pool.length - 1)}));
    };

    // Note, wanted to use "float" or "double" but those are both JS reserved words.

    // Note, fixed means N OR LESS digits after the decimal. This because
    // It could be 14.9000 but in JavaScript, when this is cast as a number,
    // the trailing zeroes are dropped. Left to the consumer if trailing zeroes are
    // needed
    /**
     *  Return a random floating point number
     *
     *  @param {Object} [options={}] can specify a fixed precision, min, max
     *  @returns {Number} a single floating point number
     *  @throws {RangeError} Can only specify fixed or precision, not both. Also
     *    min cannot be greater than max
     */
    Chance.prototype.floating = function (options) {
        options = initOptions(options, {fixed : 4});
        testRange(
            options.fixed && options.precision,
            "Chance: Cannot specify both fixed and precision."
        );

        var num;
        var fixed = Math.pow(10, options.fixed);

        var max = MAX_INT / fixed;
        var min = -max;

        testRange(
            options.min && options.fixed && options.min < min,
            "Chance: Min specified is out of range with fixed. Min should be, at least, " + min
        );
        testRange(
            options.max && options.fixed && options.max > max,
            "Chance: Max specified is out of range with fixed. Max should be, at most, " + max
        );

        options = initOptions(options, { min : min, max : max });

        // Todo - Make this work!
        // options.precision = (typeof options.precision !== "undefined") ? options.precision : false;

        num = this.integer({min: options.min * fixed, max: options.max * fixed});
        var num_fixed = (num / fixed).toFixed(options.fixed);

        return parseFloat(num_fixed);
    };

    /**
     *  Return a random integer
     *
     *  NOTE the max and min are INCLUDED in the range. So:
     *  chance.integer({min: 1, max: 3});
     *  would return either 1, 2, or 3.
     *
     *  @param {Object} [options={}] can specify a min and/or max
     *  @returns {Number} a single random integer number
     *  @throws {RangeError} min cannot be greater than max
     */
    Chance.prototype.integer = function (options) {
        // 9007199254740992 (2^53) is the max integer number in JavaScript
        // See: http://vq.io/132sa2j
        options = initOptions(options, {min: MIN_INT, max: MAX_INT});
        testRange(options.min > options.max, "Chance: Min cannot be greater than Max.");

        return Math.floor(this.random() * (options.max - options.min + 1) + options.min);
    };

    /**
     *  Return a random natural
     *
     *  NOTE the max and min are INCLUDED in the range. So:
     *  chance.natural({min: 1, max: 3});
     *  would return either 1, 2, or 3.
     *
     *  @param {Object} [options={}] can specify a min and/or maxm or a numerals count.
     *  @returns {Number} a single random integer number
     *  @throws {RangeError} min cannot be greater than max
     */
    Chance.prototype.natural = function (options) {
        options = initOptions(options, {min: 0, max: MAX_INT});
        if (typeof options.numerals === 'number'){
          testRange(options.numerals < 1, "Chance: Numerals cannot be less than one.");
          options.min = Math.pow(10, options.numerals - 1);
          options.max = Math.pow(10, options.numerals) - 1;
        }
        testRange(options.min < 0, "Chance: Min cannot be less than zero.");
        return this.integer(options);
    };

    /**
     *  Return a random hex number as string
     *
     *  NOTE the max and min are INCLUDED in the range. So:
     *  chance.hex({min: '9', max: 'B'});
     *  would return either '9', 'A' or 'B'.
     *
     *  @param {Object} [options={}] can specify a min and/or max and/or casing
     *  @returns {String} a single random string hex number
     *  @throws {RangeError} min cannot be greater than max
     */
    Chance.prototype.hex = function (options) {
        options = initOptions(options, {min: 0, max: MAX_INT, casing: 'lower'});
        testRange(options.min < 0, "Chance: Min cannot be less than zero.");
		var integer = this.natural({min: options.min, max: options.max});
		if (options.casing === 'upper') {
			return integer.toString(16).toUpperCase();
		}
		return integer.toString(16);
    };

    Chance.prototype.letter = function(options) {
        options = initOptions(options, {casing: 'lower'});
        var pool = "abcdefghijklmnopqrstuvwxyz";
        var letter = this.character({pool: pool});
        if (options.casing === 'upper') {
            letter = letter.toUpperCase();
        }
        return letter;
    }

    /**
     *  Return a random string
     *
     *  @param {Object} [options={}] can specify a length
     *  @returns {String} a string of random length
     *  @throws {RangeError} length cannot be less than zero
     */
    Chance.prototype.string = function (options) {
        options = initOptions(options, { length: this.natural({min: 5, max: 20}) });
        testRange(options.length < 0, "Chance: Length cannot be less than zero.");
        var length = options.length,
            text = this.n(this.character, length, options);

        return text.join("");
    };

    /**
     *  Return a random buffer
     *
     *  @param {Object} [options={}] can specify a length
     *  @returns {Buffer} a buffer of random length
     *  @throws {RangeError} length cannot be less than zero
     */
    Chance.prototype.buffer = function (options) {
        if (typeof Buffer === 'undefined') {
            throw new UnsupportedError('Sorry, the buffer() function is not supported on your platform');
        }
        options = initOptions(options, { length: this.natural({min: 5, max: 20}) });
        testRange(options.length < 0, "Chance: Length cannot be less than zero.");
        var length = options.length;
        var content = this.n(this.character, length, options);

        return Buffer.from(content);
    };

    // -- End Basics --

    // -- Helpers --

    Chance.prototype.capitalize = function (word) {
        return word.charAt(0).toUpperCase() + word.substr(1);
    };

    Chance.prototype.mixin = function (obj) {
        for (var func_name in obj) {
            Chance.prototype[func_name] = obj[func_name];
        }
        return this;
    };

    /**
     *  Given a function that generates something random and a number of items to generate,
     *    return an array of items where none repeat.
     *
     *  @param {Function} fn the function that generates something random
     *  @param {Number} num number of terms to generate
     *  @param {Object} options any options to pass on to the generator function
     *  @returns {Array} an array of length `num` with every item generated by `fn` and unique
     *
     *  There can be more parameters after these. All additional parameters are provided to the given function
     */
    Chance.prototype.unique = function(fn, num, options) {
        testRange(
            typeof fn !== "function",
            "Chance: The first argument must be a function."
        );

        var comparator = function(arr, val) { return arr.indexOf(val) !== -1; };

        if (options) {
            comparator = options.comparator || comparator;
        }

        var arr = [], count = 0, result, MAX_DUPLICATES = num * 50, params = slice.call(arguments, 2);

        while (arr.length < num) {
            var clonedParams = JSON.parse(JSON.stringify(params));
            result = fn.apply(this, clonedParams);
            if (!comparator(arr, result)) {
                arr.push(result);
                // reset count when unique found
                count = 0;
            }

            if (++count > MAX_DUPLICATES) {
                throw new RangeError("Chance: num is likely too large for sample set");
            }
        }
        return arr;
    };

    /**
     *  Gives an array of n random terms
     *
     *  @param {Function} fn the function that generates something random
     *  @param {Number} n number of terms to generate
     *  @returns {Array} an array of length `n` with items generated by `fn`
     *
     *  There can be more parameters after these. All additional parameters are provided to the given function
     */
    Chance.prototype.n = function(fn, n) {
        testRange(
            typeof fn !== "function",
            "Chance: The first argument must be a function."
        );

        if (typeof n === 'undefined') {
            n = 1;
        }
        var i = n, arr = [], params = slice.call(arguments, 2);

        // Providing a negative count should result in a noop.
        i = Math.max( 0, i );

        for (null; i--; null) {
            arr.push(fn.apply(this, params));
        }

        return arr;
    };

    // H/T to SO for this one: http://vq.io/OtUrZ5
    Chance.prototype.pad = function (number, width, pad) {
        // Default pad to 0 if none provided
        pad = pad || '0';
        // Convert number to a string
        number = number + '';
        return number.length >= width ? number : new Array(width - number.length + 1).join(pad) + number;
    };

    // DEPRECATED on 2015-10-01
    Chance.prototype.pick = function (arr, count) {
        if (arr.length === 0) {
            throw new RangeError("Chance: Cannot pick() from an empty array");
        }
        if (!count || count === 1) {
            return arr[this.natural({max: arr.length - 1})];
        } else {
            return this.shuffle(arr).slice(0, count);
        }
    };

    // Given an array, returns a single random element
    Chance.prototype.pickone = function (arr) {
        if (arr.length === 0) {
          throw new RangeError("Chance: Cannot pickone() from an empty array");
        }
        return arr[this.natural({max: arr.length - 1})];
    };

    // Given an array, returns a random set with 'count' elements
    Chance.prototype.pickset = function (arr, count) {
        if (count === 0) {
            return [];
        }
        if (arr.length === 0) {
            throw new RangeError("Chance: Cannot pickset() from an empty array");
        }
        if (count < 0) {
            throw new RangeError("Chance: Count must be a positive number");
        }
        if (!count || count === 1) {
            return [ this.pickone(arr) ];
        } else {
            return this.shuffle(arr).slice(0, count);
        }
    };

    Chance.prototype.shuffle = function (arr) {
        var new_array = [],
            j = 0,
            length = Number(arr.length),
            source_indexes = range(length),
            last_source_index = length - 1,
            selected_source_index;

        for (var i = 0; i < length; i++) {
            // Pick a random index from the array
            selected_source_index = this.natural({max: last_source_index});
            j = source_indexes[selected_source_index];

            // Add it to the new array
            new_array[i] = arr[j];

            // Mark the source index as used
            source_indexes[selected_source_index] = source_indexes[last_source_index];
            last_source_index -= 1;
        }

        return new_array;
    };

    // Returns a single item from an array with relative weighting of odds
    Chance.prototype.weighted = function (arr, weights, trim) {
        if (arr.length !== weights.length) {
            throw new RangeError("Chance: Length of array and weights must match");
        }

        // scan weights array and sum valid entries
        var sum = 0;
        var val;
        for (var weightIndex = 0; weightIndex < weights.length; ++weightIndex) {
            val = weights[weightIndex];
            if (isNaN(val)) {
                throw new RangeError("Chance: All weights must be numbers");
            }

            if (val > 0) {
                sum += val;
            }
        }

        if (sum === 0) {
            throw new RangeError("Chance: No valid entries in array weights");
        }

        // select a value within range
        var selected = this.random() * sum;

        // find array entry corresponding to selected value
        var total = 0;
        var lastGoodIdx = -1;
        var chosenIdx;
        for (weightIndex = 0; weightIndex < weights.length; ++weightIndex) {
            val = weights[weightIndex];
            total += val;
            if (val > 0) {
                if (selected <= total) {
                    chosenIdx = weightIndex;
                    break;
                }
                lastGoodIdx = weightIndex;
            }

            // handle any possible rounding error comparison to ensure something is picked
            if (weightIndex === (weights.length - 1)) {
                chosenIdx = lastGoodIdx;
            }
        }

        var chosen = arr[chosenIdx];
        trim = (typeof trim === 'undefined') ? false : trim;
        if (trim) {
            arr.splice(chosenIdx, 1);
            weights.splice(chosenIdx, 1);
        }

        return chosen;
    };

    // -- End Helpers --

    // -- Text --

    Chance.prototype.paragraph = function (options) {
        options = initOptions(options);

        var sentences = options.sentences || this.natural({min: 3, max: 7}),
            sentence_array = this.n(this.sentence, sentences);

        return sentence_array.join(' ');
    };

    // Could get smarter about this than generating random words and
    // chaining them together. Such as: http://vq.io/1a5ceOh
    Chance.prototype.sentence = function (options) {
        options = initOptions(options);

        var words = options.words || this.natural({min: 12, max: 18}),
            punctuation = options.punctuation,
            text, word_array = this.n(this.word, words);

        text = word_array.join(' ');

        // Capitalize first letter of sentence
        text = this.capitalize(text);

        // Make sure punctuation has a usable value
        if (punctuation !== false && !/^[\.\?;!:]$/.test(punctuation)) {
            punctuation = '.';
        }

        // Add punctuation mark
        if (punctuation) {
            text += punctuation;
        }

        return text;
    };

    Chance.prototype.syllable = function (options) {
        options = initOptions(options);

        var length = options.length || this.natural({min: 2, max: 3}),
            consonants = 'bcdfghjklmnprstvwz', // consonants except hard to speak ones
            vowels = 'aeiou', // vowels
            all = consonants + vowels, // all
            text = '',
            chr;

        // I'm sure there's a more elegant way to do this, but this works
        // decently well.
        for (var i = 0; i < length; i++) {
            if (i === 0) {
                // First character can be anything
                chr = this.character({pool: all});
            } else if (consonants.indexOf(chr) === -1) {
                // Last character was a vowel, now we want a consonant
                chr = this.character({pool: consonants});
            } else {
                // Last character was a consonant, now we want a vowel
                chr = this.character({pool: vowels});
            }

            text += chr;
        }

        if (options.capitalize) {
            text = this.capitalize(text);
        }

        return text;
    };

    Chance.prototype.word = function (options) {
        options = initOptions(options);

        testRange(
            options.syllables && options.length,
            "Chance: Cannot specify both syllables AND length."
        );

        var syllables = options.syllables || this.natural({min: 1, max: 3}),
            text = '';

        if (options.length) {
            // Either bound word by length
            do {
                text += this.syllable();
            } while (text.length < options.length);
            text = text.substring(0, options.length);
        } else {
            // Or by number of syllables
            for (var i = 0; i < syllables; i++) {
                text += this.syllable();
            }
        }

        if (options.capitalize) {
            text = this.capitalize(text);
        }

        return text;
    };

    // -- End Text --

    // -- Person --

    Chance.prototype.age = function (options) {
        options = initOptions(options);
        var ageRange;

        switch (options.type) {
            case 'child':
                ageRange = {min: 0, max: 12};
                break;
            case 'teen':
                ageRange = {min: 13, max: 19};
                break;
            case 'adult':
                ageRange = {min: 18, max: 65};
                break;
            case 'senior':
                ageRange = {min: 65, max: 100};
                break;
            case 'all':
                ageRange = {min: 0, max: 100};
                break;
            default:
                ageRange = {min: 18, max: 65};
                break;
        }

        return this.natural(ageRange);
    };

    Chance.prototype.birthday = function (options) {
        var age = this.age(options);
        var currentYear = new Date().getFullYear();

        if (options && options.type) {
            var min = new Date();
            var max = new Date();
            min.setFullYear(currentYear - age - 1);
            max.setFullYear(currentYear - age);

            options = initOptions(options, {
                min: min,
                max: max
            });
        } else {
            options = initOptions(options, {
                year: currentYear - age
            });
        }

        return this.date(options);
    };

    // CPF; ID to identify taxpayers in Brazil
    Chance.prototype.cpf = function (options) {
        options = initOptions(options, {
            formatted: true
        });

        var n = this.n(this.natural, 9, { max: 9 });
        var d1 = n[8]*2+n[7]*3+n[6]*4+n[5]*5+n[4]*6+n[3]*7+n[2]*8+n[1]*9+n[0]*10;
        d1 = 11 - (d1 % 11);
        if (d1>=10) {
            d1 = 0;
        }
        var d2 = d1*2+n[8]*3+n[7]*4+n[6]*5+n[5]*6+n[4]*7+n[3]*8+n[2]*9+n[1]*10+n[0]*11;
        d2 = 11 - (d2 % 11);
        if (d2>=10) {
            d2 = 0;
        }
        var cpf = ''+n[0]+n[1]+n[2]+'.'+n[3]+n[4]+n[5]+'.'+n[6]+n[7]+n[8]+'-'+d1+d2;
        return options.formatted ? cpf : cpf.replace(/\D/g,'');
    };

    // CNPJ: ID to identify companies in Brazil
    Chance.prototype.cnpj = function (options) {
        options = initOptions(options, {
            formatted: true
        });

        var n = this.n(this.natural, 12, { max: 12 });
        var d1 = n[11]*2+n[10]*3+n[9]*4+n[8]*5+n[7]*6+n[6]*7+n[5]*8+n[4]*9+n[3]*2+n[2]*3+n[1]*4+n[0]*5;
        d1 = 11 - (d1 % 11);
        if (d1<2) {
            d1 = 0;
        }
        var d2 = d1*2+n[11]*3+n[10]*4+n[9]*5+n[8]*6+n[7]*7+n[6]*8+n[5]*9+n[4]*2+n[3]*3+n[2]*4+n[1]*5+n[0]*6;
        d2 = 11 - (d2 % 11);
        if (d2<2) {
            d2 = 0;
        }
        var cnpj = ''+n[0]+n[1]+'.'+n[2]+n[3]+n[4]+'.'+n[5]+n[6]+n[7]+'/'+n[8]+n[9]+n[10]+n[11]+'-'+d1+d2;
        return options.formatted ? cnpj : cnpj.replace(/\D/g,'');
    };

    Chance.prototype.first = function (options) {
        options = initOptions(options, {gender: this.gender(), nationality: 'en'});
        return this.pick(this.get("firstNames")[options.gender.toLowerCase()][options.nationality.toLowerCase()]);
    };

    Chance.prototype.profession = function (options) {
        options = initOptions(options);
        if(options.rank){
            return this.pick(['Apprentice ', 'Junior ', 'Senior ', 'Lead ']) + this.pick(this.get("profession"));
        } else{
            return this.pick(this.get("profession"));
        }
    };

    Chance.prototype.company = function (){
        return this.pick(this.get("company"));
    };

    Chance.prototype.gender = function (options) {
        options = initOptions(options, {extraGenders: []});
        return this.pick(['Male', 'Female'].concat(options.extraGenders));
    };

    Chance.prototype.last = function (options) {
      options = initOptions(options, {nationality: '*'});
      if (options.nationality === "*") {
        var allLastNames = []
        var lastNames = this.get("lastNames")
        Object.keys(lastNames).forEach(function(key, i){
          allLastNames = allLastNames.concat(lastNames[key])
        })
        return this.pick(allLastNames)
      }
      else {
        return this.pick(this.get("lastNames")[options.nationality.toLowerCase()]);
      }

    };

    Chance.prototype.israelId=function(){
        var x=this.string({pool: '0123456789',length:8});
        var y=0;
        for (var i=0;i<x.length;i++){
            var thisDigit=  x[i] *  (i/2===parseInt(i/2) ? 1 : 2);
            thisDigit=this.pad(thisDigit,2).toString();
            thisDigit=parseInt(thisDigit[0]) + parseInt(thisDigit[1]);
            y=y+thisDigit;
        }
        x=x+(10-parseInt(y.toString().slice(-1))).toString().slice(-1);
        return x;
    };

    Chance.prototype.mrz = function (options) {
        var checkDigit = function (input) {
            var alpha = "<ABCDEFGHIJKLMNOPQRSTUVWXYXZ".split(''),
                multipliers = [ 7, 3, 1 ],
                runningTotal = 0;

            if (typeof input !== 'string') {
                input = input.toString();
            }

            input.split('').forEach(function(character, idx) {
                var pos = alpha.indexOf(character);

                if(pos !== -1) {
                    character = pos === 0 ? 0 : pos + 9;
                } else {
                    character = parseInt(character, 10);
                }
                character *= multipliers[idx % multipliers.length];
                runningTotal += character;
            });
            return runningTotal % 10;
        };
        var generate = function (opts) {
            var pad = function (length) {
                return new Array(length + 1).join('<');
            };
            var number = [ 'P<',
                           opts.issuer,
                           opts.last.toUpperCase(),
                           '<<',
                           opts.first.toUpperCase(),
                           pad(39 - (opts.last.length + opts.first.length + 2)),
                           opts.passportNumber,
                           checkDigit(opts.passportNumber),
                           opts.nationality,
                           opts.dob,
                           checkDigit(opts.dob),
                           opts.gender,
                           opts.expiry,
                           checkDigit(opts.expiry),
                           pad(14),
                           checkDigit(pad(14)) ].join('');

            return number +
                (checkDigit(number.substr(44, 10) +
                            number.substr(57, 7) +
                            number.substr(65, 7)));
        };

        var that = this;

        options = initOptions(options, {
            first: this.first(),
            last: this.last(),
            passportNumber: this.integer({min: 100000000, max: 999999999}),
            dob: (function () {
                var date = that.birthday({type: 'adult'});
                return [date.getFullYear().toString().substr(2),
                        that.pad(date.getMonth() + 1, 2),
                        that.pad(date.getDate(), 2)].join('');
            }()),
            expiry: (function () {
                var date = new Date();
                return [(date.getFullYear() + 5).toString().substr(2),
                        that.pad(date.getMonth() + 1, 2),
                        that.pad(date.getDate(), 2)].join('');
            }()),
            gender: this.gender() === 'Female' ? 'F': 'M',
            issuer: 'GBR',
            nationality: 'GBR'
        });
        return generate (options);
    };

    Chance.prototype.name = function (options) {
        options = initOptions(options);

        var first = this.first(options),
            last = this.last(options),
            name;

        if (options.middle) {
            name = first + ' ' + this.first(options) + ' ' + last;
        } else if (options.middle_initial) {
            name = first + ' ' + this.character({alpha: true, casing: 'upper'}) + '. ' + last;
        } else {
            name = first + ' ' + last;
        }

        if (options.prefix) {
            name = this.prefix(options) + ' ' + name;
        }

        if (options.suffix) {
            name = name + ' ' + this.suffix(options);
        }

        return name;
    };

    // Return the list of available name prefixes based on supplied gender.
    // @todo introduce internationalization
    Chance.prototype.name_prefixes = function (gender) {
        gender = gender || "all";
        gender = gender.toLowerCase();

        var prefixes = [
            { name: 'Doctor', abbreviation: 'Dr.' }
        ];

        if (gender === "male" || gender === "all") {
            prefixes.push({ name: 'Mister', abbreviation: 'Mr.' });
        }

        if (gender === "female" || gender === "all") {
            prefixes.push({ name: 'Miss', abbreviation: 'Miss' });
            prefixes.push({ name: 'Misses', abbreviation: 'Mrs.' });
        }

        return prefixes;
    };

    // Alias for name_prefix
    Chance.prototype.prefix = function (options) {
        return this.name_prefix(options);
    };

    Chance.prototype.name_prefix = function (options) {
        options = initOptions(options, { gender: "all" });
        return options.full ?
            this.pick(this.name_prefixes(options.gender)).name :
            this.pick(this.name_prefixes(options.gender)).abbreviation;
    };
    //Hungarian ID number
    Chance.prototype.HIDN= function(){
     //Hungarian ID nuber structure: XXXXXXYY (X=number,Y=Capital Latin letter)
      var idn_pool="0123456789";
      var idn_chrs="ABCDEFGHIJKLMNOPQRSTUVWXYXZ";
      var idn="";
        idn+=this.string({pool:idn_pool,length:6});
        idn+=this.string({pool:idn_chrs,length:2});
        return idn;
    };


    Chance.prototype.ssn = function (options) {
        options = initOptions(options, {ssnFour: false, dashes: true});
        var ssn_pool = "1234567890",
            ssn,
            dash = options.dashes ? '-' : '';

        if(!options.ssnFour) {
            ssn = this.string({pool: ssn_pool, length: 3}) + dash +
            this.string({pool: ssn_pool, length: 2}) + dash +
            this.string({pool: ssn_pool, length: 4});
        } else {
            ssn = this.string({pool: ssn_pool, length: 4});
        }
        return ssn;
    };

    // Aadhar is similar to ssn, used in India to uniquely identify a person
    Chance.prototype.aadhar = function (options) {
        options = initOptions(options, {onlyLastFour: false, separatedByWhiteSpace: true});
        var aadhar_pool = "1234567890",
            aadhar,
            whiteSpace = options.separatedByWhiteSpace ? ' ' : '';

        if(!options.onlyLastFour) {
            aadhar = this.string({pool: aadhar_pool, length: 4}) + whiteSpace +
            this.string({pool: aadhar_pool, length: 4}) + whiteSpace +
            this.string({pool: aadhar_pool, length: 4});
        } else {
            aadhar = this.string({pool: aadhar_pool, length: 4});
        }
        return aadhar;
    };

    // Return the list of available name suffixes
    // @todo introduce internationalization
    Chance.prototype.name_suffixes = function () {
        var suffixes = [
            { name: 'Doctor of Osteopathic Medicine', abbreviation: 'D.O.' },
            { name: 'Doctor of Philosophy', abbreviation: 'Ph.D.' },
            { name: 'Esquire', abbreviation: 'Esq.' },
            { name: 'Junior', abbreviation: 'Jr.' },
            { name: 'Juris Doctor', abbreviation: 'J.D.' },
            { name: 'Master of Arts', abbreviation: 'M.A.' },
            { name: 'Master of Business Administration', abbreviation: 'M.B.A.' },
            { name: 'Master of Science', abbreviation: 'M.S.' },
            { name: 'Medical Doctor', abbreviation: 'M.D.' },
            { name: 'Senior', abbreviation: 'Sr.' },
            { name: 'The Third', abbreviation: 'III' },
            { name: 'The Fourth', abbreviation: 'IV' },
            { name: 'Bachelor of Engineering', abbreviation: 'B.E' },
            { name: 'Bachelor of Technology', abbreviation: 'B.TECH' }
        ];
        return suffixes;
    };

    // Alias for name_suffix
    Chance.prototype.suffix = function (options) {
        return this.name_suffix(options);
    };

    Chance.prototype.name_suffix = function (options) {
        options = initOptions(options);
        return options.full ?
            this.pick(this.name_suffixes()).name :
            this.pick(this.name_suffixes()).abbreviation;
    };

    Chance.prototype.nationalities = function () {
        return this.get("nationalities");
    };

    // Generate random nationality based on json list
    Chance.prototype.nationality = function () {
        var nationality = this.pick(this.nationalities());
        return nationality.name;
    };

    // -- End Person --

    // -- Mobile --
    // Android GCM Registration ID
    Chance.prototype.android_id = function () {
        return "APA91" + this.string({ pool: "0123456789abcefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_", length: 178 });
    };

    // Apple Push Token
    Chance.prototype.apple_token = function () {
        return this.string({ pool: "abcdef1234567890", length: 64 });
    };

    // Windows Phone 8 ANID2
    Chance.prototype.wp8_anid2 = function () {
        return base64( this.hash( { length : 32 } ) );
    };

    // Windows Phone 7 ANID
    Chance.prototype.wp7_anid = function () {
        return 'A=' + this.guid().replace(/-/g, '').toUpperCase() + '&E=' + this.hash({ length:3 }) + '&W=' + this.integer({ min:0, max:9 });
    };

    // BlackBerry Device PIN
    Chance.prototype.bb_pin = function () {
        return this.hash({ length: 8 });
    };

    // -- End Mobile --

    // -- Web --
    Chance.prototype.avatar = function (options) {
        var url = null;
        var URL_BASE = '//www.gravatar.com/avatar/';
        var PROTOCOLS = {
            http: 'http',
            https: 'https'
        };
        var FILE_TYPES = {
            bmp: 'bmp',
            gif: 'gif',
            jpg: 'jpg',
            png: 'png'
        };
        var FALLBACKS = {
            '404': '404', // Return 404 if not found
            mm: 'mm', // Mystery man
            identicon: 'identicon', // Geometric pattern based on hash
            monsterid: 'monsterid', // A generated monster icon
            wavatar: 'wavatar', // A generated face
            retro: 'retro', // 8-bit icon
            blank: 'blank' // A transparent png
        };
        var RATINGS = {
            g: 'g',
            pg: 'pg',
            r: 'r',
            x: 'x'
        };
        var opts = {
            protocol: null,
            email: null,
            fileExtension: null,
            size: null,
            fallback: null,
            rating: null
        };

        if (!options) {
            // Set to a random email
            opts.email = this.email();
            options = {};
        }
        else if (typeof options === 'string') {
            opts.email = options;
            options = {};
        }
        else if (typeof options !== 'object') {
            return null;
        }
        else if (options.constructor === 'Array') {
            return null;
        }

        opts = initOptions(options, opts);

        if (!opts.email) {
            // Set to a random email
            opts.email = this.email();
        }

        // Safe checking for params
        opts.protocol = PROTOCOLS[opts.protocol] ? opts.protocol + ':' : '';
        opts.size = parseInt(opts.size, 0) ? opts.size : '';
        opts.rating = RATINGS[opts.rating] ? opts.rating : '';
        opts.fallback = FALLBACKS[opts.fallback] ? opts.fallback : '';
        opts.fileExtension = FILE_TYPES[opts.fileExtension] ? opts.fileExtension : '';

        url =
            opts.protocol +
            URL_BASE +
            this.bimd5.md5(opts.email) +
            (opts.fileExtension ? '.' + opts.fileExtension : '') +
            (opts.size || opts.rating || opts.fallback ? '?' : '') +
            (opts.size ? '&s=' + opts.size.toString() : '') +
            (opts.rating ? '&r=' + opts.rating : '') +
            (opts.fallback ? '&d=' + opts.fallback : '')
            ;

        return url;
    };

    /**
     * #Description:
     * ===============================================
     * Generate random color value base on color type:
     * -> hex
     * -> rgb
     * -> rgba
     * -> 0x
     * -> named color
     *
     * #Examples:
     * ===============================================
     * * Geerate random hex color
     * chance.color() => '#79c157' / 'rgb(110,52,164)' / '0x67ae0b' / '#e2e2e2' / '#29CFA7'
     *
     * * Generate Hex based color value
     * chance.color({format: 'hex'})    => '#d67118'
     *
     * * Generate simple rgb value
     * chance.color({format: 'rgb'})    => 'rgb(110,52,164)'
     *
     * * Generate Ox based color value
     * chance.color({format: '0x'})     => '0x67ae0b'
     *
     * * Generate graiscale based value
     * chance.color({grayscale: true})  => '#e2e2e2'
     *
     * * Return valide color name
     * chance.color({format: 'name'})   => 'red'
     *
     * * Make color uppercase
     * chance.color({casing: 'upper'})  => '#29CFA7'
     *
     * * Min Max values for RGBA
     * var light_red = chance.color({format: 'hex', min_red: 200, max_red: 255, max_green: 0, max_blue: 0, min_alpha: .2, max_alpha: .3});
     *
     * @param  [object] options
     * @return [string] color value
     */
    Chance.prototype.color = function (options) {
        function gray(value, delimiter) {
            return [value, value, value].join(delimiter || '');
        }

        function rgb(hasAlpha) {
            var rgbValue     = (hasAlpha)    ? 'rgba' : 'rgb';
            var alphaChannel = (hasAlpha)    ? (',' + this.floating({min:min_alpha, max:max_alpha})) : "";
            var colorValue   = (isGrayscale) ? (gray(this.natural({min: min_rgb, max: max_rgb}), ',')) : (this.natural({min: min_green, max: max_green}) + ',' + this.natural({min: min_blue, max: max_blue}) + ',' + this.natural({max: 255}));
            return rgbValue + '(' + colorValue + alphaChannel + ')';
        }

        function hex(start, end, withHash) {
            var symbol = (withHash) ? "#" : "";
            var hexstring = "";

            if (isGrayscale) {
                hexstring = gray(this.pad(this.hex({min: min_rgb, max: max_rgb}), 2));
                if (options.format === "shorthex") {
                    hexstring = gray(this.hex({min: 0, max: 15}));
                }
            }
            else {
                if (options.format === "shorthex") {
                    hexstring = this.pad(this.hex({min: Math.floor(min_red / 16), max: Math.floor(max_red / 16)}), 1) + this.pad(this.hex({min: Math.floor(min_green / 16), max: Math.floor(max_green / 16)}), 1) + this.pad(this.hex({min: Math.floor(min_blue / 16), max: Math.floor(max_blue / 16)}), 1);
                }
                else if (min_red !== undefined || max_red !== undefined || min_green !== undefined || max_green !== undefined || min_blue !== undefined || max_blue !== undefined) {
                    hexstring = this.pad(this.hex({min: min_red, max: max_red}), 2) + this.pad(this.hex({min: min_green, max: max_green}), 2) + this.pad(this.hex({min: min_blue, max: max_blue}), 2);
                }
                else {
                    hexstring = this.pad(this.hex({min: min_rgb, max: max_rgb}), 2) + this.pad(this.hex({min: min_rgb, max: max_rgb}), 2) + this.pad(this.hex({min: min_rgb, max: max_rgb}), 2);
                }
            }

            return symbol + hexstring;
        }

        options = initOptions(options, {
            format: this.pick(['hex', 'shorthex', 'rgb', 'rgba', '0x', 'name']),
            grayscale: false,
            casing: 'lower',
            min: 0,
            max: 255,
            min_red: undefined,
            max_red: undefined,
            min_green: undefined,
            max_green: undefined,
            min_blue: undefined,
            max_blue: undefined,
            min_alpha: 0,
            max_alpha: 1
        });

        var isGrayscale = options.grayscale;
        var min_rgb = options.min;
        var max_rgb = options.max;
        var min_red = options.min_red;
        var max_red = options.max_red;
        var min_green = options.min_green;
        var max_green = options.max_green;
        var min_blue = options.min_blue;
        var max_blue = options.max_blue;
        var min_alpha = options.min_alpha;
        var max_alpha = options.max_alpha;
        if (options.min_red === undefined) { min_red = min_rgb; }
        if (options.max_red === undefined) { max_red = max_rgb; }
        if (options.min_green === undefined) { min_green = min_rgb; }
        if (options.max_green === undefined) { max_green = max_rgb; }
        if (options.min_blue === undefined) { min_blue = min_rgb; }
        if (options.max_blue === undefined) { max_blue = max_rgb; }
        if (options.min_alpha === undefined) { min_alpha = 0; }
        if (options.max_alpha === undefined) { max_alpha = 1; }
        if (isGrayscale && min_rgb === 0 && max_rgb === 255 && min_red !== undefined && max_red !== undefined) {
            min_rgb = ((min_red + min_green + min_blue) / 3);
            max_rgb = ((max_red + max_green + max_blue) / 3);
        }
        var colorValue;

        if (options.format === 'hex') {
            colorValue = hex.call(this, 2, 6, true);
        }
        else if (options.format === 'shorthex') {
            colorValue = hex.call(this, 1, 3, true);
        }
        else if (options.format === 'rgb') {
            colorValue = rgb.call(this, false);
        }
        else if (options.format === 'rgba') {
            colorValue = rgb.call(this, true);
        }
        else if (options.format === '0x') {
            colorValue = '0x' + hex.call(this, 2, 6);
        }
        else if(options.format === 'name') {
            return this.pick(this.get("colorNames"));
        }
        else {
            throw new RangeError('Invalid format provided. Please provide one of "hex", "shorthex", "rgb", "rgba", "0x" or "name".');
        }

        if (options.casing === 'upper' ) {
            colorValue = colorValue.toUpperCase();
        }

        return colorValue;
    };

    Chance.prototype.domain = function (options) {
        options = initOptions(options);
        return this.word() + '.' + (options.tld || this.tld());
    };

    Chance.prototype.email = function (options) {
        options = initOptions(options);
        return this.word({length: options.length}) + '@' + (options.domain || this.domain());
    };

    /**
     * #Description:
     * ===============================================
     * Generate a random Facebook id, aka fbid.
     *
     * NOTE: At the moment (Sep 2017), Facebook ids are
     * "numeric strings" of length 16.
     * However, Facebook Graph API documentation states that
     * "it is extremely likely to change over time".
     * @see https://developers.facebook.com/docs/graph-api/overview/
     *
     * #Examples:
     * ===============================================
     * chance.fbid() => '1000035231661304'
     *
     * @return [string] facebook id
     */
    Chance.prototype.fbid = function () {
        return '10000' + this.string({pool: "1234567890", length: 11});
    };

    Chance.prototype.google_analytics = function () {
        var account = this.pad(this.natural({max: 999999}), 6);
        var property = this.pad(this.natural({max: 99}), 2);

        return 'UA-' + account + '-' + property;
    };

    Chance.prototype.hashtag = function () {
        return '#' + this.word();
    };

    Chance.prototype.ip = function () {
        // Todo: This could return some reserved IPs. See http://vq.io/137dgYy
        // this should probably be updated to account for that rare as it may be
        return this.natural({min: 1, max: 254}) + '.' +
               this.natural({max: 255}) + '.' +
               this.natural({max: 255}) + '.' +
               this.natural({min: 1, max: 254});
    };

    Chance.prototype.ipv6 = function () {
        var ip_addr = this.n(this.hash, 8, {length: 4});

        return ip_addr.join(":");
    };

    Chance.prototype.klout = function () {
        return this.natural({min: 1, max: 99});
    };

    Chance.prototype.semver = function (options) {
        options = initOptions(options, { include_prerelease: true });

        var range = this.pickone(["^", "~", "<", ">", "<=", ">=", "="]);
        if (options.range) {
            range = options.range;
        }

        var prerelease = "";
        if (options.include_prerelease) {
            prerelease = this.weighted(["", "-dev", "-beta", "-alpha"], [50, 10, 5, 1]);
        }
        return range + this.rpg('3d10').join('.') + prerelease;
    };

    Chance.prototype.tlds = function () {
        return ['com', 'org', 'edu', 'gov', 'co.uk', 'net', 'io', 'ac', 'ad', 'ae', 'af', 'ag', 'ai', 'al', 'am', 'an', 'ao', 'aq', 'ar', 'as', 'at', 'au', 'aw', 'ax', 'az', 'ba', 'bb', 'bd', 'be', 'bf', 'bg', 'bh', 'bi', 'bj', 'bm', 'bn', 'bo', 'bq', 'br', 'bs', 'bt', 'bv', 'bw', 'by', 'bz', 'ca', 'cc', 'cd', 'cf', 'cg', 'ch', 'ci', 'ck', 'cl', 'cm', 'cn', 'co', 'cr', 'cu', 'cv', 'cw', 'cx', 'cy', 'cz', 'de', 'dj', 'dk', 'dm', 'do', 'dz', 'ec', 'ee', 'eg', 'eh', 'er', 'es', 'et', 'eu', 'fi', 'fj', 'fk', 'fm', 'fo', 'fr', 'ga', 'gb', 'gd', 'ge', 'gf', 'gg', 'gh', 'gi', 'gl', 'gm', 'gn', 'gp', 'gq', 'gr', 'gs', 'gt', 'gu', 'gw', 'gy', 'hk', 'hm', 'hn', 'hr', 'ht', 'hu', 'id', 'ie', 'il', 'im', 'in', 'io', 'iq', 'ir', 'is', 'it', 'je', 'jm', 'jo', 'jp', 'ke', 'kg', 'kh', 'ki', 'km', 'kn', 'kp', 'kr', 'kw', 'ky', 'kz', 'la', 'lb', 'lc', 'li', 'lk', 'lr', 'ls', 'lt', 'lu', 'lv', 'ly', 'ma', 'mc', 'md', 'me', 'mg', 'mh', 'mk', 'ml', 'mm', 'mn', 'mo', 'mp', 'mq', 'mr', 'ms', 'mt', 'mu', 'mv', 'mw', 'mx', 'my', 'mz', 'na', 'nc', 'ne', 'nf', 'ng', 'ni', 'nl', 'no', 'np', 'nr', 'nu', 'nz', 'om', 'pa', 'pe', 'pf', 'pg', 'ph', 'pk', 'pl', 'pm', 'pn', 'pr', 'ps', 'pt', 'pw', 'py', 'qa', 're', 'ro', 'rs', 'ru', 'rw', 'sa', 'sb', 'sc', 'sd', 'se', 'sg', 'sh', 'si', 'sj', 'sk', 'sl', 'sm', 'sn', 'so', 'sr', 'ss', 'st', 'su', 'sv', 'sx', 'sy', 'sz', 'tc', 'td', 'tf', 'tg', 'th', 'tj', 'tk', 'tl', 'tm', 'tn', 'to', 'tp', 'tr', 'tt', 'tv', 'tw', 'tz', 'ua', 'ug', 'uk', 'us', 'uy', 'uz', 'va', 'vc', 've', 'vg', 'vi', 'vn', 'vu', 'wf', 'ws', 'ye', 'yt', 'za', 'zm', 'zw'];
    };

    Chance.prototype.tld = function () {
        return this.pick(this.tlds());
    };

    Chance.prototype.twitter = function () {
        return '@' + this.word();
    };

    Chance.prototype.url = function (options) {
        options = initOptions(options, { protocol: "http", domain: this.domain(options), domain_prefix: "", path: this.word(), extensions: []});

        var extension = options.extensions.length > 0 ? "." + this.pick(options.extensions) : "";
        var domain = options.domain_prefix ? options.domain_prefix + "." + options.domain : options.domain;

        return options.protocol + "://" + domain + "/" + options.path + extension;
    };

    Chance.prototype.port = function() {
        return this.integer({min: 0, max: 65535});
    };

    Chance.prototype.locale = function (options) {
        options = initOptions(options);
        if (options.region){
          return this.pick(this.get("locale_regions"));
        } else {
          return this.pick(this.get("locale_languages"));
        }
    };

    Chance.prototype.locales = function (options) {
      options = initOptions(options);
      if (options.region){
        return this.get("locale_regions");
      } else {
        return this.get("locale_languages");
      }
    };

    Chance.prototype.loremPicsum = function (options) {
        options = initOptions(options, { width: 500, height: 500, greyscale: false, blurred: false });

        var greyscale = options.greyscale ? 'g/' : '';
        var query = options.blurred ? '/?blur' : '/?random';

        return 'https://picsum.photos/' + greyscale + options.width + '/' + options.height + query;
    }

    // -- End Web --

    // -- Location --

    Chance.prototype.address = function (options) {
        options = initOptions(options);
        return this.natural({min: 5, max: 2000}) + ' ' + this.street(options);
    };

    Chance.prototype.altitude = function (options) {
        options = initOptions(options, {fixed: 5, min: 0, max: 8848});
        return this.floating({
            min: options.min,
            max: options.max,
            fixed: options.fixed
        });
    };

    Chance.prototype.areacode = function (options) {
        options = initOptions(options, {parens : true});
        // Don't want area codes to start with 1, or have a 9 as the second digit
        var areacode = this.natural({min: 2, max: 9}).toString() +
                this.natural({min: 0, max: 8}).toString() +
                this.natural({min: 0, max: 9}).toString();

        return options.parens ? '(' + areacode + ')' : areacode;
    };

    Chance.prototype.city = function () {
        return this.capitalize(this.word({syllables: 3}));
    };

    Chance.prototype.coordinates = function (options) {
        return this.latitude(options) + ', ' + this.longitude(options);
    };

    Chance.prototype.countries = function () {
        return this.get("countries");
    };

    Chance.prototype.country = function (options) {
        options = initOptions(options);
        var country = this.pick(this.countries());
        return options.raw ? country : options.full ? country.name : country.abbreviation;
    };

    Chance.prototype.depth = function (options) {
        options = initOptions(options, {fixed: 5, min: -10994, max: 0});
        return this.floating({
            min: options.min,
            max: options.max,
            fixed: options.fixed
        });
    };

    Chance.prototype.geohash = function (options) {
        options = initOptions(options, { length: 7 });
        return this.string({ length: options.length, pool: '0123456789bcdefghjkmnpqrstuvwxyz' });
    };

    Chance.prototype.geojson = function (options) {
        return this.latitude(options) + ', ' + this.longitude(options) + ', ' + this.altitude(options);
    };

    Chance.prototype.latitude = function (options) {
        options = initOptions(options, {fixed: 5, min: -90, max: 90});
        return this.floating({min: options.min, max: options.max, fixed: options.fixed});
    };

    Chance.prototype.longitude = function (options) {
        options = initOptions(options, {fixed: 5, min: -180, max: 180});
        return this.floating({min: options.min, max: options.max, fixed: options.fixed});
    };

    Chance.prototype.phone = function (options) {
        var self = this,
            numPick,
            ukNum = function (parts) {
                var section = [];
                //fills the section part of the phone number with random numbers.
                parts.sections.forEach(function(n) {
                    section.push(self.string({ pool: '0123456789', length: n}));
                });
                return parts.area + section.join(' ');
            };
        options = initOptions(options, {
            formatted: true,
            country: 'us',
            mobile: false
        });
        if (!options.formatted) {
            options.parens = false;
        }
        var phone;
        switch (options.country) {
            case 'fr':
                if (!options.mobile) {
                    numPick = this.pick([
                        // Valid zone and département codes.
                        '01' + this.pick(['30', '34', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '53', '55', '56', '58', '60', '64', '69', '70', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83']) + self.string({ pool: '0123456789', length: 6}),
                        '02' + this.pick(['14', '18', '22', '23', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '40', '41', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '56', '57', '61', '62', '69', '72', '76', '77', '78', '85', '90', '96', '97', '98', '99']) + self.string({ pool: '0123456789', length: 6}),
                        '03' + this.pick(['10', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '39', '44', '45', '51', '52', '54', '55', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90']) + self.string({ pool: '0123456789', length: 6}),
                        '04' + this.pick(['11', '13', '15', '20', '22', '26', '27', '30', '32', '34', '37', '42', '43', '44', '50', '56', '57', '63', '66', '67', '68', '69', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '88', '89', '90', '91', '92', '93', '94', '95', '97', '98']) + self.string({ pool: '0123456789', length: 6}),
                        '05' + this.pick(['08', '16', '17', '19', '24', '31', '32', '33', '34', '35', '40', '45', '46', '47', '49', '53', '55', '56', '57', '58', '59', '61', '62', '63', '64', '65', '67', '79', '81', '82', '86', '87', '90', '94']) + self.string({ pool: '0123456789', length: 6}),
                        '09' + self.string({ pool: '0123456789', length: 8}),
                    ]);
                    phone = options.formatted ? numPick.match(/../g).join(' ') : numPick;
                } else {
                    numPick = this.pick(['06', '07']) + self.string({ pool: '0123456789', length: 8});
                    phone = options.formatted ? numPick.match(/../g).join(' ') : numPick;
                }
                break;
            case 'uk':
                if (!options.mobile) {
                    numPick = this.pick([
                        //valid area codes of major cities/counties followed by random numbers in required format.

                        { area: '01' + this.character({ pool: '234569' }) + '1 ', sections: [3,4] },
                        { area: '020 ' + this.character({ pool: '378' }), sections: [3,4] },
                        { area: '023 ' + this.character({ pool: '89' }), sections: [3,4] },
                        { area: '024 7', sections: [3,4] },
                        { area: '028 ' + this.pick(['25','28','37','71','82','90','92','95']), sections: [2,4] },
                        { area: '012' + this.pick(['04','08','54','76','97','98']) + ' ', sections: [6] },
                        { area: '013' + this.pick(['63','64','84','86']) + ' ', sections: [6] },
                        { area: '014' + this.pick(['04','20','60','61','80','88']) + ' ', sections: [6] },
                        { area: '015' + this.pick(['24','27','62','66']) + ' ', sections: [6] },
                        { area: '016' + this.pick(['06','29','35','47','59','95']) + ' ', sections: [6] },
                        { area: '017' + this.pick(['26','44','50','68']) + ' ', sections: [6] },
                        { area: '018' + this.pick(['27','37','84','97']) + ' ', sections: [6] },
                        { area: '019' + this.pick(['00','05','35','46','49','63','95']) + ' ', sections: [6] }
                    ]);
                    phone = options.formatted ? ukNum(numPick) : ukNum(numPick).replace(' ', '', 'g');
                } else {
                    numPick = this.pick([
                        { area: '07' + this.pick(['4','5','7','8','9']), sections: [2,6] },
                        { area: '07624 ', sections: [6] }
                    ]);
                    phone = options.formatted ? ukNum(numPick) : ukNum(numPick).replace(' ', '');
                }
                break;
            case 'za':
                if (!options.mobile) {
                    numPick = this.pick([
                       '01' + this.pick(['0', '1', '2', '3', '4', '5', '6', '7', '8']) + self.string({ pool: '0123456789', length: 7}),
                       '02' + this.pick(['1', '2', '3', '4', '7', '8']) + self.string({ pool: '0123456789', length: 7}),
                       '03' + this.pick(['1', '2', '3', '5', '6', '9']) + self.string({ pool: '0123456789', length: 7}),
                       '04' + this.pick(['1', '2', '3', '4', '5','6','7', '8','9']) + self.string({ pool: '0123456789', length: 7}),
                       '05' + this.pick(['1', '3', '4', '6', '7', '8']) + self.string({ pool: '0123456789', length: 7}),
                    ]);
                    phone = options.formatted || numPick;
                } else {
                    numPick = this.pick([
                        '060' + this.pick(['3','4','5','6','7','8','9']) + self.string({ pool: '0123456789', length: 6}),
                        '061' + this.pick(['0','1','2','3','4','5','8']) + self.string({ pool: '0123456789', length: 6}),
                        '06'  + self.string({ pool: '0123456789', length: 7}),
                        '071' + this.pick(['0','1','2','3','4','5','6','7','8','9']) + self.string({ pool: '0123456789', length: 6}),
                        '07'  + this.pick(['2','3','4','6','7','8','9']) + self.string({ pool: '0123456789', length: 7}),
                        '08'  + this.pick(['0','1','2','3','4','5']) + self.string({ pool: '0123456789', length: 7}),
                    ]);
                    phone = options.formatted || numPick;
                }
                break;
            case 'us':
                var areacode = this.areacode(options).toString();
                var exchange = this.natural({ min: 2, max: 9 }).toString() +
                    this.natural({ min: 0, max: 9 }).toString() +
                    this.natural({ min: 0, max: 9 }).toString();
                var subscriber = this.natural({ min: 1000, max: 9999 }).toString(); // this could be random [0-9]{4}
                phone = options.formatted ? areacode + ' ' + exchange + '-' + subscriber : areacode + exchange + subscriber;
                break;
            case 'br':
                var areaCode = this.pick(["11", "12", "13", "14", "15", "16", "17", "18", "19", "21", "22", "24", "27", "28", "31", "32", "33", "34", "35", "37", "38", "41", "42", "43", "44", "45", "46", "47", "48", "49", "51", "53", "54", "55", "61", "62", "63", "64", "65", "66", "67", "68", "69", "71", "73", "74", "75", "77", "79", "81", "82", "83", "84", "85", "86", "87", "88", "89", "91", "92", "93", "94", "95", "96", "97", "98", "99"]);
                var prefix;
                if (options.mobile) {
                    // Brasilian official reference (mobile): http://www.anatel.gov.br/setorregulado/plano-de-numeracao-brasileiro?id=330
                    prefix = '9' + self.string({ pool: '0123456789', length: 4});
                } else {
                    // Brasilian official reference: http://www.anatel.gov.br/setorregulado/plano-de-numeracao-brasileiro?id=331
                    prefix = this.natural({ min: 2000, max: 5999 }).toString();
                }
                var mcdu = self.string({ pool: '0123456789', length: 4});
                phone = options.formatted ? '(' + areaCode + ') ' + prefix + '-' + mcdu : areaCode + prefix + mcdu;
                break;
        }
        return phone;
    };

    Chance.prototype.postal = function () {
        // Postal District
        var pd = this.character({pool: "XVTSRPNKLMHJGECBA"});
        // Forward Sortation Area (FSA)
        var fsa = pd + this.natural({max: 9}) + this.character({alpha: true, casing: "upper"});
        // Local Delivery Unut (LDU)
        var ldu = this.natural({max: 9}) + this.character({alpha: true, casing: "upper"}) + this.natural({max: 9});

        return fsa + " " + ldu;
    };

    Chance.prototype.counties = function (options) {
        options = initOptions(options, { country: 'uk' });
        return this.get("counties")[options.country.toLowerCase()];
    };

    Chance.prototype.county = function (options) {
        return this.pick(this.counties(options)).name;
    };

    Chance.prototype.provinces = function (options) {
        options = initOptions(options, { country: 'ca' });
        return this.get("provinces")[options.country.toLowerCase()];
    };

    Chance.prototype.province = function (options) {
        return (options && options.full) ?
            this.pick(this.provinces(options)).name :
            this.pick(this.provinces(options)).abbreviation;
    };

    Chance.prototype.state = function (options) {
        return (options && options.full) ?
            this.pick(this.states(options)).name :
            this.pick(this.states(options)).abbreviation;
    };

    Chance.prototype.states = function (options) {
        options = initOptions(options, { country: 'us', us_states_and_dc: true } );

        var states;

        switch (options.country.toLowerCase()) {
            case 'us':
                var us_states_and_dc = this.get("us_states_and_dc"),
                    territories = this.get("territories"),
                    armed_forces = this.get("armed_forces");

                states = [];

                if (options.us_states_and_dc) {
                    states = states.concat(us_states_and_dc);
                }
                if (options.territories) {
                    states = states.concat(territories);
                }
                if (options.armed_forces) {
                    states = states.concat(armed_forces);
                }
                break;
            case 'it':
                states = this.get("country_regions")[options.country.toLowerCase()];
                break;
            case 'uk':
                states = this.get("counties")[options.country.toLowerCase()];
                break;
        }

        return states;
    };

    Chance.prototype.street = function (options) {
        options = initOptions(options, { country: 'us', syllables: 2 });
        var     street;

        switch (options.country.toLowerCase()) {
            case 'us':
                street = this.word({ syllables: options.syllables });
                street = this.capitalize(street);
                street += ' ';
                street += options.short_suffix ?
                    this.street_suffix(options).abbreviation :
                    this.street_suffix(options).name;
                break;
            case 'it':
                street = this.word({ syllables: options.syllables });
                street = this.capitalize(street);
                street = (options.short_suffix ?
                    this.street_suffix(options).abbreviation :
                    this.street_suffix(options).name) + " " + street;
                break;
        }
        return street;
    };

    Chance.prototype.street_suffix = function (options) {
        options = initOptions(options, { country: 'us' });
        return this.pick(this.street_suffixes(options));
    };

    Chance.prototype.street_suffixes = function (options) {
        options = initOptions(options, { country: 'us' });
        // These are the most common suffixes.
        return this.get("street_suffixes")[options.country.toLowerCase()];
    };

    // Note: only returning US zip codes, internationalization will be a whole
    // other beast to tackle at some point.
    Chance.prototype.zip = function (options) {
        var zip = this.n(this.natural, 5, {max: 9});

        if (options && options.plusfour === true) {
            zip.push('-');
            zip = zip.concat(this.n(this.natural, 4, {max: 9}));
        }

        return zip.join("");
    };

    // -- End Location --

    // -- Time

    Chance.prototype.ampm = function () {
        return this.bool() ? 'am' : 'pm';
    };

    Chance.prototype.date = function (options) {
        var date_string, date;

        // If interval is specified we ignore preset
        if(options && (options.min || options.max)) {
            options = initOptions(options, {
                american: true,
                string: false
            });
            var min = typeof options.min !== "undefined" ? options.min.getTime() : 1;
            // 100,000,000 days measured relative to midnight at the beginning of 01 January, 1970 UTC. http://es5.github.io/#x15.9.1.1
            var max = typeof options.max !== "undefined" ? options.max.getTime() : 8640000000000000;

            date = new Date(this.integer({min: min, max: max}));
        } else {
            var m = this.month({raw: true});
            var daysInMonth = m.days;

            if(options && options.month) {
                // Mod 12 to allow months outside range of 0-11 (not encouraged, but also not prevented).
                daysInMonth = this.get('months')[((options.month % 12) + 12) % 12].days;
            }

            options = initOptions(options, {
                year: parseInt(this.year(), 10),
                // Necessary to subtract 1 because Date() 0-indexes month but not day or year
                // for some reason.
                month: m.numeric - 1,
                day: this.natural({min: 1, max: daysInMonth}),
                hour: this.hour({twentyfour: true}),
                minute: this.minute(),
                second: this.second(),
                millisecond: this.millisecond(),
                american: true,
                string: false
            });

            date = new Date(options.year, options.month, options.day, options.hour, options.minute, options.second, options.millisecond);
        }

        if (options.american) {
            // Adding 1 to the month is necessary because Date() 0-indexes
            // months but not day for some odd reason.
            date_string = (date.getMonth() + 1) + '/' + date.getDate() + '/' + date.getFullYear();
        } else {
            date_string = date.getDate() + '/' + (date.getMonth() + 1) + '/' + date.getFullYear();
        }

        return options.string ? date_string : date;
    };

    Chance.prototype.hammertime = function (options) {
        return this.date(options).getTime();
    };

    Chance.prototype.hour = function (options) {
        options = initOptions(options, {
            min: options && options.twentyfour ? 0 : 1,
            max: options && options.twentyfour ? 23 : 12
        });

        testRange(options.min < 0, "Chance: Min cannot be less than 0.");
        testRange(options.twentyfour && options.max > 23, "Chance: Max cannot be greater than 23 for twentyfour option.");
        testRange(!options.twentyfour && options.max > 12, "Chance: Max cannot be greater than 12.");
        testRange(options.min > options.max, "Chance: Min cannot be greater than Max.");

        return this.natural({min: options.min, max: options.max});
    };

    Chance.prototype.millisecond = function () {
        return this.natural({max: 999});
    };

    Chance.prototype.minute = Chance.prototype.second = function (options) {
        options = initOptions(options, {min: 0, max: 59});

        testRange(options.min < 0, "Chance: Min cannot be less than 0.");
        testRange(options.max > 59, "Chance: Max cannot be greater than 59.");
        testRange(options.min > options.max, "Chance: Min cannot be greater than Max.");

        return this.natural({min: options.min, max: options.max});
    };

    Chance.prototype.month = function (options) {
        options = initOptions(options, {min: 1, max: 12});

        testRange(options.min < 1, "Chance: Min cannot be less than 1.");
        testRange(options.max > 12, "Chance: Max cannot be greater than 12.");
        testRange(options.min > options.max, "Chance: Min cannot be greater than Max.");

        var month = this.pick(this.months().slice(options.min - 1, options.max));
        return options.raw ? month : month.name;
    };

    Chance.prototype.months = function () {
        return this.get("months");
    };

    Chance.prototype.second = function () {
        return this.natural({max: 59});
    };

    Chance.prototype.timestamp = function () {
        return this.natural({min: 1, max: parseInt(new Date().getTime() / 1000, 10)});
    };

    Chance.prototype.weekday = function (options) {
        options = initOptions(options, {weekday_only: false});
        var weekdays = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"];
        if (!options.weekday_only) {
            weekdays.push("Saturday");
            weekdays.push("Sunday");
        }
        return this.pickone(weekdays);
    };

    Chance.prototype.year = function (options) {
        // Default to current year as min if none specified
        options = initOptions(options, {min: new Date().getFullYear()});

        // Default to one century after current year as max if none specified
        options.max = (typeof options.max !== "undefined") ? options.max : options.min + 100;

        return this.natural(options).toString();
    };

    // -- End Time

    // -- Finance --

    Chance.prototype.cc = function (options) {
        options = initOptions(options);

        var type, number, to_generate;

        type = (options.type) ?
                    this.cc_type({ name: options.type, raw: true }) :
                    this.cc_type({ raw: true });

        number = type.prefix.split("");
        to_generate = type.length - type.prefix.length - 1;

        // Generates n - 1 digits
        number = number.concat(this.n(this.integer, to_generate, {min: 0, max: 9}));

        // Generates the last digit according to Luhn algorithm
        number.push(this.luhn_calculate(number.join("")));

        return number.join("");
    };

    Chance.prototype.cc_types = function () {
        // http://en.wikipedia.org/wiki/Bank_card_number#Issuer_identification_number_.28IIN.29
        return this.get("cc_types");
    };

    Chance.prototype.cc_type = function (options) {
        options = initOptions(options);
        var types = this.cc_types(),
            type = null;

        if (options.name) {
            for (var i = 0; i < types.length; i++) {
                // Accept either name or short_name to specify card type
                if (types[i].name === options.name || types[i].short_name === options.name) {
                    type = types[i];
                    break;
                }
            }
            if (type === null) {
                throw new RangeError("Chance: Credit card type '" + options.name + "' is not supported");
            }
        } else {
            type = this.pick(types);
        }

        return options.raw ? type : type.name;
    };

    // return all world currency by ISO 4217
    Chance.prototype.currency_types = function () {
        return this.get("currency_types");
    };

    // return random world currency by ISO 4217
    Chance.prototype.currency = function () {
        return this.pick(this.currency_types());
    };

    // return all timezones available
    Chance.prototype.timezones = function () {
        return this.get("timezones");
    };

    // return random timezone
    Chance.prototype.timezone = function () {
        return this.pick(this.timezones());
    };

    //Return random correct currency exchange pair (e.g. EUR/USD) or array of currency code
    Chance.prototype.currency_pair = function (returnAsString) {
        var currencies = this.unique(this.currency, 2, {
            comparator: function(arr, val) {

                return arr.reduce(function(acc, item) {
                    // If a match has been found, short circuit check and just return
                    return acc || (item.code === val.code);
                }, false);
            }
        });

        if (returnAsString) {
            return currencies[0].code + '/' + currencies[1].code;
        } else {
            return currencies;
        }
    };

    Chance.prototype.dollar = function (options) {
        // By default, a somewhat more sane max for dollar than all available numbers
        options = initOptions(options, {max : 10000, min : 0});

        var dollar = this.floating({min: options.min, max: options.max, fixed: 2}).toString(),
            cents = dollar.split('.')[1];

        if (cents === undefined) {
            dollar += '.00';
        } else if (cents.length < 2) {
            dollar = dollar + '0';
        }

        if (dollar < 0) {
            return '-$' + dollar.replace('-', '');
        } else {
            return '$' + dollar;
        }
    };

    Chance.prototype.euro = function (options) {
        return Number(this.dollar(options).replace("$", "")).toLocaleString() + "€";
    };

    Chance.prototype.exp = function (options) {
        options = initOptions(options);
        var exp = {};

        exp.year = this.exp_year();

        // If the year is this year, need to ensure month is greater than the
        // current month or this expiration will not be valid
        if (exp.year === (new Date().getFullYear()).toString()) {
            exp.month = this.exp_month({future: true});
        } else {
            exp.month = this.exp_month();
        }

        return options.raw ? exp : exp.month + '/' + exp.year;
    };

    Chance.prototype.exp_month = function (options) {
        options = initOptions(options);
        var month, month_int,
            // Date object months are 0 indexed
            curMonth = new Date().getMonth() + 1;

        if (options.future && (curMonth !== 12)) {
            do {
                month = this.month({raw: true}).numeric;
                month_int = parseInt(month, 10);
            } while (month_int <= curMonth);
        } else {
            month = this.month({raw: true}).numeric;
        }

        return month;
    };

    Chance.prototype.exp_year = function () {
        var curMonth = new Date().getMonth() + 1,
            curYear = new Date().getFullYear();

        return this.year({min: ((curMonth === 12) ? (curYear + 1) : curYear), max: (curYear + 10)});
    };

    Chance.prototype.vat = function (options) {
        options = initOptions(options, { country: 'it' });
        switch (options.country.toLowerCase()) {
            case 'it':
                return this.it_vat();
        }
    };

    /**
     * Generate a string matching IBAN pattern (https://en.wikipedia.org/wiki/International_Bank_Account_Number).
     * No country-specific formats support (yet)
     */
    Chance.prototype.iban = function () {
        var alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        var alphanum = alpha + '0123456789';
        var iban =
            this.string({ length: 2, pool: alpha }) +
            this.pad(this.integer({ min: 0, max: 99 }), 2) +
            this.string({ length: 4, pool: alphanum }) +
            this.pad(this.natural(), this.natural({ min: 6, max: 26 }));
        return iban;
    };

    // -- End Finance

    // -- Regional

    Chance.prototype.it_vat = function () {
        var it_vat = this.natural({min: 1, max: 1800000});

        it_vat = this.pad(it_vat, 7) + this.pad(this.pick(this.provinces({ country: 'it' })).code, 3);
        return it_vat + this.luhn_calculate(it_vat);
    };

    /*
     * this generator is written following the official algorithm
     * all data can be passed explicitely or randomized by calling chance.cf() without options
     * the code does not check that the input data is valid (it goes beyond the scope of the generator)
     *
     * @param  [Object] options = { first: first name,
     *                              last: last name,
     *                              gender: female|male,
                                    birthday: JavaScript date object,
                                    city: string(4), 1 letter + 3 numbers
                                   }
     * @return [string] codice fiscale
     *
    */
    Chance.prototype.cf = function (options) {
        options = options || {};
        var gender = !!options.gender ? options.gender : this.gender(),
            first = !!options.first ? options.first : this.first( { gender: gender, nationality: 'it'} ),
            last = !!options.last ? options.last : this.last( { nationality: 'it'} ),
            birthday = !!options.birthday ? options.birthday : this.birthday(),
            city = !!options.city ? options.city : this.pickone(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'L', 'M', 'Z']) + this.pad(this.natural({max:999}), 3),
            cf = [],
            name_generator = function(name, isLast) {
                var temp,
                    return_value = [];

                if (name.length < 3) {
                    return_value = name.split("").concat("XXX".split("")).splice(0,3);
                }
                else {
                    temp = name.toUpperCase().split('').map(function(c){
                        return ("BCDFGHJKLMNPRSTVWZ".indexOf(c) !== -1) ? c : undefined;
                    }).join('');
                    if (temp.length > 3) {
                        if (isLast) {
                            temp = temp.substr(0,3);
                        } else {
                            temp = temp[0] + temp.substr(2,2);
                        }
                    }
                    if (temp.length < 3) {
                        return_value = temp;
                        temp = name.toUpperCase().split('').map(function(c){
                            return ("AEIOU".indexOf(c) !== -1) ? c : undefined;
                        }).join('').substr(0, 3 - return_value.length);
                    }
                    return_value = return_value + temp;
                }

                return return_value;
            },
            date_generator = function(birthday, gender, that) {
                var lettermonths = ['A', 'B', 'C', 'D', 'E', 'H', 'L', 'M', 'P', 'R', 'S', 'T'];

                return  birthday.getFullYear().toString().substr(2) +
                        lettermonths[birthday.getMonth()] +
                        that.pad(birthday.getDate() + ((gender.toLowerCase() === "female") ? 40 : 0), 2);
            },
            checkdigit_generator = function(cf) {
                var range1 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                    range2 = "ABCDEFGHIJABCDEFGHIJKLMNOPQRSTUVWXYZ",
                    evens  = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                    odds   = "BAKPLCQDREVOSFTGUHMINJWZYX",
                    digit  = 0;


                for(var i = 0; i < 15; i++) {
                    if (i % 2 !== 0) {
                        digit += evens.indexOf(range2[range1.indexOf(cf[i])]);
                    }
                    else {
                        digit +=  odds.indexOf(range2[range1.indexOf(cf[i])]);
                    }
                }
                return evens[digit % 26];
            };

        cf = cf.concat(name_generator(last, true), name_generator(first), date_generator(birthday, gender, this), city.toUpperCase().split("")).join("");
        cf += checkdigit_generator(cf.toUpperCase(), this);

        return cf.toUpperCase();
    };

    Chance.prototype.pl_pesel = function () {
        var number = this.natural({min: 1, max: 9999999999});
        var arr = this.pad(number, 10).split('');
        for (var i = 0; i < arr.length; i++) {
            arr[i] = parseInt(arr[i]);
        }

        var controlNumber = (1 * arr[0] + 3 * arr[1] + 7 * arr[2] + 9 * arr[3] + 1 * arr[4] + 3 * arr[5] + 7 * arr[6] + 9 * arr[7] + 1 * arr[8] + 3 * arr[9]) % 10;
        if(controlNumber !== 0) {
            controlNumber = 10 - controlNumber;
        }

        return arr.join('') + controlNumber;
    };

    Chance.prototype.pl_nip = function () {
        var number = this.natural({min: 1, max: 999999999});
        var arr = this.pad(number, 9).split('');
        for (var i = 0; i < arr.length; i++) {
            arr[i] = parseInt(arr[i]);
        }

        var controlNumber = (6 * arr[0] + 5 * arr[1] + 7 * arr[2] + 2 * arr[3] + 3 * arr[4] + 4 * arr[5] + 5 * arr[6] + 6 * arr[7] + 7 * arr[8]) % 11;
        if(controlNumber === 10) {
            return this.pl_nip();
        }

        return arr.join('') + controlNumber;
    };

    Chance.prototype.pl_regon = function () {
        var number = this.natural({min: 1, max: 99999999});
        var arr = this.pad(number, 8).split('');
        for (var i = 0; i < arr.length; i++) {
            arr[i] = parseInt(arr[i]);
        }

        var controlNumber = (8 * arr[0] + 9 * arr[1] + 2 * arr[2] + 3 * arr[3] + 4 * arr[4] + 5 * arr[5] + 6 * arr[6] + 7 * arr[7]) % 11;
        if(controlNumber === 10) {
            controlNumber = 0;
        }

        return arr.join('') + controlNumber;
    };

    // -- End Regional

    // -- Music --

    Chance.prototype.note = function(options) {
      // choices for 'notes' option:
      // flatKey - chromatic scale with flat notes (default)
      // sharpKey - chromatic scale with sharp notes
      // flats - just flat notes
      // sharps - just sharp notes
      // naturals - just natural notes
      // all - naturals, sharps and flats
      options = initOptions(options, { notes : 'flatKey'});
      var scales = {
        naturals: ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
        flats: ['D♭', 'E♭', 'G♭', 'A♭', 'B♭'],
        sharps: ['C♯', 'D♯', 'F♯', 'G♯', 'A♯']
      };
      scales.all = scales.naturals.concat(scales.flats.concat(scales.sharps))
      scales.flatKey = scales.naturals.concat(scales.flats)
      scales.sharpKey = scales.naturals.concat(scales.sharps)
      return this.pickone(scales[options.notes]);
    }

    Chance.prototype.midi_note = function(options) {
      var min = 0;
      var max = 127;
      options = initOptions(options, { min : min, max : max });
      return this.integer({min: options.min, max: options.max});
    }

    Chance.prototype.chord_quality = function(options) {
      options = initOptions(options, { jazz: true });
      var chord_qualities = ['maj', 'min', 'aug', 'dim'];
      if (options.jazz){
        chord_qualities = [
          'maj7',
          'min7',
          '7',
          'sus',
          'dim',
          'ø'
        ];
      }
      return this.pickone(chord_qualities);
    }

    Chance.prototype.chord = function (options) {
      options = initOptions(options);
      return this.note(options) + this.chord_quality(options);
    }

    Chance.prototype.tempo = function (options) {
      var min = 40;
      var max = 320;
      options = initOptions(options, {min: min, max: max});
      return this.integer({min: options.min, max: options.max});
    }

    // -- End Music

    // -- Miscellaneous --

    // Coin - Flip, flip, flipadelphia
    Chance.prototype.coin = function(options) {
      return this.bool() ? "heads" : "tails";
    }

    // Dice - For all the board game geeks out there, myself included ;)
    function diceFn (range) {
        return function () {
            return this.natural(range);
        };
    }
    Chance.prototype.d4 = diceFn({min: 1, max: 4});
    Chance.prototype.d6 = diceFn({min: 1, max: 6});
    Chance.prototype.d8 = diceFn({min: 1, max: 8});
    Chance.prototype.d10 = diceFn({min: 1, max: 10});
    Chance.prototype.d12 = diceFn({min: 1, max: 12});
    Chance.prototype.d20 = diceFn({min: 1, max: 20});
    Chance.prototype.d30 = diceFn({min: 1, max: 30});
    Chance.prototype.d100 = diceFn({min: 1, max: 100});

    Chance.prototype.rpg = function (thrown, options) {
        options = initOptions(options);
        if (!thrown) {
            throw new RangeError("Chance: A type of die roll must be included");
        } else {
            var bits = thrown.toLowerCase().split("d"),
                rolls = [];

            if (bits.length !== 2 || !parseInt(bits[0], 10) || !parseInt(bits[1], 10)) {
                throw new Error("Chance: Invalid format provided. Please provide #d# where the first # is the number of dice to roll, the second # is the max of each die");
            }
            for (var i = bits[0]; i > 0; i--) {
                rolls[i - 1] = this.natural({min: 1, max: bits[1]});
            }
            return (typeof options.sum !== 'undefined' && options.sum) ? rolls.reduce(function (p, c) { return p + c; }) : rolls;
        }
    };

    // Guid
    Chance.prototype.guid = function (options) {
        options = initOptions(options, { version: 5 });

        var guid_pool = "abcdef1234567890",
            variant_pool = "ab89",
            guid = this.string({ pool: guid_pool, length: 8 }) + '-' +
                   this.string({ pool: guid_pool, length: 4 }) + '-' +
                   // The Version
                   options.version +
                   this.string({ pool: guid_pool, length: 3 }) + '-' +
                   // The Variant
                   this.string({ pool: variant_pool, length: 1 }) +
                   this.string({ pool: guid_pool, length: 3 }) + '-' +
                   this.string({ pool: guid_pool, length: 12 });
        return guid;
    };

    // Hash
    Chance.prototype.hash = function (options) {
        options = initOptions(options, {length : 40, casing: 'lower'});
        var pool = options.casing === 'upper' ? HEX_POOL.toUpperCase() : HEX_POOL;
        return this.string({pool: pool, length: options.length});
    };

    Chance.prototype.luhn_check = function (num) {
        var str = num.toString();
        var checkDigit = +str.substring(str.length - 1);
        return checkDigit === this.luhn_calculate(+str.substring(0, str.length - 1));
    };

    Chance.prototype.luhn_calculate = function (num) {
        var digits = num.toString().split("").reverse();
        var sum = 0;
        var digit;

        for (var i = 0, l = digits.length; l > i; ++i) {
            digit = +digits[i];
            if (i % 2 === 0) {
                digit *= 2;
                if (digit > 9) {
                    digit -= 9;
                }
            }
            sum += digit;
        }
        return (sum * 9) % 10;
    };

    // MD5 Hash
    Chance.prototype.md5 = function(options) {
        var opts = { str: '', key: null, raw: false };

        if (!options) {
            opts.str = this.string();
            options = {};
        }
        else if (typeof options === 'string') {
            opts.str = options;
            options = {};
        }
        else if (typeof options !== 'object') {
            return null;
        }
        else if(options.constructor === 'Array') {
            return null;
        }

        opts = initOptions(options, opts);

        if(!opts.str){
            throw new Error('A parameter is required to return an md5 hash.');
        }

        return this.bimd5.md5(opts.str, opts.key, opts.raw);
    };

    /**
     * #Description:
     * =====================================================
     * Generate random file name with extension
     *
     * The argument provide extension type
     * -> raster
     * -> vector
     * -> 3d
     * -> document
     *
     * If nothing is provided the function return random file name with random
     * extension type of any kind
     *
     * The user can validate the file name length range
     * If nothing provided the generated file name is random
     *
     * #Extension Pool :
     * * Currently the supported extensions are
     *  -> some of the most popular raster image extensions
     *  -> some of the most popular vector image extensions
     *  -> some of the most popular 3d image extensions
     *  -> some of the most popular document extensions
     *
     * #Examples :
     * =====================================================
     *
     * Return random file name with random extension. The file extension
     * is provided by a predefined collection of extensions. More about the extension
     * pool can be found in #Extension Pool section
     *
     * chance.file()
     * => dsfsdhjf.xml
     *
     * In order to generate a file name with specific length, specify the
     * length property and integer value. The extension is going to be random
     *
     * chance.file({length : 10})
     * => asrtineqos.pdf
     *
     * In order to generate file with extension from some of the predefined groups
     * of the extension pool just specify the extension pool category in fileType property
     *
     * chance.file({fileType : 'raster'})
     * => dshgssds.psd
     *
     * You can provide specific extension for your files
     * chance.file({extension : 'html'})
     * => djfsd.html
     *
     * Or you could pass custom collection of extensions by array or by object
     * chance.file({extensions : [...]})
     * => dhgsdsd.psd
     *
     * chance.file({extensions : { key : [...], key : [...]}})
     * => djsfksdjsd.xml
     *
     * @param  [collection] options
     * @return [string]
     *
     */
    Chance.prototype.file = function(options) {

        var fileOptions = options || {};
        var poolCollectionKey = "fileExtension";
        var typeRange   = Object.keys(this.get("fileExtension"));//['raster', 'vector', '3d', 'document'];
        var fileName;
        var fileExtension;

        // Generate random file name
        fileName = this.word({length : fileOptions.length});

        // Generate file by specific extension provided by the user
        if(fileOptions.extension) {

            fileExtension = fileOptions.extension;
            return (fileName + '.' + fileExtension);
        }

        // Generate file by specific extension collection
        if(fileOptions.extensions) {

            if(Array.isArray(fileOptions.extensions)) {

                fileExtension = this.pickone(fileOptions.extensions);
                return (fileName + '.' + fileExtension);
            }
            else if(fileOptions.extensions.constructor === Object) {

                var extensionObjectCollection = fileOptions.extensions;
                var keys = Object.keys(extensionObjectCollection);

                fileExtension = this.pickone(extensionObjectCollection[this.pickone(keys)]);
                return (fileName + '.' + fileExtension);
            }

            throw new Error("Chance: Extensions must be an Array or Object");
        }

        // Generate file extension based on specific file type
        if(fileOptions.fileType) {

            var fileType = fileOptions.fileType;
            if(typeRange.indexOf(fileType) !== -1) {

                fileExtension = this.pickone(this.get(poolCollectionKey)[fileType]);
                return (fileName + '.' + fileExtension);
            }

            throw new RangeError("Chance: Expect file type value to be 'raster', 'vector', '3d' or 'document'");
        }

        // Generate random file name if no extension options are passed
        fileExtension = this.pickone(this.get(poolCollectionKey)[this.pickone(typeRange)]);
        return (fileName + '.' + fileExtension);
    };

    var data = {

        firstNames: {
            "male": {
                "en": ["James", "John", "Robert", "Michael", "William", "David", "Richard", "Joseph", "Charles", "Thomas", "Christopher", "Daniel", "Matthew", "George", "Donald", "Anthony", "Paul", "Mark", "Edward", "Steven", "Kenneth", "Andrew", "Brian", "Joshua", "Kevin", "Ronald", "Timothy", "Jason", "Jeffrey", "Frank", "Gary", "Ryan", "Nicholas", "Eric", "Stephen", "Jacob", "Larry", "Jonathan", "Scott", "Raymond", "Justin", "Brandon", "Gregory", "Samuel", "Benjamin", "Patrick", "Jack", "Henry", "Walter", "Dennis", "Jerry", "Alexander", "Peter", "Tyler", "Douglas", "Harold", "Aaron", "Jose", "Adam", "Arthur", "Zachary", "Carl", "Nathan", "Albert", "Kyle", "Lawrence", "Joe", "Willie", "Gerald", "Roger", "Keith", "Jeremy", "Terry", "Harry", "Ralph", "Sean", "Jesse", "Roy", "Louis", "Billy", "Austin", "Bruce", "Eugene", "Christian", "Bryan", "Wayne", "Russell", "Howard", "Fred", "Ethan", "Jordan", "Philip", "Alan", "Juan", "Randy", "Vincent", "Bobby", "Dylan", "Johnny", "Phillip", "Victor", "Clarence", "Ernest", "Martin", "Craig", "Stanley", "Shawn", "Travis", "Bradley", "Leonard", "Earl", "Gabriel", "Jimmy", "Francis", "Todd", "Noah", "Danny", "Dale", "Cody", "Carlos", "Allen", "Frederick", "Logan", "Curtis", "Alex", "Joel", "Luis", "Norman", "Marvin", "Glenn", "Tony", "Nathaniel", "Rodney", "Melvin", "Alfred", "Steve", "Cameron", "Chad", "Edwin", "Caleb", "Evan", "Antonio", "Lee", "Herbert", "Jeffery", "Isaac", "Derek", "Ricky", "Marcus", "Theodore", "Elijah", "Luke", "Jesus", "Eddie", "Troy", "Mike", "Dustin", "Ray", "Adrian", "Bernard", "Leroy", "Angel", "Randall", "Wesley", "Ian", "Jared", "Mason", "Hunter", "Calvin", "Oscar", "Clifford", "Jay", "Shane", "Ronnie", "Barry", "Lucas", "Corey", "Manuel", "Leo", "Tommy", "Warren", "Jackson", "Isaiah", "Connor", "Don", "Dean", "Jon", "Julian", "Miguel", "Bill", "Lloyd", "Charlie", "Mitchell", "Leon", "Jerome", "Darrell", "Jeremiah", "Alvin", "Brett", "Seth", "Floyd", "Jim", "Blake", "Micheal", "Gordon", "Trevor", "Lewis", "Erik", "Edgar", "Vernon", "Devin", "Gavin", "Jayden", "Chris", "Clyde", "Tom", "Derrick", "Mario", "Brent", "Marc", "Herman", "Chase", "Dominic", "Ricardo", "Franklin", "Maurice", "Max", "Aiden", "Owen", "Lester", "Gilbert", "Elmer", "Gene", "Francisco", "Glen", "Cory", "Garrett", "Clayton", "Sam", "Jorge", "Chester", "Alejandro", "Jeff", "Harvey", "Milton", "Cole", "Ivan", "Andre", "Duane", "Landon"],
                // Data taken from http://www.dati.gov.it/dataset/comune-di-firenze_0163
                "it": ["Adolfo", "Alberto", "Aldo", "Alessandro", "Alessio", "Alfredo", "Alvaro", "Andrea", "Angelo", "Angiolo", "Antonino", "Antonio", "Attilio", "Benito", "Bernardo", "Bruno", "Carlo", "Cesare", "Christian", "Claudio", "Corrado", "Cosimo", "Cristian", "Cristiano", "Daniele", "Dario", "David", "Davide", "Diego", "Dino", "Domenico", "Duccio", "Edoardo", "Elia", "Elio", "Emanuele", "Emiliano", "Emilio", "Enrico", "Enzo", "Ettore", "Fabio", "Fabrizio", "Federico", "Ferdinando", "Fernando", "Filippo", "Francesco", "Franco", "Gabriele", "Giacomo", "Giampaolo", "Giampiero", "Giancarlo", "Gianfranco", "Gianluca", "Gianmarco", "Gianni", "Gino", "Giorgio", "Giovanni", "Giuliano", "Giulio", "Giuseppe", "Graziano", "Gregorio", "Guido", "Iacopo", "Jacopo", "Lapo", "Leonardo", "Lorenzo", "Luca", "Luciano", "Luigi", "Manuel", "Marcello", "Marco", "Marino", "Mario", "Massimiliano", "Massimo", "Matteo", "Mattia", "Maurizio", "Mauro", "Michele", "Mirko", "Mohamed", "Nello", "Neri", "Niccolò", "Nicola", "Osvaldo", "Otello", "Paolo", "Pier Luigi", "Piero", "Pietro", "Raffaele", "Remo", "Renato", "Renzo", "Riccardo", "Roberto", "Rolando", "Romano", "Salvatore", "Samuele", "Sandro", "Sergio", "Silvano", "Simone", "Stefano", "Thomas", "Tommaso", "Ubaldo", "Ugo", "Umberto", "Valerio", "Valter", "Vasco", "Vincenzo", "Vittorio"],
                // Data taken from http://www.svbkindernamen.nl/int/nl/kindernamen/index.html
                "nl": ["Aaron","Abel","Adam","Adriaan","Albert","Alexander","Ali","Arjen","Arno","Bart","Bas","Bastiaan","Benjamin","Bob", "Boris","Bram","Brent","Cas","Casper","Chris","Christiaan","Cornelis","Daan","Daley","Damian","Dani","Daniel","Daniël","David","Dean","Dirk","Dylan","Egbert","Elijah","Erik","Erwin","Evert","Ezra","Fabian","Fedde","Finn","Florian","Floris","Frank","Frans","Frederik","Freek","Geert","Gerard","Gerben","Gerrit","Gijs","Guus","Hans","Hendrik","Henk","Herman","Hidde","Hugo","Jaap","Jan Jaap","Jan-Willem","Jack","Jacob","Jan","Jason","Jasper","Jayden","Jelle","Jelte","Jens","Jeroen","Jesse","Jim","Job","Joep","Johannes","John","Jonathan","Joris","Joshua","Joël","Julian","Kees","Kevin","Koen","Lars","Laurens","Leendert","Lennard","Lodewijk","Luc","Luca","Lucas","Lukas","Luuk","Maarten","Marcus","Martijn","Martin","Matthijs","Maurits","Max","Mees","Melle","Mick","Mika","Milan","Mohamed","Mohammed","Morris","Muhammed","Nathan","Nick","Nico","Niek","Niels","Noah","Noud","Olivier","Oscar","Owen","Paul","Pepijn","Peter","Pieter","Pim","Quinten","Reinier","Rens","Robin","Ruben","Sam","Samuel","Sander","Sebastiaan","Sem","Sep","Sepp","Siem","Simon","Stan","Stef","Steven","Stijn","Sven","Teun","Thijmen","Thijs","Thomas","Tijn","Tim","Timo","Tobias","Tom","Victor","Vince","Willem","Wim","Wouter","Yusuf"],
                // Data taken from https://fr.wikipedia.org/wiki/Liste_de_pr%C3%A9noms_fran%C3%A7ais_et_de_la_francophonie
                "fr": ["Aaron","Abdon","Abel","Abélard","Abelin","Abondance","Abraham","Absalon","Acace","Achaire","Achille","Adalard","Adalbald","Adalbéron","Adalbert","Adalric","Adam","Adegrin","Adel","Adelin","Andelin","Adelphe","Adam","Adéodat","Adhémar","Adjutor","Adolphe","Adonis","Adon","Adrien","Agapet","Agathange","Agathon","Agilbert","Agénor","Agnan","Aignan","Agrippin","Aimable","Aimé","Alain","Alban","Albin","Aubin","Albéric","Albert","Albertet","Alcibiade","Alcide","Alcée","Alcime","Aldonce","Aldric","Aldéric","Aleaume","Alexandre","Alexis","Alix","Alliaume","Aleaume","Almine","Almire","Aloïs","Alphée","Alphonse","Alpinien","Alverède","Amalric","Amaury","Amandin","Amant","Ambroise","Amédée","Amélien","Amiel","Amour","Anaël","Anastase","Anatole","Ancelin","Andéol","Andoche","André","Andoche","Ange","Angelin","Angilbe","Anglebert","Angoustan","Anicet","Anne","Annibal","Ansbert","Anselme","Anthelme","Antheaume","Anthime","Antide","Antoine","Antonius","Antonin","Apollinaire","Apollon","Aquilin","Arcade","Archambaud","Archambeau","Archange","Archibald","Arian","Ariel","Ariste","Aristide","Armand","Armel","Armin","Arnould","Arnaud","Arolde","Arsène","Arsinoé","Arthaud","Arthème","Arthur","Ascelin","Athanase","Aubry","Audebert","Audouin","Audran","Audric","Auguste","Augustin","Aurèle","Aurélien","Aurian","Auxence","Axel","Aymard","Aymeric","Aymon","Aymond","Balthazar","Baptiste","Barnabé","Barthélemy","Bartimée","Basile","Bastien","Baudouin","Bénigne","Benjamin","Benoît","Bérenger","Bérard","Bernard","Bertrand","Blaise","Bon","Boniface","Bouchard","Brice","Brieuc","Bruno","Brunon","Calixte","Calliste","Camélien","Camille","Camillien","Candide","Caribert","Carloman","Cassandre","Cassien","Cédric","Céleste","Célestin","Célien","Césaire","César","Charles","Charlemagne","Childebert","Chilpéric","Chrétien","Christian","Christodule","Christophe","Chrysostome","Clarence","Claude","Claudien","Cléandre","Clément","Clotaire","Côme","Constance","Constant","Constantin","Corentin","Cyprien","Cyriaque","Cyrille","Cyril","Damien","Daniel","David","Delphin","Denis","Désiré","Didier","Dieudonné","Dimitri","Dominique","Dorian","Dorothée","Edgard","Edmond","Édouard","Éleuthère","Élie","Élisée","Émeric","Émile","Émilien","Emmanuel","Enguerrand","Épiphane","Éric","Esprit","Ernest","Étienne","Eubert","Eudes","Eudoxe","Eugène","Eusèbe","Eustache","Évariste","Évrard","Fabien","Fabrice","Falba","Félicité","Félix","Ferdinand","Fiacre","Fidèle","Firmin","Flavien","Flodoard","Florent","Florentin","Florestan","Florian","Fortuné","Foulques","Francisque","François","Français","Franciscus","Francs","Frédéric","Fulbert","Fulcran","Fulgence","Gabin","Gabriel","Gaël","Garnier","Gaston","Gaspard","Gatien","Gaud","Gautier","Gédéon","Geoffroy","Georges","Géraud","Gérard","Gerbert","Germain","Gervais","Ghislain","Gilbert","Gilles","Girart","Gislebert","Gondebaud","Gonthier","Gontran","Gonzague","Grégoire","Guérin","Gui","Guillaume","Gustave","Guy","Guyot","Hardouin","Hector","Hédelin","Hélier","Henri","Herbert","Herluin","Hervé","Hilaire","Hildebert","Hincmar","Hippolyte","Honoré","Hubert","Hugues","Innocent","Isabeau","Isidore","Jacques","Japhet","Jason","Jean","Jeannel","Jeannot","Jérémie","Jérôme","Joachim","Joanny","Job","Jocelyn","Joël","Johan","Jonas","Jonathan","Joseph","Josse","Josselin","Jourdain","Jude","Judicaël","Jules","Julien","Juste","Justin","Lambert","Landry","Laurent","Lazare","Léandre","Léon","Léonard","Léopold","Leu","Loup","Leufroy","Libère","Liétald","Lionel","Loïc","Longin","Lorrain","Lorraine","Lothaire","Louis","Loup","Luc","Lucas","Lucien","Ludolphe","Ludovic","Macaire","Malo","Mamert","Manassé","Marc","Marceau","Marcel","Marcelin","Marius","Marseille","Martial","Martin","Mathurin","Matthias","Mathias","Matthieu","Maugis","Maurice","Mauricet","Maxence","Maxime","Maximilien","Mayeul","Médéric","Melchior","Mence","Merlin","Mérovée","Michaël","Michel","Moïse","Morgan","Nathan","Nathanaël","Narcisse","Néhémie","Nestor","Nestor","Nicéphore","Nicolas","Noé","Noël","Norbert","Normand","Normands","Octave","Odilon","Odon","Oger","Olivier","Oury","Pacôme","Palémon","Parfait","Pascal","Paterne","Patrice","Paul","Pépin","Perceval","Philémon","Philibert","Philippe","Philothée","Pie","Pierre","Pierrick","Prosper","Quentin","Raoul","Raphaël","Raymond","Régis","Réjean","Rémi","Renaud","René","Reybaud","Richard","Robert","Roch","Rodolphe","Rodrigue","Roger","Roland","Romain","Romuald","Roméo","Rome","Ronan","Roselin","Salomon","Samuel","Savin","Savinien","Scholastique","Sébastien","Séraphin","Serge","Séverin","Sidoine","Sigebert","Sigismond","Silvère","Simon","Siméon","Sixte","Stanislas","Stéphane","Stephan","Sylvain","Sylvestre","Tancrède","Tanguy","Taurin","Théodore","Théodose","Théophile","Théophraste","Thibault","Thibert","Thierry","Thomas","Timoléon","Timothée","Titien","Tonnin","Toussaint","Trajan","Tristan","Turold","Tim","Ulysse","Urbain","Valentin","Valère","Valéry","Venance","Venant","Venceslas","Vianney","Victor","Victorien","Victorin","Vigile","Vincent","Vital","Vitalien","Vivien","Waleran","Wandrille","Xavier","Xénophon","Yves","Zacharie","Zaché","Zéphirin"]
            },

            "female": {
                "en": ["Mary", "Emma", "Elizabeth", "Minnie", "Margaret", "Ida", "Alice", "Bertha", "Sarah", "Annie", "Clara", "Ella", "Florence", "Cora", "Martha", "Laura", "Nellie", "Grace", "Carrie", "Maude", "Mabel", "Bessie", "Jennie", "Gertrude", "Julia", "Hattie", "Edith", "Mattie", "Rose", "Catherine", "Lillian", "Ada", "Lillie", "Helen", "Jessie", "Louise", "Ethel", "Lula", "Myrtle", "Eva", "Frances", "Lena", "Lucy", "Edna", "Maggie", "Pearl", "Daisy", "Fannie", "Josephine", "Dora", "Rosa", "Katherine", "Agnes", "Marie", "Nora", "May", "Mamie", "Blanche", "Stella", "Ellen", "Nancy", "Effie", "Sallie", "Nettie", "Della", "Lizzie", "Flora", "Susie", "Maud", "Mae", "Etta", "Harriet", "Sadie", "Caroline", "Katie", "Lydia", "Elsie", "Kate", "Susan", "Mollie", "Alma", "Addie", "Georgia", "Eliza", "Lulu", "Nannie", "Lottie", "Amanda", "Belle", "Charlotte", "Rebecca", "Ruth", "Viola", "Olive", "Amelia", "Hannah", "Jane", "Virginia", "Emily", "Matilda", "Irene", "Kathryn", "Esther", "Willie", "Henrietta", "Ollie", "Amy", "Rachel", "Sara", "Estella", "Theresa", "Augusta", "Ora", "Pauline", "Josie", "Lola", "Sophia", "Leona", "Anne", "Mildred", "Ann", "Beulah", "Callie", "Lou", "Delia", "Eleanor", "Barbara", "Iva", "Louisa", "Maria", "Mayme", "Evelyn", "Estelle", "Nina", "Betty", "Marion", "Bettie", "Dorothy", "Luella", "Inez", "Lela", "Rosie", "Allie", "Millie", "Janie", "Cornelia", "Victoria", "Ruby", "Winifred", "Alta", "Celia", "Christine", "Beatrice", "Birdie", "Harriett", "Mable", "Myra", "Sophie", "Tillie", "Isabel", "Sylvia", "Carolyn", "Isabelle", "Leila", "Sally", "Ina", "Essie", "Bertie", "Nell", "Alberta", "Katharine", "Lora", "Rena", "Mina", "Rhoda", "Mathilda", "Abbie", "Eula", "Dollie", "Hettie", "Eunice", "Fanny", "Ola", "Lenora", "Adelaide", "Christina", "Lelia", "Nelle", "Sue", "Johanna", "Lilly", "Lucinda", "Minerva", "Lettie", "Roxie", "Cynthia", "Helena", "Hilda", "Hulda", "Bernice", "Genevieve", "Jean", "Cordelia", "Marian", "Francis", "Jeanette", "Adeline", "Gussie", "Leah", "Lois", "Lura", "Mittie", "Hallie", "Isabella", "Olga", "Phoebe", "Teresa", "Hester", "Lida", "Lina", "Winnie", "Claudia", "Marguerite", "Vera", "Cecelia", "Bess", "Emilie", "Rosetta", "Verna", "Myrtie", "Cecilia", "Elva", "Olivia", "Ophelia", "Georgie", "Elnora", "Violet", "Adele", "Lily", "Linnie", "Loretta", "Madge", "Polly", "Virgie", "Eugenia", "Lucile", "Lucille", "Mabelle", "Rosalie"],
                // Data taken from http://www.dati.gov.it/dataset/comune-di-firenze_0162
                "it": ["Ada", "Adriana", "Alessandra", "Alessia", "Alice", "Angela", "Anna", "Anna Maria", "Annalisa", "Annita", "Annunziata", "Antonella", "Arianna", "Asia", "Assunta", "Aurora", "Barbara", "Beatrice", "Benedetta", "Bianca", "Bruna", "Camilla", "Carla", "Carlotta", "Carmela", "Carolina", "Caterina", "Catia", "Cecilia", "Chiara", "Cinzia", "Clara", "Claudia", "Costanza", "Cristina", "Daniela", "Debora", "Diletta", "Dina", "Donatella", "Elena", "Eleonora", "Elisa", "Elisabetta", "Emanuela", "Emma", "Eva", "Federica", "Fernanda", "Fiorella", "Fiorenza", "Flora", "Franca", "Francesca", "Gabriella", "Gaia", "Gemma", "Giada", "Gianna", "Gina", "Ginevra", "Giorgia", "Giovanna", "Giulia", "Giuliana", "Giuseppa", "Giuseppina", "Grazia", "Graziella", "Greta", "Ida", "Ilaria", "Ines", "Iolanda", "Irene", "Irma", "Isabella", "Jessica", "Laura", "Lea", "Letizia", "Licia", "Lidia", "Liliana", "Lina", "Linda", "Lisa", "Livia", "Loretta", "Luana", "Lucia", "Luciana", "Lucrezia", "Luisa", "Manuela", "Mara", "Marcella", "Margherita", "Maria", "Maria Cristina", "Maria Grazia", "Maria Luisa", "Maria Pia", "Maria Teresa", "Marina", "Marisa", "Marta", "Martina", "Marzia", "Matilde", "Melissa", "Michela", "Milena", "Mirella", "Monica", "Natalina", "Nella", "Nicoletta", "Noemi", "Olga", "Paola", "Patrizia", "Piera", "Pierina", "Raffaella", "Rebecca", "Renata", "Rina", "Rita", "Roberta", "Rosa", "Rosanna", "Rossana", "Rossella", "Sabrina", "Sandra", "Sara", "Serena", "Silvana", "Silvia", "Simona", "Simonetta", "Sofia", "Sonia", "Stefania", "Susanna", "Teresa", "Tina", "Tiziana", "Tosca", "Valentina", "Valeria", "Vanda", "Vanessa", "Vanna", "Vera", "Veronica", "Vilma", "Viola", "Virginia", "Vittoria"],
                // Data taken from http://www.svbkindernamen.nl/int/nl/kindernamen/index.html
                "nl": ["Ada", "Arianne", "Afke", "Amanda", "Amber", "Amy", "Aniek", "Anita", "Anja", "Anna", "Anne", "Annelies", "Annemarie", "Annette", "Anouk", "Astrid", "Aukje", "Barbara", "Bianca", "Carla", "Carlijn", "Carolien", "Chantal", "Charlotte", "Claudia", "Daniëlle", "Debora", "Diane", "Dora", "Eline", "Elise", "Ella", "Ellen", "Emma", "Esmee", "Evelien", "Esther", "Erica", "Eva", "Femke", "Fleur", "Floor", "Froukje", "Gea", "Gerda", "Hanna", "Hanneke", "Heleen", "Hilde", "Ilona", "Ina", "Inge", "Ingrid", "Iris", "Isabel", "Isabelle", "Janneke", "Jasmijn", "Jeanine", "Jennifer", "Jessica", "Johanna", "Joke", "Julia", "Julie", "Karen", "Karin", "Katja", "Kim", "Lara", "Laura", "Lena", "Lianne", "Lieke", "Lilian", "Linda", "Lisa", "Lisanne", "Lotte", "Louise", "Maaike", "Manon", "Marga", "Maria", "Marissa", "Marit", "Marjolein", "Martine", "Marleen", "Melissa", "Merel", "Miranda", "Michelle", "Mirjam", "Mirthe", "Naomi", "Natalie", 'Nienke', "Nina", "Noortje", "Olivia", "Patricia", "Paula", "Paulien", "Ramona", "Ria", "Rianne", "Roos", "Rosanne", "Ruth", "Sabrina", "Sandra", "Sanne", "Sara", "Saskia", "Silvia", "Sofia", "Sophie", "Sonja", "Suzanne", "Tamara", "Tess", "Tessa", "Tineke", "Valerie", "Vanessa", "Veerle", "Vera", "Victoria", "Wendy", "Willeke", "Yvonne", "Zoë"],
                // Data taken from https://fr.wikipedia.org/wiki/Liste_de_pr%C3%A9noms_fran%C3%A7ais_et_de_la_francophonie
                "fr": ["Abdon","Abel","Abigaëlle","Abigaïl","Acacius","Acanthe","Adalbert","Adalsinde","Adegrine","Adélaïde","Adèle","Adélie","Adeline","Adeltrude","Adolphe","Adonis","Adrastée","Adrehilde","Adrienne","Agathe","Agilbert","Aglaé","Aignan","Agneflète","Agnès","Agrippine","Aimé","Alaine","Alaïs","Albane","Albérade","Alberte","Alcide","Alcine","Alcyone","Aldegonde","Aleth","Alexandrine","Alexine","Alice","Aliénor","Aliette","Aline","Alix","Alizé","Aloïse","Aloyse","Alphonsine","Althée","Amaliane","Amalthée","Amande","Amandine","Amant","Amarande","Amaranthe","Amaryllis","Ambre","Ambroisie","Amélie","Améthyste","Aminte","Anaël","Anaïs","Anastasie","Anatole","Ancelin","Andrée","Anémone","Angadrême","Angèle","Angeline","Angélique","Angilbert","Anicet","Annabelle","Anne","Annette","Annick","Annie","Annonciade","Ansbert","Anstrudie","Anthelme","Antigone","Antoinette","Antonine","Aphélie","Apolline","Apollonie","Aquiline","Arabelle","Arcadie","Archange","Argine","Ariane","Aricie","Ariel","Arielle","Arlette","Armance","Armande","Armandine","Armelle","Armide","Armelle","Armin","Arnaud","Arsène","Arsinoé","Artémis","Arthur","Ascelin","Ascension","Assomption","Astarté","Astérie","Astrée","Astrid","Athalie","Athanasie","Athina","Aube","Albert","Aude","Audrey","Augustine","Aure","Aurélie","Aurélien","Aurèle","Aurore","Auxence","Aveline","Abigaëlle","Avoye","Axelle","Aymard","Azalée","Adèle","Adeline","Barbe","Basilisse","Bathilde","Béatrice","Béatrix","Bénédicte","Bérengère","Bernadette","Berthe","Bertille","Beuve","Blanche","Blanc","Blandine","Brigitte","Brune","Brunehilde","Callista","Camille","Capucine","Carine","Caroline","Cassandre","Catherine","Cécile","Céleste","Célestine","Céline","Chantal","Charlène","Charline","Charlotte","Chloé","Christelle","Christiane","Christine","Claire","Clara","Claude","Claudine","Clarisse","Clémence","Clémentine","Cléo","Clio","Clotilde","Coline","Conception","Constance","Coralie","Coraline","Corentine","Corinne","Cyrielle","Daniel","Daniel","Daphné","Débora","Delphine","Denise","Diane","Dieudonné","Dominique","Doriane","Dorothée","Douce","Édith","Edmée","Éléonore","Éliane","Élia","Éliette","Élisabeth","Élise","Ella","Élodie","Éloïse","Elsa","Émeline","Émérance","Émérentienne","Émérencie","Émilie","Emma","Emmanuelle","Emmelie","Ernestine","Esther","Estelle","Eudoxie","Eugénie","Eulalie","Euphrasie","Eusébie","Évangéline","Eva","Ève","Évelyne","Fanny","Fantine","Faustine","Félicie","Fernande","Flavie","Fleur","Flore","Florence","Florie","Fortuné","France","Francia","Françoise","Francine","Gabrielle","Gaëlle","Garance","Geneviève","Georgette","Gerberge","Germaine","Gertrude","Gisèle","Guenièvre","Guilhemine","Guillemette","Gustave","Gwenael","Hélène","Héloïse","Henriette","Hermine","Hermione","Hippolyte","Honorine","Hortense","Huguette","Ines","Irène","Irina","Iris","Isabeau","Isabelle","Iseult","Isolde","Ismérie","Jacinthe","Jacqueline","Jade","Janine","Jeanne","Jocelyne","Joëlle","Joséphine","Judith","Julia","Julie","Jules","Juliette","Justine","Katy","Kathy","Katie","Laura","Laure","Laureline","Laurence","Laurene","Lauriane","Laurianne","Laurine","Léa","Léna","Léonie","Léon","Léontine","Lorraine","Lucie","Lucienne","Lucille","Ludivine","Lydie","Lydie","Megane","Madeleine","Magali","Maguelone","Mallaury","Manon","Marceline","Margot","Marguerite","Marianne","Marie","Myriam","Marie","Marine","Marion","Marlène","Marthe","Martine","Mathilde","Maud","Maureen","Mauricette","Maxime","Mélanie","Melissa","Mélissandre","Mélisande","Mélodie","Michel","Micheline","Mireille","Miriam","Moïse","Monique","Morgane","Muriel","Mylène","Nadège","Nadine","Nathalie","Nicole","Nicolette","Nine","Noël","Noémie","Océane","Odette","Odile","Olive","Olivia","Olympe","Ombline","Ombeline","Ophélie","Oriande","Oriane","Ozanne","Pascale","Pascaline","Paule","Paulette","Pauline","Priscille","Prisca","Prisque","Pécine","Pélagie","Pénélope","Perrine","Pétronille","Philippine","Philomène","Philothée","Primerose","Prudence","Pulchérie","Quentine","Quiéta","Quintia","Quintilla","Rachel","Raphaëlle","Raymonde","Rebecca","Régine","Réjeanne","René","Rita","Rita","Rolande","Romane","Rosalie","Rose","Roseline","Sabine","Salomé","Sandra","Sandrine","Sarah","Ségolène","Séverine","Sibylle","Simone","Sixt","Solange","Soline","Solène","Sophie","Stéphanie","Suzanne","Sylvain","Sylvie","Tatiana","Thaïs","Théodora","Thérèse","Tiphaine","Ursule","Valentine","Valérie","Véronique","Victoire","Victorine","Vinciane","Violette","Virginie","Viviane","Xavière","Yolande","Ysaline","Yvette","Yvonne","Zélie","Zita","Zoé"]
            }
        },

        lastNames: {
            "en": ['Smith', 'Johnson', 'Williams', 'Jones', 'Brown', 'Davis', 'Miller', 'Wilson', 'Moore', 'Taylor', 'Anderson', 'Thomas', 'Jackson', 'White', 'Harris', 'Martin', 'Thompson', 'Garcia', 'Martinez', 'Robinson', 'Clark', 'Rodriguez', 'Lewis', 'Lee', 'Walker', 'Hall', 'Allen', 'Young', 'Hernandez', 'King', 'Wright', 'Lopez', 'Hill', 'Scott', 'Green', 'Adams', 'Baker', 'Gonzalez', 'Nelson', 'Carter', 'Mitchell', 'Perez', 'Roberts', 'Turner', 'Phillips', 'Campbell', 'Parker', 'Evans', 'Edwards', 'Collins', 'Stewart', 'Sanchez', 'Morris', 'Rogers', 'Reed', 'Cook', 'Morgan', 'Bell', 'Murphy', 'Bailey', 'Rivera', 'Cooper', 'Richardson', 'Cox', 'Howard', 'Ward', 'Torres', 'Peterson', 'Gray', 'Ramirez', 'James', 'Watson', 'Brooks', 'Kelly', 'Sanders', 'Price', 'Bennett', 'Wood', 'Barnes', 'Ross', 'Henderson', 'Coleman', 'Jenkins', 'Perry', 'Powell', 'Long', 'Patterson', 'Hughes', 'Flores', 'Washington', 'Butler', 'Simmons', 'Foster', 'Gonzales', 'Bryant', 'Alexander', 'Russell', 'Griffin', 'Diaz', 'Hayes', 'Myers', 'Ford', 'Hamilton', 'Graham', 'Sullivan', 'Wallace', 'Woods', 'Cole', 'West', 'Jordan', 'Owens', 'Reynolds', 'Fisher', 'Ellis', 'Harrison', 'Gibson', 'McDonald', 'Cruz', 'Marshall', 'Ortiz', 'Gomez', 'Murray', 'Freeman', 'Wells', 'Webb', 'Simpson', 'Stevens', 'Tucker', 'Porter', 'Hunter', 'Hicks', 'Crawford', 'Henry', 'Boyd', 'Mason', 'Morales', 'Kennedy', 'Warren', 'Dixon', 'Ramos', 'Reyes', 'Burns', 'Gordon', 'Shaw', 'Holmes', 'Rice', 'Robertson', 'Hunt', 'Black', 'Daniels', 'Palmer', 'Mills', 'Nichols', 'Grant', 'Knight', 'Ferguson', 'Rose', 'Stone', 'Hawkins', 'Dunn', 'Perkins', 'Hudson', 'Spencer', 'Gardner', 'Stephens', 'Payne', 'Pierce', 'Berry', 'Matthews', 'Arnold', 'Wagner', 'Willis', 'Ray', 'Watkins', 'Olson', 'Carroll', 'Duncan', 'Snyder', 'Hart', 'Cunningham', 'Bradley', 'Lane', 'Andrews', 'Ruiz', 'Harper', 'Fox', 'Riley', 'Armstrong', 'Carpenter', 'Weaver', 'Greene', 'Lawrence', 'Elliott', 'Chavez', 'Sims', 'Austin', 'Peters', 'Kelley', 'Franklin', 'Lawson', 'Fields', 'Gutierrez', 'Ryan', 'Schmidt', 'Carr', 'Vasquez', 'Castillo', 'Wheeler', 'Chapman', 'Oliver', 'Montgomery', 'Richards', 'Williamson', 'Johnston', 'Banks', 'Meyer', 'Bishop', 'McCoy', 'Howell', 'Alvarez', 'Morrison', 'Hansen', 'Fernandez', 'Garza', 'Harvey', 'Little', 'Burton', 'Stanley', 'Nguyen', 'George', 'Jacobs', 'Reid', 'Kim', 'Fuller', 'Lynch', 'Dean', 'Gilbert', 'Garrett', 'Romero', 'Welch', 'Larson', 'Frazier', 'Burke', 'Hanson', 'Day', 'Mendoza', 'Moreno', 'Bowman', 'Medina', 'Fowler', 'Brewer', 'Hoffman', 'Carlson', 'Silva', 'Pearson', 'Holland', 'Douglas', 'Fleming', 'Jensen', 'Vargas', 'Byrd', 'Davidson', 'Hopkins', 'May', 'Terry', 'Herrera', 'Wade', 'Soto', 'Walters', 'Curtis', 'Neal', 'Caldwell', 'Lowe', 'Jennings', 'Barnett', 'Graves', 'Jimenez', 'Horton', 'Shelton', 'Barrett', 'Obrien', 'Castro', 'Sutton', 'Gregory', 'McKinney', 'Lucas', 'Miles', 'Craig', 'Rodriquez', 'Chambers', 'Holt', 'Lambert', 'Fletcher', 'Watts', 'Bates', 'Hale', 'Rhodes', 'Pena', 'Beck', 'Newman', 'Haynes', 'McDaniel', 'Mendez', 'Bush', 'Vaughn', 'Parks', 'Dawson', 'Santiago', 'Norris', 'Hardy', 'Love', 'Steele', 'Curry', 'Powers', 'Schultz', 'Barker', 'Guzman', 'Page', 'Munoz', 'Ball', 'Keller', 'Chandler', 'Weber', 'Leonard', 'Walsh', 'Lyons', 'Ramsey', 'Wolfe', 'Schneider', 'Mullins', 'Benson', 'Sharp', 'Bowen', 'Daniel', 'Barber', 'Cummings', 'Hines', 'Baldwin', 'Griffith', 'Valdez', 'Hubbard', 'Salazar', 'Reeves', 'Warner', 'Stevenson', 'Burgess', 'Santos', 'Tate', 'Cross', 'Garner', 'Mann', 'Mack', 'Moss', 'Thornton', 'Dennis', 'McGee', 'Farmer', 'Delgado', 'Aguilar', 'Vega', 'Glover', 'Manning', 'Cohen', 'Harmon', 'Rodgers', 'Robbins', 'Newton', 'Todd', 'Blair', 'Higgins', 'Ingram', 'Reese', 'Cannon', 'Strickland', 'Townsend', 'Potter', 'Goodwin', 'Walton', 'Rowe', 'Hampton', 'Ortega', 'Patton', 'Swanson', 'Joseph', 'Francis', 'Goodman', 'Maldonado', 'Yates', 'Becker', 'Erickson', 'Hodges', 'Rios', 'Conner', 'Adkins', 'Webster', 'Norman', 'Malone', 'Hammond', 'Flowers', 'Cobb', 'Moody', 'Quinn', 'Blake', 'Maxwell', 'Pope', 'Floyd', 'Osborne', 'Paul', 'McCarthy', 'Guerrero', 'Lindsey', 'Estrada', 'Sandoval', 'Gibbs', 'Tyler', 'Gross', 'Fitzgerald', 'Stokes', 'Doyle', 'Sherman', 'Saunders', 'Wise', 'Colon', 'Gill', 'Alvarado', 'Greer', 'Padilla', 'Simon', 'Waters', 'Nunez', 'Ballard', 'Schwartz', 'McBride', 'Houston', 'Christensen', 'Klein', 'Pratt', 'Briggs', 'Parsons', 'McLaughlin', 'Zimmerman', 'French', 'Buchanan', 'Moran', 'Copeland', 'Roy', 'Pittman', 'Brady', 'McCormick', 'Holloway', 'Brock', 'Poole', 'Frank', 'Logan', 'Owen', 'Bass', 'Marsh', 'Drake', 'Wong', 'Jefferson', 'Park', 'Morton', 'Abbott', 'Sparks', 'Patrick', 'Norton', 'Huff', 'Clayton', 'Massey', 'Lloyd', 'Figueroa', 'Carson', 'Bowers', 'Roberson', 'Barton', 'Tran', 'Lamb', 'Harrington', 'Casey', 'Boone', 'Cortez', 'Clarke', 'Mathis', 'Singleton', 'Wilkins', 'Cain', 'Bryan', 'Underwood', 'Hogan', 'McKenzie', 'Collier', 'Luna', 'Phelps', 'McGuire', 'Allison', 'Bridges', 'Wilkerson', 'Nash', 'Summers', 'Atkins'],
                // Data taken from http://www.dati.gov.it/dataset/comune-di-firenze_0164 (first 1000)
            "it": ["Acciai", "Aglietti", "Agostini", "Agresti", "Ahmed", "Aiazzi", "Albanese", "Alberti", "Alessi", "Alfani", "Alinari", "Alterini", "Amato", "Ammannati", "Ancillotti", "Andrei", "Andreini", "Andreoni", "Angeli", "Anichini", "Antonelli", "Antonini", "Arena", "Ariani", "Arnetoli", "Arrighi", "Baccani", "Baccetti", "Bacci", "Bacherini", "Badii", "Baggiani", "Baglioni", "Bagni", "Bagnoli", "Baldassini", "Baldi", "Baldini", "Ballerini", "Balli", "Ballini", "Balloni", "Bambi", "Banchi", "Bandinelli", "Bandini", "Bani", "Barbetti", "Barbieri", "Barchielli", "Bardazzi", "Bardelli", "Bardi", "Barducci", "Bargellini", "Bargiacchi", "Barni", "Baroncelli", "Baroncini", "Barone", "Baroni", "Baronti", "Bartalesi", "Bartoletti", "Bartoli", "Bartolini", "Bartoloni", "Bartolozzi", "Basagni", "Basile", "Bassi", "Batacchi", "Battaglia", "Battaglini", "Bausi", "Becagli", "Becattini", "Becchi", "Becucci", "Bellandi", "Bellesi", "Belli", "Bellini", "Bellucci", "Bencini", "Benedetti", "Benelli", "Beni", "Benini", "Bensi", "Benucci", "Benvenuti", "Berlincioni", "Bernacchioni", "Bernardi", "Bernardini", "Berni", "Bernini", "Bertelli", "Berti", "Bertini", "Bessi", "Betti", "Bettini", "Biagi", "Biagini", "Biagioni", "Biagiotti", "Biancalani", "Bianchi", "Bianchini", "Bianco", "Biffoli", "Bigazzi", "Bigi", "Biliotti", "Billi", "Binazzi", "Bindi", "Bini", "Biondi", "Bizzarri", "Bocci", "Bogani", "Bolognesi", "Bonaiuti", "Bonanni", "Bonciani", "Boncinelli", "Bondi", "Bonechi", "Bongini", "Boni", "Bonini", "Borchi", "Boretti", "Borghi", "Borghini", "Borgioli", "Borri", "Borselli", "Boschi", "Bottai", "Bracci", "Braccini", "Brandi", "Braschi", "Bravi", "Brazzini", "Breschi", "Brilli", "Brizzi", "Brogelli", "Brogi", "Brogioni", "Brunelli", "Brunetti", "Bruni", "Bruno", "Brunori", "Bruschi", "Bucci", "Bucciarelli", "Buccioni", "Bucelli", "Bulli", "Burberi", "Burchi", "Burgassi", "Burroni", "Bussotti", "Buti", "Caciolli", "Caiani", "Calabrese", "Calamai", "Calamandrei", "Caldini", "Calo'", "Calonaci", "Calosi", "Calvelli", "Cambi", "Camiciottoli", "Cammelli", "Cammilli", "Campolmi", "Cantini", "Capanni", "Capecchi", "Caponi", "Cappelletti", "Cappelli", "Cappellini", "Cappugi", "Capretti", "Caputo", "Carbone", "Carboni", "Cardini", "Carlesi", "Carletti", "Carli", "Caroti", "Carotti", "Carrai", "Carraresi", "Carta", "Caruso", "Casalini", "Casati", "Caselli", "Casini", "Castagnoli", "Castellani", "Castelli", "Castellucci", "Catalano", "Catarzi", "Catelani", "Cavaciocchi", "Cavallaro", "Cavallini", "Cavicchi", "Cavini", "Ceccarelli", "Ceccatelli", "Ceccherelli", "Ceccherini", "Cecchi", "Cecchini", "Cecconi", "Cei", "Cellai", "Celli", "Cellini", "Cencetti", "Ceni", "Cenni", "Cerbai", "Cesari", "Ceseri", "Checcacci", "Checchi", "Checcucci", "Cheli", "Chellini", "Chen", "Cheng", "Cherici", "Cherubini", "Chiaramonti", "Chiarantini", "Chiarelli", "Chiari", "Chiarini", "Chiarugi", "Chiavacci", "Chiesi", "Chimenti", "Chini", "Chirici", "Chiti", "Ciabatti", "Ciampi", "Cianchi", "Cianfanelli", "Cianferoni", "Ciani", "Ciapetti", "Ciappi", "Ciardi", "Ciatti", "Cicali", "Ciccone", "Cinelli", "Cini", "Ciobanu", "Ciolli", "Cioni", "Cipriani", "Cirillo", "Cirri", "Ciucchi", "Ciuffi", "Ciulli", "Ciullini", "Clemente", "Cocchi", "Cognome", "Coli", "Collini", "Colombo", "Colzi", "Comparini", "Conforti", "Consigli", "Conte", "Conti", "Contini", "Coppini", "Coppola", "Corsi", "Corsini", "Corti", "Cortini", "Cosi", "Costa", "Costantini", "Costantino", "Cozzi", "Cresci", "Crescioli", "Cresti", "Crini", "Curradi", "D'Agostino", "D'Alessandro", "D'Amico", "D'Angelo", "Daddi", "Dainelli", "Dallai", "Danti", "Davitti", "De Angelis", "De Luca", "De Marco", "De Rosa", "De Santis", "De Simone", "De Vita", "Degl'Innocenti", "Degli Innocenti", "Dei", "Del Lungo", "Del Re", "Di Marco", "Di Stefano", "Dini", "Diop", "Dobre", "Dolfi", "Donati", "Dondoli", "Dong", "Donnini", "Ducci", "Dumitru", "Ermini", "Esposito", "Evangelisti", "Fabbri", "Fabbrini", "Fabbrizzi", "Fabbroni", "Fabbrucci", "Fabiani", "Facchini", "Faggi", "Fagioli", "Failli", "Faini", "Falciani", "Falcini", "Falcone", "Fallani", "Falorni", "Falsini", "Falugiani", "Fancelli", "Fanelli", "Fanetti", "Fanfani", "Fani", "Fantappie'", "Fantechi", "Fanti", "Fantini", "Fantoni", "Farina", "Fattori", "Favilli", "Fedi", "Fei", "Ferrante", "Ferrara", "Ferrari", "Ferraro", "Ferretti", "Ferri", "Ferrini", "Ferroni", "Fiaschi", "Fibbi", "Fiesoli", "Filippi", "Filippini", "Fini", "Fioravanti", "Fiore", "Fiorentini", "Fiorini", "Fissi", "Focardi", "Foggi", "Fontana", "Fontanelli", "Fontani", "Forconi", "Formigli", "Forte", "Forti", "Fortini", "Fossati", "Fossi", "Francalanci", "Franceschi", "Franceschini", "Franchi", "Franchini", "Franci", "Francini", "Francioni", "Franco", "Frassineti", "Frati", "Fratini", "Frilli", "Frizzi", "Frosali", "Frosini", "Frullini", "Fusco", "Fusi", "Gabbrielli", "Gabellini", "Gagliardi", "Galanti", "Galardi", "Galeotti", "Galletti", "Galli", "Gallo", "Gallori", "Gambacciani", "Gargani", "Garofalo", "Garuglieri", "Gashi", "Gasperini", "Gatti", "Gelli", "Gensini", "Gentile", "Gentili", "Geri", "Gerini", "Gheri", "Ghini", "Giachetti", "Giachi", "Giacomelli", "Gianassi", "Giani", "Giannelli", "Giannetti", "Gianni", "Giannini", "Giannoni", "Giannotti", "Giannozzi", "Gigli", "Giordano", "Giorgetti", "Giorgi", "Giovacchini", "Giovannelli", "Giovannetti", "Giovannini", "Giovannoni", "Giuliani", "Giunti", "Giuntini", "Giusti", "Gonnelli", "Goretti", "Gori", "Gradi", "Gramigni", "Grassi", "Grasso", "Graziani", "Grazzini", "Greco", "Grifoni", "Grillo", "Grimaldi", "Grossi", "Gualtieri", "Guarducci", "Guarino", "Guarnieri", "Guasti", "Guerra", "Guerri", "Guerrini", "Guidi", "Guidotti", "He", "Hoxha", "Hu", "Huang", "Iandelli", "Ignesti", "Innocenti", "Jin", "La Rosa", "Lai", "Landi", "Landini", "Lanini", "Lapi", "Lapini", "Lari", "Lascialfari", "Lastrucci", "Latini", "Lazzeri", "Lazzerini", "Lelli", "Lenzi", "Leonardi", "Leoncini", "Leone", "Leoni", "Lepri", "Li", "Liao", "Lin", "Linari", "Lippi", "Lisi", "Livi", "Lombardi", "Lombardini", "Lombardo", "Longo", "Lopez", "Lorenzi", "Lorenzini", "Lorini", "Lotti", "Lu", "Lucchesi", "Lucherini", "Lunghi", "Lupi", "Madiai", "Maestrini", "Maffei", "Maggi", "Maggini", "Magherini", "Magini", "Magnani", "Magnelli", "Magni", "Magnolfi", "Magrini", "Malavolti", "Malevolti", "Manca", "Mancini", "Manetti", "Manfredi", "Mangani", "Mannelli", "Manni", "Mannini", "Mannucci", "Manuelli", "Manzini", "Marcelli", "Marchese", "Marchetti", "Marchi", "Marchiani", "Marchionni", "Marconi", "Marcucci", "Margheri", "Mari", "Mariani", "Marilli", "Marinai", "Marinari", "Marinelli", "Marini", "Marino", "Mariotti", "Marsili", "Martelli", "Martinelli", "Martini", "Martino", "Marzi", "Masi", "Masini", "Masoni", "Massai", "Materassi", "Mattei", "Matteini", "Matteucci", "Matteuzzi", "Mattioli", "Mattolini", "Matucci", "Mauro", "Mazzanti", "Mazzei", "Mazzetti", "Mazzi", "Mazzini", "Mazzocchi", "Mazzoli", "Mazzoni", "Mazzuoli", "Meacci", "Mecocci", "Meini", "Melani", "Mele", "Meli", "Mengoni", "Menichetti", "Meoni", "Merlini", "Messeri", "Messina", "Meucci", "Miccinesi", "Miceli", "Micheli", "Michelini", "Michelozzi", "Migliori", "Migliorini", "Milani", "Miniati", "Misuri", "Monaco", "Montagnani", "Montagni", "Montanari", "Montelatici", "Monti", "Montigiani", "Montini", "Morandi", "Morandini", "Morelli", "Moretti", "Morganti", "Mori", "Morini", "Moroni", "Morozzi", "Mugnai", "Mugnaini", "Mustafa", "Naldi", "Naldini", "Nannelli", "Nanni", "Nannini", "Nannucci", "Nardi", "Nardini", "Nardoni", "Natali", "Ndiaye", "Nencetti", "Nencini", "Nencioni", "Neri", "Nesi", "Nesti", "Niccolai", "Niccoli", "Niccolini", "Nigi", "Nistri", "Nocentini", "Noferini", "Novelli", "Nucci", "Nuti", "Nutini", "Oliva", "Olivieri", "Olmi", "Orlandi", "Orlandini", "Orlando", "Orsini", "Ortolani", "Ottanelli", "Pacciani", "Pace", "Paci", "Pacini", "Pagani", "Pagano", "Paggetti", "Pagliai", "Pagni", "Pagnini", "Paladini", "Palagi", "Palchetti", "Palloni", "Palmieri", "Palumbo", "Pampaloni", "Pancani", "Pandolfi", "Pandolfini", "Panerai", "Panichi", "Paoletti", "Paoli", "Paolini", "Papi", "Papini", "Papucci", "Parenti", "Parigi", "Parisi", "Parri", "Parrini", "Pasquini", "Passeri", "Pecchioli", "Pecorini", "Pellegrini", "Pepi", "Perini", "Perrone", "Peruzzi", "Pesci", "Pestelli", "Petri", "Petrini", "Petrucci", "Pettini", "Pezzati", "Pezzatini", "Piani", "Piazza", "Piazzesi", "Piazzini", "Piccardi", "Picchi", "Piccini", "Piccioli", "Pieraccini", "Pieraccioni", "Pieralli", "Pierattini", "Pieri", "Pierini", "Pieroni", "Pietrini", "Pini", "Pinna", "Pinto", "Pinzani", "Pinzauti", "Piras", "Pisani", "Pistolesi", "Poggesi", "Poggi", "Poggiali", "Poggiolini", "Poli", "Pollastri", "Porciani", "Pozzi", "Pratellesi", "Pratesi", "Prosperi", "Pruneti", "Pucci", "Puccini", "Puccioni", "Pugi", "Pugliese", "Puliti", "Querci", "Quercioli", "Raddi", "Radu", "Raffaelli", "Ragazzini", "Ranfagni", "Ranieri", "Rastrelli", "Raugei", "Raveggi", "Renai", "Renzi", "Rettori", "Ricci", "Ricciardi", "Ridi", "Ridolfi", "Rigacci", "Righi", "Righini", "Rinaldi", "Risaliti", "Ristori", "Rizzo", "Rocchi", "Rocchini", "Rogai", "Romagnoli", "Romanelli", "Romani", "Romano", "Romei", "Romeo", "Romiti", "Romoli", "Romolini", "Rontini", "Rosati", "Roselli", "Rosi", "Rossetti", "Rossi", "Rossini", "Rovai", "Ruggeri", "Ruggiero", "Russo", "Sabatini", "Saccardi", "Sacchetti", "Sacchi", "Sacco", "Salerno", "Salimbeni", "Salucci", "Salvadori", "Salvestrini", "Salvi", "Salvini", "Sanesi", "Sani", "Sanna", "Santi", "Santini", "Santoni", "Santoro", "Santucci", "Sardi", "Sarri", "Sarti", "Sassi", "Sbolci", "Scali", "Scarpelli", "Scarselli", "Scopetani", "Secci", "Selvi", "Senatori", "Senesi", "Serafini", "Sereni", "Serra", "Sestini", "Sguanci", "Sieni", "Signorini", "Silvestri", "Simoncini", "Simonetti", "Simoni", "Singh", "Sodi", "Soldi", "Somigli", "Sorbi", "Sorelli", "Sorrentino", "Sottili", "Spina", "Spinelli", "Staccioli", "Staderini", "Stefanelli", "Stefani", "Stefanini", "Stella", "Susini", "Tacchi", "Tacconi", "Taddei", "Tagliaferri", "Tamburini", "Tanganelli", "Tani", "Tanini", "Tapinassi", "Tarchi", "Tarchiani", "Targioni", "Tassi", "Tassini", "Tempesti", "Terzani", "Tesi", "Testa", "Testi", "Tilli", "Tinti", "Tirinnanzi", "Toccafondi", "Tofanari", "Tofani", "Tognaccini", "Tonelli", "Tonini", "Torelli", "Torrini", "Tosi", "Toti", "Tozzi", "Trambusti", "Trapani", "Tucci", "Turchi", "Ugolini", "Ulivi", "Valente", "Valenti", "Valentini", "Vangelisti", "Vanni", "Vannini", "Vannoni", "Vannozzi", "Vannucchi", "Vannucci", "Ventura", "Venturi", "Venturini", "Vestri", "Vettori", "Vichi", "Viciani", "Vieri", "Vigiani", "Vignoli", "Vignolini", "Vignozzi", "Villani", "Vinci", "Visani", "Vitale", "Vitali", "Viti", "Viviani", "Vivoli", "Volpe", "Volpi", "Wang", "Wu", "Xu", "Yang", "Ye", "Zagli", "Zani", "Zanieri", "Zanobini", "Zecchi", "Zetti", "Zhang", "Zheng", "Zhou", "Zhu", "Zingoni", "Zini", "Zoppi"],
            // http://www.voornamelijk.nl/meest-voorkomende-achternamen-in-nederland-en-amsterdam/
            "nl":["Albers", "Alblas", "Appelman", "Baars", "Baas", "Bakker", "Blank", "Bleeker", "Blok", "Blom", "Boer", "Boers", "Boldewijn", "Boon", "Boot", "Bos", "Bosch", "Bosma", "Bosman", "Bouma", "Bouman", "Bouwman", "Brands", "Brouwer", "Burger", "Buijs", "Buitenhuis", "Ceder", "Cohen", "Dekker", "Dekkers", "Dijkman", "Dijkstra", "Driessen", "Drost", "Engel", "Evers", "Faber", "Franke", "Gerritsen", "Goedhart", "Goossens", "Groen", "Groenenberg", "Groot", "Haan", "Hart", "Heemskerk", "Hendriks", "Hermans", "Hoekstra", "Hofman", "Hopman", "Huisman", "Jacobs", "Jansen", "Janssen", "Jonker", "Jaspers", "Keijzer", "Klaassen", "Klein", "Koek", "Koenders", "Kok", "Kool", "Koopman", "Koopmans", "Koning", "Koster", "Kramer", "Kroon", "Kuijpers", "Kuiper", "Kuipers", "Kurt", "Koster", "Kwakman", "Los", "Lubbers", "Maas", "Markus", "Martens", "Meijer", "Mol", "Molenaar", "Mulder", "Nieuwenhuis", "Peeters", "Peters", "Pengel", "Pieters", "Pool", "Post", "Postma", "Prins", "Pronk", "Reijnders", "Rietveld", "Roest", "Roos", "Sanders", "Schaap", "Scheffer", "Schenk", "Schilder", "Schipper", "Schmidt", "Scholten", "Schouten", "Schut", "Schutte", "Schuurman", "Simons", "Smeets", "Smit", "Smits", "Snel", "Swinkels", "Tas", "Terpstra", "Timmermans", "Tol", "Tromp", "Troost", "Valk", "Veenstra", "Veldkamp", "Verbeek", "Verheul", "Verhoeven", "Vermeer", "Vermeulen", "Verweij", "Vink", "Visser", "Voorn", "Vos", "Wagenaar", "Wiersema", "Willems", "Willemsen", "Witteveen", "Wolff", "Wolters", "Zijlstra", "Zwart", "de Beer", "de Boer", "de Bruijn", "de Bruin", "de Graaf", "de Groot", "de Haan", "de Haas", "de Jager", "de Jong", "de Jonge", "de Koning", "de Lange", "de Leeuw", "de Ridder", "de Rooij", "de Ruiter", "de Vos", "de Vries", "de Waal", "de Wit", "de Zwart", "van Beek", "van Boven", "van Dam", "van Dijk", "van Dongen", "van Doorn", "van Egmond", "van Eijk", "van Es", "van Gelder", "van Gelderen", "van Houten", "van Hulst", "van Kempen", "van Kesteren", "van Leeuwen", "van Loon", "van Mill", "van Noord", "van Ommen", "van Ommeren", "van Oosten", "van Oostveen", "van Rijn", "van Schaik", "van Veen", "van Vliet", "van Wijk", "van Wijngaarden", "van den Poel", "van de Pol", "van den Ploeg", "van de Ven", "van den Berg", "van den Bosch", "van den Brink", "van den Broek", "van den Heuvel", "van der Heijden", "van der Horst", "van der Hulst", "van der Kroon", "van der Laan", "van der Linden", "van der Meer", "van der Meij", "van der Meulen", "van der Molen", "van der Sluis", "van der Spek", "van der Veen", "van der Velde", "van der Velden", "van der Vliet", "van der Wal"],
            // https://surnames.behindthename.com/top/lists/england-wales/1991
            "uk":["Smith","Jones","Williams","Taylor","Brown","Davies","Evans","Wilson","Thomas","Johnson","Roberts","Robinson","Thompson","Wright","Walker","White","Edwards","Hughes","Green","Hall","Lewis","Harris","Clarke","Patel","Jackson","Wood","Turner","Martin","Cooper","Hill","Ward","Morris","Moore","Clark","Lee","King","Baker","Harrison","Morgan","Allen","James","Scott","Phillips","Watson","Davis","Parker","Price","Bennett","Young","Griffiths","Mitchell","Kelly","Cook","Carter","Richardson","Bailey","Collins","Bell","Shaw","Murphy","Miller","Cox","Richards","Khan","Marshall","Anderson","Simpson","Ellis","Adams","Singh","Begum","Wilkinson","Foster","Chapman","Powell","Webb","Rogers","Gray","Mason","Ali","Hunt","Hussain","Campbell","Matthews","Owen","Palmer","Holmes","Mills","Barnes","Knight","Lloyd","Butler","Russell","Barker","Fisher","Stevens","Jenkins","Murray","Dixon","Harvey","Graham","Pearson","Ahmed","Fletcher","Walsh","Kaur","Gibson","Howard","Andrews","Stewart","Elliott","Reynolds","Saunders","Payne","Fox","Ford","Pearce","Day","Brooks","West","Lawrence","Cole","Atkinson","Bradley","Spencer","Gill","Dawson","Ball","Burton","O'brien","Watts","Rose","Booth","Perry","Ryan","Grant","Wells","Armstrong","Francis","Rees","Hayes","Hart","Hudson","Newman","Barrett","Webster","Hunter","Gregory","Carr","Lowe","Page","Marsh","Riley","Dunn","Woods","Parsons","Berry","Stone","Reid","Holland","Hawkins","Harding","Porter","Robertson","Newton","Oliver","Reed","Kennedy","Williamson","Bird","Gardner","Shah","Dean","Lane","Cooke","Bates","Henderson","Parry","Burgess","Bishop","Walton","Burns","Nicholson","Shepherd","Ross","Cross","Long","Freeman","Warren","Nicholls","Hamilton","Byrne","Sutton","Mcdonald","Yates","Hodgson","Robson","Curtis","Hopkins","O'connor","Harper","Coleman","Watkins","Moss","Mccarthy","Chambers","O'neill","Griffin","Sharp","Hardy","Wheeler","Potter","Osborne","Johnston","Gordon","Doyle","Wallace","George","Jordan","Hutchinson","Rowe","Burke","May","Pritchard","Gilbert","Willis","Higgins","Read","Miles","Stevenson","Stephenson","Hammond","Arnold","Buckley","Walters","Hewitt","Barber","Nelson","Slater","Austin","Sullivan","Whitehead","Mann","Frost","Lambert","Stephens","Blake","Akhtar","Lynch","Goodwin","Barton","Woodward","Thomson","Cunningham","Quinn","Barnett","Baxter","Bibi","Clayton","Nash","Greenwood","Jennings","Holt","Kemp","Poole","Gallagher","Bond","Stokes","Tucker","Davidson","Fowler","Heath","Norman","Middleton","Lawson","Banks","French","Stanley","Jarvis","Gibbs","Ferguson","Hayward","Carroll","Douglas","Dickinson","Todd","Barlow","Peters","Lucas","Knowles","Hartley","Miah","Simmons","Morton","Alexander","Field","Morrison","Norris","Townsend","Preston","Hancock","Thornton","Baldwin","Burrows","Briggs","Parkinson","Reeves","Macdonald","Lamb","Black","Abbott","Sanders","Thorpe","Holden","Tomlinson","Perkins","Ashton","Rhodes","Fuller","Howe","Bryant","Vaughan","Dale","Davey","Weston","Bartlett","Whittaker","Davison","Kent","Skinner","Birch","Morley","Daniels","Glover","Howell","Cartwright","Pugh","Humphreys","Goddard","Brennan","Wall","Kirby","Bowen","Savage","Bull","Wong","Dobson","Smart","Wilkins","Kirk","Fraser","Duffy","Hicks","Patterson","Bradshaw","Little","Archer","Warner","Waters","O'sullivan","Farrell","Brookes","Atkins","Kay","Dodd","Bentley","Flynn","John","Schofield","Short","Haynes","Wade","Butcher","Henry","Sanderson","Crawford","Sheppard","Bolton","Coates","Giles","Gould","Houghton","Gibbons","Pratt","Manning","Law","Hooper","Noble","Dyer","Rahman","Clements","Moran","Sykes","Chan","Doherty","Connolly","Joyce","Franklin","Hobbs","Coles","Herbert","Steele","Kerr","Leach","Winter","Owens","Duncan","Naylor","Fleming","Horton","Finch","Fitzgerald","Randall","Carpenter","Marsden","Browne","Garner","Pickering","Hale","Dennis","Vincent","Chadwick","Chandler","Sharpe","Nolan","Lyons","Hurst","Collier","Peacock","Howarth","Faulkner","Rice","Pollard","Welch","Norton","Gough","Sinclair","Blackburn","Bryan","Conway","Power","Cameron","Daly","Allan","Hanson","Gardiner","Boyle","Myers","Turnbull","Wallis","Mahmood","Sims","Swift","Iqbal","Pope","Brady","Chamberlain","Rowley","Tyler","Farmer","Metcalfe","Hilton","Godfrey","Holloway","Parkin","Bray","Talbot","Donnelly","Nixon","Charlton","Benson","Whitehouse","Barry","Hope","Lord","North","Storey","Connor","Potts","Bevan","Hargreaves","Mclean","Mistry","Bruce","Howells","Hyde","Parkes","Wyatt","Fry","Lees","O'donnell","Craig","Forster","Mckenzie","Humphries","Mellor","Carey","Ingram","Summers","Leonard"],
            // https://surnames.behindthename.com/top/lists/germany/2017
            "de": ["Müller","Schmidt","Schneider","Fischer","Weber","Meyer","Wagner","Becker","Schulz","Hoffmann","Schäfer","Koch","Bauer","Richter","Klein","Wolf","Schröder","Neumann","Schwarz","Zimmermann","Braun","Krüger","Hofmann","Hartmann","Lange","Schmitt","Werner","Schmitz","Krause","Meier","Lehmann","Schmid","Schulze","Maier","Köhler","Herrmann","König","Walter","Mayer","Huber","Kaiser","Fuchs","Peters","Lang","Scholz","Möller","Weiß","Jung","Hahn","Schubert","Vogel","Friedrich","Keller","Günther","Frank","Berger","Winkler","Roth","Beck","Lorenz","Baumann","Franke","Albrecht","Schuster","Simon","Ludwig","Böhm","Winter","Kraus","Martin","Schumacher","Krämer","Vogt","Stein","Jäger","Otto","Sommer","Groß","Seidel","Heinrich","Brandt","Haas","Schreiber","Graf","Schulte","Dietrich","Ziegler","Kuhn","Kühn","Pohl","Engel","Horn","Busch","Bergmann","Thomas","Voigt","Sauer","Arnold","Wolff","Pfeiffer"],
            // http://www.japantimes.co.jp/life/2009/10/11/lifestyle/japans-top-100-most-common-family-names/
            "jp": ["Sato","Suzuki","Takahashi","Tanaka","Watanabe","Ito","Yamamoto","Nakamura","Kobayashi","Kato","Yoshida","Yamada","Sasaki","Yamaguchi","Saito","Matsumoto","Inoue","Kimura","Hayashi","Shimizu","Yamazaki","Mori","Abe","Ikeda","Hashimoto","Yamashita","Ishikawa","Nakajima","Maeda","Fujita","Ogawa","Goto","Okada","Hasegawa","Murakami","Kondo","Ishii","Saito","Sakamoto","Endo","Aoki","Fujii","Nishimura","Fukuda","Ota","Miura","Fujiwara","Okamoto","Matsuda","Nakagawa","Nakano","Harada","Ono","Tamura","Takeuchi","Kaneko","Wada","Nakayama","Ishida","Ueda","Morita","Hara","Shibata","Sakai","Kudo","Yokoyama","Miyazaki","Miyamoto","Uchida","Takagi","Ando","Taniguchi","Ohno","Maruyama","Imai","Takada","Fujimoto","Takeda","Murata","Ueno","Sugiyama","Masuda","Sugawara","Hirano","Kojima","Otsuka","Chiba","Kubo","Matsui","Iwasaki","Sakurai","Kinoshita","Noguchi","Matsuo","Nomura","Kikuchi","Sano","Onishi","Sugimoto","Arai"],
            // http://www.lowchensaustralia.com/names/popular-spanish-names.htm
            "es": ["Garcia","Fernandez","Lopez","Martinez","Gonzalez","Rodriguez","Sanchez","Perez","Martin","Gomez","Ruiz","Diaz","Hernandez","Alvarez","Jimenez","Moreno","Munoz","Alonso","Romero","Navarro","Gutierrez","Torres","Dominguez","Gil","Vazquez","Blanco","Serrano","Ramos","Castro","Suarez","Sanz","Rubio","Ortega","Molina","Delgado","Ortiz","Morales","Ramirez","Marin","Iglesias","Santos","Castillo","Garrido","Calvo","Pena","Cruz","Cano","Nunez","Prieto","Diez","Lozano","Vidal","Pascual","Ferrer","Medina","Vega","Leon","Herrero","Vicente","Mendez","Guerrero","Fuentes","Campos","Nieto","Cortes","Caballero","Ibanez","Lorenzo","Pastor","Gimenez","Saez","Soler","Marquez","Carrasco","Herrera","Montero","Arias","Crespo","Flores","Andres","Aguilar","Hidalgo","Cabrera","Mora","Duran","Velasco","Rey","Pardo","Roman","Vila","Bravo","Merino","Moya","Soto","Izquierdo","Reyes","Redondo","Marcos","Carmona","Menendez"],
            // Data taken from https://fr.wikipedia.org/wiki/Liste_des_noms_de_famille_les_plus_courants_en_France
            "fr": ["Martin","Bernard","Thomas","Petit","Robert","Richard","Durand","Dubois","Moreau","Laurent","Simon","Michel","Lefèvre","Leroy","Roux","David","Bertrand","Morel","Fournier","Girard","Bonnet","Dupont","Lambert","Fontaine","Rousseau","Vincent","Müller","Lefèvre","Faure","André","Mercier","Blanc","Guérin","Boyer","Garnier","Chevalier","François","Legrand","Gauthier","Garcia","Perrin","Robin","Clément","Morin","Nicolas","Henry","Roussel","Matthieu","Gautier","Masson","Marchand","Duval","Denis","Dumont","Marie","Lemaire","Noël","Meyer","Dufour","Meunier","Brun","Blanchard","Giraud","Joly","Rivière","Lucas","Brunet","Gaillard","Barbier","Arnaud","Martínez","Gérard","Roche","Renard","Schmitt","Roy","Leroux","Colin","Vidal","Caron","Picard","Roger","Fabre","Aubert","Lemoine","Renaud","Dumas","Lacroix","Olivier","Philippe","Bourgeois","Pierre","Benoît","Rey","Leclerc","Payet","Rolland","Leclercq","Guillaume","Lecomte","López","Jean","Dupuy","Guillot","Hubert","Berger","Carpentier","Sánchez","Dupuis","Moulin","Louis","Deschamps","Huet","Vasseur","Perez","Boucher","Fleury","Royer","Klein","Jacquet","Adam","Paris","Poirier","Marty","Aubry","Guyot","Carré","Charles","Renault","Charpentier","Ménard","Maillard","Baron","Bertin","Bailly","Hervé","Schneider","Fernández","Le GallGall","Collet","Léger","Bouvier","Julien","Prévost","Millet","Perrot","Daniel","Le RouxRoux","Cousin","Germain","Breton","Besson","Langlois","Rémi","Le GoffGoff","Pelletier","Lévêque","Perrier","Leblanc","Barré","Lebrun","Marchal","Weber","Mallet","Hamon","Boulanger","Jacob","Monnier","Michaud","Rodríguez","Guichard","Gillet","Étienne","Grondin","Poulain","Tessier","Chevallier","Collin","Chauvin","Da SilvaSilva","Bouchet","Gay","Lemaître","Bénard","Maréchal","Humbert","Reynaud","Antoine","Hoarau","Perret","Barthélemy","Cordier","Pichon","Lejeune","Gilbert","Lamy","Delaunay","Pasquier","Carlier","LaporteLaporte"]
        },

        // Data taken from https://github.com/umpirsky/country-list/blob/master/data/en_US/country.json
        countries: [{"name":"Afghanistan","abbreviation":"AF"},{"name":"Åland Islands","abbreviation":"AX"},{"name":"Albania","abbreviation":"AL"},{"name":"Algeria","abbreviation":"DZ"},{"name":"American Samoa","abbreviation":"AS"},{"name":"Andorra","abbreviation":"AD"},{"name":"Angola","abbreviation":"AO"},{"name":"Anguilla","abbreviation":"AI"},{"name":"Antarctica","abbreviation":"AQ"},{"name":"Antigua & Barbuda","abbreviation":"AG"},{"name":"Argentina","abbreviation":"AR"},{"name":"Armenia","abbreviation":"AM"},{"name":"Aruba","abbreviation":"AW"},{"name":"Ascension Island","abbreviation":"AC"},{"name":"Australia","abbreviation":"AU"},{"name":"Austria","abbreviation":"AT"},{"name":"Azerbaijan","abbreviation":"AZ"},{"name":"Bahamas","abbreviation":"BS"},{"name":"Bahrain","abbreviation":"BH"},{"name":"Bangladesh","abbreviation":"BD"},{"name":"Barbados","abbreviation":"BB"},{"name":"Belarus","abbreviation":"BY"},{"name":"Belgium","abbreviation":"BE"},{"name":"Belize","abbreviation":"BZ"},{"name":"Benin","abbreviation":"BJ"},{"name":"Bermuda","abbreviation":"BM"},{"name":"Bhutan","abbreviation":"BT"},{"name":"Bolivia","abbreviation":"BO"},{"name":"Bosnia & Herzegovina","abbreviation":"BA"},{"name":"Botswana","abbreviation":"BW"},{"name":"Brazil","abbreviation":"BR"},{"name":"British Indian Ocean Territory","abbreviation":"IO"},{"name":"British Virgin Islands","abbreviation":"VG"},{"name":"Brunei","abbreviation":"BN"},{"name":"Bulgaria","abbreviation":"BG"},{"name":"Burkina Faso","abbreviation":"BF"},{"name":"Burundi","abbreviation":"BI"},{"name":"Cambodia","abbreviation":"KH"},{"name":"Cameroon","abbreviation":"CM"},{"name":"Canada","abbreviation":"CA"},{"name":"Canary Islands","abbreviation":"IC"},{"name":"Cape Verde","abbreviation":"CV"},{"name":"Caribbean Netherlands","abbreviation":"BQ"},{"name":"Cayman Islands","abbreviation":"KY"},{"name":"Central African Republic","abbreviation":"CF"},{"name":"Ceuta & Melilla","abbreviation":"EA"},{"name":"Chad","abbreviation":"TD"},{"name":"Chile","abbreviation":"CL"},{"name":"China","abbreviation":"CN"},{"name":"Christmas Island","abbreviation":"CX"},{"name":"Cocos (Keeling) Islands","abbreviation":"CC"},{"name":"Colombia","abbreviation":"CO"},{"name":"Comoros","abbreviation":"KM"},{"name":"Congo - Brazzaville","abbreviation":"CG"},{"name":"Congo - Kinshasa","abbreviation":"CD"},{"name":"Cook Islands","abbreviation":"CK"},{"name":"Costa Rica","abbreviation":"CR"},{"name":"Côte d'Ivoire","abbreviation":"CI"},{"name":"Croatia","abbreviation":"HR"},{"name":"Cuba","abbreviation":"CU"},{"name":"Curaçao","abbreviation":"CW"},{"name":"Cyprus","abbreviation":"CY"},{"name":"Czech Republic","abbreviation":"CZ"},{"name":"Denmark","abbreviation":"DK"},{"name":"Diego Garcia","abbreviation":"DG"},{"name":"Djibouti","abbreviation":"DJ"},{"name":"Dominica","abbreviation":"DM"},{"name":"Dominican Republic","abbreviation":"DO"},{"name":"Ecuador","abbreviation":"EC"},{"name":"Egypt","abbreviation":"EG"},{"name":"El Salvador","abbreviation":"SV"},{"name":"Equatorial Guinea","abbreviation":"GQ"},{"name":"Eritrea","abbreviation":"ER"},{"name":"Estonia","abbreviation":"EE"},{"name":"Ethiopia","abbreviation":"ET"},{"name":"Falkland Islands","abbreviation":"FK"},{"name":"Faroe Islands","abbreviation":"FO"},{"name":"Fiji","abbreviation":"FJ"},{"name":"Finland","abbreviation":"FI"},{"name":"France","abbreviation":"FR"},{"name":"French Guiana","abbreviation":"GF"},{"name":"French Polynesia","abbreviation":"PF"},{"name":"French Southern Territories","abbreviation":"TF"},{"name":"Gabon","abbreviation":"GA"},{"name":"Gambia","abbreviation":"GM"},{"name":"Georgia","abbreviation":"GE"},{"name":"Germany","abbreviation":"DE"},{"name":"Ghana","abbreviation":"GH"},{"name":"Gibraltar","abbreviation":"GI"},{"name":"Greece","abbreviation":"GR"},{"name":"Greenland","abbreviation":"GL"},{"name":"Grenada","abbreviation":"GD"},{"name":"Guadeloupe","abbreviation":"GP"},{"name":"Guam","abbreviation":"GU"},{"name":"Guatemala","abbreviation":"GT"},{"name":"Guernsey","abbreviation":"GG"},{"name":"Guinea","abbreviation":"GN"},{"name":"Guinea-Bissau","abbreviation":"GW"},{"name":"Guyana","abbreviation":"GY"},{"name":"Haiti","abbreviation":"HT"},{"name":"Honduras","abbreviation":"HN"},{"name":"Hong Kong SAR China","abbreviation":"HK"},{"name":"Hungary","abbreviation":"HU"},{"name":"Iceland","abbreviation":"IS"},{"name":"India","abbreviation":"IN"},{"name":"Indonesia","abbreviation":"ID"},{"name":"Iran","abbreviation":"IR"},{"name":"Iraq","abbreviation":"IQ"},{"name":"Ireland","abbreviation":"IE"},{"name":"Isle of Man","abbreviation":"IM"},{"name":"Israel","abbreviation":"IL"},{"name":"Italy","abbreviation":"IT"},{"name":"Jamaica","abbreviation":"JM"},{"name":"Japan","abbreviation":"JP"},{"name":"Jersey","abbreviation":"JE"},{"name":"Jordan","abbreviation":"JO"},{"name":"Kazakhstan","abbreviation":"KZ"},{"name":"Kenya","abbreviation":"KE"},{"name":"Kiribati","abbreviation":"KI"},{"name":"Kosovo","abbreviation":"XK"},{"name":"Kuwait","abbreviation":"KW"},{"name":"Kyrgyzstan","abbreviation":"KG"},{"name":"Laos","abbreviation":"LA"},{"name":"Latvia","abbreviation":"LV"},{"name":"Lebanon","abbreviation":"LB"},{"name":"Lesotho","abbreviation":"LS"},{"name":"Liberia","abbreviation":"LR"},{"name":"Libya","abbreviation":"LY"},{"name":"Liechtenstein","abbreviation":"LI"},{"name":"Lithuania","abbreviation":"LT"},{"name":"Luxembourg","abbreviation":"LU"},{"name":"Macau SAR China","abbreviation":"MO"},{"name":"Macedonia","abbreviation":"MK"},{"name":"Madagascar","abbreviation":"MG"},{"name":"Malawi","abbreviation":"MW"},{"name":"Malaysia","abbreviation":"MY"},{"name":"Maldives","abbreviation":"MV"},{"name":"Mali","abbreviation":"ML"},{"name":"Malta","abbreviation":"MT"},{"name":"Marshall Islands","abbreviation":"MH"},{"name":"Martinique","abbreviation":"MQ"},{"name":"Mauritania","abbreviation":"MR"},{"name":"Mauritius","abbreviation":"MU"},{"name":"Mayotte","abbreviation":"YT"},{"name":"Mexico","abbreviation":"MX"},{"name":"Micronesia","abbreviation":"FM"},{"name":"Moldova","abbreviation":"MD"},{"name":"Monaco","abbreviation":"MC"},{"name":"Mongolia","abbreviation":"MN"},{"name":"Montenegro","abbreviation":"ME"},{"name":"Montserrat","abbreviation":"MS"},{"name":"Morocco","abbreviation":"MA"},{"name":"Mozambique","abbreviation":"MZ"},{"name":"Myanmar (Burma)","abbreviation":"MM"},{"name":"Namibia","abbreviation":"NA"},{"name":"Nauru","abbreviation":"NR"},{"name":"Nepal","abbreviation":"NP"},{"name":"Netherlands","abbreviation":"NL"},{"name":"New Caledonia","abbreviation":"NC"},{"name":"New Zealand","abbreviation":"NZ"},{"name":"Nicaragua","abbreviation":"NI"},{"name":"Niger","abbreviation":"NE"},{"name":"Nigeria","abbreviation":"NG"},{"name":"Niue","abbreviation":"NU"},{"name":"Norfolk Island","abbreviation":"NF"},{"name":"North Korea","abbreviation":"KP"},{"name":"Northern Mariana Islands","abbreviation":"MP"},{"name":"Norway","abbreviation":"NO"},{"name":"Oman","abbreviation":"OM"},{"name":"Pakistan","abbreviation":"PK"},{"name":"Palau","abbreviation":"PW"},{"name":"Palestinian Territories","abbreviation":"PS"},{"name":"Panama","abbreviation":"PA"},{"name":"Papua New Guinea","abbreviation":"PG"},{"name":"Paraguay","abbreviation":"PY"},{"name":"Peru","abbreviation":"PE"},{"name":"Philippines","abbreviation":"PH"},{"name":"Pitcairn Islands","abbreviation":"PN"},{"name":"Poland","abbreviation":"PL"},{"name":"Portugal","abbreviation":"PT"},{"name":"Puerto Rico","abbreviation":"PR"},{"name":"Qatar","abbreviation":"QA"},{"name":"Réunion","abbreviation":"RE"},{"name":"Romania","abbreviation":"RO"},{"name":"Russia","abbreviation":"RU"},{"name":"Rwanda","abbreviation":"RW"},{"name":"Samoa","abbreviation":"WS"},{"name":"San Marino","abbreviation":"SM"},{"name":"São Tomé and Príncipe","abbreviation":"ST"},{"name":"Saudi Arabia","abbreviation":"SA"},{"name":"Senegal","abbreviation":"SN"},{"name":"Serbia","abbreviation":"RS"},{"name":"Seychelles","abbreviation":"SC"},{"name":"Sierra Leone","abbreviation":"SL"},{"name":"Singapore","abbreviation":"SG"},{"name":"Sint Maarten","abbreviation":"SX"},{"name":"Slovakia","abbreviation":"SK"},{"name":"Slovenia","abbreviation":"SI"},{"name":"Solomon Islands","abbreviation":"SB"},{"name":"Somalia","abbreviation":"SO"},{"name":"South Africa","abbreviation":"ZA"},{"name":"South Georgia & South Sandwich Islands","abbreviation":"GS"},{"name":"South Korea","abbreviation":"KR"},{"name":"South Sudan","abbreviation":"SS"},{"name":"Spain","abbreviation":"ES"},{"name":"Sri Lanka","abbreviation":"LK"},{"name":"St. Barthélemy","abbreviation":"BL"},{"name":"St. Helena","abbreviation":"SH"},{"name":"St. Kitts & Nevis","abbreviation":"KN"},{"name":"St. Lucia","abbreviation":"LC"},{"name":"St. Martin","abbreviation":"MF"},{"name":"St. Pierre & Miquelon","abbreviation":"PM"},{"name":"St. Vincent & Grenadines","abbreviation":"VC"},{"name":"Sudan","abbreviation":"SD"},{"name":"Suriname","abbreviation":"SR"},{"name":"Svalbard & Jan Mayen","abbreviation":"SJ"},{"name":"Swaziland","abbreviation":"SZ"},{"name":"Sweden","abbreviation":"SE"},{"name":"Switzerland","abbreviation":"CH"},{"name":"Syria","abbreviation":"SY"},{"name":"Taiwan","abbreviation":"TW"},{"name":"Tajikistan","abbreviation":"TJ"},{"name":"Tanzania","abbreviation":"TZ"},{"name":"Thailand","abbreviation":"TH"},{"name":"Timor-Leste","abbreviation":"TL"},{"name":"Togo","abbreviation":"TG"},{"name":"Tokelau","abbreviation":"TK"},{"name":"Tonga","abbreviation":"TO"},{"name":"Trinidad & Tobago","abbreviation":"TT"},{"name":"Tristan da Cunha","abbreviation":"TA"},{"name":"Tunisia","abbreviation":"TN"},{"name":"Turkey","abbreviation":"TR"},{"name":"Turkmenistan","abbreviation":"TM"},{"name":"Turks & Caicos Islands","abbreviation":"TC"},{"name":"Tuvalu","abbreviation":"TV"},{"name":"U.S. Outlying Islands","abbreviation":"UM"},{"name":"U.S. Virgin Islands","abbreviation":"VI"},{"name":"Uganda","abbreviation":"UG"},{"name":"Ukraine","abbreviation":"UA"},{"name":"United Arab Emirates","abbreviation":"AE"},{"name":"United Kingdom","abbreviation":"GB"},{"name":"United States","abbreviation":"US"},{"name":"Uruguay","abbreviation":"UY"},{"name":"Uzbekistan","abbreviation":"UZ"},{"name":"Vanuatu","abbreviation":"VU"},{"name":"Vatican City","abbreviation":"VA"},{"name":"Venezuela","abbreviation":"VE"},{"name":"Vietnam","abbreviation":"VN"},{"name":"Wallis & Futuna","abbreviation":"WF"},{"name":"Western Sahara","abbreviation":"EH"},{"name":"Yemen","abbreviation":"YE"},{"name":"Zambia","abbreviation":"ZM"},{"name":"Zimbabwe","abbreviation":"ZW"}],

                counties: {
            // Data taken from http://www.downloadexcelfiles.com/gb_en/download-excel-file-list-counties-uk
            "uk": [
                {name: 'Bath and North East Somerset'},
                {name: 'Aberdeenshire'},
                {name: 'Anglesey'},
                {name: 'Angus'},
                {name: 'Bedford'},
                {name: 'Blackburn with Darwen'},
                {name: 'Blackpool'},
                {name: 'Bournemouth'},
                {name: 'Bracknell Forest'},
                {name: 'Brighton & Hove'},
                {name: 'Bristol'},
                {name: 'Buckinghamshire'},
                {name: 'Cambridgeshire'},
                {name: 'Carmarthenshire'},
                {name: 'Central Bedfordshire'},
                {name: 'Ceredigion'},
                {name: 'Cheshire East'},
                {name: 'Cheshire West and Chester'},
                {name: 'Clackmannanshire'},
                {name: 'Conwy'},
                {name: 'Cornwall'},
                {name: 'County Antrim'},
                {name: 'County Armagh'},
                {name: 'County Down'},
                {name: 'County Durham'},
                {name: 'County Fermanagh'},
                {name: 'County Londonderry'},
                {name: 'County Tyrone'},
                {name: 'Cumbria'},
                {name: 'Darlington'},
                {name: 'Denbighshire'},
                {name: 'Derby'},
                {name: 'Derbyshire'},
                {name: 'Devon'},
                {name: 'Dorset'},
                {name: 'Dumfries and Galloway'},
                {name: 'Dundee'},
                {name: 'East Lothian'},
                {name: 'East Riding of Yorkshire'},
                {name: 'East Sussex'},
                {name: 'Edinburgh?'},
                {name: 'Essex'},
                {name: 'Falkirk'},
                {name: 'Fife'},
                {name: 'Flintshire'},
                {name: 'Gloucestershire'},
                {name: 'Greater London'},
                {name: 'Greater Manchester'},
                {name: 'Gwent'},
                {name: 'Gwynedd'},
                {name: 'Halton'},
                {name: 'Hampshire'},
                {name: 'Hartlepool'},
                {name: 'Herefordshire'},
                {name: 'Hertfordshire'},
                {name: 'Highlands'},
                {name: 'Hull'},
                {name: 'Isle of Wight'},
                {name: 'Isles of Scilly'},
                {name: 'Kent'},
                {name: 'Lancashire'},
                {name: 'Leicester'},
                {name: 'Leicestershire'},
                {name: 'Lincolnshire'},
                {name: 'Lothian'},
                {name: 'Luton'},
                {name: 'Medway'},
                {name: 'Merseyside'},
                {name: 'Mid Glamorgan'},
                {name: 'Middlesbrough'},
                {name: 'Milton Keynes'},
                {name: 'Monmouthshire'},
                {name: 'Moray'},
                {name: 'Norfolk'},
                {name: 'North East Lincolnshire'},
                {name: 'North Lincolnshire'},
                {name: 'North Somerset'},
                {name: 'North Yorkshire'},
                {name: 'Northamptonshire'},
                {name: 'Northumberland'},
                {name: 'Nottingham'},
                {name: 'Nottinghamshire'},
                {name: 'Oxfordshire'},
                {name: 'Pembrokeshire'},
                {name: 'Perth and Kinross'},
                {name: 'Peterborough'},
                {name: 'Plymouth'},
                {name: 'Poole'},
                {name: 'Portsmouth'},
                {name: 'Powys'},
                {name: 'Reading'},
                {name: 'Redcar and Cleveland'},
                {name: 'Rutland'},
                {name: 'Scottish Borders'},
                {name: 'Shropshire'},
                {name: 'Slough'},
                {name: 'Somerset'},
                {name: 'South Glamorgan'},
                {name: 'South Gloucestershire'},
                {name: 'South Yorkshire'},
                {name: 'Southampton'},
                {name: 'Southend-on-Sea'},
                {name: 'Staffordshire'},
                {name: 'Stirlingshire'},
                {name: 'Stockton-on-Tees'},
                {name: 'Stoke-on-Trent'},
                {name: 'Strathclyde'},
                {name: 'Suffolk'},
                {name: 'Surrey'},
                {name: 'Swindon'},
                {name: 'Telford and Wrekin'},
                {name: 'Thurrock'},
                {name: 'Torbay'},
                {name: 'Tyne and Wear'},
                {name: 'Warrington'},
                {name: 'Warwickshire'},
                {name: 'West Berkshire'},
                {name: 'West Glamorgan'},
                {name: 'West Lothian'},
                {name: 'West Midlands'},
                {name: 'West Sussex'},
                {name: 'West Yorkshire'},
                {name: 'Western Isles'},
                {name: 'Wiltshire'},
                {name: 'Windsor and Maidenhead'},
                {name: 'Wokingham'},
                {name: 'Worcestershire'},
                {name: 'Wrexham'},
                {name: 'York'}]
                                },
        provinces: {
            "ca": [
                {name: 'Alberta', abbreviation: 'AB'},
                {name: 'British Columbia', abbreviation: 'BC'},
                {name: 'Manitoba', abbreviation: 'MB'},
                {name: 'New Brunswick', abbreviation: 'NB'},
                {name: 'Newfoundland and Labrador', abbreviation: 'NL'},
                {name: 'Nova Scotia', abbreviation: 'NS'},
                {name: 'Ontario', abbreviation: 'ON'},
                {name: 'Prince Edward Island', abbreviation: 'PE'},
                {name: 'Quebec', abbreviation: 'QC'},
                {name: 'Saskatchewan', abbreviation: 'SK'},

                // The case could be made that the following are not actually provinces
                // since they are technically considered "territories" however they all
                // look the same on an envelope!
                {name: 'Northwest Territories', abbreviation: 'NT'},
                {name: 'Nunavut', abbreviation: 'NU'},
                {name: 'Yukon', abbreviation: 'YT'}
            ],
            "it": [
                { name: "Agrigento", abbreviation: "AG", code: 84 },
                { name: "Alessandria", abbreviation: "AL", code: 6 },
                { name: "Ancona", abbreviation: "AN", code: 42 },
                { name: "Aosta", abbreviation: "AO", code: 7 },
                { name: "L'Aquila", abbreviation: "AQ", code: 66 },
                { name: "Arezzo", abbreviation: "AR", code: 51 },
                { name: "Ascoli-Piceno", abbreviation: "AP", code: 44 },
                { name: "Asti", abbreviation: "AT", code: 5 },
                { name: "Avellino", abbreviation: "AV", code: 64 },
                { name: "Bari", abbreviation: "BA", code: 72 },
                { name: "Barletta-Andria-Trani", abbreviation: "BT", code: 72 },
                { name: "Belluno", abbreviation: "BL", code: 25 },
                { name: "Benevento", abbreviation: "BN", code: 62 },
                { name: "Bergamo", abbreviation: "BG", code: 16 },
                { name: "Biella", abbreviation: "BI", code: 96 },
                { name: "Bologna", abbreviation: "BO", code: 37 },
                { name: "Bolzano", abbreviation: "BZ", code: 21 },
                { name: "Brescia", abbreviation: "BS", code: 17 },
                { name: "Brindisi", abbreviation: "BR", code: 74 },
                { name: "Cagliari", abbreviation: "CA", code: 92 },
                { name: "Caltanissetta", abbreviation: "CL", code: 85 },
                { name: "Campobasso", abbreviation: "CB", code: 70 },
                { name: "Carbonia Iglesias", abbreviation: "CI", code: 70 },
                { name: "Caserta", abbreviation: "CE", code: 61 },
                { name: "Catania", abbreviation: "CT", code: 87 },
                { name: "Catanzaro", abbreviation: "CZ", code: 79 },
                { name: "Chieti", abbreviation: "CH", code: 69 },
                { name: "Como", abbreviation: "CO", code: 13 },
                { name: "Cosenza", abbreviation: "CS", code: 78 },
                { name: "Cremona", abbreviation: "CR", code: 19 },
                { name: "Crotone", abbreviation: "KR", code: 101 },
                { name: "Cuneo", abbreviation: "CN", code: 4 },
                { name: "Enna", abbreviation: "EN", code: 86 },
                { name: "Fermo", abbreviation: "FM", code: 86 },
                { name: "Ferrara", abbreviation: "FE", code: 38 },
                { name: "Firenze", abbreviation: "FI", code: 48 },
                { name: "Foggia", abbreviation: "FG", code: 71 },
                { name: "Forli-Cesena", abbreviation: "FC", code: 71 },
                { name: "Frosinone", abbreviation: "FR", code: 60 },
                { name: "Genova", abbreviation: "GE", code: 10 },
                { name: "Gorizia", abbreviation: "GO", code: 31 },
                { name: "Grosseto", abbreviation: "GR", code: 53 },
                { name: "Imperia", abbreviation: "IM", code: 8 },
                { name: "Isernia", abbreviation: "IS", code: 94 },
                { name: "La-Spezia", abbreviation: "SP", code: 66 },
                { name: "Latina", abbreviation: "LT", code: 59 },
                { name: "Lecce", abbreviation: "LE", code: 75 },
                { name: "Lecco", abbreviation: "LC", code: 97 },
                { name: "Livorno", abbreviation: "LI", code: 49 },
                { name: "Lodi", abbreviation: "LO", code: 98 },
                { name: "Lucca", abbreviation: "LU", code: 46 },
                { name: "Macerata", abbreviation: "MC", code: 43 },
                { name: "Mantova", abbreviation: "MN", code: 20 },
                { name: "Massa-Carrara", abbreviation: "MS", code: 45 },
                { name: "Matera", abbreviation: "MT", code: 77 },
                { name: "Medio Campidano", abbreviation: "VS", code: 77 },
                { name: "Messina", abbreviation: "ME", code: 83 },
                { name: "Milano", abbreviation: "MI", code: 15 },
                { name: "Modena", abbreviation: "MO", code: 36 },
                { name: "Monza-Brianza", abbreviation: "MB", code: 36 },
                { name: "Napoli", abbreviation: "NA", code: 63 },
                { name: "Novara", abbreviation: "NO", code: 3 },
                { name: "Nuoro", abbreviation: "NU", code: 91 },
                { name: "Ogliastra", abbreviation: "OG", code: 91 },
                { name: "Olbia Tempio", abbreviation: "OT", code: 91 },
                { name: "Oristano", abbreviation: "OR", code: 95 },
                { name: "Padova", abbreviation: "PD", code: 28 },
                { name: "Palermo", abbreviation: "PA", code: 82 },
                { name: "Parma", abbreviation: "PR", code: 34 },
                { name: "Pavia", abbreviation: "PV", code: 18 },
                { name: "Perugia", abbreviation: "PG", code: 54 },
                { name: "Pesaro-Urbino", abbreviation: "PU", code: 41 },
                { name: "Pescara", abbreviation: "PE", code: 68 },
                { name: "Piacenza", abbreviation: "PC", code: 33 },
                { name: "Pisa", abbreviation: "PI", code: 50 },
                { name: "Pistoia", abbreviation: "PT", code: 47 },
                { name: "Pordenone", abbreviation: "PN", code: 93 },
                { name: "Potenza", abbreviation: "PZ", code: 76 },
                { name: "Prato", abbreviation: "PO", code: 100 },
                { name: "Ragusa", abbreviation: "RG", code: 88 },
                { name: "Ravenna", abbreviation: "RA", code: 39 },
                { name: "Reggio-Calabria", abbreviation: "RC", code: 35 },
                { name: "Reggio-Emilia", abbreviation: "RE", code: 35 },
                { name: "Rieti", abbreviation: "RI", code: 57 },
                { name: "Rimini", abbreviation: "RN", code: 99 },
                { name: "Roma", abbreviation: "Roma", code: 58 },
                { name: "Rovigo", abbreviation: "RO", code: 29 },
                { name: "Salerno", abbreviation: "SA", code: 65 },
                { name: "Sassari", abbreviation: "SS", code: 90 },
                { name: "Savona", abbreviation: "SV", code: 9 },
                { name: "Siena", abbreviation: "SI", code: 52 },
                { name: "Siracusa", abbreviation: "SR", code: 89 },
                { name: "Sondrio", abbreviation: "SO", code: 14 },
                { name: "Taranto", abbreviation: "TA", code: 73 },
                { name: "Teramo", abbreviation: "TE", code: 67 },
                { name: "Terni", abbreviation: "TR", code: 55 },
                { name: "Torino", abbreviation: "TO", code: 1 },
                { name: "Trapani", abbreviation: "TP", code: 81 },
                { name: "Trento", abbreviation: "TN", code: 22 },
                { name: "Treviso", abbreviation: "TV", code: 26 },
                { name: "Trieste", abbreviation: "TS", code: 32 },
                { name: "Udine", abbreviation: "UD", code: 30 },
                { name: "Varese", abbreviation: "VA", code: 12 },
                { name: "Venezia", abbreviation: "VE", code: 27 },
                { name: "Verbania", abbreviation: "VB", code: 27 },
                { name: "Vercelli", abbreviation: "VC", code: 2 },
                { name: "Verona", abbreviation: "VR", code: 23 },
                { name: "Vibo-Valentia", abbreviation: "VV", code: 102 },
                { name: "Vicenza", abbreviation: "VI", code: 24 },
                { name: "Viterbo", abbreviation: "VT", code: 56 }
            ]
        },

            // from: https://github.com/samsargent/Useful-Autocomplete-Data/blob/master/data/nationalities.json
        nationalities: [
           {name: 'Afghan'},
           {name: 'Albanian'},
           {name: 'Algerian'},
           {name: 'American'},
           {name: 'Andorran'},
           {name: 'Angolan'},
           {name: 'Antiguans'},
           {name: 'Argentinean'},
           {name: 'Armenian'},
           {name: 'Australian'},
           {name: 'Austrian'},
           {name: 'Azerbaijani'},
           {name: 'Bahami'},
           {name: 'Bahraini'},
           {name: 'Bangladeshi'},
           {name: 'Barbadian'},
           {name: 'Barbudans'},
           {name: 'Batswana'},
           {name: 'Belarusian'},
           {name: 'Belgian'},
           {name: 'Belizean'},
           {name: 'Beninese'},
           {name: 'Bhutanese'},
           {name: 'Bolivian'},
           {name: 'Bosnian'},
           {name: 'Brazilian'},
           {name: 'British'},
           {name: 'Bruneian'},
           {name: 'Bulgarian'},
           {name: 'Burkinabe'},
           {name: 'Burmese'},
           {name: 'Burundian'},
           {name: 'Cambodian'},
           {name: 'Cameroonian'},
           {name: 'Canadian'},
           {name: 'Cape Verdean'},
           {name: 'Central African'},
           {name: 'Chadian'},
           {name: 'Chilean'},
           {name: 'Chinese'},
           {name: 'Colombian'},
           {name: 'Comoran'},
           {name: 'Congolese'},
           {name: 'Costa Rican'},
           {name: 'Croatian'},
           {name: 'Cuban'},
           {name: 'Cypriot'},
           {name: 'Czech'},
           {name: 'Danish'},
           {name: 'Djibouti'},
           {name: 'Dominican'},
           {name: 'Dutch'},
           {name: 'East Timorese'},
           {name: 'Ecuadorean'},
           {name: 'Egyptian'},
           {name: 'Emirian'},
           {name: 'Equatorial Guinean'},
           {name: 'Eritrean'},
           {name: 'Estonian'},
           {name: 'Ethiopian'},
           {name: 'Fijian'},
           {name: 'Filipino'},
           {name: 'Finnish'},
           {name: 'French'},
           {name: 'Gabonese'},
           {name: 'Gambian'},
           {name: 'Georgian'},
           {name: 'German'},
           {name: 'Ghanaian'},
           {name: 'Greek'},
           {name: 'Grenadian'},
           {name: 'Guatemalan'},
           {name: 'Guinea-Bissauan'},
           {name: 'Guinean'},
           {name: 'Guyanese'},
           {name: 'Haitian'},
           {name: 'Herzegovinian'},
           {name: 'Honduran'},
           {name: 'Hungarian'},
           {name: 'I-Kiribati'},
           {name: 'Icelander'},
           {name: 'Indian'},
           {name: 'Indonesian'},
           {name: 'Iranian'},
           {name: 'Iraqi'},
           {name: 'Irish'},
           {name: 'Israeli'},
           {name: 'Italian'},
           {name: 'Ivorian'},
           {name: 'Jamaican'},
           {name: 'Japanese'},
           {name: 'Jordanian'},
           {name: 'Kazakhstani'},
           {name: 'Kenyan'},
           {name: 'Kittian and Nevisian'},
           {name: 'Kuwaiti'},
           {name: 'Kyrgyz'},
           {name: 'Laotian'},
           {name: 'Latvian'},
           {name: 'Lebanese'},
           {name: 'Liberian'},
           {name: 'Libyan'},
           {name: 'Liechtensteiner'},
           {name: 'Lithuanian'},
           {name: 'Luxembourger'},
           {name: 'Macedonian'},
           {name: 'Malagasy'},
           {name: 'Malawian'},
           {name: 'Malaysian'},
           {name: 'Maldivan'},
           {name: 'Malian'},
           {name: 'Maltese'},
           {name: 'Marshallese'},
           {name: 'Mauritanian'},
           {name: 'Mauritian'},
           {name: 'Mexican'},
           {name: 'Micronesian'},
           {name: 'Moldovan'},
           {name: 'Monacan'},
           {name: 'Mongolian'},
           {name: 'Moroccan'},
           {name: 'Mosotho'},
           {name: 'Motswana'},
           {name: 'Mozambican'},
           {name: 'Namibian'},
           {name: 'Nauruan'},
           {name: 'Nepalese'},
           {name: 'New Zealander'},
           {name: 'Nicaraguan'},
           {name: 'Nigerian'},
           {name: 'Nigerien'},
           {name: 'North Korean'},
           {name: 'Northern Irish'},
           {name: 'Norwegian'},
           {name: 'Omani'},
           {name: 'Pakistani'},
           {name: 'Palauan'},
           {name: 'Panamanian'},
           {name: 'Papua New Guinean'},
           {name: 'Paraguayan'},
           {name: 'Peruvian'},
           {name: 'Polish'},
           {name: 'Portuguese'},
           {name: 'Qatari'},
           {name: 'Romani'},
           {name: 'Russian'},
           {name: 'Rwandan'},
           {name: 'Saint Lucian'},
           {name: 'Salvadoran'},
           {name: 'Samoan'},
           {name: 'San Marinese'},
           {name: 'Sao Tomean'},
           {name: 'Saudi'},
           {name: 'Scottish'},
           {name: 'Senegalese'},
           {name: 'Serbian'},
           {name: 'Seychellois'},
           {name: 'Sierra Leonean'},
           {name: 'Singaporean'},
           {name: 'Slovakian'},
           {name: 'Slovenian'},
           {name: 'Solomon Islander'},
           {name: 'Somali'},
           {name: 'South African'},
           {name: 'South Korean'},
           {name: 'Spanish'},
           {name: 'Sri Lankan'},
           {name: 'Sudanese'},
           {name: 'Surinamer'},
           {name: 'Swazi'},
           {name: 'Swedish'},
           {name: 'Swiss'},
           {name: 'Syrian'},
           {name: 'Taiwanese'},
           {name: 'Tajik'},
           {name: 'Tanzanian'},
           {name: 'Thai'},
           {name: 'Togolese'},
           {name: 'Tongan'},
           {name: 'Trinidadian or Tobagonian'},
           {name: 'Tunisian'},
           {name: 'Turkish'},
           {name: 'Tuvaluan'},
           {name: 'Ugandan'},
           {name: 'Ukrainian'},
           {name: 'Uruguaya'},
           {name: 'Uzbekistani'},
           {name: 'Venezuela'},
           {name: 'Vietnamese'},
           {name: 'Wels'},
           {name: 'Yemenit'},
           {name: 'Zambia'},
           {name: 'Zimbabwe'},
        ],
          // http://www.loc.gov/standards/iso639-2/php/code_list.php (ISO-639-1 codes)
        locale_languages: [
          "aa",
          "ab",
          "ae",
          "af",
          "ak",
          "am",
          "an",
          "ar",
          "as",
          "av",
          "ay",
          "az",
          "ba",
          "be",
          "bg",
          "bh",
          "bi",
          "bm",
          "bn",
          "bo",
          "br",
          "bs",
          "ca",
          "ce",
          "ch",
          "co",
          "cr",
          "cs",
          "cu",
          "cv",
          "cy",
          "da",
          "de",
          "dv",
          "dz",
          "ee",
          "el",
          "en",
          "eo",
          "es",
          "et",
          "eu",
          "fa",
          "ff",
          "fi",
          "fj",
          "fo",
          "fr",
          "fy",
          "ga",
          "gd",
          "gl",
          "gn",
          "gu",
          "gv",
          "ha",
          "he",
          "hi",
          "ho",
          "hr",
          "ht",
          "hu",
          "hy",
          "hz",
          "ia",
          "id",
          "ie",
          "ig",
          "ii",
          "ik",
          "io",
          "is",
          "it",
          "iu",
          "ja",
          "jv",
          "ka",
          "kg",
          "ki",
          "kj",
          "kk",
          "kl",
          "km",
          "kn",
          "ko",
          "kr",
          "ks",
          "ku",
          "kv",
          "kw",
          "ky",
          "la",
          "lb",
          "lg",
          "li",
          "ln",
          "lo",
          "lt",
          "lu",
          "lv",
          "mg",
          "mh",
          "mi",
          "mk",
          "ml",
          "mn",
          "mr",
          "ms",
          "mt",
          "my",
          "na",
          "nb",
          "nd",
          "ne",
          "ng",
          "nl",
          "nn",
          "no",
          "nr",
          "nv",
          "ny",
          "oc",
          "oj",
          "om",
          "or",
          "os",
          "pa",
          "pi",
          "pl",
          "ps",
          "pt",
          "qu",
          "rm",
          "rn",
          "ro",
          "ru",
          "rw",
          "sa",
          "sc",
          "sd",
          "se",
          "sg",
          "si",
          "sk",
          "sl",
          "sm",
          "sn",
          "so",
          "sq",
          "sr",
          "ss",
          "st",
          "su",
          "sv",
          "sw",
          "ta",
          "te",
          "tg",
          "th",
          "ti",
          "tk",
          "tl",
          "tn",
          "to",
          "tr",
          "ts",
          "tt",
          "tw",
          "ty",
          "ug",
          "uk",
          "ur",
          "uz",
          "ve",
          "vi",
          "vo",
          "wa",
          "wo",
          "xh",
          "yi",
          "yo",
          "za",
          "zh",
          "zu"
        ],

        // From http://data.okfn.org/data/core/language-codes#resource-language-codes-full (IETF language tags)
        locale_regions: [
          "agq-CM",
          "asa-TZ",
          "ast-ES",
          "bas-CM",
          "bem-ZM",
          "bez-TZ",
          "brx-IN",
          "cgg-UG",
          "chr-US",
          "dav-KE",
          "dje-NE",
          "dsb-DE",
          "dua-CM",
          "dyo-SN",
          "ebu-KE",
          "ewo-CM",
          "fil-PH",
          "fur-IT",
          "gsw-CH",
          "gsw-FR",
          "gsw-LI",
          "guz-KE",
          "haw-US",
          "hsb-DE",
          "jgo-CM",
          "jmc-TZ",
          "kab-DZ",
          "kam-KE",
          "kde-TZ",
          "kea-CV",
          "khq-ML",
          "kkj-CM",
          "kln-KE",
          "kok-IN",
          "ksb-TZ",
          "ksf-CM",
          "ksh-DE",
          "lag-TZ",
          "lkt-US",
          "luo-KE",
          "luy-KE",
          "mas-KE",
          "mas-TZ",
          "mer-KE",
          "mfe-MU",
          "mgh-MZ",
          "mgo-CM",
          "mua-CM",
          "naq-NA",
          "nmg-CM",
          "nnh-CM",
          "nus-SD",
          "nyn-UG",
          "rof-TZ",
          "rwk-TZ",
          "sah-RU",
          "saq-KE",
          "sbp-TZ",
          "seh-MZ",
          "ses-ML",
          "shi-Latn",
          "shi-Latn-MA",
          "shi-Tfng",
          "shi-Tfng-MA",
          "smn-FI",
          "teo-KE",
          "teo-UG",
          "twq-NE",
          "tzm-Latn",
          "tzm-Latn-MA",
          "vai-Latn",
          "vai-Latn-LR",
          "vai-Vaii",
          "vai-Vaii-LR",
          "vun-TZ",
          "wae-CH",
          "xog-UG",
          "yav-CM",
          "zgh-MA",
          "af-NA",
          "af-ZA",
          "ak-GH",
          "am-ET",
          "ar-001",
          "ar-AE",
          "ar-BH",
          "ar-DJ",
          "ar-DZ",
          "ar-EG",
          "ar-EH",
          "ar-ER",
          "ar-IL",
          "ar-IQ",
          "ar-JO",
          "ar-KM",
          "ar-KW",
          "ar-LB",
          "ar-LY",
          "ar-MA",
          "ar-MR",
          "ar-OM",
          "ar-PS",
          "ar-QA",
          "ar-SA",
          "ar-SD",
          "ar-SO",
          "ar-SS",
          "ar-SY",
          "ar-TD",
          "ar-TN",
          "ar-YE",
          "as-IN",
          "az-Cyrl",
          "az-Cyrl-AZ",
          "az-Latn",
          "az-Latn-AZ",
          "be-BY",
          "bg-BG",
          "bm-Latn",
          "bm-Latn-ML",
          "bn-BD",
          "bn-IN",
          "bo-CN",
          "bo-IN",
          "br-FR",
          "bs-Cyrl",
          "bs-Cyrl-BA",
          "bs-Latn",
          "bs-Latn-BA",
          "ca-AD",
          "ca-ES",
          "ca-ES-VALENCIA",
          "ca-FR",
          "ca-IT",
          "cs-CZ",
          "cy-GB",
          "da-DK",
          "da-GL",
          "de-AT",
          "de-BE",
          "de-CH",
          "de-DE",
          "de-LI",
          "de-LU",
          "dz-BT",
          "ee-GH",
          "ee-TG",
          "el-CY",
          "el-GR",
          "en-001",
          "en-150",
          "en-AG",
          "en-AI",
          "en-AS",
          "en-AU",
          "en-BB",
          "en-BE",
          "en-BM",
          "en-BS",
          "en-BW",
          "en-BZ",
          "en-CA",
          "en-CC",
          "en-CK",
          "en-CM",
          "en-CX",
          "en-DG",
          "en-DM",
          "en-ER",
          "en-FJ",
          "en-FK",
          "en-FM",
          "en-GB",
          "en-GD",
          "en-GG",
          "en-GH",
          "en-GI",
          "en-GM",
          "en-GU",
          "en-GY",
          "en-HK",
          "en-IE",
          "en-IM",
          "en-IN",
          "en-IO",
          "en-JE",
          "en-JM",
          "en-KE",
          "en-KI",
          "en-KN",
          "en-KY",
          "en-LC",
          "en-LR",
          "en-LS",
          "en-MG",
          "en-MH",
          "en-MO",
          "en-MP",
          "en-MS",
          "en-MT",
          "en-MU",
          "en-MW",
          "en-MY",
          "en-NA",
          "en-NF",
          "en-NG",
          "en-NR",
          "en-NU",
          "en-NZ",
          "en-PG",
          "en-PH",
          "en-PK",
          "en-PN",
          "en-PR",
          "en-PW",
          "en-RW",
          "en-SB",
          "en-SC",
          "en-SD",
          "en-SG",
          "en-SH",
          "en-SL",
          "en-SS",
          "en-SX",
          "en-SZ",
          "en-TC",
          "en-TK",
          "en-TO",
          "en-TT",
          "en-TV",
          "en-TZ",
          "en-UG",
          "en-UM",
          "en-US",
          "en-US-POSIX",
          "en-VC",
          "en-VG",
          "en-VI",
          "en-VU",
          "en-WS",
          "en-ZA",
          "en-ZM",
          "en-ZW",
          "eo-001",
          "es-419",
          "es-AR",
          "es-BO",
          "es-CL",
          "es-CO",
          "es-CR",
          "es-CU",
          "es-DO",
          "es-EA",
          "es-EC",
          "es-ES",
          "es-GQ",
          "es-GT",
          "es-HN",
          "es-IC",
          "es-MX",
          "es-NI",
          "es-PA",
          "es-PE",
          "es-PH",
          "es-PR",
          "es-PY",
          "es-SV",
          "es-US",
          "es-UY",
          "es-VE",
          "et-EE",
          "eu-ES",
          "fa-AF",
          "fa-IR",
          "ff-CM",
          "ff-GN",
          "ff-MR",
          "ff-SN",
          "fi-FI",
          "fo-FO",
          "fr-BE",
          "fr-BF",
          "fr-BI",
          "fr-BJ",
          "fr-BL",
          "fr-CA",
          "fr-CD",
          "fr-CF",
          "fr-CG",
          "fr-CH",
          "fr-CI",
          "fr-CM",
          "fr-DJ",
          "fr-DZ",
          "fr-FR",
          "fr-GA",
          "fr-GF",
          "fr-GN",
          "fr-GP",
          "fr-GQ",
          "fr-HT",
          "fr-KM",
          "fr-LU",
          "fr-MA",
          "fr-MC",
          "fr-MF",
          "fr-MG",
          "fr-ML",
          "fr-MQ",
          "fr-MR",
          "fr-MU",
          "fr-NC",
          "fr-NE",
          "fr-PF",
          "fr-PM",
          "fr-RE",
          "fr-RW",
          "fr-SC",
          "fr-SN",
          "fr-SY",
          "fr-TD",
          "fr-TG",
          "fr-TN",
          "fr-VU",
          "fr-WF",
          "fr-YT",
          "fy-NL",
          "ga-IE",
          "gd-GB",
          "gl-ES",
          "gu-IN",
          "gv-IM",
          "ha-Latn",
          "ha-Latn-GH",
          "ha-Latn-NE",
          "ha-Latn-NG",
          "he-IL",
          "hi-IN",
          "hr-BA",
          "hr-HR",
          "hu-HU",
          "hy-AM",
          "id-ID",
          "ig-NG",
          "ii-CN",
          "is-IS",
          "it-CH",
          "it-IT",
          "it-SM",
          "ja-JP",
          "ka-GE",
          "ki-KE",
          "kk-Cyrl",
          "kk-Cyrl-KZ",
          "kl-GL",
          "km-KH",
          "kn-IN",
          "ko-KP",
          "ko-KR",
          "ks-Arab",
          "ks-Arab-IN",
          "kw-GB",
          "ky-Cyrl",
          "ky-Cyrl-KG",
          "lb-LU",
          "lg-UG",
          "ln-AO",
          "ln-CD",
          "ln-CF",
          "ln-CG",
          "lo-LA",
          "lt-LT",
          "lu-CD",
          "lv-LV",
          "mg-MG",
          "mk-MK",
          "ml-IN",
          "mn-Cyrl",
          "mn-Cyrl-MN",
          "mr-IN",
          "ms-Latn",
          "ms-Latn-BN",
          "ms-Latn-MY",
          "ms-Latn-SG",
          "mt-MT",
          "my-MM",
          "nb-NO",
          "nb-SJ",
          "nd-ZW",
          "ne-IN",
          "ne-NP",
          "nl-AW",
          "nl-BE",
          "nl-BQ",
          "nl-CW",
          "nl-NL",
          "nl-SR",
          "nl-SX",
          "nn-NO",
          "om-ET",
          "om-KE",
          "or-IN",
          "os-GE",
          "os-RU",
          "pa-Arab",
          "pa-Arab-PK",
          "pa-Guru",
          "pa-Guru-IN",
          "pl-PL",
          "ps-AF",
          "pt-AO",
          "pt-BR",
          "pt-CV",
          "pt-GW",
          "pt-MO",
          "pt-MZ",
          "pt-PT",
          "pt-ST",
          "pt-TL",
          "qu-BO",
          "qu-EC",
          "qu-PE",
          "rm-CH",
          "rn-BI",
          "ro-MD",
          "ro-RO",
          "ru-BY",
          "ru-KG",
          "ru-KZ",
          "ru-MD",
          "ru-RU",
          "ru-UA",
          "rw-RW",
          "se-FI",
          "se-NO",
          "se-SE",
          "sg-CF",
          "si-LK",
          "sk-SK",
          "sl-SI",
          "sn-ZW",
          "so-DJ",
          "so-ET",
          "so-KE",
          "so-SO",
          "sq-AL",
          "sq-MK",
          "sq-XK",
          "sr-Cyrl",
          "sr-Cyrl-BA",
          "sr-Cyrl-ME",
          "sr-Cyrl-RS",
          "sr-Cyrl-XK",
          "sr-Latn",
          "sr-Latn-BA",
          "sr-Latn-ME",
          "sr-Latn-RS",
          "sr-Latn-XK",
          "sv-AX",
          "sv-FI",
          "sv-SE",
          "sw-CD",
          "sw-KE",
          "sw-TZ",
          "sw-UG",
          "ta-IN",
          "ta-LK",
          "ta-MY",
          "ta-SG",
          "te-IN",
          "th-TH",
          "ti-ER",
          "ti-ET",
          "to-TO",
          "tr-CY",
          "tr-TR",
          "ug-Arab",
          "ug-Arab-CN",
          "uk-UA",
          "ur-IN",
          "ur-PK",
          "uz-Arab",
          "uz-Arab-AF",
          "uz-Cyrl",
          "uz-Cyrl-UZ",
          "uz-Latn",
          "uz-Latn-UZ",
          "vi-VN",
          "yi-001",
          "yo-BJ",
          "yo-NG",
          "zh-Hans",
          "zh-Hans-CN",
          "zh-Hans-HK",
          "zh-Hans-MO",
          "zh-Hans-SG",
          "zh-Hant",
          "zh-Hant-HK",
          "zh-Hant-MO",
          "zh-Hant-TW",
          "zu-ZA"
        ],

        us_states_and_dc: [
            {name: 'Alabama', abbreviation: 'AL'},
            {name: 'Alaska', abbreviation: 'AK'},
            {name: 'Arizona', abbreviation: 'AZ'},
            {name: 'Arkansas', abbreviation: 'AR'},
            {name: 'California', abbreviation: 'CA'},
            {name: 'Colorado', abbreviation: 'CO'},
            {name: 'Connecticut', abbreviation: 'CT'},
            {name: 'Delaware', abbreviation: 'DE'},
            {name: 'District of Columbia', abbreviation: 'DC'},
            {name: 'Florida', abbreviation: 'FL'},
            {name: 'Georgia', abbreviation: 'GA'},
            {name: 'Hawaii', abbreviation: 'HI'},
            {name: 'Idaho', abbreviation: 'ID'},
            {name: 'Illinois', abbreviation: 'IL'},
            {name: 'Indiana', abbreviation: 'IN'},
            {name: 'Iowa', abbreviation: 'IA'},
            {name: 'Kansas', abbreviation: 'KS'},
            {name: 'Kentucky', abbreviation: 'KY'},
            {name: 'Louisiana', abbreviation: 'LA'},
            {name: 'Maine', abbreviation: 'ME'},
            {name: 'Maryland', abbreviation: 'MD'},
            {name: 'Massachusetts', abbreviation: 'MA'},
            {name: 'Michigan', abbreviation: 'MI'},
            {name: 'Minnesota', abbreviation: 'MN'},
            {name: 'Mississippi', abbreviation: 'MS'},
            {name: 'Missouri', abbreviation: 'MO'},
            {name: 'Montana', abbreviation: 'MT'},
            {name: 'Nebraska', abbreviation: 'NE'},
            {name: 'Nevada', abbreviation: 'NV'},
            {name: 'New Hampshire', abbreviation: 'NH'},
            {name: 'New Jersey', abbreviation: 'NJ'},
            {name: 'New Mexico', abbreviation: 'NM'},
            {name: 'New York', abbreviation: 'NY'},
            {name: 'North Carolina', abbreviation: 'NC'},
            {name: 'North Dakota', abbreviation: 'ND'},
            {name: 'Ohio', abbreviation: 'OH'},
            {name: 'Oklahoma', abbreviation: 'OK'},
            {name: 'Oregon', abbreviation: 'OR'},
            {name: 'Pennsylvania', abbreviation: 'PA'},
            {name: 'Rhode Island', abbreviation: 'RI'},
            {name: 'South Carolina', abbreviation: 'SC'},
            {name: 'South Dakota', abbreviation: 'SD'},
            {name: 'Tennessee', abbreviation: 'TN'},
            {name: 'Texas', abbreviation: 'TX'},
            {name: 'Utah', abbreviation: 'UT'},
            {name: 'Vermont', abbreviation: 'VT'},
            {name: 'Virginia', abbreviation: 'VA'},
            {name: 'Washington', abbreviation: 'WA'},
            {name: 'West Virginia', abbreviation: 'WV'},
            {name: 'Wisconsin', abbreviation: 'WI'},
            {name: 'Wyoming', abbreviation: 'WY'}
        ],

        territories: [
            {name: 'American Samoa', abbreviation: 'AS'},
            {name: 'Federated States of Micronesia', abbreviation: 'FM'},
            {name: 'Guam', abbreviation: 'GU'},
            {name: 'Marshall Islands', abbreviation: 'MH'},
            {name: 'Northern Mariana Islands', abbreviation: 'MP'},
            {name: 'Puerto Rico', abbreviation: 'PR'},
            {name: 'Virgin Islands, U.S.', abbreviation: 'VI'}
        ],

        armed_forces: [
            {name: 'Armed Forces Europe', abbreviation: 'AE'},
            {name: 'Armed Forces Pacific', abbreviation: 'AP'},
            {name: 'Armed Forces the Americas', abbreviation: 'AA'}
        ],

        country_regions: {
            it: [
                { name: "Valle d'Aosta", abbreviation: "VDA" },
                { name: "Piemonte", abbreviation: "PIE" },
                { name: "Lombardia", abbreviation: "LOM" },
                { name: "Veneto", abbreviation: "VEN" },
                { name: "Trentino Alto Adige", abbreviation: "TAA" },
                { name: "Friuli Venezia Giulia", abbreviation: "FVG" },
                { name: "Liguria", abbreviation: "LIG" },
                { name: "Emilia Romagna", abbreviation: "EMR" },
                { name: "Toscana", abbreviation: "TOS" },
                { name: "Umbria", abbreviation: "UMB" },
                { name: "Marche", abbreviation: "MAR" },
                { name: "Abruzzo", abbreviation: "ABR" },
                { name: "Lazio", abbreviation: "LAZ" },
                { name: "Campania", abbreviation: "CAM" },
                { name: "Puglia", abbreviation: "PUG" },
                { name: "Basilicata", abbreviation: "BAS" },
                { name: "Molise", abbreviation: "MOL" },
                { name: "Calabria", abbreviation: "CAL" },
                { name: "Sicilia", abbreviation: "SIC" },
                { name: "Sardegna", abbreviation: "SAR" }
            ]
        },

        street_suffixes: {
            'us': [
                {name: 'Avenue', abbreviation: 'Ave'},
                {name: 'Boulevard', abbreviation: 'Blvd'},
                {name: 'Center', abbreviation: 'Ctr'},
                {name: 'Circle', abbreviation: 'Cir'},
                {name: 'Court', abbreviation: 'Ct'},
                {name: 'Drive', abbreviation: 'Dr'},
                {name: 'Extension', abbreviation: 'Ext'},
                {name: 'Glen', abbreviation: 'Gln'},
                {name: 'Grove', abbreviation: 'Grv'},
                {name: 'Heights', abbreviation: 'Hts'},
                {name: 'Highway', abbreviation: 'Hwy'},
                {name: 'Junction', abbreviation: 'Jct'},
                {name: 'Key', abbreviation: 'Key'},
                {name: 'Lane', abbreviation: 'Ln'},
                {name: 'Loop', abbreviation: 'Loop'},
                {name: 'Manor', abbreviation: 'Mnr'},
                {name: 'Mill', abbreviation: 'Mill'},
                {name: 'Park', abbreviation: 'Park'},
                {name: 'Parkway', abbreviation: 'Pkwy'},
                {name: 'Pass', abbreviation: 'Pass'},
                {name: 'Path', abbreviation: 'Path'},
                {name: 'Pike', abbreviation: 'Pike'},
                {name: 'Place', abbreviation: 'Pl'},
                {name: 'Plaza', abbreviation: 'Plz'},
                {name: 'Point', abbreviation: 'Pt'},
                {name: 'Ridge', abbreviation: 'Rdg'},
                {name: 'River', abbreviation: 'Riv'},
                {name: 'Road', abbreviation: 'Rd'},
                {name: 'Square', abbreviation: 'Sq'},
                {name: 'Street', abbreviation: 'St'},
                {name: 'Terrace', abbreviation: 'Ter'},
                {name: 'Trail', abbreviation: 'Trl'},
                {name: 'Turnpike', abbreviation: 'Tpke'},
                {name: 'View', abbreviation: 'Vw'},
                {name: 'Way', abbreviation: 'Way'}
            ],
            'it': [
                { name: 'Accesso', abbreviation: 'Acc.' },
                { name: 'Alzaia', abbreviation: 'Alz.' },
                { name: 'Arco', abbreviation: 'Arco' },
                { name: 'Archivolto', abbreviation: 'Acv.' },
                { name: 'Arena', abbreviation: 'Arena' },
                { name: 'Argine', abbreviation: 'Argine' },
                { name: 'Bacino', abbreviation: 'Bacino' },
                { name: 'Banchi', abbreviation: 'Banchi' },
                { name: 'Banchina', abbreviation: 'Ban.' },
                { name: 'Bastioni', abbreviation: 'Bas.' },
                { name: 'Belvedere', abbreviation: 'Belv.' },
                { name: 'Borgata', abbreviation: 'B.ta' },
                { name: 'Borgo', abbreviation: 'B.go' },
                { name: 'Calata', abbreviation: 'Cal.' },
                { name: 'Calle', abbreviation: 'Calle' },
                { name: 'Campiello', abbreviation: 'Cam.' },
                { name: 'Campo', abbreviation: 'Cam.' },
                { name: 'Canale', abbreviation: 'Can.' },
                { name: 'Carraia', abbreviation: 'Carr.' },
                { name: 'Cascina', abbreviation: 'Cascina' },
                { name: 'Case sparse', abbreviation: 'c.s.' },
                { name: 'Cavalcavia', abbreviation: 'Cv.' },
                { name: 'Circonvallazione', abbreviation: 'Cv.' },
                { name: 'Complanare', abbreviation: 'C.re' },
                { name: 'Contrada', abbreviation: 'C.da' },
                { name: 'Corso', abbreviation: 'C.so' },
                { name: 'Corte', abbreviation: 'C.te' },
                { name: 'Cortile', abbreviation: 'C.le' },
                { name: 'Diramazione', abbreviation: 'Dir.' },
                { name: 'Fondaco', abbreviation: 'F.co' },
                { name: 'Fondamenta', abbreviation: 'F.ta' },
                { name: 'Fondo', abbreviation: 'F.do' },
                { name: 'Frazione', abbreviation: 'Fr.' },
                { name: 'Isola', abbreviation: 'Is.' },
                { name: 'Largo', abbreviation: 'L.go' },
                { name: 'Litoranea', abbreviation: 'Lit.' },
                { name: 'Lungolago', abbreviation: 'L.go lago' },
                { name: 'Lungo Po', abbreviation: 'l.go Po' },
                { name: 'Molo', abbreviation: 'Molo' },
                { name: 'Mura', abbreviation: 'Mura' },
                { name: 'Passaggio privato', abbreviation: 'pass. priv.' },
                { name: 'Passeggiata', abbreviation: 'Pass.' },
                { name: 'Piazza', abbreviation: 'P.zza' },
                { name: 'Piazzale', abbreviation: 'P.le' },
                { name: 'Ponte', abbreviation: 'P.te' },
                { name: 'Portico', abbreviation: 'P.co' },
                { name: 'Rampa', abbreviation: 'Rampa' },
                { name: 'Regione', abbreviation: 'Reg.' },
                { name: 'Rione', abbreviation: 'R.ne' },
                { name: 'Rio', abbreviation: 'Rio' },
                { name: 'Ripa', abbreviation: 'Ripa' },
                { name: 'Riva', abbreviation: 'Riva' },
                { name: 'Rondò', abbreviation: 'Rondò' },
                { name: 'Rotonda', abbreviation: 'Rot.' },
                { name: 'Sagrato', abbreviation: 'Sagr.' },
                { name: 'Salita', abbreviation: 'Sal.' },
                { name: 'Scalinata', abbreviation: 'Scal.' },
                { name: 'Scalone', abbreviation: 'Scal.' },
                { name: 'Slargo', abbreviation: 'Sl.' },
                { name: 'Sottoportico', abbreviation: 'Sott.' },
                { name: 'Strada', abbreviation: 'Str.' },
                { name: 'Stradale', abbreviation: 'Str.le' },
                { name: 'Strettoia', abbreviation: 'Strett.' },
                { name: 'Traversa', abbreviation: 'Trav.' },
                { name: 'Via', abbreviation: 'V.' },
                { name: 'Viale', abbreviation: 'V.le' },
                { name: 'Vicinale', abbreviation: 'Vic.le' },
                { name: 'Vicolo', abbreviation: 'Vic.' }
            ],
            'uk' : [
                {name: 'Avenue', abbreviation: 'Ave'},
                {name: 'Close', abbreviation: 'Cl'},
                {name: 'Court', abbreviation: 'Ct'},
                {name: 'Crescent', abbreviation: 'Cr'},
                {name: 'Drive', abbreviation: 'Dr'},
                {name: 'Garden', abbreviation: 'Gdn'},
                {name: 'Gardens', abbreviation: 'Gdns'},
                {name: 'Green', abbreviation: 'Gn'},
                {name: 'Grove', abbreviation: 'Gr'},
                {name: 'Lane', abbreviation: 'Ln'},
                {name: 'Mount', abbreviation: 'Mt'},
                {name: 'Place', abbreviation: 'Pl'},
                {name: 'Park', abbreviation: 'Pk'},
                {name: 'Ridge', abbreviation: 'Rdg'},
                {name: 'Road', abbreviation: 'Rd'},
                {name: 'Square', abbreviation: 'Sq'},
                {name: 'Street', abbreviation: 'St'},
                {name: 'Terrace', abbreviation: 'Ter'},
                {name: 'Valley', abbreviation: 'Val'}
            ]
        },

        months: [
            {name: 'January', short_name: 'Jan', numeric: '01', days: 31},
            // Not messing with leap years...
            {name: 'February', short_name: 'Feb', numeric: '02', days: 28},
            {name: 'March', short_name: 'Mar', numeric: '03', days: 31},
            {name: 'April', short_name: 'Apr', numeric: '04', days: 30},
            {name: 'May', short_name: 'May', numeric: '05', days: 31},
            {name: 'June', short_name: 'Jun', numeric: '06', days: 30},
            {name: 'July', short_name: 'Jul', numeric: '07', days: 31},
            {name: 'August', short_name: 'Aug', numeric: '08', days: 31},
            {name: 'September', short_name: 'Sep', numeric: '09', days: 30},
            {name: 'October', short_name: 'Oct', numeric: '10', days: 31},
            {name: 'November', short_name: 'Nov', numeric: '11', days: 30},
            {name: 'December', short_name: 'Dec', numeric: '12', days: 31}
        ],

        // http://en.wikipedia.org/wiki/Bank_card_number#Issuer_identification_number_.28IIN.29
        cc_types: [
            {name: "American Express", short_name: 'amex', prefix: '34', length: 15},
            {name: "Bankcard", short_name: 'bankcard', prefix: '5610', length: 16},
            {name: "China UnionPay", short_name: 'chinaunion', prefix: '62', length: 16},
            {name: "Diners Club Carte Blanche", short_name: 'dccarte', prefix: '300', length: 14},
            {name: "Diners Club enRoute", short_name: 'dcenroute', prefix: '2014', length: 15},
            {name: "Diners Club International", short_name: 'dcintl', prefix: '36', length: 14},
            {name: "Diners Club United States & Canada", short_name: 'dcusc', prefix: '54', length: 16},
            {name: "Discover Card", short_name: 'discover', prefix: '6011', length: 16},
            {name: "InstaPayment", short_name: 'instapay', prefix: '637', length: 16},
            {name: "JCB", short_name: 'jcb', prefix: '3528', length: 16},
            {name: "Laser", short_name: 'laser', prefix: '6304', length: 16},
            {name: "Maestro", short_name: 'maestro', prefix: '5018', length: 16},
            {name: "Mastercard", short_name: 'mc', prefix: '51', length: 16},
            {name: "Solo", short_name: 'solo', prefix: '6334', length: 16},
            {name: "Switch", short_name: 'switch', prefix: '4903', length: 16},
            {name: "Visa", short_name: 'visa', prefix: '4', length: 16},
            {name: "Visa Electron", short_name: 'electron', prefix: '4026', length: 16}
        ],

        //return all world currency by ISO 4217
        currency_types: [
            {'code' : 'AED', 'name' : 'United Arab Emirates Dirham'},
            {'code' : 'AFN', 'name' : 'Afghanistan Afghani'},
            {'code' : 'ALL', 'name' : 'Albania Lek'},
            {'code' : 'AMD', 'name' : 'Armenia Dram'},
            {'code' : 'ANG', 'name' : 'Netherlands Antilles Guilder'},
            {'code' : 'AOA', 'name' : 'Angola Kwanza'},
            {'code' : 'ARS', 'name' : 'Argentina Peso'},
            {'code' : 'AUD', 'name' : 'Australia Dollar'},
            {'code' : 'AWG', 'name' : 'Aruba Guilder'},
            {'code' : 'AZN', 'name' : 'Azerbaijan New Manat'},
            {'code' : 'BAM', 'name' : 'Bosnia and Herzegovina Convertible Marka'},
            {'code' : 'BBD', 'name' : 'Barbados Dollar'},
            {'code' : 'BDT', 'name' : 'Bangladesh Taka'},
            {'code' : 'BGN', 'name' : 'Bulgaria Lev'},
            {'code' : 'BHD', 'name' : 'Bahrain Dinar'},
            {'code' : 'BIF', 'name' : 'Burundi Franc'},
            {'code' : 'BMD', 'name' : 'Bermuda Dollar'},
            {'code' : 'BND', 'name' : 'Brunei Darussalam Dollar'},
            {'code' : 'BOB', 'name' : 'Bolivia Boliviano'},
            {'code' : 'BRL', 'name' : 'Brazil Real'},
            {'code' : 'BSD', 'name' : 'Bahamas Dollar'},
            {'code' : 'BTN', 'name' : 'Bhutan Ngultrum'},
            {'code' : 'BWP', 'name' : 'Botswana Pula'},
            {'code' : 'BYR', 'name' : 'Belarus Ruble'},
            {'code' : 'BZD', 'name' : 'Belize Dollar'},
            {'code' : 'CAD', 'name' : 'Canada Dollar'},
            {'code' : 'CDF', 'name' : 'Congo/Kinshasa Franc'},
            {'code' : 'CHF', 'name' : 'Switzerland Franc'},
            {'code' : 'CLP', 'name' : 'Chile Peso'},
            {'code' : 'CNY', 'name' : 'China Yuan Renminbi'},
            {'code' : 'COP', 'name' : 'Colombia Peso'},
            {'code' : 'CRC', 'name' : 'Costa Rica Colon'},
            {'code' : 'CUC', 'name' : 'Cuba Convertible Peso'},
            {'code' : 'CUP', 'name' : 'Cuba Peso'},
            {'code' : 'CVE', 'name' : 'Cape Verde Escudo'},
            {'code' : 'CZK', 'name' : 'Czech Republic Koruna'},
            {'code' : 'DJF', 'name' : 'Djibouti Franc'},
            {'code' : 'DKK', 'name' : 'Denmark Krone'},
            {'code' : 'DOP', 'name' : 'Dominican Republic Peso'},
            {'code' : 'DZD', 'name' : 'Algeria Dinar'},
            {'code' : 'EGP', 'name' : 'Egypt Pound'},
            {'code' : 'ERN', 'name' : 'Eritrea Nakfa'},
            {'code' : 'ETB', 'name' : 'Ethiopia Birr'},
            {'code' : 'EUR', 'name' : 'Euro Member Countries'},
            {'code' : 'FJD', 'name' : 'Fiji Dollar'},
            {'code' : 'FKP', 'name' : 'Falkland Islands (Malvinas) Pound'},
            {'code' : 'GBP', 'name' : 'United Kingdom Pound'},
            {'code' : 'GEL', 'name' : 'Georgia Lari'},
            {'code' : 'GGP', 'name' : 'Guernsey Pound'},
            {'code' : 'GHS', 'name' : 'Ghana Cedi'},
            {'code' : 'GIP', 'name' : 'Gibraltar Pound'},
            {'code' : 'GMD', 'name' : 'Gambia Dalasi'},
            {'code' : 'GNF', 'name' : 'Guinea Franc'},
            {'code' : 'GTQ', 'name' : 'Guatemala Quetzal'},
            {'code' : 'GYD', 'name' : 'Guyana Dollar'},
            {'code' : 'HKD', 'name' : 'Hong Kong Dollar'},
            {'code' : 'HNL', 'name' : 'Honduras Lempira'},
            {'code' : 'HRK', 'name' : 'Croatia Kuna'},
            {'code' : 'HTG', 'name' : 'Haiti Gourde'},
            {'code' : 'HUF', 'name' : 'Hungary Forint'},
            {'code' : 'IDR', 'name' : 'Indonesia Rupiah'},
            {'code' : 'ILS', 'name' : 'Israel Shekel'},
            {'code' : 'IMP', 'name' : 'Isle of Man Pound'},
            {'code' : 'INR', 'name' : 'India Rupee'},
            {'code' : 'IQD', 'name' : 'Iraq Dinar'},
            {'code' : 'IRR', 'name' : 'Iran Rial'},
            {'code' : 'ISK', 'name' : 'Iceland Krona'},
            {'code' : 'JEP', 'name' : 'Jersey Pound'},
            {'code' : 'JMD', 'name' : 'Jamaica Dollar'},
            {'code' : 'JOD', 'name' : 'Jordan Dinar'},
            {'code' : 'JPY', 'name' : 'Japan Yen'},
            {'code' : 'KES', 'name' : 'Kenya Shilling'},
            {'code' : 'KGS', 'name' : 'Kyrgyzstan Som'},
            {'code' : 'KHR', 'name' : 'Cambodia Riel'},
            {'code' : 'KMF', 'name' : 'Comoros Franc'},
            {'code' : 'KPW', 'name' : 'Korea (North) Won'},
            {'code' : 'KRW', 'name' : 'Korea (South) Won'},
            {'code' : 'KWD', 'name' : 'Kuwait Dinar'},
            {'code' : 'KYD', 'name' : 'Cayman Islands Dollar'},
            {'code' : 'KZT', 'name' : 'Kazakhstan Tenge'},
            {'code' : 'LAK', 'name' : 'Laos Kip'},
            {'code' : 'LBP', 'name' : 'Lebanon Pound'},
            {'code' : 'LKR', 'name' : 'Sri Lanka Rupee'},
            {'code' : 'LRD', 'name' : 'Liberia Dollar'},
            {'code' : 'LSL', 'name' : 'Lesotho Loti'},
            {'code' : 'LTL', 'name' : 'Lithuania Litas'},
            {'code' : 'LYD', 'name' : 'Libya Dinar'},
            {'code' : 'MAD', 'name' : 'Morocco Dirham'},
            {'code' : 'MDL', 'name' : 'Moldova Leu'},
            {'code' : 'MGA', 'name' : 'Madagascar Ariary'},
            {'code' : 'MKD', 'name' : 'Macedonia Denar'},
            {'code' : 'MMK', 'name' : 'Myanmar (Burma) Kyat'},
            {'code' : 'MNT', 'name' : 'Mongolia Tughrik'},
            {'code' : 'MOP', 'name' : 'Macau Pataca'},
            {'code' : 'MRO', 'name' : 'Mauritania Ouguiya'},
            {'code' : 'MUR', 'name' : 'Mauritius Rupee'},
            {'code' : 'MVR', 'name' : 'Maldives (Maldive Islands) Rufiyaa'},
            {'code' : 'MWK', 'name' : 'Malawi Kwacha'},
            {'code' : 'MXN', 'name' : 'Mexico Peso'},
            {'code' : 'MYR', 'name' : 'Malaysia Ringgit'},
            {'code' : 'MZN', 'name' : 'Mozambique Metical'},
            {'code' : 'NAD', 'name' : 'Namibia Dollar'},
            {'code' : 'NGN', 'name' : 'Nigeria Naira'},
            {'code' : 'NIO', 'name' : 'Nicaragua Cordoba'},
            {'code' : 'NOK', 'name' : 'Norway Krone'},
            {'code' : 'NPR', 'name' : 'Nepal Rupee'},
            {'code' : 'NZD', 'name' : 'New Zealand Dollar'},
            {'code' : 'OMR', 'name' : 'Oman Rial'},
            {'code' : 'PAB', 'name' : 'Panama Balboa'},
            {'code' : 'PEN', 'name' : 'Peru Nuevo Sol'},
            {'code' : 'PGK', 'name' : 'Papua New Guinea Kina'},
            {'code' : 'PHP', 'name' : 'Philippines Peso'},
            {'code' : 'PKR', 'name' : 'Pakistan Rupee'},
            {'code' : 'PLN', 'name' : 'Poland Zloty'},
            {'code' : 'PYG', 'name' : 'Paraguay Guarani'},
            {'code' : 'QAR', 'name' : 'Qatar Riyal'},
            {'code' : 'RON', 'name' : 'Romania New Leu'},
            {'code' : 'RSD', 'name' : 'Serbia Dinar'},
            {'code' : 'RUB', 'name' : 'Russia Ruble'},
            {'code' : 'RWF', 'name' : 'Rwanda Franc'},
            {'code' : 'SAR', 'name' : 'Saudi Arabia Riyal'},
            {'code' : 'SBD', 'name' : 'Solomon Islands Dollar'},
            {'code' : 'SCR', 'name' : 'Seychelles Rupee'},
            {'code' : 'SDG', 'name' : 'Sudan Pound'},
            {'code' : 'SEK', 'name' : 'Sweden Krona'},
            {'code' : 'SGD', 'name' : 'Singapore Dollar'},
            {'code' : 'SHP', 'name' : 'Saint Helena Pound'},
            {'code' : 'SLL', 'name' : 'Sierra Leone Leone'},
            {'code' : 'SOS', 'name' : 'Somalia Shilling'},
            {'code' : 'SPL', 'name' : 'Seborga Luigino'},
            {'code' : 'SRD', 'name' : 'Suriname Dollar'},
            {'code' : 'STD', 'name' : 'São Tomé and Príncipe Dobra'},
            {'code' : 'SVC', 'name' : 'El Salvador Colon'},
            {'code' : 'SYP', 'name' : 'Syria Pound'},
            {'code' : 'SZL', 'name' : 'Swaziland Lilangeni'},
            {'code' : 'THB', 'name' : 'Thailand Baht'},
            {'code' : 'TJS', 'name' : 'Tajikistan Somoni'},
            {'code' : 'TMT', 'name' : 'Turkmenistan Manat'},
            {'code' : 'TND', 'name' : 'Tunisia Dinar'},
            {'code' : 'TOP', 'name' : 'Tonga Pa\'anga'},
            {'code' : 'TRY', 'name' : 'Turkey Lira'},
            {'code' : 'TTD', 'name' : 'Trinidad and Tobago Dollar'},
            {'code' : 'TVD', 'name' : 'Tuvalu Dollar'},
            {'code' : 'TWD', 'name' : 'Taiwan New Dollar'},
            {'code' : 'TZS', 'name' : 'Tanzania Shilling'},
            {'code' : 'UAH', 'name' : 'Ukraine Hryvnia'},
            {'code' : 'UGX', 'name' : 'Uganda Shilling'},
            {'code' : 'USD', 'name' : 'United States Dollar'},
            {'code' : 'UYU', 'name' : 'Uruguay Peso'},
            {'code' : 'UZS', 'name' : 'Uzbekistan Som'},
            {'code' : 'VEF', 'name' : 'Venezuela Bolivar'},
            {'code' : 'VND', 'name' : 'Viet Nam Dong'},
            {'code' : 'VUV', 'name' : 'Vanuatu Vatu'},
            {'code' : 'WST', 'name' : 'Samoa Tala'},
            {'code' : 'XAF', 'name' : 'Communauté Financière Africaine (BEAC) CFA Franc BEAC'},
            {'code' : 'XCD', 'name' : 'East Caribbean Dollar'},
            {'code' : 'XDR', 'name' : 'International Monetary Fund (IMF) Special Drawing Rights'},
            {'code' : 'XOF', 'name' : 'Communauté Financière Africaine (BCEAO) Franc'},
            {'code' : 'XPF', 'name' : 'Comptoirs Français du Pacifique (CFP) Franc'},
            {'code' : 'YER', 'name' : 'Yemen Rial'},
            {'code' : 'ZAR', 'name' : 'South Africa Rand'},
            {'code' : 'ZMW', 'name' : 'Zambia Kwacha'},
            {'code' : 'ZWD', 'name' : 'Zimbabwe Dollar'}
        ],

        // return the names of all valide colors
        colorNames : [  "AliceBlue", "Black", "Navy", "DarkBlue", "MediumBlue", "Blue", "DarkGreen", "Green", "Teal", "DarkCyan", "DeepSkyBlue", "DarkTurquoise", "MediumSpringGreen", "Lime", "SpringGreen",
            "Aqua", "Cyan", "MidnightBlue", "DodgerBlue", "LightSeaGreen", "ForestGreen", "SeaGreen", "DarkSlateGray", "LimeGreen", "MediumSeaGreen", "Turquoise", "RoyalBlue", "SteelBlue", "DarkSlateBlue", "MediumTurquoise",
            "Indigo", "DarkOliveGreen", "CadetBlue", "CornflowerBlue", "RebeccaPurple", "MediumAquaMarine", "DimGray", "SlateBlue", "OliveDrab", "SlateGray", "LightSlateGray", "MediumSlateBlue", "LawnGreen", "Chartreuse",
            "Aquamarine", "Maroon", "Purple", "Olive", "Gray", "SkyBlue", "LightSkyBlue", "BlueViolet", "DarkRed", "DarkMagenta", "SaddleBrown", "Ivory", "White",
            "DarkSeaGreen", "LightGreen", "MediumPurple", "DarkViolet", "PaleGreen", "DarkOrchid", "YellowGreen", "Sienna", "Brown", "DarkGray", "LightBlue", "GreenYellow", "PaleTurquoise", "LightSteelBlue", "PowderBlue",
            "FireBrick", "DarkGoldenRod", "MediumOrchid", "RosyBrown", "DarkKhaki", "Silver", "MediumVioletRed", "IndianRed", "Peru", "Chocolate", "Tan", "LightGray", "Thistle", "Orchid", "GoldenRod", "PaleVioletRed",
            "Crimson", "Gainsboro", "Plum", "BurlyWood", "LightCyan", "Lavender", "DarkSalmon", "Violet", "PaleGoldenRod", "LightCoral", "Khaki", "AliceBlue", "HoneyDew", "Azure", "SandyBrown", "Wheat", "Beige", "WhiteSmoke",
            "MintCream", "GhostWhite", "Salmon", "AntiqueWhite", "Linen", "LightGoldenRodYellow", "OldLace", "Red", "Fuchsia", "Magenta", "DeepPink", "OrangeRed", "Tomato", "HotPink", "Coral", "DarkOrange", "LightSalmon", "Orange",
            "LightPink", "Pink", "Gold", "PeachPuff", "NavajoWhite", "Moccasin", "Bisque", "MistyRose", "BlanchedAlmond", "PapayaWhip", "LavenderBlush", "SeaShell", "Cornsilk", "LemonChiffon", "FloralWhite", "Snow", "Yellow", "LightYellow"
        ],

        // Data taken from https://www.sec.gov/rules/other/4-460list.htm
        company: [ "3Com Corp",
        "3M Company",
        "A.G. Edwards Inc.",
        "Abbott Laboratories",
        "Abercrombie & Fitch Co.",
        "ABM Industries Incorporated",
        "Ace Hardware Corporation",
        "ACT Manufacturing Inc.",
        "Acterna Corp.",
        "Adams Resources & Energy, Inc.",
        "ADC Telecommunications, Inc.",
        "Adelphia Communications Corporation",
        "Administaff, Inc.",
        "Adobe Systems Incorporated",
        "Adolph Coors Company",
        "Advance Auto Parts, Inc.",
        "Advanced Micro Devices, Inc.",
        "AdvancePCS, Inc.",
        "Advantica Restaurant Group, Inc.",
        "The AES Corporation",
        "Aetna Inc.",
        "Affiliated Computer Services, Inc.",
        "AFLAC Incorporated",
        "AGCO Corporation",
        "Agilent Technologies, Inc.",
        "Agway Inc.",
        "Apartment Investment and Management Company",
        "Air Products and Chemicals, Inc.",
        "Airborne, Inc.",
        "Airgas, Inc.",
        "AK Steel Holding Corporation",
        "Alaska Air Group, Inc.",
        "Alberto-Culver Company",
        "Albertson's, Inc.",
        "Alcoa Inc.",
        "Alleghany Corporation",
        "Allegheny Energy, Inc.",
        "Allegheny Technologies Incorporated",
        "Allergan, Inc.",
        "ALLETE, Inc.",
        "Alliant Energy Corporation",
        "Allied Waste Industries, Inc.",
        "Allmerica Financial Corporation",
        "The Allstate Corporation",
        "ALLTEL Corporation",
        "The Alpine Group, Inc.",
        "Amazon.com, Inc.",
        "AMC Entertainment Inc.",
        "American Power Conversion Corporation",
        "Amerada Hess Corporation",
        "AMERCO",
        "Ameren Corporation",
        "America West Holdings Corporation",
        "American Axle & Manufacturing Holdings, Inc.",
        "American Eagle Outfitters, Inc.",
        "American Electric Power Company, Inc.",
        "American Express Company",
        "American Financial Group, Inc.",
        "American Greetings Corporation",
        "American International Group, Inc.",
        "American Standard Companies Inc.",
        "American Water Works Company, Inc.",
        "AmerisourceBergen Corporation",
        "Ames Department Stores, Inc.",
        "Amgen Inc.",
        "Amkor Technology, Inc.",
        "AMR Corporation",
        "AmSouth Bancorp.",
        "Amtran, Inc.",
        "Anadarko Petroleum Corporation",
        "Analog Devices, Inc.",
        "Anheuser-Busch Companies, Inc.",
        "Anixter International Inc.",
        "AnnTaylor Inc.",
        "Anthem, Inc.",
        "AOL Time Warner Inc.",
        "Aon Corporation",
        "Apache Corporation",
        "Apple Computer, Inc.",
        "Applera Corporation",
        "Applied Industrial Technologies, Inc.",
        "Applied Materials, Inc.",
        "Aquila, Inc.",
        "ARAMARK Corporation",
        "Arch Coal, Inc.",
        "Archer Daniels Midland Company",
        "Arkansas Best Corporation",
        "Armstrong Holdings, Inc.",
        "Arrow Electronics, Inc.",
        "ArvinMeritor, Inc.",
        "Ashland Inc.",
        "Astoria Financial Corporation",
        "AT&T Corp.",
        "Atmel Corporation",
        "Atmos Energy Corporation",
        "Audiovox Corporation",
        "Autoliv, Inc.",
        "Automatic Data Processing, Inc.",
        "AutoNation, Inc.",
        "AutoZone, Inc.",
        "Avaya Inc.",
        "Avery Dennison Corporation",
        "Avista Corporation",
        "Avnet, Inc.",
        "Avon Products, Inc.",
        "Baker Hughes Incorporated",
        "Ball Corporation",
        "Bank of America Corporation",
        "The Bank of New York Company, Inc.",
        "Bank One Corporation",
        "Banknorth Group, Inc.",
        "Banta Corporation",
        "Barnes & Noble, Inc.",
        "Bausch & Lomb Incorporated",
        "Baxter International Inc.",
        "BB&T Corporation",
        "The Bear Stearns Companies Inc.",
        "Beazer Homes USA, Inc.",
        "Beckman Coulter, Inc.",
        "Becton, Dickinson and Company",
        "Bed Bath & Beyond Inc.",
        "Belk, Inc.",
        "Bell Microproducts Inc.",
        "BellSouth Corporation",
        "Belo Corp.",
        "Bemis Company, Inc.",
        "Benchmark Electronics, Inc.",
        "Berkshire Hathaway Inc.",
        "Best Buy Co., Inc.",
        "Bethlehem Steel Corporation",
        "Beverly Enterprises, Inc.",
        "Big Lots, Inc.",
        "BJ Services Company",
        "BJ's Wholesale Club, Inc.",
        "The Black & Decker Corporation",
        "Black Hills Corporation",
        "BMC Software, Inc.",
        "The Boeing Company",
        "Boise Cascade Corporation",
        "Borders Group, Inc.",
        "BorgWarner Inc.",
        "Boston Scientific Corporation",
        "Bowater Incorporated",
        "Briggs & Stratton Corporation",
        "Brightpoint, Inc.",
        "Brinker International, Inc.",
        "Bristol-Myers Squibb Company",
        "Broadwing, Inc.",
        "Brown Shoe Company, Inc.",
        "Brown-Forman Corporation",
        "Brunswick Corporation",
        "Budget Group, Inc.",
        "Burlington Coat Factory Warehouse Corporation",
        "Burlington Industries, Inc.",
        "Burlington Northern Santa Fe Corporation",
        "Burlington Resources Inc.",
        "C. H. Robinson Worldwide Inc.",
        "Cablevision Systems Corp",
        "Cabot Corp",
        "Cadence Design Systems, Inc.",
        "Calpine Corp.",
        "Campbell Soup Co.",
        "Capital One Financial Corp.",
        "Cardinal Health Inc.",
        "Caremark Rx Inc.",
        "Carlisle Cos. Inc.",
        "Carpenter Technology Corp.",
        "Casey's General Stores Inc.",
        "Caterpillar Inc.",
        "CBRL Group Inc.",
        "CDI Corp.",
        "CDW Computer Centers Inc.",
        "CellStar Corp.",
        "Cendant Corp",
        "Cenex Harvest States Cooperatives",
        "Centex Corp.",
        "CenturyTel Inc.",
        "Ceridian Corp.",
        "CH2M Hill Cos. Ltd.",
        "Champion Enterprises Inc.",
        "Charles Schwab Corp.",
        "Charming Shoppes Inc.",
        "Charter Communications Inc.",
        "Charter One Financial Inc.",
        "ChevronTexaco Corp.",
        "Chiquita Brands International Inc.",
        "Chubb Corp",
        "Ciena Corp.",
        "Cigna Corp",
        "Cincinnati Financial Corp.",
        "Cinergy Corp.",
        "Cintas Corp.",
        "Circuit City Stores Inc.",
        "Cisco Systems Inc.",
        "Citigroup, Inc",
        "Citizens Communications Co.",
        "CKE Restaurants Inc.",
        "Clear Channel Communications Inc.",
        "The Clorox Co.",
        "CMGI Inc.",
        "CMS Energy Corp.",
        "CNF Inc.",
        "Coca-Cola Co.",
        "Coca-Cola Enterprises Inc.",
        "Colgate-Palmolive Co.",
        "Collins & Aikman Corp.",
        "Comcast Corp.",
        "Comdisco Inc.",
        "Comerica Inc.",
        "Comfort Systems USA Inc.",
        "Commercial Metals Co.",
        "Community Health Systems Inc.",
        "Compass Bancshares Inc",
        "Computer Associates International Inc.",
        "Computer Sciences Corp.",
        "Compuware Corp.",
        "Comverse Technology Inc.",
        "ConAgra Foods Inc.",
        "Concord EFS Inc.",
        "Conectiv, Inc",
        "Conoco Inc",
        "Conseco Inc.",
        "Consolidated Freightways Corp.",
        "Consolidated Edison Inc.",
        "Constellation Brands Inc.",
        "Constellation Emergy Group Inc.",
        "Continental Airlines Inc.",
        "Convergys Corp.",
        "Cooper Cameron Corp.",
        "Cooper Industries Ltd.",
        "Cooper Tire & Rubber Co.",
        "Corn Products International Inc.",
        "Corning Inc.",
        "Costco Wholesale Corp.",
        "Countrywide Credit Industries Inc.",
        "Coventry Health Care Inc.",
        "Cox Communications Inc.",
        "Crane Co.",
        "Crompton Corp.",
        "Crown Cork & Seal Co. Inc.",
        "CSK Auto Corp.",
        "CSX Corp.",
        "Cummins Inc.",
        "CVS Corp.",
        "Cytec Industries Inc.",
        "D&K Healthcare Resources, Inc.",
        "D.R. Horton Inc.",
        "Dana Corporation",
        "Danaher Corporation",
        "Darden Restaurants Inc.",
        "DaVita Inc.",
        "Dean Foods Company",
        "Deere & Company",
        "Del Monte Foods Co",
        "Dell Computer Corporation",
        "Delphi Corp.",
        "Delta Air Lines Inc.",
        "Deluxe Corporation",
        "Devon Energy Corporation",
        "Di Giorgio Corporation",
        "Dial Corporation",
        "Diebold Incorporated",
        "Dillard's Inc.",
        "DIMON Incorporated",
        "Dole Food Company, Inc.",
        "Dollar General Corporation",
        "Dollar Tree Stores, Inc.",
        "Dominion Resources, Inc.",
        "Domino's Pizza LLC",
        "Dover Corporation, Inc.",
        "Dow Chemical Company",
        "Dow Jones & Company, Inc.",
        "DPL Inc.",
        "DQE Inc.",
        "Dreyer's Grand Ice Cream, Inc.",
        "DST Systems, Inc.",
        "DTE Energy Co.",
        "E.I. Du Pont de Nemours and Company",
        "Duke Energy Corp",
        "Dun & Bradstreet Inc.",
        "DURA Automotive Systems Inc.",
        "DynCorp",
        "Dynegy Inc.",
        "E*Trade Group, Inc.",
        "E.W. Scripps Company",
        "Earthlink, Inc.",
        "Eastman Chemical Company",
        "Eastman Kodak Company",
        "Eaton Corporation",
        "Echostar Communications Corporation",
        "Ecolab Inc.",
        "Edison International",
        "EGL Inc.",
        "El Paso Corporation",
        "Electronic Arts Inc.",
        "Electronic Data Systems Corp.",
        "Eli Lilly and Company",
        "EMC Corporation",
        "Emcor Group Inc.",
        "Emerson Electric Co.",
        "Encompass Services Corporation",
        "Energizer Holdings Inc.",
        "Energy East Corporation",
        "Engelhard Corporation",
        "Enron Corp.",
        "Entergy Corporation",
        "Enterprise Products Partners L.P.",
        "EOG Resources, Inc.",
        "Equifax Inc.",
        "Equitable Resources Inc.",
        "Equity Office Properties Trust",
        "Equity Residential Properties Trust",
        "Estee Lauder Companies Inc.",
        "Exelon Corporation",
        "Exide Technologies",
        "Expeditors International of Washington Inc.",
        "Express Scripts Inc.",
        "ExxonMobil Corporation",
        "Fairchild Semiconductor International Inc.",
        "Family Dollar Stores Inc.",
        "Farmland Industries Inc.",
        "Federal Mogul Corp.",
        "Federated Department Stores Inc.",
        "Federal Express Corp.",
        "Felcor Lodging Trust Inc.",
        "Ferro Corp.",
        "Fidelity National Financial Inc.",
        "Fifth Third Bancorp",
        "First American Financial Corp.",
        "First Data Corp.",
        "First National of Nebraska Inc.",
        "First Tennessee National Corp.",
        "FirstEnergy Corp.",
        "Fiserv Inc.",
        "Fisher Scientific International Inc.",
        "FleetBoston Financial Co.",
        "Fleetwood Enterprises Inc.",
        "Fleming Companies Inc.",
        "Flowers Foods Inc.",
        "Flowserv Corp",
        "Fluor Corp",
        "FMC Corp",
        "Foamex International Inc",
        "Foot Locker Inc",
        "Footstar Inc.",
        "Ford Motor Co",
        "Forest Laboratories Inc.",
        "Fortune Brands Inc.",
        "Foster Wheeler Ltd.",
        "FPL Group Inc.",
        "Franklin Resources Inc.",
        "Freeport McMoran Copper & Gold Inc.",
        "Frontier Oil Corp",
        "Furniture Brands International Inc.",
        "Gannett Co., Inc.",
        "Gap Inc.",
        "Gateway Inc.",
        "GATX Corporation",
        "Gemstar-TV Guide International Inc.",
        "GenCorp Inc.",
        "General Cable Corporation",
        "General Dynamics Corporation",
        "General Electric Company",
        "General Mills Inc",
        "General Motors Corporation",
        "Genesis Health Ventures Inc.",
        "Gentek Inc.",
        "Gentiva Health Services Inc.",
        "Genuine Parts Company",
        "Genuity Inc.",
        "Genzyme Corporation",
        "Georgia Gulf Corporation",
        "Georgia-Pacific Corporation",
        "Gillette Company",
        "Gold Kist Inc.",
        "Golden State Bancorp Inc.",
        "Golden West Financial Corporation",
        "Goldman Sachs Group Inc.",
        "Goodrich Corporation",
        "The Goodyear Tire & Rubber Company",
        "Granite Construction Incorporated",
        "Graybar Electric Company Inc.",
        "Great Lakes Chemical Corporation",
        "Great Plains Energy Inc.",
        "GreenPoint Financial Corp.",
        "Greif Bros. Corporation",
        "Grey Global Group Inc.",
        "Group 1 Automotive Inc.",
        "Guidant Corporation",
        "H&R Block Inc.",
        "H.B. Fuller Company",
        "H.J. Heinz Company",
        "Halliburton Co.",
        "Harley-Davidson Inc.",
        "Harman International Industries Inc.",
        "Harrah's Entertainment Inc.",
        "Harris Corp.",
        "Harsco Corp.",
        "Hartford Financial Services Group Inc.",
        "Hasbro Inc.",
        "Hawaiian Electric Industries Inc.",
        "HCA Inc.",
        "Health Management Associates Inc.",
        "Health Net Inc.",
        "Healthsouth Corp",
        "Henry Schein Inc.",
        "Hercules Inc.",
        "Herman Miller Inc.",
        "Hershey Foods Corp.",
        "Hewlett-Packard Company",
        "Hibernia Corp.",
        "Hillenbrand Industries Inc.",
        "Hilton Hotels Corp.",
        "Hollywood Entertainment Corp.",
        "Home Depot Inc.",
        "Hon Industries Inc.",
        "Honeywell International Inc.",
        "Hormel Foods Corp.",
        "Host Marriott Corp.",
        "Household International Corp.",
        "Hovnanian Enterprises Inc.",
        "Hub Group Inc.",
        "Hubbell Inc.",
        "Hughes Supply Inc.",
        "Humana Inc.",
        "Huntington Bancshares Inc.",
        "Idacorp Inc.",
        "IDT Corporation",
        "IKON Office Solutions Inc.",
        "Illinois Tool Works Inc.",
        "IMC Global Inc.",
        "Imperial Sugar Company",
        "IMS Health Inc.",
        "Ingles Market Inc",
        "Ingram Micro Inc.",
        "Insight Enterprises Inc.",
        "Integrated Electrical Services Inc.",
        "Intel Corporation",
        "International Paper Co.",
        "Interpublic Group of Companies Inc.",
        "Interstate Bakeries Corporation",
        "International Business Machines Corp.",
        "International Flavors & Fragrances Inc.",
        "International Multifoods Corporation",
        "Intuit Inc.",
        "IT Group Inc.",
        "ITT Industries Inc.",
        "Ivax Corp.",
        "J.B. Hunt Transport Services Inc.",
        "J.C. Penny Co.",
        "J.P. Morgan Chase & Co.",
        "Jabil Circuit Inc.",
        "Jack In The Box Inc.",
        "Jacobs Engineering Group Inc.",
        "JDS Uniphase Corp.",
        "Jefferson-Pilot Co.",
        "John Hancock Financial Services Inc.",
        "Johnson & Johnson",
        "Johnson Controls Inc.",
        "Jones Apparel Group Inc.",
        "KB Home",
        "Kellogg Company",
        "Kellwood Company",
        "Kelly Services Inc.",
        "Kemet Corp.",
        "Kennametal Inc.",
        "Kerr-McGee Corporation",
        "KeyCorp",
        "KeySpan Corp.",
        "Kimball International Inc.",
        "Kimberly-Clark Corporation",
        "Kindred Healthcare Inc.",
        "KLA-Tencor Corporation",
        "K-Mart Corp.",
        "Knight-Ridder Inc.",
        "Kohl's Corp.",
        "KPMG Consulting Inc.",
        "Kroger Co.",
        "L-3 Communications Holdings Inc.",
        "Laboratory Corporation of America Holdings",
        "Lam Research Corporation",
        "LandAmerica Financial Group Inc.",
        "Lands' End Inc.",
        "Landstar System Inc.",
        "La-Z-Boy Inc.",
        "Lear Corporation",
        "Legg Mason Inc.",
        "Leggett & Platt Inc.",
        "Lehman Brothers Holdings Inc.",
        "Lennar Corporation",
        "Lennox International Inc.",
        "Level 3 Communications Inc.",
        "Levi Strauss & Co.",
        "Lexmark International Inc.",
        "Limited Inc.",
        "Lincoln National Corporation",
        "Linens 'n Things Inc.",
        "Lithia Motors Inc.",
        "Liz Claiborne Inc.",
        "Lockheed Martin Corporation",
        "Loews Corporation",
        "Longs Drug Stores Corporation",
        "Louisiana-Pacific Corporation",
        "Lowe's Companies Inc.",
        "LSI Logic Corporation",
        "The LTV Corporation",
        "The Lubrizol Corporation",
        "Lucent Technologies Inc.",
        "Lyondell Chemical Company",
        "M & T Bank Corporation",
        "Magellan Health Services Inc.",
        "Mail-Well Inc.",
        "Mandalay Resort Group",
        "Manor Care Inc.",
        "Manpower Inc.",
        "Marathon Oil Corporation",
        "Mariner Health Care Inc.",
        "Markel Corporation",
        "Marriott International Inc.",
        "Marsh & McLennan Companies Inc.",
        "Marsh Supermarkets Inc.",
        "Marshall & Ilsley Corporation",
        "Martin Marietta Materials Inc.",
        "Masco Corporation",
        "Massey Energy Company",
        "MasTec Inc.",
        "Mattel Inc.",
        "Maxim Integrated Products Inc.",
        "Maxtor Corporation",
        "Maxxam Inc.",
        "The May Department Stores Company",
        "Maytag Corporation",
        "MBNA Corporation",
        "McCormick & Company Incorporated",
        "McDonald's Corporation",
        "The McGraw-Hill Companies Inc.",
        "McKesson Corporation",
        "McLeodUSA Incorporated",
        "M.D.C. Holdings Inc.",
        "MDU Resources Group Inc.",
        "MeadWestvaco Corporation",
        "Medtronic Inc.",
        "Mellon Financial Corporation",
        "The Men's Wearhouse Inc.",
        "Merck & Co., Inc.",
        "Mercury General Corporation",
        "Merrill Lynch & Co. Inc.",
        "Metaldyne Corporation",
        "Metals USA Inc.",
        "MetLife Inc.",
        "Metris Companies Inc",
        "MGIC Investment Corporation",
        "MGM Mirage",
        "Michaels Stores Inc.",
        "Micron Technology Inc.",
        "Microsoft Corporation",
        "Milacron Inc.",
        "Millennium Chemicals Inc.",
        "Mirant Corporation",
        "Mohawk Industries Inc.",
        "Molex Incorporated",
        "The MONY Group Inc.",
        "Morgan Stanley Dean Witter & Co.",
        "Motorola Inc.",
        "MPS Group Inc.",
        "Murphy Oil Corporation",
        "Nabors Industries Inc",
        "Nacco Industries Inc",
        "Nash Finch Company",
        "National City Corp.",
        "National Commerce Financial Corporation",
        "National Fuel Gas Company",
        "National Oilwell Inc",
        "National Rural Utilities Cooperative Finance Corporation",
        "National Semiconductor Corporation",
        "National Service Industries Inc",
        "Navistar International Corporation",
        "NCR Corporation",
        "The Neiman Marcus Group Inc.",
        "New Jersey Resources Corporation",
        "New York Times Company",
        "Newell Rubbermaid Inc",
        "Newmont Mining Corporation",
        "Nextel Communications Inc",
        "Nicor Inc",
        "Nike Inc",
        "NiSource Inc",
        "Noble Energy Inc",
        "Nordstrom Inc",
        "Norfolk Southern Corporation",
        "Nortek Inc",
        "North Fork Bancorporation Inc",
        "Northeast Utilities System",
        "Northern Trust Corporation",
        "Northrop Grumman Corporation",
        "NorthWestern Corporation",
        "Novellus Systems Inc",
        "NSTAR",
        "NTL Incorporated",
        "Nucor Corp",
        "Nvidia Corp",
        "NVR Inc",
        "Northwest Airlines Corp",
        "Occidental Petroleum Corp",
        "Ocean Energy Inc",
        "Office Depot Inc.",
        "OfficeMax Inc",
        "OGE Energy Corp",
        "Oglethorpe Power Corp.",
        "Ohio Casualty Corp.",
        "Old Republic International Corp.",
        "Olin Corp.",
        "OM Group Inc",
        "Omnicare Inc",
        "Omnicom Group",
        "On Semiconductor Corp",
        "ONEOK Inc",
        "Oracle Corp",
        "Oshkosh Truck Corp",
        "Outback Steakhouse Inc.",
        "Owens & Minor Inc.",
        "Owens Corning",
        "Owens-Illinois Inc",
        "Oxford Health Plans Inc",
        "Paccar Inc",
        "PacifiCare Health Systems Inc",
        "Packaging Corp. of America",
        "Pactiv Corp",
        "Pall Corp",
        "Pantry Inc",
        "Park Place Entertainment Corp",
        "Parker Hannifin Corp.",
        "Pathmark Stores Inc.",
        "Paychex Inc",
        "Payless Shoesource Inc",
        "Penn Traffic Co.",
        "Pennzoil-Quaker State Company",
        "Pentair Inc",
        "Peoples Energy Corp.",
        "PeopleSoft Inc",
        "Pep Boys Manny, Moe & Jack",
        "Potomac Electric Power Co.",
        "Pepsi Bottling Group Inc.",
        "PepsiAmericas Inc.",
        "PepsiCo Inc.",
        "Performance Food Group Co.",
        "Perini Corp",
        "PerkinElmer Inc",
        "Perot Systems Corp",
        "Petco Animal Supplies Inc.",
        "Peter Kiewit Sons', Inc.",
        "PETsMART Inc",
        "Pfizer Inc",
        "Pacific Gas & Electric Corp.",
        "Pharmacia Corp",
        "Phar Mor Inc.",
        "Phelps Dodge Corp.",
        "Philip Morris Companies Inc.",
        "Phillips Petroleum Co",
        "Phillips Van Heusen Corp.",
        "Phoenix Companies Inc",
        "Pier 1 Imports Inc.",
        "Pilgrim's Pride Corporation",
        "Pinnacle West Capital Corp",
        "Pioneer-Standard Electronics Inc.",
        "Pitney Bowes Inc.",
        "Pittston Brinks Group",
        "Plains All American Pipeline LP",
        "PNC Financial Services Group Inc.",
        "PNM Resources Inc",
        "Polaris Industries Inc.",
        "Polo Ralph Lauren Corp",
        "PolyOne Corp",
        "Popular Inc",
        "Potlatch Corp",
        "PPG Industries Inc",
        "PPL Corp",
        "Praxair Inc",
        "Precision Castparts Corp",
        "Premcor Inc.",
        "Pride International Inc",
        "Primedia Inc",
        "Principal Financial Group Inc.",
        "Procter & Gamble Co.",
        "Pro-Fac Cooperative Inc.",
        "Progress Energy Inc",
        "Progressive Corporation",
        "Protective Life Corp",
        "Provident Financial Group",
        "Providian Financial Corp.",
        "Prudential Financial Inc.",
        "PSS World Medical Inc",
        "Public Service Enterprise Group Inc.",
        "Publix Super Markets Inc.",
        "Puget Energy Inc.",
        "Pulte Homes Inc",
        "Qualcomm Inc",
        "Quanta Services Inc.",
        "Quantum Corp",
        "Quest Diagnostics Inc.",
        "Questar Corp",
        "Quintiles Transnational",
        "Qwest Communications Intl Inc",
        "R.J. Reynolds Tobacco Company",
        "R.R. Donnelley & Sons Company",
        "Radio Shack Corporation",
        "Raymond James Financial Inc.",
        "Raytheon Company",
        "Reader's Digest Association Inc.",
        "Reebok International Ltd.",
        "Regions Financial Corp.",
        "Regis Corporation",
        "Reliance Steel & Aluminum Co.",
        "Reliant Energy Inc.",
        "Rent A Center Inc",
        "Republic Services Inc",
        "Revlon Inc",
        "RGS Energy Group Inc",
        "Rite Aid Corp",
        "Riverwood Holding Inc.",
        "RoadwayCorp",
        "Robert Half International Inc.",
        "Rock-Tenn Co",
        "Rockwell Automation Inc",
        "Rockwell Collins Inc",
        "Rohm & Haas Co.",
        "Ross Stores Inc",
        "RPM Inc.",
        "Ruddick Corp",
        "Ryder System Inc",
        "Ryerson Tull Inc",
        "Ryland Group Inc.",
        "Sabre Holdings Corp",
        "Safeco Corp",
        "Safeguard Scientifics Inc.",
        "Safeway Inc",
        "Saks Inc",
        "Sanmina-SCI Inc",
        "Sara Lee Corp",
        "SBC Communications Inc",
        "Scana Corp.",
        "Schering-Plough Corp",
        "Scholastic Corp",
        "SCI Systems Onc.",
        "Science Applications Intl. Inc.",
        "Scientific-Atlanta Inc",
        "Scotts Company",
        "Seaboard Corp",
        "Sealed Air Corp",
        "Sears Roebuck & Co",
        "Sempra Energy",
        "Sequa Corp",
        "Service Corp. International",
        "ServiceMaster Co",
        "Shaw Group Inc",
        "Sherwin-Williams Company",
        "Shopko Stores Inc",
        "Siebel Systems Inc",
        "Sierra Health Services Inc",
        "Sierra Pacific Resources",
        "Silgan Holdings Inc.",
        "Silicon Graphics Inc",
        "Simon Property Group Inc",
        "SLM Corporation",
        "Smith International Inc",
        "Smithfield Foods Inc",
        "Smurfit-Stone Container Corp",
        "Snap-On Inc",
        "Solectron Corp",
        "Solutia Inc",
        "Sonic Automotive Inc.",
        "Sonoco Products Co.",
        "Southern Company",
        "Southern Union Company",
        "SouthTrust Corp.",
        "Southwest Airlines Co",
        "Southwest Gas Corp",
        "Sovereign Bancorp Inc.",
        "Spartan Stores Inc",
        "Spherion Corp",
        "Sports Authority Inc",
        "Sprint Corp.",
        "SPX Corp",
        "St. Jude Medical Inc",
        "St. Paul Cos.",
        "Staff Leasing Inc.",
        "StanCorp Financial Group Inc",
        "Standard Pacific Corp.",
        "Stanley Works",
        "Staples Inc",
        "Starbucks Corp",
        "Starwood Hotels & Resorts Worldwide Inc",
        "State Street Corp.",
        "Stater Bros. Holdings Inc.",
        "Steelcase Inc",
        "Stein Mart Inc",
        "Stewart & Stevenson Services Inc",
        "Stewart Information Services Corp",
        "Stilwell Financial Inc",
        "Storage Technology Corporation",
        "Stryker Corp",
        "Sun Healthcare Group Inc.",
        "Sun Microsystems Inc.",
        "SunGard Data Systems Inc.",
        "Sunoco Inc.",
        "SunTrust Banks Inc",
        "Supervalu Inc",
        "Swift Transportation, Co., Inc",
        "Symbol Technologies Inc",
        "Synovus Financial Corp.",
        "Sysco Corp",
        "Systemax Inc.",
        "Target Corp.",
        "Tech Data Corporation",
        "TECO Energy Inc",
        "Tecumseh Products Company",
        "Tektronix Inc",
        "Teleflex Incorporated",
        "Telephone & Data Systems Inc",
        "Tellabs Inc.",
        "Temple-Inland Inc",
        "Tenet Healthcare Corporation",
        "Tenneco Automotive Inc.",
        "Teradyne Inc",
        "Terex Corp",
        "Tesoro Petroleum Corp.",
        "Texas Industries Inc.",
        "Texas Instruments Incorporated",
        "Textron Inc",
        "Thermo Electron Corporation",
        "Thomas & Betts Corporation",
        "Tiffany & Co",
        "Timken Company",
        "TJX Companies Inc",
        "TMP Worldwide Inc",
        "Toll Brothers Inc",
        "Torchmark Corporation",
        "Toro Company",
        "Tower Automotive Inc.",
        "Toys 'R' Us Inc",
        "Trans World Entertainment Corp.",
        "TransMontaigne Inc",
        "Transocean Inc",
        "TravelCenters of America Inc.",
        "Triad Hospitals Inc",
        "Tribune Company",
        "Trigon Healthcare Inc.",
        "Trinity Industries Inc",
        "Trump Hotels & Casino Resorts Inc.",
        "TruServ Corporation",
        "TRW Inc",
        "TXU Corp",
        "Tyson Foods Inc",
        "U.S. Bancorp",
        "U.S. Industries Inc.",
        "UAL Corporation",
        "UGI Corporation",
        "Unified Western Grocers Inc",
        "Union Pacific Corporation",
        "Union Planters Corp",
        "Unisource Energy Corp",
        "Unisys Corporation",
        "United Auto Group Inc",
        "United Defense Industries Inc.",
        "United Parcel Service Inc",
        "United Rentals Inc",
        "United Stationers Inc",
        "United Technologies Corporation",
        "UnitedHealth Group Incorporated",
        "Unitrin Inc",
        "Universal Corporation",
        "Universal Forest Products Inc",
        "Universal Health Services Inc",
        "Unocal Corporation",
        "Unova Inc",
        "UnumProvident Corporation",
        "URS Corporation",
        "US Airways Group Inc",
        "US Oncology Inc",
        "USA Interactive",
        "USFreighways Corporation",
        "USG Corporation",
        "UST Inc",
        "Valero Energy Corporation",
        "Valspar Corporation",
        "Value City Department Stores Inc",
        "Varco International Inc",
        "Vectren Corporation",
        "Veritas Software Corporation",
        "Verizon Communications Inc",
        "VF Corporation",
        "Viacom Inc",
        "Viad Corp",
        "Viasystems Group Inc",
        "Vishay Intertechnology Inc",
        "Visteon Corporation",
        "Volt Information Sciences Inc",
        "Vulcan Materials Company",
        "W.R. Berkley Corporation",
        "W.R. Grace & Co",
        "W.W. Grainger Inc",
        "Wachovia Corporation",
        "Wakenhut Corporation",
        "Walgreen Co",
        "Wallace Computer Services Inc",
        "Wal-Mart Stores Inc",
        "Walt Disney Co",
        "Walter Industries Inc",
        "Washington Mutual Inc",
        "Washington Post Co.",
        "Waste Management Inc",
        "Watsco Inc",
        "Weatherford International Inc",
        "Weis Markets Inc.",
        "Wellpoint Health Networks Inc",
        "Wells Fargo & Company",
        "Wendy's International Inc",
        "Werner Enterprises Inc",
        "WESCO International Inc",
        "Western Digital Inc",
        "Western Gas Resources Inc",
        "WestPoint Stevens Inc",
        "Weyerhauser Company",
        "WGL Holdings Inc",
        "Whirlpool Corporation",
        "Whole Foods Market Inc",
        "Willamette Industries Inc.",
        "Williams Companies Inc",
        "Williams Sonoma Inc",
        "Winn Dixie Stores Inc",
        "Wisconsin Energy Corporation",
        "Wm Wrigley Jr Company",
        "World Fuel Services Corporation",
        "WorldCom Inc",
        "Worthington Industries Inc",
        "WPS Resources Corporation",
        "Wyeth",
        "Wyndham International Inc",
        "Xcel Energy Inc",
        "Xerox Corp",
        "Xilinx Inc",
        "XO Communications Inc",
        "Yellow Corporation",
        "York International Corp",
        "Yum Brands Inc.",
        "Zale Corporation",
        "Zions Bancorporation"
      ],

        fileExtension : {
            "raster"    : ["bmp", "gif", "gpl", "ico", "jpeg", "psd", "png", "psp", "raw", "tiff"],
            "vector"    : ["3dv", "amf", "awg", "ai", "cgm", "cdr", "cmx", "dxf", "e2d", "egt", "eps", "fs", "odg", "svg", "xar"],
            "3d"        : ["3dmf", "3dm", "3mf", "3ds", "an8", "aoi", "blend", "cal3d", "cob", "ctm", "iob", "jas", "max", "mb", "mdx", "obj", "x", "x3d"],
            "document"  : ["doc", "docx", "dot", "html", "xml", "odt", "odm", "ott", "csv", "rtf", "tex", "xhtml", "xps"]
        },

        // Data taken from https://github.com/dmfilipenko/timezones.json/blob/master/timezones.json
        timezones: [
                  {
                    "name": "Dateline Standard Time",
                    "abbr": "DST",
                    "offset": -12,
                    "isdst": false,
                    "text": "(UTC-12:00) International Date Line West",
                    "utc": [
                      "Etc/GMT+12"
                    ]
                  },
                  {
                    "name": "UTC-11",
                    "abbr": "U",
                    "offset": -11,
                    "isdst": false,
                    "text": "(UTC-11:00) Coordinated Universal Time-11",
                    "utc": [
                      "Etc/GMT+11",
                      "Pacific/Midway",
                      "Pacific/Niue",
                      "Pacific/Pago_Pago"
                    ]
                  },
                  {
                    "name": "Hawaiian Standard Time",
                    "abbr": "HST",
                    "offset": -10,
                    "isdst": false,
                    "text": "(UTC-10:00) Hawaii",
                    "utc": [
                      "Etc/GMT+10",
                      "Pacific/Honolulu",
                      "Pacific/Johnston",
                      "Pacific/Rarotonga",
                      "Pacific/Tahiti"
                    ]
                  },
                  {
                    "name": "Alaskan Standard Time",
                    "abbr": "AKDT",
                    "offset": -8,
                    "isdst": true,
                    "text": "(UTC-09:00) Alaska",
                    "utc": [
                      "America/Anchorage",
                      "America/Juneau",
                      "America/Nome",
                      "America/Sitka",
                      "America/Yakutat"
                    ]
                  },
                  {
                    "name": "Pacific Standard Time (Mexico)",
                    "abbr": "PDT",
                    "offset": -7,
                    "isdst": true,
                    "text": "(UTC-08:00) Baja California",
                    "utc": [
                      "America/Santa_Isabel"
                    ]
                  },
                  {
                    "name": "Pacific Standard Time",
                    "abbr": "PDT",
                    "offset": -7,
                    "isdst": true,
                    "text": "(UTC-08:00) Pacific Time (US & Canada)",
                    "utc": [
                      "America/Dawson",
                      "America/Los_Angeles",
                      "America/Tijuana",
                      "America/Vancouver",
                      "America/Whitehorse",
                      "PST8PDT"
                    ]
                  },
                  {
                    "name": "US Mountain Standard Time",
                    "abbr": "UMST",
                    "offset": -7,
                    "isdst": false,
                    "text": "(UTC-07:00) Arizona",
                    "utc": [
                      "America/Creston",
                      "America/Dawson_Creek",
                      "America/Hermosillo",
                      "America/Phoenix",
                      "Etc/GMT+7"
                    ]
                  },
                  {
                    "name": "Mountain Standard Time (Mexico)",
                    "abbr": "MDT",
                    "offset": -6,
                    "isdst": true,
                    "text": "(UTC-07:00) Chihuahua, La Paz, Mazatlan",
                    "utc": [
                      "America/Chihuahua",
                      "America/Mazatlan"
                    ]
                  },
                  {
                    "name": "Mountain Standard Time",
                    "abbr": "MDT",
                    "offset": -6,
                    "isdst": true,
                    "text": "(UTC-07:00) Mountain Time (US & Canada)",
                    "utc": [
                      "America/Boise",
                      "America/Cambridge_Bay",
                      "America/Denver",
                      "America/Edmonton",
                      "America/Inuvik",
                      "America/Ojinaga",
                      "America/Yellowknife",
                      "MST7MDT"
                    ]
                  },
                  {
                    "name": "Central America Standard Time",
                    "abbr": "CAST",
                    "offset": -6,
                    "isdst": false,
                    "text": "(UTC-06:00) Central America",
                    "utc": [
                      "America/Belize",
                      "America/Costa_Rica",
                      "America/El_Salvador",
                      "America/Guatemala",
                      "America/Managua",
                      "America/Tegucigalpa",
                      "Etc/GMT+6",
                      "Pacific/Galapagos"
                    ]
                  },
                  {
                    "name": "Central Standard Time",
                    "abbr": "CDT",
                    "offset": -5,
                    "isdst": true,
                    "text": "(UTC-06:00) Central Time (US & Canada)",
                    "utc": [
                      "America/Chicago",
                      "America/Indiana/Knox",
                      "America/Indiana/Tell_City",
                      "America/Matamoros",
                      "America/Menominee",
                      "America/North_Dakota/Beulah",
                      "America/North_Dakota/Center",
                      "America/North_Dakota/New_Salem",
                      "America/Rainy_River",
                      "America/Rankin_Inlet",
                      "America/Resolute",
                      "America/Winnipeg",
                      "CST6CDT"
                    ]
                  },
                  {
                    "name": "Central Standard Time (Mexico)",
                    "abbr": "CDT",
                    "offset": -5,
                    "isdst": true,
                    "text": "(UTC-06:00) Guadalajara, Mexico City, Monterrey",
                    "utc": [
                      "America/Bahia_Banderas",
                      "America/Cancun",
                      "America/Merida",
                      "America/Mexico_City",
                      "America/Monterrey"
                    ]
                  },
                  {
                    "name": "Canada Central Standard Time",
                    "abbr": "CCST",
                    "offset": -6,
                    "isdst": false,
                    "text": "(UTC-06:00) Saskatchewan",
                    "utc": [
                      "America/Regina",
                      "America/Swift_Current"
                    ]
                  },
                  {
                    "name": "SA Pacific Standard Time",
                    "abbr": "SPST",
                    "offset": -5,
                    "isdst": false,
                    "text": "(UTC-05:00) Bogota, Lima, Quito",
                    "utc": [
                      "America/Bogota",
                      "America/Cayman",
                      "America/Coral_Harbour",
                      "America/Eirunepe",
                      "America/Guayaquil",
                      "America/Jamaica",
                      "America/Lima",
                      "America/Panama",
                      "America/Rio_Branco",
                      "Etc/GMT+5"
                    ]
                  },
                  {
                    "name": "Eastern Standard Time",
                    "abbr": "EDT",
                    "offset": -4,
                    "isdst": true,
                    "text": "(UTC-05:00) Eastern Time (US & Canada)",
                    "utc": [
                      "America/Detroit",
                      "America/Havana",
                      "America/Indiana/Petersburg",
                      "America/Indiana/Vincennes",
                      "America/Indiana/Winamac",
                      "America/Iqaluit",
                      "America/Kentucky/Monticello",
                      "America/Louisville",
                      "America/Montreal",
                      "America/Nassau",
                      "America/New_York",
                      "America/Nipigon",
                      "America/Pangnirtung",
                      "America/Port-au-Prince",
                      "America/Thunder_Bay",
                      "America/Toronto",
                      "EST5EDT"
                    ]
                  },
                  {
                    "name": "US Eastern Standard Time",
                    "abbr": "UEDT",
                    "offset": -4,
                    "isdst": true,
                    "text": "(UTC-05:00) Indiana (East)",
                    "utc": [
                      "America/Indiana/Marengo",
                      "America/Indiana/Vevay",
                      "America/Indianapolis"
                    ]
                  },
                  {
                    "name": "Venezuela Standard Time",
                    "abbr": "VST",
                    "offset": -4.5,
                    "isdst": false,
                    "text": "(UTC-04:30) Caracas",
                    "utc": [
                      "America/Caracas"
                    ]
                  },
                  {
                    "name": "Paraguay Standard Time",
                    "abbr": "PST",
                    "offset": -4,
                    "isdst": false,
                    "text": "(UTC-04:00) Asuncion",
                    "utc": [
                      "America/Asuncion"
                    ]
                  },
                  {
                    "name": "Atlantic Standard Time",
                    "abbr": "ADT",
                    "offset": -3,
                    "isdst": true,
                    "text": "(UTC-04:00) Atlantic Time (Canada)",
                    "utc": [
                      "America/Glace_Bay",
                      "America/Goose_Bay",
                      "America/Halifax",
                      "America/Moncton",
                      "America/Thule",
                      "Atlantic/Bermuda"
                    ]
                  },
                  {
                    "name": "Central Brazilian Standard Time",
                    "abbr": "CBST",
                    "offset": -4,
                    "isdst": false,
                    "text": "(UTC-04:00) Cuiaba",
                    "utc": [
                      "America/Campo_Grande",
                      "America/Cuiaba"
                    ]
                  },
                  {
                    "name": "SA Western Standard Time",
                    "abbr": "SWST",
                    "offset": -4,
                    "isdst": false,
                    "text": "(UTC-04:00) Georgetown, La Paz, Manaus, San Juan",
                    "utc": [
                      "America/Anguilla",
                      "America/Antigua",
                      "America/Aruba",
                      "America/Barbados",
                      "America/Blanc-Sablon",
                      "America/Boa_Vista",
                      "America/Curacao",
                      "America/Dominica",
                      "America/Grand_Turk",
                      "America/Grenada",
                      "America/Guadeloupe",
                      "America/Guyana",
                      "America/Kralendijk",
                      "America/La_Paz",
                      "America/Lower_Princes",
                      "America/Manaus",
                      "America/Marigot",
                      "America/Martinique",
                      "America/Montserrat",
                      "America/Port_of_Spain",
                      "America/Porto_Velho",
                      "America/Puerto_Rico",
                      "America/Santo_Domingo",
                      "America/St_Barthelemy",
                      "America/St_Kitts",
                      "America/St_Lucia",
                      "America/St_Thomas",
                      "America/St_Vincent",
                      "America/Tortola",
                      "Etc/GMT+4"
                    ]
                  },
                  {
                    "name": "Pacific SA Standard Time",
                    "abbr": "PSST",
                    "offset": -4,
                    "isdst": false,
                    "text": "(UTC-04:00) Santiago",
                    "utc": [
                      "America/Santiago",
                      "Antarctica/Palmer"
                    ]
                  },
                  {
                    "name": "Newfoundland Standard Time",
                    "abbr": "NDT",
                    "offset": -2.5,
                    "isdst": true,
                    "text": "(UTC-03:30) Newfoundland",
                    "utc": [
                      "America/St_Johns"
                    ]
                  },
                  {
                    "name": "E. South America Standard Time",
                    "abbr": "ESAST",
                    "offset": -3,
                    "isdst": false,
                    "text": "(UTC-03:00) Brasilia",
                    "utc": [
                      "America/Sao_Paulo"
                    ]
                  },
                  {
                    "name": "Argentina Standard Time",
                    "abbr": "AST",
                    "offset": -3,
                    "isdst": false,
                    "text": "(UTC-03:00) Buenos Aires",
                    "utc": [
                      "America/Argentina/La_Rioja",
                      "America/Argentina/Rio_Gallegos",
                      "America/Argentina/Salta",
                      "America/Argentina/San_Juan",
                      "America/Argentina/San_Luis",
                      "America/Argentina/Tucuman",
                      "America/Argentina/Ushuaia",
                      "America/Buenos_Aires",
                      "America/Catamarca",
                      "America/Cordoba",
                      "America/Jujuy",
                      "America/Mendoza"
                    ]
                  },
                  {
                    "name": "SA Eastern Standard Time",
                    "abbr": "SEST",
                    "offset": -3,
                    "isdst": false,
                    "text": "(UTC-03:00) Cayenne, Fortaleza",
                    "utc": [
                      "America/Araguaina",
                      "America/Belem",
                      "America/Cayenne",
                      "America/Fortaleza",
                      "America/Maceio",
                      "America/Paramaribo",
                      "America/Recife",
                      "America/Santarem",
                      "Antarctica/Rothera",
                      "Atlantic/Stanley",
                      "Etc/GMT+3"
                    ]
                  },
                  {
                    "name": "Greenland Standard Time",
                    "abbr": "GDT",
                    "offset": -2,
                    "isdst": true,
                    "text": "(UTC-03:00) Greenland",
                    "utc": [
                      "America/Godthab"
                    ]
                  },
                  {
                    "name": "Montevideo Standard Time",
                    "abbr": "MST",
                    "offset": -3,
                    "isdst": false,
                    "text": "(UTC-03:00) Montevideo",
                    "utc": [
                      "America/Montevideo"
                    ]
                  },
                  {
                    "name": "Bahia Standard Time",
                    "abbr": "BST",
                    "offset": -3,
                    "isdst": false,
                    "text": "(UTC-03:00) Salvador",
                    "utc": [
                      "America/Bahia"
                    ]
                  },
                  {
                    "name": "UTC-02",
                    "abbr": "U",
                    "offset": -2,
                    "isdst": false,
                    "text": "(UTC-02:00) Coordinated Universal Time-02",
                    "utc": [
                      "America/Noronha",
                      "Atlantic/South_Georgia",
                      "Etc/GMT+2"
                    ]
                  },
                  {
                    "name": "Mid-Atlantic Standard Time",
                    "abbr": "MDT",
                    "offset": -1,
                    "isdst": true,
                    "text": "(UTC-02:00) Mid-Atlantic - Old"
                  },
                  {
                    "name": "Azores Standard Time",
                    "abbr": "ADT",
                    "offset": 0,
                    "isdst": true,
                    "text": "(UTC-01:00) Azores",
                    "utc": [
                      "America/Scoresbysund",
                      "Atlantic/Azores"
                    ]
                  },
                  {
                    "name": "Cape Verde Standard Time",
                    "abbr": "CVST",
                    "offset": -1,
                    "isdst": false,
                    "text": "(UTC-01:00) Cape Verde Is.",
                    "utc": [
                      "Atlantic/Cape_Verde",
                      "Etc/GMT+1"
                    ]
                  },
                  {
                    "name": "Morocco Standard Time",
                    "abbr": "MDT",
                    "offset": 1,
                    "isdst": true,
                    "text": "(UTC) Casablanca",
                    "utc": [
                      "Africa/Casablanca",
                      "Africa/El_Aaiun"
                    ]
                  },
                  {
                    "name": "UTC",
                    "abbr": "CUT",
                    "offset": 0,
                    "isdst": false,
                    "text": "(UTC) Coordinated Universal Time",
                    "utc": [
                      "America/Danmarkshavn",
                      "Etc/GMT"
                    ]
                  },
                  {
                    "name": "GMT Standard Time",
                    "abbr": "GDT",
                    "offset": 1,
                    "isdst": true,
                    "text": "(UTC) Dublin, Edinburgh, Lisbon, London",
                    "utc": [
                      "Atlantic/Canary",
                      "Atlantic/Faeroe",
                      "Atlantic/Madeira",
                      "Europe/Dublin",
                      "Europe/Guernsey",
                      "Europe/Isle_of_Man",
                      "Europe/Jersey",
                      "Europe/Lisbon",
                      "Europe/London"
                    ]
                  },
                  {
                    "name": "Greenwich Standard Time",
                    "abbr": "GST",
                    "offset": 0,
                    "isdst": false,
                    "text": "(UTC) Monrovia, Reykjavik",
                    "utc": [
                      "Africa/Abidjan",
                      "Africa/Accra",
                      "Africa/Bamako",
                      "Africa/Banjul",
                      "Africa/Bissau",
                      "Africa/Conakry",
                      "Africa/Dakar",
                      "Africa/Freetown",
                      "Africa/Lome",
                      "Africa/Monrovia",
                      "Africa/Nouakchott",
                      "Africa/Ouagadougou",
                      "Africa/Sao_Tome",
                      "Atlantic/Reykjavik",
                      "Atlantic/St_Helena"
                    ]
                  },
                  {
                    "name": "W. Europe Standard Time",
                    "abbr": "WEDT",
                    "offset": 2,
                    "isdst": true,
                    "text": "(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna",
                    "utc": [
                      "Arctic/Longyearbyen",
                      "Europe/Amsterdam",
                      "Europe/Andorra",
                      "Europe/Berlin",
                      "Europe/Busingen",
                      "Europe/Gibraltar",
                      "Europe/Luxembourg",
                      "Europe/Malta",
                      "Europe/Monaco",
                      "Europe/Oslo",
                      "Europe/Rome",
                      "Europe/San_Marino",
                      "Europe/Stockholm",
                      "Europe/Vaduz",
                      "Europe/Vatican",
                      "Europe/Vienna",
                      "Europe/Zurich"
                    ]
                  },
                  {
                    "name": "Central Europe Standard Time",
                    "abbr": "CEDT",
                    "offset": 2,
                    "isdst": true,
                    "text": "(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague",
                    "utc": [
                      "Europe/Belgrade",
                      "Europe/Bratislava",
                      "Europe/Budapest",
                      "Europe/Ljubljana",
                      "Europe/Podgorica",
                      "Europe/Prague",
                      "Europe/Tirane"
                    ]
                  },
                  {
                    "name": "Romance Standard Time",
                    "abbr": "RDT",
                    "offset": 2,
                    "isdst": true,
                    "text": "(UTC+01:00) Brussels, Copenhagen, Madrid, Paris",
                    "utc": [
                      "Africa/Ceuta",
                      "Europe/Brussels",
                      "Europe/Copenhagen",
                      "Europe/Madrid",
                      "Europe/Paris"
                    ]
                  },
                  {
                    "name": "Central European Standard Time",
                    "abbr": "CEDT",
                    "offset": 2,
                    "isdst": true,
                    "text": "(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb",
                    "utc": [
                      "Europe/Sarajevo",
                      "Europe/Skopje",
                      "Europe/Warsaw",
                      "Europe/Zagreb"
                    ]
                  },
                  {
                    "name": "W. Central Africa Standard Time",
                    "abbr": "WCAST",
                    "offset": 1,
                    "isdst": false,
                    "text": "(UTC+01:00) West Central Africa",
                    "utc": [
                      "Africa/Algiers",
                      "Africa/Bangui",
                      "Africa/Brazzaville",
                      "Africa/Douala",
                      "Africa/Kinshasa",
                      "Africa/Lagos",
                      "Africa/Libreville",
                      "Africa/Luanda",
                      "Africa/Malabo",
                      "Africa/Ndjamena",
                      "Africa/Niamey",
                      "Africa/Porto-Novo",
                      "Africa/Tunis",
                      "Etc/GMT-1"
                    ]
                  },
                  {
                    "name": "Namibia Standard Time",
                    "abbr": "NST",
                    "offset": 1,
                    "isdst": false,
                    "text": "(UTC+01:00) Windhoek",
                    "utc": [
                      "Africa/Windhoek"
                    ]
                  },
                  {
                    "name": "GTB Standard Time",
                    "abbr": "GDT",
                    "offset": 3,
                    "isdst": true,
                    "text": "(UTC+02:00) Athens, Bucharest",
                    "utc": [
                      "Asia/Nicosia",
                      "Europe/Athens",
                      "Europe/Bucharest",
                      "Europe/Chisinau"
                    ]
                  },
                  {
                    "name": "Middle East Standard Time",
                    "abbr": "MEDT",
                    "offset": 3,
                    "isdst": true,
                    "text": "(UTC+02:00) Beirut",
                    "utc": [
                      "Asia/Beirut"
                    ]
                  },
                  {
                    "name": "Egypt Standard Time",
                    "abbr": "EST",
                    "offset": 2,
                    "isdst": false,
                    "text": "(UTC+02:00) Cairo",
                    "utc": [
                      "Africa/Cairo"
                    ]
                  },
                  {
                    "name": "Syria Standard Time",
                    "abbr": "SDT",
                    "offset": 3,
                    "isdst": true,
                    "text": "(UTC+02:00) Damascus",
                    "utc": [
                      "Asia/Damascus"
                    ]
                  },
                  {
                    "name": "E. Europe Standard Time",
                    "abbr": "EEDT",
                    "offset": 3,
                    "isdst": true,
                    "text": "(UTC+02:00) E. Europe"
                  },
                  {
                    "name": "South Africa Standard Time",
                    "abbr": "SAST",
                    "offset": 2,
                    "isdst": false,
                    "text": "(UTC+02:00) Harare, Pretoria",
                    "utc": [
                      "Africa/Blantyre",
                      "Africa/Bujumbura",
                      "Africa/Gaborone",
                      "Africa/Harare",
                      "Africa/Johannesburg",
                      "Africa/Kigali",
                      "Africa/Lubumbashi",
                      "Africa/Lusaka",
                      "Africa/Maputo",
                      "Africa/Maseru",
                      "Africa/Mbabane",
                      "Etc/GMT-2"
                    ]
                  },
                  {
                    "name": "FLE Standard Time",
                    "abbr": "FDT",
                    "offset": 3,
                    "isdst": true,
                    "text": "(UTC+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius",
                    "utc": [
                      "Europe/Helsinki",
                      "Europe/Kiev",
                      "Europe/Mariehamn",
                      "Europe/Riga",
                      "Europe/Sofia",
                      "Europe/Tallinn",
                      "Europe/Uzhgorod",
                      "Europe/Vilnius",
                      "Europe/Zaporozhye"
                    ]
                  },
                  {
                    "name": "Turkey Standard Time",
                    "abbr": "TDT",
                    "offset": 3,
                    "isdst": true,
                    "text": "(UTC+02:00) Istanbul",
                    "utc": [
                      "Europe/Istanbul"
                    ]
                  },
                  {
                    "name": "Israel Standard Time",
                    "abbr": "JDT",
                    "offset": 3,
                    "isdst": true,
                    "text": "(UTC+02:00) Jerusalem",
                    "utc": [
                      "Asia/Jerusalem"
                    ]
                  },
                  {
                    "name": "Libya Standard Time",
                    "abbr": "LST",
                    "offset": 2,
                    "isdst": false,
                    "text": "(UTC+02:00) Tripoli",
                    "utc": [
                      "Africa/Tripoli"
                    ]
                  },
                  {
                    "name": "Jordan Standard Time",
                    "abbr": "JST",
                    "offset": 3,
                    "isdst": false,
                    "text": "(UTC+03:00) Amman",
                    "utc": [
                      "Asia/Amman"
                    ]
                  },
                  {
                    "name": "Arabic Standard Time",
                    "abbr": "AST",
                    "offset": 3,
                    "isdst": false,
                    "text": "(UTC+03:00) Baghdad",
                    "utc": [
                      "Asia/Baghdad"
                    ]
                  },
                  {
                    "name": "Kaliningrad Standard Time",
                    "abbr": "KST",
                    "offset": 3,
                    "isdst": false,
                    "text": "(UTC+03:00) Kaliningrad, Minsk",
                    "utc": [
                      "Europe/Kaliningrad",
                      "Europe/Minsk"
                    ]
                  },
                  {
                    "name": "Arab Standard Time",
                    "abbr": "AST",
                    "offset": 3,
                    "isdst": false,
                    "text": "(UTC+03:00) Kuwait, Riyadh",
                    "utc": [
                      "Asia/Aden",
                      "Asia/Bahrain",
                      "Asia/Kuwait",
                      "Asia/Qatar",
                      "Asia/Riyadh"
                    ]
                  },
                  {
                    "name": "E. Africa Standard Time",
                    "abbr": "EAST",
                    "offset": 3,
                    "isdst": false,
                    "text": "(UTC+03:00) Nairobi",
                    "utc": [
                      "Africa/Addis_Ababa",
                      "Africa/Asmera",
                      "Africa/Dar_es_Salaam",
                      "Africa/Djibouti",
                      "Africa/Juba",
                      "Africa/Kampala",
                      "Africa/Khartoum",
                      "Africa/Mogadishu",
                      "Africa/Nairobi",
                      "Antarctica/Syowa",
                      "Etc/GMT-3",
                      "Indian/Antananarivo",
                      "Indian/Comoro",
                      "Indian/Mayotte"
                    ]
                  },
                  {
                    "name": "Iran Standard Time",
                    "abbr": "IDT",
                    "offset": 4.5,
                    "isdst": true,
                    "text": "(UTC+03:30) Tehran",
                    "utc": [
                      "Asia/Tehran"
                    ]
                  },
                  {
                    "name": "Arabian Standard Time",
                    "abbr": "AST",
                    "offset": 4,
                    "isdst": false,
                    "text": "(UTC+04:00) Abu Dhabi, Muscat",
                    "utc": [
                      "Asia/Dubai",
                      "Asia/Muscat",
                      "Etc/GMT-4"
                    ]
                  },
                  {
                    "name": "Azerbaijan Standard Time",
                    "abbr": "ADT",
                    "offset": 5,
                    "isdst": true,
                    "text": "(UTC+04:00) Baku",
                    "utc": [
                      "Asia/Baku"
                    ]
                  },
                  {
                    "name": "Russian Standard Time",
                    "abbr": "RST",
                    "offset": 4,
                    "isdst": false,
                    "text": "(UTC+04:00) Moscow, St. Petersburg, Volgograd",
                    "utc": [
                      "Europe/Moscow",
                      "Europe/Samara",
                      "Europe/Simferopol",
                      "Europe/Volgograd"
                    ]
                  },
                  {
                    "name": "Mauritius Standard Time",
                    "abbr": "MST",
                    "offset": 4,
                    "isdst": false,
                    "text": "(UTC+04:00) Port Louis",
                    "utc": [
                      "Indian/Mahe",
                      "Indian/Mauritius",
                      "Indian/Reunion"
                    ]
                  },
                  {
                    "name": "Georgian Standard Time",
                    "abbr": "GST",
                    "offset": 4,
                    "isdst": false,
                    "text": "(UTC+04:00) Tbilisi",
                    "utc": [
                      "Asia/Tbilisi"
                    ]
                  },
                  {
                    "name": "Caucasus Standard Time",
                    "abbr": "CST",
                    "offset": 4,
                    "isdst": false,
                    "text": "(UTC+04:00) Yerevan",
                    "utc": [
                      "Asia/Yerevan"
                    ]
                  },
                  {
                    "name": "Afghanistan Standard Time",
                    "abbr": "AST",
                    "offset": 4.5,
                    "isdst": false,
                    "text": "(UTC+04:30) Kabul",
                    "utc": [
                      "Asia/Kabul"
                    ]
                  },
                  {
                    "name": "West Asia Standard Time",
                    "abbr": "WAST",
                    "offset": 5,
                    "isdst": false,
                    "text": "(UTC+05:00) Ashgabat, Tashkent",
                    "utc": [
                      "Antarctica/Mawson",
                      "Asia/Aqtau",
                      "Asia/Aqtobe",
                      "Asia/Ashgabat",
                      "Asia/Dushanbe",
                      "Asia/Oral",
                      "Asia/Samarkand",
                      "Asia/Tashkent",
                      "Etc/GMT-5",
                      "Indian/Kerguelen",
                      "Indian/Maldives"
                    ]
                  },
                  {
                    "name": "Pakistan Standard Time",
                    "abbr": "PST",
                    "offset": 5,
                    "isdst": false,
                    "text": "(UTC+05:00) Islamabad, Karachi",
                    "utc": [
                      "Asia/Karachi"
                    ]
                  },
                  {
                    "name": "India Standard Time",
                    "abbr": "IST",
                    "offset": 5.5,
                    "isdst": false,
                    "text": "(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi",
                    "utc": [
                      "Asia/Calcutta"
                    ]
                  },
                  {
                    "name": "Sri Lanka Standard Time",
                    "abbr": "SLST",
                    "offset": 5.5,
                    "isdst": false,
                    "text": "(UTC+05:30) Sri Jayawardenepura",
                    "utc": [
                      "Asia/Colombo"
                    ]
                  },
                  {
                    "name": "Nepal Standard Time",
                    "abbr": "NST",
                    "offset": 5.75,
                    "isdst": false,
                    "text": "(UTC+05:45) Kathmandu",
                    "utc": [
                      "Asia/Katmandu"
                    ]
                  },
                  {
                    "name": "Central Asia Standard Time",
                    "abbr": "CAST",
                    "offset": 6,
                    "isdst": false,
                    "text": "(UTC+06:00) Astana",
                    "utc": [
                      "Antarctica/Vostok",
                      "Asia/Almaty",
                      "Asia/Bishkek",
                      "Asia/Qyzylorda",
                      "Asia/Urumqi",
                      "Etc/GMT-6",
                      "Indian/Chagos"
                    ]
                  },
                  {
                    "name": "Bangladesh Standard Time",
                    "abbr": "BST",
                    "offset": 6,
                    "isdst": false,
                    "text": "(UTC+06:00) Dhaka",
                    "utc": [
                      "Asia/Dhaka",
                      "Asia/Thimphu"
                    ]
                  },
                  {
                    "name": "Ekaterinburg Standard Time",
                    "abbr": "EST",
                    "offset": 6,
                    "isdst": false,
                    "text": "(UTC+06:00) Ekaterinburg",
                    "utc": [
                      "Asia/Yekaterinburg"
                    ]
                  },
                  {
                    "name": "Myanmar Standard Time",
                    "abbr": "MST",
                    "offset": 6.5,
                    "isdst": false,
                    "text": "(UTC+06:30) Yangon (Rangoon)",
                    "utc": [
                      "Asia/Rangoon",
                      "Indian/Cocos"
                    ]
                  },
                  {
                    "name": "SE Asia Standard Time",
                    "abbr": "SAST",
                    "offset": 7,
                    "isdst": false,
                    "text": "(UTC+07:00) Bangkok, Hanoi, Jakarta",
                    "utc": [
                      "Antarctica/Davis",
                      "Asia/Bangkok",
                      "Asia/Hovd",
                      "Asia/Jakarta",
                      "Asia/Phnom_Penh",
                      "Asia/Pontianak",
                      "Asia/Saigon",
                      "Asia/Vientiane",
                      "Etc/GMT-7",
                      "Indian/Christmas"
                    ]
                  },
                  {
                    "name": "N. Central Asia Standard Time",
                    "abbr": "NCAST",
                    "offset": 7,
                    "isdst": false,
                    "text": "(UTC+07:00) Novosibirsk",
                    "utc": [
                      "Asia/Novokuznetsk",
                      "Asia/Novosibirsk",
                      "Asia/Omsk"
                    ]
                  },
                  {
                    "name": "China Standard Time",
                    "abbr": "CST",
                    "offset": 8,
                    "isdst": false,
                    "text": "(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi",
                    "utc": [
                      "Asia/Hong_Kong",
                      "Asia/Macau",
                      "Asia/Shanghai"
                    ]
                  },
                  {
                    "name": "North Asia Standard Time",
                    "abbr": "NAST",
                    "offset": 8,
                    "isdst": false,
                    "text": "(UTC+08:00) Krasnoyarsk",
                    "utc": [
                      "Asia/Krasnoyarsk"
                    ]
                  },
                  {
                    "name": "Singapore Standard Time",
                    "abbr": "MPST",
                    "offset": 8,
                    "isdst": false,
                    "text": "(UTC+08:00) Kuala Lumpur, Singapore",
                    "utc": [
                      "Asia/Brunei",
                      "Asia/Kuala_Lumpur",
                      "Asia/Kuching",
                      "Asia/Makassar",
                      "Asia/Manila",
                      "Asia/Singapore",
                      "Etc/GMT-8"
                    ]
                  },
                  {
                    "name": "W. Australia Standard Time",
                    "abbr": "WAST",
                    "offset": 8,
                    "isdst": false,
                    "text": "(UTC+08:00) Perth",
                    "utc": [
                      "Antarctica/Casey",
                      "Australia/Perth"
                    ]
                  },
                  {
                    "name": "Taipei Standard Time",
                    "abbr": "TST",
                    "offset": 8,
                    "isdst": false,
                    "text": "(UTC+08:00) Taipei",
                    "utc": [
                      "Asia/Taipei"
                    ]
                  },
                  {
                    "name": "Ulaanbaatar Standard Time",
                    "abbr": "UST",
                    "offset": 8,
                    "isdst": false,
                    "text": "(UTC+08:00) Ulaanbaatar",
                    "utc": [
                      "Asia/Choibalsan",
                      "Asia/Ulaanbaatar"
                    ]
                  },
                  {
                    "name": "North Asia East Standard Time",
                    "abbr": "NAEST",
                    "offset": 9,
                    "isdst": false,
                    "text": "(UTC+09:00) Irkutsk",
                    "utc": [
                      "Asia/Irkutsk"
                    ]
                  },
                  {
                    "name": "Tokyo Standard Time",
                    "abbr": "TST",
                    "offset": 9,
                    "isdst": false,
                    "text": "(UTC+09:00) Osaka, Sapporo, Tokyo",
                    "utc": [
                      "Asia/Dili",
                      "Asia/Jayapura",
                      "Asia/Tokyo",
                      "Etc/GMT-9",
                      "Pacific/Palau"
                    ]
                  },
                  {
                    "name": "Korea Standard Time",
                    "abbr": "KST",
                    "offset": 9,
                    "isdst": false,
                    "text": "(UTC+09:00) Seoul",
                    "utc": [
                      "Asia/Pyongyang",
                      "Asia/Seoul"
                    ]
                  },
                  {
                    "name": "Cen. Australia Standard Time",
                    "abbr": "CAST",
                    "offset": 9.5,
                    "isdst": false,
                    "text": "(UTC+09:30) Adelaide",
                    "utc": [
                      "Australia/Adelaide",
                      "Australia/Broken_Hill"
                    ]
                  },
                  {
                    "name": "AUS Central Standard Time",
                    "abbr": "ACST",
                    "offset": 9.5,
                    "isdst": false,
                    "text": "(UTC+09:30) Darwin",
                    "utc": [
                      "Australia/Darwin"
                    ]
                  },
                  {
                    "name": "E. Australia Standard Time",
                    "abbr": "EAST",
                    "offset": 10,
                    "isdst": false,
                    "text": "(UTC+10:00) Brisbane",
                    "utc": [
                      "Australia/Brisbane",
                      "Australia/Lindeman"
                    ]
                  },
                  {
                    "name": "AUS Eastern Standard Time",
                    "abbr": "AEST",
                    "offset": 10,
                    "isdst": false,
                    "text": "(UTC+10:00) Canberra, Melbourne, Sydney",
                    "utc": [
                      "Australia/Melbourne",
                      "Australia/Sydney"
                    ]
                  },
                  {
                    "name": "West Pacific Standard Time",
                    "abbr": "WPST",
                    "offset": 10,
                    "isdst": false,
                    "text": "(UTC+10:00) Guam, Port Moresby",
                    "utc": [
                      "Antarctica/DumontDUrville",
                      "Etc/GMT-10",
                      "Pacific/Guam",
                      "Pacific/Port_Moresby",
                      "Pacific/Saipan",
                      "Pacific/Truk"
                    ]
                  },
                  {
                    "name": "Tasmania Standard Time",
                    "abbr": "TST",
                    "offset": 10,
                    "isdst": false,
                    "text": "(UTC+10:00) Hobart",
                    "utc": [
                      "Australia/Currie",
                      "Australia/Hobart"
                    ]
                  },
                  {
                    "name": "Yakutsk Standard Time",
                    "abbr": "YST",
                    "offset": 10,
                    "isdst": false,
                    "text": "(UTC+10:00) Yakutsk",
                    "utc": [
                      "Asia/Chita",
                      "Asia/Khandyga",
                      "Asia/Yakutsk"
                    ]
                  },
                  {
                    "name": "Central Pacific Standard Time",
                    "abbr": "CPST",
                    "offset": 11,
                    "isdst": false,
                    "text": "(UTC+11:00) Solomon Is., New Caledonia",
                    "utc": [
                      "Antarctica/Macquarie",
                      "Etc/GMT-11",
                      "Pacific/Efate",
                      "Pacific/Guadalcanal",
                      "Pacific/Kosrae",
                      "Pacific/Noumea",
                      "Pacific/Ponape"
                    ]
                  },
                  {
                    "name": "Vladivostok Standard Time",
                    "abbr": "VST",
                    "offset": 11,
                    "isdst": false,
                    "text": "(UTC+11:00) Vladivostok",
                    "utc": [
                      "Asia/Sakhalin",
                      "Asia/Ust-Nera",
                      "Asia/Vladivostok"
                    ]
                  },
                  {
                    "name": "New Zealand Standard Time",
                    "abbr": "NZST",
                    "offset": 12,
                    "isdst": false,
                    "text": "(UTC+12:00) Auckland, Wellington",
                    "utc": [
                      "Antarctica/McMurdo",
                      "Pacific/Auckland"
                    ]
                  },
                  {
                    "name": "UTC+12",
                    "abbr": "U",
                    "offset": 12,
                    "isdst": false,
                    "text": "(UTC+12:00) Coordinated Universal Time+12",
                    "utc": [
                      "Etc/GMT-12",
                      "Pacific/Funafuti",
                      "Pacific/Kwajalein",
                      "Pacific/Majuro",
                      "Pacific/Nauru",
                      "Pacific/Tarawa",
                      "Pacific/Wake",
                      "Pacific/Wallis"
                    ]
                  },
                  {
                    "name": "Fiji Standard Time",
                    "abbr": "FST",
                    "offset": 12,
                    "isdst": false,
                    "text": "(UTC+12:00) Fiji",
                    "utc": [
                      "Pacific/Fiji"
                    ]
                  },
                  {
                    "name": "Magadan Standard Time",
                    "abbr": "MST",
                    "offset": 12,
                    "isdst": false,
                    "text": "(UTC+12:00) Magadan",
                    "utc": [
                      "Asia/Anadyr",
                      "Asia/Kamchatka",
                      "Asia/Magadan",
                      "Asia/Srednekolymsk"
                    ]
                  },
                  {
                    "name": "Kamchatka Standard Time",
                    "abbr": "KDT",
                    "offset": 13,
                    "isdst": true,
                    "text": "(UTC+12:00) Petropavlovsk-Kamchatsky - Old"
                  },
                  {
                    "name": "Tonga Standard Time",
                    "abbr": "TST",
                    "offset": 13,
                    "isdst": false,
                    "text": "(UTC+13:00) Nuku'alofa",
                    "utc": [
                      "Etc/GMT-13",
                      "Pacific/Enderbury",
                      "Pacific/Fakaofo",
                      "Pacific/Tongatapu"
                    ]
                  },
                  {
                    "name": "Samoa Standard Time",
                    "abbr": "SST",
                    "offset": 13,
                    "isdst": false,
                    "text": "(UTC+13:00) Samoa",
                    "utc": [
                      "Pacific/Apia"
                    ]
                  }
                ],
        //List source: http://answers.google.com/answers/threadview/id/589312.html
        profession: [
            "Airline Pilot",
            "Academic Team",
            "Accountant",
            "Account Executive",
            "Actor",
            "Actuary",
            "Acquisition Analyst",
            "Administrative Asst.",
            "Administrative Analyst",
            "Administrator",
            "Advertising Director",
            "Aerospace Engineer",
            "Agent",
            "Agricultural Inspector",
            "Agricultural Scientist",
            "Air Traffic Controller",
            "Animal Trainer",
            "Anthropologist",
            "Appraiser",
            "Architect",
            "Art Director",
            "Artist",
            "Astronomer",
            "Athletic Coach",
            "Auditor",
            "Author",
            "Baker",
            "Banker",
            "Bankruptcy Attorney",
            "Benefits Manager",
            "Biologist",
            "Bio-feedback Specialist",
            "Biomedical Engineer",
            "Biotechnical Researcher",
            "Broadcaster",
            "Broker",
            "Building Manager",
            "Building Contractor",
            "Building Inspector",
            "Business Analyst",
            "Business Planner",
            "Business Manager",
            "Buyer",
            "Call Center Manager",
            "Career Counselor",
            "Cash Manager",
            "Ceramic Engineer",
            "Chief Executive Officer",
            "Chief Operation Officer",
            "Chef",
            "Chemical Engineer",
            "Chemist",
            "Child Care Manager",
            "Chief Medical Officer",
            "Chiropractor",
            "Cinematographer",
            "City Housing Manager",
            "City Manager",
            "Civil Engineer",
            "Claims Manager",
            "Clinical Research Assistant",
            "Collections Manager.",
            "Compliance Manager",
            "Comptroller",
            "Computer Manager",
            "Commercial Artist",
            "Communications Affairs Director",
            "Communications Director",
            "Communications Engineer",
            "Compensation Analyst",
            "Computer Programmer",
            "Computer Ops. Manager",
            "Computer Engineer",
            "Computer Operator",
            "Computer Graphics Specialist",
            "Construction Engineer",
            "Construction Manager",
            "Consultant",
            "Consumer Relations Manager",
            "Contract Administrator",
            "Copyright Attorney",
            "Copywriter",
            "Corporate Planner",
            "Corrections Officer",
            "Cosmetologist",
            "Credit Analyst",
            "Cruise Director",
            "Chief Information Officer",
            "Chief Technology Officer",
            "Customer Service Manager",
            "Cryptologist",
            "Dancer",
            "Data Security Manager",
            "Database Manager",
            "Day Care Instructor",
            "Dentist",
            "Designer",
            "Design Engineer",
            "Desktop Publisher",
            "Developer",
            "Development Officer",
            "Diamond Merchant",
            "Dietitian",
            "Direct Marketer",
            "Director",
            "Distribution Manager",
            "Diversity Manager",
            "Economist",
            "EEO Compliance Manager",
            "Editor",
            "Education Adminator",
            "Electrical Engineer",
            "Electro Optical Engineer",
            "Electronics Engineer",
            "Embassy Management",
            "Employment Agent",
            "Engineer Technician",
            "Entrepreneur",
            "Environmental Analyst",
            "Environmental Attorney",
            "Environmental Engineer",
            "Environmental Specialist",
            "Escrow Officer",
            "Estimator",
            "Executive Assistant",
            "Executive Director",
            "Executive Recruiter",
            "Facilities Manager",
            "Family Counselor",
            "Fashion Events Manager",
            "Fashion Merchandiser",
            "Fast Food Manager",
            "Film Producer",
            "Film Production Assistant",
            "Financial Analyst",
            "Financial Planner",
            "Financier",
            "Fine Artist",
            "Wildlife Specialist",
            "Fitness Consultant",
            "Flight Attendant",
            "Flight Engineer",
            "Floral Designer",
            "Food & Beverage Director",
            "Food Service Manager",
            "Forestry Technician",
            "Franchise Management",
            "Franchise Sales",
            "Fraud Investigator",
            "Freelance Writer",
            "Fund Raiser",
            "General Manager",
            "Geologist",
            "General Counsel",
            "Geriatric Specialist",
            "Gerontologist",
            "Glamour Photographer",
            "Golf Club Manager",
            "Gourmet Chef",
            "Graphic Designer",
            "Grounds Keeper",
            "Hazardous Waste Manager",
            "Health Care Manager",
            "Health Therapist",
            "Health Service Administrator",
            "Hearing Officer",
            "Home Economist",
            "Horticulturist",
            "Hospital Administrator",
            "Hotel Manager",
            "Human Resources Manager",
            "Importer",
            "Industrial Designer",
            "Industrial Engineer",
            "Information Director",
            "Inside Sales",
            "Insurance Adjuster",
            "Interior Decorator",
            "Internal Controls Director",
            "International Acct.",
            "International Courier",
            "International Lawyer",
            "Interpreter",
            "Investigator",
            "Investment Banker",
            "Investment Manager",
            "IT Architect",
            "IT Project Manager",
            "IT Systems Analyst",
            "Jeweler",
            "Joint Venture Manager",
            "Journalist",
            "Labor Negotiator",
            "Labor Organizer",
            "Labor Relations Manager",
            "Lab Services Director",
            "Lab Technician",
            "Land Developer",
            "Landscape Architect",
            "Law Enforcement Officer",
            "Lawyer",
            "Lead Software Engineer",
            "Lead Software Test Engineer",
            "Leasing Manager",
            "Legal Secretary",
            "Library Manager",
            "Litigation Attorney",
            "Loan Officer",
            "Lobbyist",
            "Logistics Manager",
            "Maintenance Manager",
            "Management Consultant",
            "Managed Care Director",
            "Managing Partner",
            "Manufacturing Director",
            "Manpower Planner",
            "Marine Biologist",
            "Market Res. Analyst",
            "Marketing Director",
            "Materials Manager",
            "Mathematician",
            "Membership Chairman",
            "Mechanic",
            "Mechanical Engineer",
            "Media Buyer",
            "Medical Investor",
            "Medical Secretary",
            "Medical Technician",
            "Mental Health Counselor",
            "Merchandiser",
            "Metallurgical Engineering",
            "Meteorologist",
            "Microbiologist",
            "MIS Manager",
            "Motion Picture Director",
            "Multimedia Director",
            "Musician",
            "Network Administrator",
            "Network Specialist",
            "Network Operator",
            "New Product Manager",
            "Novelist",
            "Nuclear Engineer",
            "Nuclear Specialist",
            "Nutritionist",
            "Nursing Administrator",
            "Occupational Therapist",
            "Oceanographer",
            "Office Manager",
            "Operations Manager",
            "Operations Research Director",
            "Optical Technician",
            "Optometrist",
            "Organizational Development Manager",
            "Outplacement Specialist",
            "Paralegal",
            "Park Ranger",
            "Patent Attorney",
            "Payroll Specialist",
            "Personnel Specialist",
            "Petroleum Engineer",
            "Pharmacist",
            "Photographer",
            "Physical Therapist",
            "Physician",
            "Physician Assistant",
            "Physicist",
            "Planning Director",
            "Podiatrist",
            "Political Analyst",
            "Political Scientist",
            "Politician",
            "Portfolio Manager",
            "Preschool Management",
            "Preschool Teacher",
            "Principal",
            "Private Banker",
            "Private Investigator",
            "Probation Officer",
            "Process Engineer",
            "Producer",
            "Product Manager",
            "Product Engineer",
            "Production Engineer",
            "Production Planner",
            "Professional Athlete",
            "Professional Coach",
            "Professor",
            "Project Engineer",
            "Project Manager",
            "Program Manager",
            "Property Manager",
            "Public Administrator",
            "Public Safety Director",
            "PR Specialist",
            "Publisher",
            "Purchasing Agent",
            "Publishing Director",
            "Quality Assurance Specialist",
            "Quality Control Engineer",
            "Quality Control Inspector",
            "Radiology Manager",
            "Railroad Engineer",
            "Real Estate Broker",
            "Recreational Director",
            "Recruiter",
            "Redevelopment Specialist",
            "Regulatory Affairs Manager",
            "Registered Nurse",
            "Rehabilitation Counselor",
            "Relocation Manager",
            "Reporter",
            "Research Specialist",
            "Restaurant Manager",
            "Retail Store Manager",
            "Risk Analyst",
            "Safety Engineer",
            "Sales Engineer",
            "Sales Trainer",
            "Sales Promotion Manager",
            "Sales Representative",
            "Sales Manager",
            "Service Manager",
            "Sanitation Engineer",
            "Scientific Programmer",
            "Scientific Writer",
            "Securities Analyst",
            "Security Consultant",
            "Security Director",
            "Seminar Presenter",
            "Ship's Officer",
            "Singer",
            "Social Director",
            "Social Program Planner",
            "Social Research",
            "Social Scientist",
            "Social Worker",
            "Sociologist",
            "Software Developer",
            "Software Engineer",
            "Software Test Engineer",
            "Soil Scientist",
            "Special Events Manager",
            "Special Education Teacher",
            "Special Projects Director",
            "Speech Pathologist",
            "Speech Writer",
            "Sports Event Manager",
            "Statistician",
            "Store Manager",
            "Strategic Alliance Director",
            "Strategic Planning Director",
            "Stress Reduction Specialist",
            "Stockbroker",
            "Surveyor",
            "Structural Engineer",
            "Superintendent",
            "Supply Chain Director",
            "System Engineer",
            "Systems Analyst",
            "Systems Programmer",
            "System Administrator",
            "Tax Specialist",
            "Teacher",
            "Technical Support Specialist",
            "Technical Illustrator",
            "Technical Writer",
            "Technology Director",
            "Telecom Analyst",
            "Telemarketer",
            "Theatrical Director",
            "Title Examiner",
            "Tour Escort",
            "Tour Guide Director",
            "Traffic Manager",
            "Trainer Translator",
            "Transportation Manager",
            "Travel Agent",
            "Treasurer",
            "TV Programmer",
            "Underwriter",
            "Union Representative",
            "University Administrator",
            "University Dean",
            "Urban Planner",
            "Veterinarian",
            "Vendor Relations Director",
            "Viticulturist",
            "Warehouse Manager"
        ],
        animals : {
          //list of ocean animals comes from https://owlcation.com/stem/list-of-ocean-animals
          "ocean" : ["Acantharea","Anemone","Angelfish King","Ahi Tuna","Albacore","American Oyster","Anchovy","Armored Snail","Arctic Char","Atlantic Bluefin Tuna","Atlantic Cod","Atlantic Goliath Grouper","Atlantic Trumpetfish","Atlantic Wolffish","Baleen Whale","Banded Butterflyfish","Banded Coral Shrimp","Banded Sea Krait","Barnacle","Barndoor Skate","Barracuda","Basking Shark","Bass","Beluga Whale","Bluebanded Goby","Bluehead Wrasse","Bluefish","Bluestreak Cleaner-Wrasse","Blue Marlin","Blue Shark","Blue Spiny Lobster","Blue Tang","Blue Whale","Broadclub Cuttlefish","Bull Shark","Chambered Nautilus","Chilean Basket Star","Chilean Jack Mackerel","Chinook Salmon","Christmas Tree Worm","Clam","Clown Anemonefish","Clown Triggerfish","Cod","Coelacanth","Cockscomb Cup Coral","Common Fangtooth","Conch","Cookiecutter Shark","Copepod","Coral","Corydoras","Cownose Ray","Crab","Crown-of-Thorns Starfish","Cushion Star","Cuttlefish","California Sea Otters","Dolphin","Dolphinfish","Dory","Devil Fish","Dugong","Dumbo Octopus","Dungeness Crab","Eccentric Sand Dollar","Edible Sea Cucumber","Eel","Elephant Seal","Elkhorn Coral","Emperor Shrimp","Estuarine Crocodile","Fathead Sculpin","Fiddler Crab","Fin Whale","Flameback","Flamingo Tongue Snail","Flashlight Fish","Flatback Turtle","Flatfish","Flying Fish","Flounder","Fluke","French Angelfish","Frilled Shark","Fugu (also called Pufferfish)","Gar","Geoduck","Giant Barrel Sponge","Giant Caribbean Sea Anemone","Giant Clam","Giant Isopod","Giant Kingfish","Giant Oarfish","Giant Pacific Octopus","Giant Pyrosome","Giant Sea Star","Giant Squid","Glowing Sucker Octopus","Giant Tube Worm","Goblin Shark","Goosefish","Great White Shark","Greenland Shark","Grey Atlantic Seal","Grouper","Grunion","Guineafowl Puffer","Haddock","Hake","Halibut","Hammerhead Shark","Hapuka","Harbor Porpoise","Harbor Seal","Hatchetfish","Hawaiian Monk Seal","Hawksbill Turtle","Hector's Dolphin","Hermit Crab","Herring","Hoki","Horn Shark","Horseshoe Crab","Humpback Anglerfish","Humpback Whale","Icefish","Imperator Angelfish","Irukandji Jellyfish","Isopod","Ivory Bush Coral","Japanese Spider Crab","Jellyfish","John Dory","Juan Fernandez Fur Seal","Killer Whale","Kiwa Hirsuta","Krill","Lagoon Triggerfish","Lamprey","Leafy Seadragon","Leopard Seal","Limpet","Ling","Lionfish","Lions Mane Jellyfish","Lobe Coral","Lobster","Loggerhead Turtle","Longnose Sawshark","Longsnout Seahorse","Lophelia Coral","Marrus Orthocanna","Manatee","Manta Ray","Marlin","Megamouth Shark","Mexican Lookdown","Mimic Octopus","Moon Jelly","Mollusk","Monkfish","Moray Eel","Mullet","Mussel","Megaladon","Napoleon Wrasse","Nassau Grouper","Narwhal","Nautilus","Needlefish","Northern Seahorse","North Atlantic Right Whale","Northern Red Snapper","Norway Lobster","Nudibranch","Nurse Shark","Oarfish","Ocean Sunfish","Oceanic Whitetip Shark","Octopus","Olive Sea Snake","Orange Roughy","Ostracod","Otter","Oyster","Pacific Angelshark","Pacific Blackdragon","Pacific Halibut","Pacific Sardine","Pacific Sea Nettle Jellyfish","Pacific White Sided Dolphin","Pantropical Spotted Dolphin","Patagonian Toothfish","Peacock Mantis Shrimp","Pelagic Thresher Shark","Penguin","Peruvian Anchoveta","Pilchard","Pink Salmon","Pinniped","Plankton","Porpoise","Polar Bear","Portuguese Man o' War","Pycnogonid Sea Spider","Quahog","Queen Angelfish","Queen Conch","Queen Parrotfish","Queensland Grouper","Ragfish","Ratfish","Rattail Fish","Ray","Red Drum","Red King Crab","Ringed Seal","Risso's Dolphin","Ross Seals","Sablefish","Salmon","Sand Dollar","Sandbar Shark","Sawfish","Sarcastic Fringehead","Scalloped Hammerhead Shark","Seahorse","Sea Cucumber","Sea Lion","Sea Urchin","Seal","Shark","Shortfin Mako Shark","Shovelnose Guitarfish","Shrimp","Silverside Fish","Skipjack Tuna","Slender Snipe Eel","Smalltooth Sawfish","Smelts","Sockeye Salmon","Southern Stingray","Sponge","Spotted Porcupinefish","Spotted Dolphin","Spotted Eagle Ray","Spotted Moray","Squid","Squidworm","Starfish","Stickleback","Stonefish","Stoplight Loosejaw","Sturgeon","Swordfish","Tan Bristlemouth","Tasseled Wobbegong","Terrible Claw Lobster","Threespot Damselfish","Tiger Prawn","Tiger Shark","Tilefish","Toadfish","Tropical Two-Wing Flyfish","Tuna","Umbrella Squid","Velvet Crab","Venus Flytrap Sea Anemone","Vigtorniella Worm","Viperfish","Vampire Squid","Vaquita","Wahoo","Walrus","West Indian Manatee","Whale","Whale Shark","Whiptail Gulper","White-Beaked Dolphin","White-Ring Garden Eel","White Shrimp","Wobbegong","Wrasse","Wreckfish","Xiphosura","Yellowtail Damselfish","Yelloweye Rockfish","Yellow Cup Black Coral","Yellow Tube Sponge","Yellowfin Tuna","Zebrashark","Zooplankton"],
          //list of desert, grassland, and forest animals comes from http://www.skyenimals.com/
          "desert" : ["Aardwolf","Addax","African Wild Ass","Ant","Antelope","Armadillo","Baboon","Badger","Bat","Bearded Dragon","Beetle","Bird","Black-footed Cat","Boa","Brown Bear","Bustard","Butterfly","Camel","Caracal","Caracara","Caterpillar","Centipede","Cheetah","Chipmunk","Chuckwalla","Climbing Mouse","Coati","Cobra","Cotton Rat","Cougar","Courser","Crane Fly","Crow","Dassie Rat","Dove","Dunnart","Eagle","Echidna","Elephant","Emu","Falcon","Fly","Fox","Frogmouth","Gecko","Geoffroy's Cat","Gerbil","Grasshopper","Guanaco","Gundi","Hamster","Hawk","Hedgehog","Hyena","Hyrax","Jackal","Kangaroo","Kangaroo Rat","Kestrel","Kowari","Kultarr","Leopard","Lion","Macaw","Meerkat","Mouse","Oryx","Ostrich","Owl","Pronghorn","Python","Rabbit","Raccoon","Rattlesnake","Rhinoceros","Sand Cat","Spectacled Bear","Spiny Mouse","Starling","Stick Bug","Tarantula","Tit","Toad","Tortoise","Tyrant Flycatcher","Viper","Vulture","Waxwing","Xerus","Zebra"],
          "grassland" : ["Aardvark","Aardwolf","Accentor","African Buffalo","African Wild Dog","Alpaca","Anaconda","Ant","Anteater","Antelope","Armadillo","Baboon","Badger","Bandicoot","Barbet","Bat","Bee","Bee-eater","Beetle","Bird","Bison","Black-footed Cat","Black-footed Ferret","Bluebird","Boa","Bowerbird","Brown Bear","Bush Dog","Bushshrike","Bustard","Butterfly","Buzzard","Caracal","Caracara","Cardinal","Caterpillar","Cheetah","Chipmunk","Civet","Climbing Mouse","Clouded Leopard","Coati","Cobra","Cockatoo","Cockroach","Common Genet","Cotton Rat","Cougar","Courser","Coyote","Crane","Crane Fly","Cricket","Crow","Culpeo","Death Adder","Deer","Deer Mouse","Dingo","Dinosaur","Dove","Drongo","Duck","Duiker","Dunnart","Eagle","Echidna","Elephant","Elk","Emu","Falcon","Finch","Flea","Fly","Flying Frog","Fox","Frog","Frogmouth","Garter Snake","Gazelle","Gecko","Geoffroy's Cat","Gerbil","Giant Tortoise","Giraffe","Grasshopper","Grison","Groundhog","Grouse","Guanaco","Guinea Pig","Hamster","Harrier","Hartebeest","Hawk","Hedgehog","Helmetshrike","Hippopotamus","Hornbill","Hyena","Hyrax","Impala","Jackal","Jaguar","Jaguarundi","Kangaroo","Kangaroo Rat","Kestrel","Kultarr","Ladybug","Leopard","Lion","Macaw","Meerkat","Mouse","Newt","Oryx","Ostrich","Owl","Pangolin","Pheasant","Prairie Dog","Pronghorn","Przewalski's Horse","Python","Quoll","Rabbit","Raven","Rhinoceros","Shelduck","Sloth Bear","Spectacled Bear","Squirrel","Starling","Stick Bug","Tamandua","Tasmanian Devil","Thornbill","Thrush","Toad","Tortoise"],
          "forest" : ["Agouti","Anaconda","Anoa","Ant","Anteater","Antelope","Armadillo","Asian Black Bear","Aye-aye","Babirusa","Baboon","Badger","Bandicoot","Banteng","Barbet","Basilisk","Bat","Bearded Dragon","Bee","Bee-eater","Beetle","Bettong","Binturong","Bird-of-paradise","Bongo","Bowerbird","Bulbul","Bush Dog","Bushbaby","Bushshrike","Butterfly","Buzzard","Caecilian","Cardinal","Cassowary","Caterpillar","Centipede","Chameleon","Chimpanzee","Cicada","Civet","Clouded Leopard","Coati","Cobra","Cockatoo","Cockroach","Colugo","Cotinga","Cotton Rat","Cougar","Crane Fly","Cricket","Crocodile","Crow","Cuckoo","Cuscus","Death Adder","Deer","Dhole","Dingo","Dinosaur","Drongo","Duck","Duiker","Eagle","Echidna","Elephant","Finch","Flat-headed Cat","Flea","Flowerpecker","Fly","Flying Frog","Fossa","Frog","Frogmouth","Gaur","Gecko","Gorilla","Grison","Hawaiian Honeycreeper","Hawk","Hedgehog","Helmetshrike","Hornbill","Hyrax","Iguana","Jackal","Jaguar","Jaguarundi","Kestrel","Ladybug","Lemur","Leopard","Lion","Macaw","Mandrill","Margay","Monkey","Mouse","Mouse Deer","Newt","Okapi","Old World Flycatcher","Orangutan","Owl","Pangolin","Peafowl","Pheasant","Possum","Python","Quokka","Rabbit","Raccoon","Red Panda","Red River Hog","Rhinoceros","Sloth Bear","Spectacled Bear","Squirrel","Starling","Stick Bug","Sun Bear","Tamandua","Tamarin","Tapir","Tarantula","Thrush","Tiger","Tit","Toad","Tortoise","Toucan","Trogon","Trumpeter","Turaco","Turtle","Tyrant Flycatcher","Viper","Vulture","Wallaby","Warbler","Wasp","Waxwing","Weaver","Weaver-finch","Whistler","White-eye","Whydah","Woodswallow","Worm","Wren","Xenops","Yellowjacket","Accentor","African Buffalo","American Black Bear","Anole","Bird","Bison","Boa","Brown Bear","Chipmunk","Common Genet","Copperhead","Coyote","Deer Mouse","Dormouse","Elk","Emu","Fisher","Fox","Garter Snake","Giant Panda","Giant Tortoise","Groundhog","Grouse","Guanaco","Himalayan Tahr","Kangaroo","Koala","Numbat","Quoll","Raccoon dog","Tasmanian Devil","Thornbill","Turkey","Vole","Weasel","Wildcat","Wolf","Wombat","Woodchuck","Woodpecker"],
          //list of farm animals comes from https://www.buzzle.com/articles/farm-animals-list.html
          "farm" : ["Alpaca","Buffalo","Banteng","Cow","Cat","Chicken","Carp","Camel","Donkey","Dog","Duck","Emu","Goat","Gayal","Guinea","Goose","Horse","Honey","Llama","Pig","Pigeon","Rhea","Rabbit","Sheep","Silkworm","Turkey","Yak","Zebu"],
          //list of pet animals comes from https://www.dogbreedinfo.com/pets/pet.htm
          "pet" : ["Bearded Dragon","Birds","Burro","Cats","Chameleons","Chickens","Chinchillas","Chinese Water Dragon","Cows","Dogs","Donkey","Ducks","Ferrets","Fish","Geckos","Geese","Gerbils","Goats","Guinea Fowl","Guinea Pigs","Hamsters","Hedgehogs","Horses","Iguanas","Llamas","Lizards","Mice","Mule","Peafowl","Pigs and Hogs","Pigeons","Ponies","Pot Bellied Pig","Rabbits","Rats","Sheep","Skinks","Snakes","Stick Insects","Sugar Gliders","Tarantula","Turkeys","Turtles"],
          //list of zoo animals comes from https://bronxzoo.com/animals
          "zoo" : ["Aardvark","African Wild Dog","Aldabra Tortoise","American Alligator","American Bison","Amur Tiger","Anaconda","Andean Condor","Asian Elephant","Baby Doll Sheep","Bald Eagle","Barred Owl","Blue Iguana","Boer Goat","California Sea Lion","Caribbean Flamingo","Chinchilla","Collared Lemur","Coquerel's Sifaka","Cuban Amazon Parrot","Ebony Langur","Fennec Fox","Fossa","Gelada","Giant Anteater","Giraffe","Gorilla","Grizzly Bear","Henkel's Leaf-tailed Gecko","Indian Gharial","Indian Rhinoceros","King Cobra","King Vulture","Komodo Dragon","Linne's Two-toed Sloth","Lion","Little Penguin","Madagascar Tree Boa","Magellanic Penguin","Malayan Tapir","Malayan Tiger","Matschies Tree Kangaroo","Mini Donkey","Monarch Butterfly","Nile crocodile","North American Porcupine","Nubian Ibex","Okapi","Poison Dart Frog","Polar Bear","Pygmy Marmoset","Radiated Tortoise","Red Panda","Red Ruffed Lemur","Ring-tailed Lemur","Ring-tailed Mongoose","Rock Hyrax","Small Clawed Asian Otter","Snow Leopard","Snowy Owl","Southern White-faced Owl","Southern White Rhinocerous","Squirrel Monkey","Tufted Puffin","White Cheeked Gibbon","White-throated Bee Eater","Zebra"]
        }
    };

    var o_hasOwnProperty = Object.prototype.hasOwnProperty;
    var o_keys = (Object.keys || function(obj) {
      var result = [];
      for (var key in obj) {
        if (o_hasOwnProperty.call(obj, key)) {
          result.push(key);
        }
      }

      return result;
    });


    function _copyObject(source, target) {
      var keys = o_keys(source);
      var key;

      for (var i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        target[key] = source[key] || target[key];
      }
    }

    function _copyArray(source, target) {
      for (var i = 0, l = source.length; i < l; i++) {
        target[i] = source[i];
      }
    }

    function copyObject(source, _target) {
        var isArray = Array.isArray(source);
        var target = _target || (isArray ? new Array(source.length) : {});

        if (isArray) {
          _copyArray(source, target);
        } else {
          _copyObject(source, target);
        }

        return target;
    }

    /** Get the data based on key**/
    Chance.prototype.get = function (name) {
        return copyObject(data[name]);
    };

    // Mac Address
    Chance.prototype.mac_address = function(options){
        // typically mac addresses are separated by ":"
        // however they can also be separated by "-"
        // the network variant uses a dot every fourth byte

        options = initOptions(options);
        if(!options.separator) {
            options.separator =  options.networkVersion ? "." : ":";
        }

        var mac_pool="ABCDEF1234567890",
            mac = "";
        if(!options.networkVersion) {
            mac = this.n(this.string, 6, { pool: mac_pool, length:2 }).join(options.separator);
        } else {
            mac = this.n(this.string, 3, { pool: mac_pool, length:4 }).join(options.separator);
        }

        return mac;
    };

    Chance.prototype.normal = function (options) {
        options = initOptions(options, {mean : 0, dev : 1, pool : []});

        testRange(
            options.pool.constructor !== Array,
            "Chance: The pool option must be a valid array."
        );
        testRange(
            typeof options.mean !== 'number',
            "Chance: Mean (mean) must be a number"
        );
        testRange(
            typeof options.dev !== 'number',
            "Chance: Standard deviation (dev) must be a number"
        );

        // If a pool has been passed, then we are returning an item from that pool,
        // using the normal distribution settings that were passed in
        if (options.pool.length > 0) {
            return this.normal_pool(options);
        }

        // The Marsaglia Polar method
        var s, u, v, norm,
            mean = options.mean,
            dev = options.dev;

        do {
            // U and V are from the uniform distribution on (-1, 1)
            u = this.random() * 2 - 1;
            v = this.random() * 2 - 1;

            s = u * u + v * v;
        } while (s >= 1);

        // Compute the standard normal variate
        norm = u * Math.sqrt(-2 * Math.log(s) / s);

        // Shape and scale
        return dev * norm + mean;
    };

    Chance.prototype.normal_pool = function(options) {
        var performanceCounter = 0;
        do {
            var idx = Math.round(this.normal({ mean: options.mean, dev: options.dev }));
            if (idx < options.pool.length && idx >= 0) {
                return options.pool[idx];
            } else {
                performanceCounter++;
            }
        } while(performanceCounter < 100);

        throw new RangeError("Chance: Your pool is too small for the given mean and standard deviation. Please adjust.");
    };

    Chance.prototype.radio = function (options) {
        // Initial Letter (Typically Designated by Side of Mississippi River)
        options = initOptions(options, {side : "?"});
        var fl = "";
        switch (options.side.toLowerCase()) {
        case "east":
        case "e":
            fl = "W";
            break;
        case "west":
        case "w":
            fl = "K";
            break;
        default:
            fl = this.character({pool: "KW"});
            break;
        }

        return fl + this.character({alpha: true, casing: "upper"}) +
                this.character({alpha: true, casing: "upper"}) +
                this.character({alpha: true, casing: "upper"});
    };

    // Set the data as key and data or the data map
    Chance.prototype.set = function (name, values) {
        if (typeof name === "string") {
            data[name] = values;
        } else {
            data = copyObject(name, data);
        }
    };

    Chance.prototype.tv = function (options) {
        return this.radio(options);
    };

    // ID number for Brazil companies
    Chance.prototype.cnpj = function () {
        var n = this.n(this.natural, 8, { max: 9 });
        var d1 = 2+n[7]*6+n[6]*7+n[5]*8+n[4]*9+n[3]*2+n[2]*3+n[1]*4+n[0]*5;
        d1 = 11 - (d1 % 11);
        if (d1>=10){
            d1 = 0;
        }
        var d2 = d1*2+3+n[7]*7+n[6]*8+n[5]*9+n[4]*2+n[3]*3+n[2]*4+n[1]*5+n[0]*6;
        d2 = 11 - (d2 % 11);
        if (d2>=10){
            d2 = 0;
        }
        return ''+n[0]+n[1]+'.'+n[2]+n[3]+n[4]+'.'+n[5]+n[6]+n[7]+'/0001-'+d1+d2;
    };

    // -- End Miscellaneous --

    Chance.prototype.mersenne_twister = function (seed) {
        return new MersenneTwister(seed);
    };

    Chance.prototype.blueimp_md5 = function () {
        return new BlueImpMD5();
    };

    // Mersenne Twister from https://gist.github.com/banksean/300494
    /*
       A C-program for MT19937, with initialization improved 2002/1/26.
       Coded by Takuji Nishimura and Makoto Matsumoto.

       Before using, initialize the state by using init_genrand(seed)
       or init_by_array(init_key, key_length).

       Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
       All rights reserved.

       Redistribution and use in source and binary forms, with or without
       modification, are permitted provided that the following conditions
       are met:

       1. Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.

       2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

       3. The names of its contributors may not be used to endorse or promote
       products derived from this software without specific prior written
       permission.

       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
       "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
       LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
       A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
       CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
       EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
       PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
       PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
       LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
       NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
       SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


       Any feedback is very welcome.
       http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
       email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
     */
    var MersenneTwister = function (seed) {
        if (seed === undefined) {
            // kept random number same size as time used previously to ensure no unexpected results downstream
            seed = Math.floor(Math.random()*Math.pow(10,13));
        }
        /* Period parameters */
        this.N = 624;
        this.M = 397;
        this.MATRIX_A = 0x9908b0df;   /* constant vector a */
        this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
        this.LOWER_MASK = 0x7fffffff; /* least significant r bits */

        this.mt = new Array(this.N); /* the array for the state vector */
        this.mti = this.N + 1; /* mti==N + 1 means mt[N] is not initialized */

        this.init_genrand(seed);
    };

    /* initializes mt[N] with a seed */
    MersenneTwister.prototype.init_genrand = function (s) {
        this.mt[0] = s >>> 0;
        for (this.mti = 1; this.mti < this.N; this.mti++) {
            s = this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >>> 30);
            this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253) + this.mti;
            /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
            /* In the previous versions, MSBs of the seed affect   */
            /* only MSBs of the array mt[].                        */
            /* 2002/01/09 modified by Makoto Matsumoto             */
            this.mt[this.mti] >>>= 0;
            /* for >32 bit machines */
        }
    };

    /* initialize by an array with array-length */
    /* init_key is the array for initializing keys */
    /* key_length is its length */
    /* slight change for C++, 2004/2/26 */
    MersenneTwister.prototype.init_by_array = function (init_key, key_length) {
        var i = 1, j = 0, k, s;
        this.init_genrand(19650218);
        k = (this.N > key_length ? this.N : key_length);
        for (; k; k--) {
            s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);
            this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525))) + init_key[j] + j; /* non linear */
            this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
            i++;
            j++;
            if (i >= this.N) { this.mt[0] = this.mt[this.N - 1]; i = 1; }
            if (j >= key_length) { j = 0; }
        }
        for (k = this.N - 1; k; k--) {
            s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);
            this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941)) - i; /* non linear */
            this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
            i++;
            if (i >= this.N) { this.mt[0] = this.mt[this.N - 1]; i = 1; }
        }

        this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
    };

    /* generates a random number on [0,0xffffffff]-interval */
    MersenneTwister.prototype.genrand_int32 = function () {
        var y;
        var mag01 = new Array(0x0, this.MATRIX_A);
        /* mag01[x] = x * MATRIX_A  for x=0,1 */

        if (this.mti >= this.N) { /* generate N words at one time */
            var kk;

            if (this.mti === this.N + 1) {   /* if init_genrand() has not been called, */
                this.init_genrand(5489); /* a default initial seed is used */
            }
            for (kk = 0; kk < this.N - this.M; kk++) {
                y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk + 1]&this.LOWER_MASK);
                this.mt[kk] = this.mt[kk + this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
            }
            for (;kk < this.N - 1; kk++) {
                y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk + 1]&this.LOWER_MASK);
                this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
            }
            y = (this.mt[this.N - 1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
            this.mt[this.N - 1] = this.mt[this.M - 1] ^ (y >>> 1) ^ mag01[y & 0x1];

            this.mti = 0;
        }

        y = this.mt[this.mti++];

        /* Tempering */
        y ^= (y >>> 11);
        y ^= (y << 7) & 0x9d2c5680;
        y ^= (y << 15) & 0xefc60000;
        y ^= (y >>> 18);

        return y >>> 0;
    };

    /* generates a random number on [0,0x7fffffff]-interval */
    MersenneTwister.prototype.genrand_int31 = function () {
        return (this.genrand_int32() >>> 1);
    };

    /* generates a random number on [0,1]-real-interval */
    MersenneTwister.prototype.genrand_real1 = function () {
        return this.genrand_int32() * (1.0 / 4294967295.0);
        /* divided by 2^32-1 */
    };

    /* generates a random number on [0,1)-real-interval */
    MersenneTwister.prototype.random = function () {
        return this.genrand_int32() * (1.0 / 4294967296.0);
        /* divided by 2^32 */
    };

    /* generates a random number on (0,1)-real-interval */
    MersenneTwister.prototype.genrand_real3 = function () {
        return (this.genrand_int32() + 0.5) * (1.0 / 4294967296.0);
        /* divided by 2^32 */
    };

    /* generates a random number on [0,1) with 53-bit resolution*/
    MersenneTwister.prototype.genrand_res53 = function () {
        var a = this.genrand_int32()>>>5, b = this.genrand_int32()>>>6;
        return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);
    };

    // BlueImp MD5 hashing algorithm from https://github.com/blueimp/JavaScript-MD5
    var BlueImpMD5 = function () {};

    BlueImpMD5.prototype.VERSION = '1.0.1';

    /*
    * Add integers, wrapping at 2^32. This uses 16-bit operations internally
    * to work around bugs in some JS interpreters.
    */
    BlueImpMD5.prototype.safe_add = function safe_add(x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF),
            msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    };

    /*
    * Bitwise rotate a 32-bit number to the left.
    */
    BlueImpMD5.prototype.bit_roll = function (num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    };

    /*
    * These functions implement the five basic operations the algorithm uses.
    */
    BlueImpMD5.prototype.md5_cmn = function (q, a, b, x, s, t) {
        return this.safe_add(this.bit_roll(this.safe_add(this.safe_add(a, q), this.safe_add(x, t)), s), b);
    };
    BlueImpMD5.prototype.md5_ff = function (a, b, c, d, x, s, t) {
        return this.md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    };
    BlueImpMD5.prototype.md5_gg = function (a, b, c, d, x, s, t) {
        return this.md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    };
    BlueImpMD5.prototype.md5_hh = function (a, b, c, d, x, s, t) {
        return this.md5_cmn(b ^ c ^ d, a, b, x, s, t);
    };
    BlueImpMD5.prototype.md5_ii = function (a, b, c, d, x, s, t) {
        return this.md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    };

    /*
    * Calculate the MD5 of an array of little-endian words, and a bit length.
    */
    BlueImpMD5.prototype.binl_md5 = function (x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << (len % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var i, olda, oldb, oldc, oldd,
            a =  1732584193,
            b = -271733879,
            c = -1732584194,
            d =  271733878;

        for (i = 0; i < x.length; i += 16) {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;

            a = this.md5_ff(a, b, c, d, x[i],       7, -680876936);
            d = this.md5_ff(d, a, b, c, x[i +  1], 12, -389564586);
            c = this.md5_ff(c, d, a, b, x[i +  2], 17,  606105819);
            b = this.md5_ff(b, c, d, a, x[i +  3], 22, -1044525330);
            a = this.md5_ff(a, b, c, d, x[i +  4],  7, -176418897);
            d = this.md5_ff(d, a, b, c, x[i +  5], 12,  1200080426);
            c = this.md5_ff(c, d, a, b, x[i +  6], 17, -1473231341);
            b = this.md5_ff(b, c, d, a, x[i +  7], 22, -45705983);
            a = this.md5_ff(a, b, c, d, x[i +  8],  7,  1770035416);
            d = this.md5_ff(d, a, b, c, x[i +  9], 12, -1958414417);
            c = this.md5_ff(c, d, a, b, x[i + 10], 17, -42063);
            b = this.md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = this.md5_ff(a, b, c, d, x[i + 12],  7,  1804603682);
            d = this.md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = this.md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = this.md5_ff(b, c, d, a, x[i + 15], 22,  1236535329);

            a = this.md5_gg(a, b, c, d, x[i +  1],  5, -165796510);
            d = this.md5_gg(d, a, b, c, x[i +  6],  9, -1069501632);
            c = this.md5_gg(c, d, a, b, x[i + 11], 14,  643717713);
            b = this.md5_gg(b, c, d, a, x[i],      20, -373897302);
            a = this.md5_gg(a, b, c, d, x[i +  5],  5, -701558691);
            d = this.md5_gg(d, a, b, c, x[i + 10],  9,  38016083);
            c = this.md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = this.md5_gg(b, c, d, a, x[i +  4], 20, -405537848);
            a = this.md5_gg(a, b, c, d, x[i +  9],  5,  568446438);
            d = this.md5_gg(d, a, b, c, x[i + 14],  9, -1019803690);
            c = this.md5_gg(c, d, a, b, x[i +  3], 14, -187363961);
            b = this.md5_gg(b, c, d, a, x[i +  8], 20,  1163531501);
            a = this.md5_gg(a, b, c, d, x[i + 13],  5, -1444681467);
            d = this.md5_gg(d, a, b, c, x[i +  2],  9, -51403784);
            c = this.md5_gg(c, d, a, b, x[i +  7], 14,  1735328473);
            b = this.md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

            a = this.md5_hh(a, b, c, d, x[i +  5],  4, -378558);
            d = this.md5_hh(d, a, b, c, x[i +  8], 11, -2022574463);
            c = this.md5_hh(c, d, a, b, x[i + 11], 16,  1839030562);
            b = this.md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = this.md5_hh(a, b, c, d, x[i +  1],  4, -1530992060);
            d = this.md5_hh(d, a, b, c, x[i +  4], 11,  1272893353);
            c = this.md5_hh(c, d, a, b, x[i +  7], 16, -155497632);
            b = this.md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = this.md5_hh(a, b, c, d, x[i + 13],  4,  681279174);
            d = this.md5_hh(d, a, b, c, x[i],      11, -358537222);
            c = this.md5_hh(c, d, a, b, x[i +  3], 16, -722521979);
            b = this.md5_hh(b, c, d, a, x[i +  6], 23,  76029189);
            a = this.md5_hh(a, b, c, d, x[i +  9],  4, -640364487);
            d = this.md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = this.md5_hh(c, d, a, b, x[i + 15], 16,  530742520);
            b = this.md5_hh(b, c, d, a, x[i +  2], 23, -995338651);

            a = this.md5_ii(a, b, c, d, x[i],       6, -198630844);
            d = this.md5_ii(d, a, b, c, x[i +  7], 10,  1126891415);
            c = this.md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = this.md5_ii(b, c, d, a, x[i +  5], 21, -57434055);
            a = this.md5_ii(a, b, c, d, x[i + 12],  6,  1700485571);
            d = this.md5_ii(d, a, b, c, x[i +  3], 10, -1894986606);
            c = this.md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = this.md5_ii(b, c, d, a, x[i +  1], 21, -2054922799);
            a = this.md5_ii(a, b, c, d, x[i +  8],  6,  1873313359);
            d = this.md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = this.md5_ii(c, d, a, b, x[i +  6], 15, -1560198380);
            b = this.md5_ii(b, c, d, a, x[i + 13], 21,  1309151649);
            a = this.md5_ii(a, b, c, d, x[i +  4],  6, -145523070);
            d = this.md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = this.md5_ii(c, d, a, b, x[i +  2], 15,  718787259);
            b = this.md5_ii(b, c, d, a, x[i +  9], 21, -343485551);

            a = this.safe_add(a, olda);
            b = this.safe_add(b, oldb);
            c = this.safe_add(c, oldc);
            d = this.safe_add(d, oldd);
        }
        return [a, b, c, d];
    };

    /*
    * Convert an array of little-endian words to a string
    */
    BlueImpMD5.prototype.binl2rstr = function (input) {
        var i,
            output = '';
        for (i = 0; i < input.length * 32; i += 8) {
            output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
        }
        return output;
    };

    /*
    * Convert a raw string to an array of little-endian words
    * Characters >255 have their high-byte silently ignored.
    */
    BlueImpMD5.prototype.rstr2binl = function (input) {
        var i,
            output = [];
        output[(input.length >> 2) - 1] = undefined;
        for (i = 0; i < output.length; i += 1) {
            output[i] = 0;
        }
        for (i = 0; i < input.length * 8; i += 8) {
            output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);
        }
        return output;
    };

    /*
    * Calculate the MD5 of a raw string
    */
    BlueImpMD5.prototype.rstr_md5 = function (s) {
        return this.binl2rstr(this.binl_md5(this.rstr2binl(s), s.length * 8));
    };

    /*
    * Calculate the HMAC-MD5, of a key and some data (raw strings)
    */
    BlueImpMD5.prototype.rstr_hmac_md5 = function (key, data) {
        var i,
            bkey = this.rstr2binl(key),
            ipad = [],
            opad = [],
            hash;
        ipad[15] = opad[15] = undefined;
        if (bkey.length > 16) {
            bkey = this.binl_md5(bkey, key.length * 8);
        }
        for (i = 0; i < 16; i += 1) {
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }
        hash = this.binl_md5(ipad.concat(this.rstr2binl(data)), 512 + data.length * 8);
        return this.binl2rstr(this.binl_md5(opad.concat(hash), 512 + 128));
    };

    /*
    * Convert a raw string to a hex string
    */
    BlueImpMD5.prototype.rstr2hex = function (input) {
        var hex_tab = '0123456789abcdef',
            output = '',
            x,
            i;
        for (i = 0; i < input.length; i += 1) {
            x = input.charCodeAt(i);
            output += hex_tab.charAt((x >>> 4) & 0x0F) +
                hex_tab.charAt(x & 0x0F);
        }
        return output;
    };

    /*
    * Encode a string as utf-8
    */
    BlueImpMD5.prototype.str2rstr_utf8 = function (input) {
        return unescape(encodeURIComponent(input));
    };

    /*
    * Take string arguments and return either raw or hex encoded strings
    */
    BlueImpMD5.prototype.raw_md5 = function (s) {
        return this.rstr_md5(this.str2rstr_utf8(s));
    };
    BlueImpMD5.prototype.hex_md5 = function (s) {
        return this.rstr2hex(this.raw_md5(s));
    };
    BlueImpMD5.prototype.raw_hmac_md5 = function (k, d) {
        return this.rstr_hmac_md5(this.str2rstr_utf8(k), this.str2rstr_utf8(d));
    };
    BlueImpMD5.prototype.hex_hmac_md5 = function (k, d) {
        return this.rstr2hex(this.raw_hmac_md5(k, d));
    };

    BlueImpMD5.prototype.md5 = function (string, key, raw) {
        if (!key) {
            if (!raw) {
                return this.hex_md5(string);
            }

            return this.raw_md5(string);
        }

        if (!raw) {
            return this.hex_hmac_md5(key, string);
        }

        return this.raw_hmac_md5(key, string);
    };

    // CommonJS module
    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = Chance;
        }
        exports.Chance = Chance;
    }

    // Register as an anonymous AMD module
    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return Chance;
        });
    }

    // if there is a importsScrips object define chance for worker
    // allows worker to use full Chance functionality with seed
    if (typeof importScripts !== 'undefined') {
        chance = new Chance();
        self.Chance = Chance;
    }

    // If there is a window object, that at least has a document property,
    // instantiate and define chance on the window
    if (typeof window === "object" && typeof window.document === "object") {
        window.Chance = Chance;
        window.chance = new Chance();
    }
})();

}).call(this,require("buffer").Buffer)
},{"buffer":2}]},{},[])("chance")
});

/*globals define*/
/*eslint-env node, browser*/
/**
 * @author kecso / https://github.com/kecso
 */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('common/core/constants',[], factory);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = factory();
    }
}(function () {
    'use strict';
    //return string constants
    return {
        ATTRIBUTES_PROPERTY: 'atr',
        REGISTRY_PROPERTY: 'reg',
        OVERLAYS_PROPERTY: 'ovr',
        COLLECTION_NAME_SUFFIX: '-inv',
        ALL_SETS_PROPERTY: '_sets',
        SET_MODIFIED_REGISTRY: '_sets_',
        MEMBER_RELATION: 'member',
        BASE_POINTER: 'base',
        PATH_SEP: '/',
        MUTABLE_PROPERTY: '_mutable',
        MINIMAL_RELID_LENGTH_PROPERTY: '_minlenrelid',
        DOES_NOT_HAVE_RELID_CHILDREN: {
            _sets: true, // ALL_SETS_PROPERTY
            _meta: true  // META_NODE
        },
        INHERITED_CHILD_HAS_OWN_RELATION_PROPERTY: '_hasownrelation',

        NULLPTR_NAME: '_null_pointer',
        NULLPTR_RELID: '_nullptr',

        META_SET_NAME: 'MetaAspectSet',
        NULL_GUID: '00000000-0000-0000-0000-000000000000',
        OWN_GUID: '_relguid',

        CONSTRAINTS_RELID: '_constraints',
        C_DEF_PRIORITY: 1,
        CONSTRAINT_REGISTRY_PREFIX: '_ch#_',

        TO_DELETE_STRING: '*to*delete*',

        SET_ITEMS: 'items',
        SET_ITEMS_MAX: 'max',
        SET_ITEMS_MIN: 'min',

        META_ASPECTS: 'aspects',
        META_CHILDREN: 'children',
        META_NODE: '_meta',
        META_POINTER_PREFIX: '_p_',
        META_ASPECT_PREFIX: '_a_',

        ATTRIBUTE_TYPES: {
            STRING: 'string',
            INTEGER: 'integer',
            FLOAT: 'float',
            BOOLEAN: 'boolean',
            ASSET: 'asset'
        },

        MIXINS_SET: '_mixins',
        MIXIN_ERROR_TYPE: {
            MISSING: 'missing',
            ATTRIBUTE_COLLISION: 'attribute collision',
            SET_COLLISION: 'set collision',
            POINTER_COLLISION: 'pointer collision',
            CONTAINMENT_COLLISION: 'containment collision',
            ASPECT_COLLISION: 'aspect collision',
            CONSTRAINT_COLLISION: 'constraint collision'
        },

        EXPORT_TYPE_PROJECT: 'project',
        EXPORT_TYPE_LIBRARY: 'library',

        NAMESPACE_SEPARATOR: '.',

        MAX_AGE: 3,
        MAX_TICKS: 2000,
        MAX_MUTATE: 30000,
        MAXIMUM_STARTING_RELID_LENGTH: 5,

        OVERLAY_SHARD_INDICATOR: 'sharded'
    };
}));
/*globals define*/
/*eslint-env node, browser*/

/**
 * STRING CONSTANT DEFINITIONS USED IN BOTH CLIENT AND SERVER JAVASCRIPT
 * @author rkereskenyi / https://github.com/rkereskenyi
 * @author pmeijer / https://github.com/pmeijer
 */


(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('common/Constants',['common/core/constants', 'common/storage/constants'], factory);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = factory(require('./core/constants'), require('./storage/constants'));
    }
}(function (CORE, STORAGE) {
    'use strict';
    //return string constants
    return {
        /*
         * TERRITORY EVENTS
         */
        TERRITORY_EVENT_LOAD: 'load',
        TERRITORY_EVENT_UPDATE: 'update',
        TERRITORY_EVENT_UNLOAD: 'unload',
        TERRITORY_EVENT_COMPLETE: 'complete',
        TERRITORY_EVENT_INCOMPLETE: 'incomplete',

        /*
         * GME_ID: wherever a GME object ID needs to be present
         */
        GME_ID: 'GME_ID',

        /*
         * DEDICATED GME OBJECT IDs
         */
        PROJECT_ROOT_ID: '',
        PROJECT_FCO_ID: 'FCO_ID',
        PROJECT_FCO_GUID: 'cd891e7b-e2ea-e929-f6cd-9faf4f1fc045',
        PROJECT_FCO_RELID: '1',

        /*
         * DEDICATED GME ROOT properties
         */
        PROJECT_ROOT_NAME: 'ROOT',

        /*
         * Dedicated POINTER names
         */
        POINTER_SOURCE: 'src',      //dedicated connection source pointer name
        POINTER_TARGET: 'dst',      //dedicated connection target pointer name
        POINTER_BASE: 'base',       //dedicated inheritance pointer name
        POINTER_CONSTRAINED_BY: 'constrainedby', //dedicated replaceable/constrainedBy pointer name

        /*
         * Dedicated RELATION names
         */
        RELATION_CONTAINMENT: 'containment',

        CORE: CORE,
        STORAGE: STORAGE,

        WEBHOOK_EVENTS: {
            BRANCH_DELETED: STORAGE.BRANCH_DELETED,
            BRANCH_CREATED: STORAGE.BRANCH_CREATED,
            BRANCH_HASH_UPDATED: STORAGE.BRANCH_HASH_UPDATED,
            TAG_DELETED: STORAGE.TAG_DELETED,
            TAG_CREATED: STORAGE.TAG_CREATED,
            COMMIT: STORAGE.COMMIT,
            PROJECT_DELETED: STORAGE.PROJECT_DELETED,
            BRANCH_JOINED: STORAGE.BRANCH_JOINED,
            BRANCH_LEFT: STORAGE.BRANCH_LEFT
        },

        SERVER_WORKER_REQUESTS: {
            EXECUTE_PLUGIN: 'executePlugin',
            SEED_PROJECT: 'seedProject',
            DIFF: 'diff',
            AUTO_MERGE: 'autoMerge',
            RESOLVE: 'resolve',
            CHECK_CONSTRAINTS: 'checkConstraints',

            IMPORT_PROJECT_FROM_FILE: 'importProjectFromFile',
            EXPORT_PROJECT_TO_FILE: 'exportProjectToFile',
            ADD_LIBRARY: 'addLibrary',
            UPDATE_LIBRARY: 'updateLibrary',
            EXPORT_SELECTION_TO_FILE: 'exportSelectionToFile',
            IMPORT_SELECTION_FROM_FILE: 'importSelectionFromFile',
            UPDATE_PROJECT_FROM_FILE: 'updateProjectFromFile',
            RENAME_CONCEPT: 'renameConcept',
            CHANGE_ATTRIBUTE_META: 'changeAttributeMeta',
            RENAME_META_POINTER_TARGET: 'renameMetaPointerTarget',
            CHANGE_ASPECT_META: 'changeAspectMeta',
            REMOVE_META_RULE: 'removeMetaRule'
        },

        ATTRIBUTE_MULTILINE_TYPES: {
            plaintext: 'plaintext',
            c: 'c',
            cpp: 'cpp',
            csharp: 'csharp',
            css: 'css',
            erlang: 'erlang',
            html: 'html',
            java: 'java',
            javascript: 'javascript',
            latex: 'latex',
            lua: 'lua',
            markdown: 'markdown',
            mathematica: 'mathematica',
            modelica: 'modelica',
            python: 'python',
            sql: 'sql',
            tex: 'tex',
            ttcn: 'ttcn',
            yaml: 'yaml'
        },

        HTTP_HEADERS: {
            MOUNTED_PATH: 'X-Proxy-Mounted-Path'
        }
    };
}));
/*globals define*/
/*eslint-env node, browser*/

/**
 * @author kecso / https://github.com/kecso
 *
 * collection of functions that uses random Numbers in WebGME
 */

define('common/util/random',['chance', 'common/Constants'], function (ChanceJs, CONSTANTS) {
    'use strict';

    var guidPool = '0123456789abcdef',
        relidPool = '0123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM',
        excludeList = ['atr', 'reg', 'ovr'],
        maxTry = 2,
        chance = new ChanceJs(),
        randFunction = function (max) {
            //return Math.floor(Math.random() * max);
            return chance.natural({max: max - 1});
        },
        relidRegexp = _generateRelidRegexp(),
        random = {
            generateGuid: generateGuid,
            generateRelid: generateRelid,
            isValidRelid: isValidRelid,
            isValidPath: isValidPath,
            relidToInteger: relidToInteger,
            generateRandomString: generateRandomString
        };

    function _generateRelidRegexp() {
        var regexp = '',
            i;

        //adding excludes
        if (excludeList.length > 0) {
            for (i = 0; i < excludeList.length; i += 1) {
                regexp += '(?!(^' + excludeList[i] + '$))';
            }
        }
        //adding the pool
        regexp += '^(-)?[' + relidPool + ']+$';

        return new RegExp(regexp);
    }

    function getRandomCharacter(pool) {
        return pool.charAt(randFunction(pool.length));
    }

    function generateGuid() {
        var s4 = function () {
            return getRandomCharacter(guidPool) +
                getRandomCharacter(guidPool) +
                getRandomCharacter(guidPool) +
                getRandomCharacter(guidPool);
        };

        return (s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4());
    }

    function generateRelid(object, minimalLength) {
        var relid,
            i,
            length = minimalLength || 1,
            tries = 0;

        do {
            if (tries >= maxTry) {
                tries = 0;
                length += 1;
            }
            relid = '';
            for (i = 0; i < length; i += 1) {
                relid += getRandomCharacter(relidPool);
            }
            tries += 1;
        } while (object.hasOwnProperty(relid) === true || isValidRelid(relid) === false);

        return relid;
    }

    function generateRandomString(length) {
        return chance.string({
            pool: relidPool,
            length: length
        });
    }

    function isValidRelid(relid) {

        if (typeof relid !== 'string') {
            return false;
        }
        return relidRegexp.test(relid);
    }

    function isValidPath(path) {
        var relid;

        if (path === CONSTANTS.PROJECT_ROOT_ID) {
            return true;
        }

        path = path.split(CONSTANTS.CORE.PATH_SEP);

        relid = path.shift();

        if (relid !== CONSTANTS.PROJECT_ROOT_ID) {
            return false;
        }

        do {
            relid = path.shift();
            if (typeof relid === 'string' && relidRegexp.test(relid) === false) {
                return false;
            }
        } while (relid);

        return true;
    }

    function relidToInteger(relid) {
        var num = 'NaN',
            //negative = false,
            i;

        if (isValidRelid(relid)) {
            num = 0;
            for (i = 0; i < relid.length; i += 1) {
                if (relid.charAt(i) === '-') {
                    //negative = true;
                } else {
                    num = num * relidPool.length;
                    num += relidPool.indexOf(relid.charAt(i));
                }
            }
        }

        return num;
    }

    return random;
});

/*globals define*/
/*eslint-env node, browser*/
/**
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/regexp',[], function () {
    'use strict';
    var HASH = new RegExp('^#[0-9a-zA-Z_]*$'),
        DB_HASH = new RegExp('^#[0-9a-zA-Z_]{40}$'),
        BRANCH = new RegExp('^[0-9a-zA-Z_]*$'),
        TAG = new RegExp('^[0-9a-zA-Z_]*$'),
        RAW_BRANCH = new RegExp('^\\*[0-9a-zA-Z_]*$'), // This is how it's stored in mongodb, i.e. with a prefixed *.
        PROJECT = new RegExp('^(?!system\\.)(?!_)[0-9a-zA-Z_+]*$'), // project name may not start with system. or _
        DOCUMENT_KEY = new RegExp('^[^($|_).][^.]*$'), //based on the MongoDB requirements (no '.' and no leading $)
        PROJECT_NAME = new RegExp('^[0-9a-zA-Z_]+$'),

        INVALID_CSS_CHARS = new RegExp('[!"#$%&\'()*+,./:;<=>?@[\\]^`{|}~ ]+', 'g'),
        HTML_ELEMENT = new RegExp('<[a-z][\\s\\S]*>', 'i'),
        GUID = new RegExp('[a-z0-9]{8}(-[a-z0-9]{4}){3}-[a-z0-9]{12}', 'i'),
        BLOB_HASH = new RegExp('^[0-9a-f]{40}$');
    return {
        HASH: HASH,
        DB_HASH: DB_HASH,
        BRANCH: BRANCH,
        TAG: TAG,
        RAW_BRANCH: RAW_BRANCH,
        PROJECT: PROJECT,
        DOCUMENT_KEY: DOCUMENT_KEY,
        GUID: GUID,
        INVALID_CSS_CHARS: INVALID_CSS_CHARS,
        HTML_ELEMENT: HTML_ELEMENT,
        PROJECT_NAME: PROJECT_NAME,
        BLOB_HASH: BLOB_HASH
    };
});

/*globals define*/
/*eslint-env node, browser*/

/**
 * This is a partial implementation of RFC 6902
 * the generated patch is fully compliant though the
 * patch generation is specialized to the expected input form.
 *
 * @author kecso / https://github.com/kecso
 */

define('common/util/jsonPatcher',[
    'common/util/canon',
    'common/util/random',
    'common/core/constants',
    'common/regexp'
], function (CANON, RANDOM, CORE_CONSTANTS, REGEXP) {

    'use strict';

    var MIN_RELID_LENGTH_PATH = CORE_CONSTANTS.PATH_SEP + CORE_CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY;

    function _strEncode(str) {
        //we should replace the '/' in the patch paths
        return str.replace(/\//g, '%2f');
    }

    function _strDecode(str) {
        return str.replace(/%2f/g, '/');
    }

    // function _endsWith(str, pattern) {
    //     var d = str.length - pattern.length;
    //     return d >= 0 && str.lastIndexOf(pattern) === d;
    // }

    function _startsWith(str, pattern) {
        return str.indexOf(pattern) === 0;
    }

    function _isOvr(path) {
        return path.indexOf('/ovr') === 0;
    }

    function _isRelid(path) {
        return RANDOM.isValidRelid(path.substring(1));
    }

    function _isGmePath(path) {
        if (typeof path !== 'string') {
            return false;
        }

        if (path === '') {
            return true;
        }

        var relIds = path.split('/'),
            result = false,
            i;

        for (i = 1; i < relIds.length; i += 1) {
            if (RANDOM.isValidRelid(relIds[i]) === false) {
                return false;
            } else {
                result = true;
            }
        }

        return result;
    }

    function diff(source, target, basePath, excludeList, noUpdate, innerPath, overlay, inOverlay) {
        var result = [],
            patchItem,
            path,
            i;

        //add
        for (i in target) {
            if (excludeList.indexOf(i) === -1 && target.hasOwnProperty(i)) {
                if (!source.hasOwnProperty(i)) {
                    patchItem = {
                        op: 'add',
                        path: basePath + _strEncode(i),
                        value: target[i]
                    };

                    if (inOverlay || overlay) {
                        patchItem.partialUpdates = [];
                        patchItem.updates = [];
                        if (inOverlay) {
                            if (_isGmePath(innerPath)) {
                                patchItem.updates.push(innerPath);
                            }
                            if (_isGmePath(target[i])) {
                                patchItem.partialUpdates.push(target[i]);
                            }
                        } else {
                            if (_isGmePath(i)) {
                                patchItem.updates.push(i);
                            }
                            for (path in target[i]) {
                                if (_isGmePath(target[i][path])) {
                                    patchItem.partialUpdates.push(target[i][path]);
                                }
                            }
                        }
                    }

                    result.push(patchItem);
                }
            }
        }

        //replace
        if (!noUpdate) {
            for (i in target) {
                if (excludeList.indexOf(i) === -1 && target.hasOwnProperty(i)) {
                    if (source.hasOwnProperty(i) && CANON.stringify(source[i]) !== CANON.stringify(target[i])) {
                        patchItem = {
                            op: 'replace',
                            path: basePath + _strEncode(i),
                            value: target[i]
                            //oldValue: source[i]
                        };

                        if (inOverlay) {
                            patchItem.partialUpdates = [];
                            patchItem.updates = [];
                            if (_isGmePath(innerPath)) {
                                patchItem.updates.push(innerPath);
                            }

                            if (_isGmePath(target[i])) {
                                patchItem.partialUpdates.push(target[i]);
                            }

                            if (_isGmePath(source[i])) {
                                patchItem.partialUpdates.push(source[i]);
                            }
                        }

                        result.push(patchItem);
                    }
                }
            }
        }

        //remove
        for (i in source) {
            if (excludeList.indexOf(i) === -1 && source.hasOwnProperty(i)) {
                if (!target.hasOwnProperty(i)) {
                    patchItem = {
                        op: 'remove',
                        path: basePath + _strEncode(i)
                        //oldValue: source[i]
                    };

                    if (inOverlay || overlay) {
                        patchItem.partialUpdates = [];
                        patchItem.updates = [];
                        if (inOverlay) {
                            if (_isGmePath(innerPath)) {
                                patchItem.updates.push(innerPath);
                            }
                            if (_isGmePath(source[i])) {
                                patchItem.partialUpdates.push(source[i]);
                            }
                        } else {
                            if (_isGmePath(i)) {
                                patchItem.updates.push(i);
                            }
                            for (path in source[i]) {
                                if (_isGmePath(source[i][path])) {
                                    patchItem.partialUpdates.push(source[i][path]);
                                }
                            }
                        }
                    }

                    result.push(patchItem);
                }
            }
        }

        return result;
    }

    function _isEmptyObject(object) {
        for (var key in object) {
            return false;
        }
        return true;
    }

    function wholeShardDiff(items, isAddition) {
        var patchItem = {
                updates: [],
                partialUpdates: []
            },
            source,
            name;

        patchItem.op = 'replace';
        patchItem.path = '/items';

        if (isAddition) {
            patchItem.value = items;
        } else {
            patchItem.value = {};
        }

        for (source in items) {
            patchItem.updates.push(source);
            for (name in items[source]) {
                if (_isGmePath(items[source][name])) {
                    patchItem.partialUpdates.push(items[source][name]);
                }
            }
        }

        return patchItem;
    }

    function overlayShardDiff(sourceJson, targetJson) {
        var patch,
            key,
            sourceEmpty = _isEmptyObject(sourceJson.items || {}),
            targetEmpty = _isEmptyObject(targetJson.items || {});

        patch = diff(sourceJson, targetJson, '/', ['_id', 'type', 'items'], false, '', false, false);

        if (sourceEmpty && targetEmpty) {
            // Do nothing as nothing have changed
        } else if (sourceEmpty) {
            patch.push(wholeShardDiff(targetJson.items, true));
        } else if (targetEmpty) {
            patch.push(wholeShardDiff(sourceJson.items, false));
        } else {
            patch = patch
                .concat(diff(sourceJson.items || {}, targetJson.items || {}, '/items/', [], true, '', true, false));
            for (key in sourceJson.items) {
                if (targetJson.items.hasOwnProperty(key)) {
                    patch = patch.concat(diff(
                        sourceJson.items[key],
                        targetJson.items[key],
                        '/items/' + _strEncode(key) + '/',
                        [],
                        false,
                        key,
                        false,
                        true));
                }
            }
        }

        return patch;
    }

    function getShardingDiff(commonOverlay, shardedOverlay) {
        var patchItem = {
            op: 'replace',
            path: '/ovr',
            value: shardedOverlay,
            preShardRelations: commonOverlay
        };

        return patchItem;
    }

    function create(sourceJson, targetJson) {
        var patch,
            patchItem,
            diffRes,
            i,
            key;

        //if it is an overlay shard, we make a more simple diff
        if (sourceJson.type === 'shard' && targetJson.type === 'shard') {
            return overlayShardDiff(sourceJson, targetJson);
        }

        //main level diff
        patch = diff(sourceJson, targetJson, '/', ['_id', 'ovr', 'atr', 'reg', '_sets'], false, '', false, false);

        //atr
        if (sourceJson.atr && targetJson.atr) {
            patch = patch.concat(diff(sourceJson.atr, targetJson.atr, '/atr/', [], false, '', false, false));
        } else if (sourceJson.atr) {
            patch.push({
                op: 'remove',
                path: '/atr'
            });
        } else if (targetJson.atr) {
            patch.push({
                op: 'add',
                path: '/atr',
                value: targetJson.atr
            });
        }

        //reg
        if (sourceJson.reg && targetJson.reg) {
            patch = patch.concat(diff(sourceJson.reg, targetJson.reg, '/reg/', [], false, '', false, false));
        } else if (sourceJson.reg) {
            patch.push({
                op: 'remove',
                path: '/reg'
            });
        } else if (targetJson.reg) {
            patch.push({
                op: 'add',
                path: '/reg',
                value: targetJson.reg
            });
        }

        //_sets
        if (sourceJson._sets && targetJson._sets) {
            patch = patch.concat(diff(sourceJson._sets, targetJson._sets, '/_sets/', [], true, '', false, false));
            for (key in targetJson._sets) {
                if (sourceJson._sets[key]) {
                    patch = patch.concat(diff(
                        sourceJson._sets[key],
                        targetJson._sets[key],
                        '/_sets/' + _strEncode(key) + '/',
                        [],
                        false,
                        '',
                        false,
                        false));
                }
            }
        } else if (sourceJson._sets) {
            patch.push({
                op: 'remove',
                path: '/_sets'
            });
        } else if (targetJson._sets) {
            patch.push({
                op: 'add',
                path: '/_sets',
                value: targetJson._sets
            });
        }

        //ovr
        if (sourceJson.ovr && targetJson.ovr) {
            if (sourceJson.ovr.sharded !== true && targetJson.ovr.sharded === true) {
                // Transformation into sharded overlays means that we have to collect update information.
                patch.push(getShardingDiff(sourceJson.ovr, targetJson.ovr));
            } else if (sourceJson.ovr.sharded === true && targetJson.ovr.sharded === true) {
                patch = patch.concat(diff(sourceJson.ovr, targetJson.ovr, '/ovr/', [], false, '', true, false));
            } else {
                patch = patch.concat(diff(sourceJson.ovr, targetJson.ovr, '/ovr/', [], true, '', true, false));
                for (key in targetJson.ovr) {
                    if (sourceJson.ovr[key]) {
                        patch = patch.concat(diff(
                            sourceJson.ovr[key],
                            targetJson.ovr[key],
                            '/ovr/' + _strEncode(key) + '/',
                            [],
                            false,
                            key,
                            false,
                            true));
                    }
                }
            }
        } else if (sourceJson.ovr || targetJson.ovr) {
            patchItem = {
                path: '/ovr',
                partialUpdates: [],
                updates: []
            };

            if (sourceJson.ovr) {
                patchItem.op = 'remove';
            } else {
                patchItem.op = 'add';
                patchItem.value = targetJson.ovr;
            }

            // For ovr removal/addition we need to compute updates/partialUpdates
            diffRes = diff(sourceJson.ovr || {}, targetJson.ovr || {}, '/ovr/', [], true, '', true, false);
            for (i = 0; i < diffRes.length; i += 1) {
                patchItem.partialUpdates = patchItem.partialUpdates.concat(diffRes[i].partialUpdates);
                patchItem.updates = patchItem.updates.concat(diffRes[i].updates);
            }

            patch.push(patchItem);
        }

        return patch;
    }

    function apply(sourceJson, patch) {
        var targetJson = JSON.parse(JSON.stringify(sourceJson)),
            i, j,
            badOperation = false,
            pathArray,
            key,
            parent,
            result = {
                status: 'success',
                faults: [],
                patch: patch,
                result: targetJson
            };

        for (i = 0; i < patch.length; i += 1) {
            pathArray = (patch[i].path + '').split('/').slice(1);
            parent = targetJson;

            for (j = 0; j < pathArray.length; j += 1) {
                pathArray[j] = _strDecode(pathArray[j]);
            }
            key = pathArray.pop();
            badOperation = false;
            switch (patch[i].op) {
                case 'remove':
                    if (typeof patch[i].path === 'string') {
                        for (j = 0; j < pathArray.length; j += 1) {
                            if (!parent[pathArray[j]]) {
                                badOperation = true;
                                break;
                            }
                            parent = parent[pathArray[j]];
                        }
                        if (!badOperation && parent[key] !== undefined) {
                            delete parent[key];
                        } else {
                            result.status = 'fail';
                            result.faults.push(patch[i]);
                        }
                    } else {
                        result.status = 'fail';
                        result.faults.push(patch[i]);
                    }
                    break;
                case 'add':
                    if (typeof patch[i].path === 'string' && patch[i].value !== undefined) {
                        for (j = 0; j < pathArray.length; j += 1) {
                            if (!parent[pathArray[j]]) {
                                parent[pathArray[j]] = {};
                            }
                            parent = parent[pathArray[j]];
                        }
                        parent[key] = patch[i].value;

                    } else {
                        result.status = 'fail';
                        result.faults.push(patch[i]);
                    }
                    break;
                case 'replace':
                    if (typeof patch[i].path === 'string' && patch[i].value !== undefined) {
                        for (j = 0; j < pathArray.length; j += 1) {
                            if (!parent[pathArray[j]]) {
                                badOperation = true;
                                break;
                            }
                            parent = parent[pathArray[j]];
                        }
                        if (!badOperation && parent[key] !== undefined) {
                            parent[key] = patch[i].value;
                        } else {
                            result.status = 'fail';
                            result.faults.push(patch[i]);
                        }
                    } else {
                        result.status = 'fail';
                        result.faults.push(patch[i]);
                    }
                    break;
                default:
                    result.status = 'fail';
                    result.faults.push(patch[i]);
                    break;
            }
        }

        return result;
    }

    function _inLoadOrUnload(res, gmePath) {
        var pathPieces = gmePath.split('/'),
            parentPath;

        parentPath = gmePath;

        do {
            if (res.load[parentPath] || res.unload[parentPath]) {
                return true;
            }

            pathPieces.pop();
            parentPath = pathPieces.join('/');
        } while (pathPieces.length > 1);

        return false;
    }

    function _removeFromUpdates(res, gmePath) {
        var updatesPath,
            i;

        updatesPath = Object.keys(res.update);
        for (i = 0; i < updatesPath; i += 1) {
            if (_startsWith(updatesPath[i], gmePath)) {
                delete res.update[gmePath];
            }
        }

        updatesPath = Object.keys(res.partialUpdate);
        for (i = 0; i < updatesPath; i += 1) {
            if (_startsWith(updatesPath[i], gmePath)) {
                delete res.partialUpdate[gmePath];
            }
        }
    }

    function _isShardChange(patchItem) {
        if (!_isOvr(patchItem.path)) {
            return false;
        }

        if (patchItem.op === 'add' || patchItem.op === 'replace') {
            return REGEXP.HASH.test(patchItem.value);
        }
    }

    function _getChangedNodesFromShard(patch, res, hash, gmePath) {
        var shardPatch = patch[hash] && patch[hash].patch ? patch[hash] && patch[hash].patch : patch[hash],
            source,
            name,
            i, j,
            absGmePath;

        if (!shardPatch) {
            return;
        }

        if (shardPatch instanceof Array) {
            // patch objects
            for (i = 0; i < shardPatch.length; i += 1) {
                if (shardPatch[i].updates instanceof Array) {
                    for (j = 0; j < shardPatch[i].updates.length; j += 1) {
                        absGmePath = gmePath + shardPatch[i].updates[j];
                        if (_inLoadOrUnload(res, absGmePath) === false) {
                            res.update[absGmePath] = true;
                        }
                    }
                }

                if (shardPatch[i].partialUpdates instanceof Array) {
                    for (j = 0; j < shardPatch[i].partialUpdates.length; j += 1) {
                        absGmePath = gmePath + shardPatch[i].partialUpdates[j];
                        if (_inLoadOrUnload(res, absGmePath) === false) {
                            res.partialUpdate[absGmePath] = true;
                        }
                    }
                }
            }
        } else {
            // completely new shard
            for (source in shardPatch.items || {}) {
                for (name in shardPatch.items[source]) {
                    absGmePath = gmePath + source;
                    if (_inLoadOrUnload(res, absGmePath) === false) {
                        res.update[absGmePath] = true;
                    }

                    absGmePath = gmePath + shardPatch.items[source][name];
                    if (_inLoadOrUnload(res, absGmePath) === false) {
                        res.partialUpdate[absGmePath] = true;
                    }
                }
            }
        }
    }

    function _getChangedNodesFromSharding(patch, patchItem, res, gmePath) {
        var shards = [],
            shardId,
            absGmePath,
            preShardRelations = patchItem.preShardRelations,
            foundSource,
            source,
            name,
            i;

        for (shardId in patchItem.value) {
            if (REGEXP.HASH.test(patchItem.value[shardId])) {
                if (patch[patchItem.value[shardId]]) {
                    shards.push(patch[patchItem.value[shardId]]);
                }
            }
        }

        // First handle those relations where we have the source in both states
        for (source in preShardRelations) {
            foundSource = false;
            for (i = 0; i < shards.length; i += 1) {
                if (shards[i].items.hasOwnProperty(source)) {
                    foundSource = true;
                    // check the removal and updates
                    for (name in preShardRelations[source]) {
                        if (shards[i].items[source].hasOwnProperty(name)) {
                            if (shards[i].items[source][name] !== preShardRelations[source][name]) {
                                // update
                                absGmePath = gmePath + source;
                                if (_inLoadOrUnload(res, absGmePath) === false) {
                                    res.update[absGmePath] = true;
                                }

                                if (_isGmePath(preShardRelations[source][name])) {
                                    absGmePath = gmePath + preShardRelations[source][name];
                                    if (_inLoadOrUnload(res, absGmePath) === false) {
                                        res.partialUpdate[absGmePath] = true;
                                    }
                                }

                                if (_isGmePath(shards[i].items[source][name])) {
                                    absGmePath = gmePath + shards[i].items[source][name];
                                    if (_inLoadOrUnload(res, absGmePath) === false) {
                                        res.partialUpdate[absGmePath] = true;
                                    }
                                }
                            }
                        } else {
                            // remove
                            absGmePath = gmePath + source;
                            if (_inLoadOrUnload(res, absGmePath) === false) {
                                res.update[absGmePath] = true;
                            }

                            if (_isGmePath(preShardRelations[source][name])) {
                                absGmePath = gmePath + preShardRelations[source][name];
                                if (_inLoadOrUnload(res, absGmePath) === false) {
                                    res.partialUpdate[absGmePath] = true;
                                }
                            }
                        }
                    }

                    // check additions
                    for (name in shards[i].items[source]) {
                        if (preShardRelations[source].hasOwnProperty(name) === false) {
                            absGmePath = gmePath + source;
                            if (_inLoadOrUnload(res, absGmePath) === false) {
                                res.update[absGmePath] = true;
                            }

                            if (_isGmePath(shards[i].items[source][name])) {
                                absGmePath = gmePath + shards[i].items[source][name];
                                if (_inLoadOrUnload(res, absGmePath) === false) {
                                    res.partialUpdate[absGmePath] = true;
                                }
                            }
                        }
                    }
                    break;
                }
            }

            if (!foundSource) {
                // All relations from this source was removed
                absGmePath = gmePath + source;
                if (_inLoadOrUnload(res, absGmePath) === false) {
                    res.update[absGmePath] = true;
                }

                for (name in preShardRelations[source]) {
                    if (preShardRelations[source][name] instanceof Array) {
                        // Sharding from v < 1 with inverse relations stored.
                        continue;
                    }
                    absGmePath = gmePath + preShardRelations[source][name];
                    if (_inLoadOrUnload(res, absGmePath) === false) {
                        res.partialUpdate[absGmePath] = true;
                    }
                }
            }
        }

        // Finally check for completely new sources
        for (i = 0; i < shards.length; i += 1) {
            for (source in shards[i].items) {
                if (preShardRelations.hasOwnProperty(source) === false) {
                    // All relations from this source was removed
                    absGmePath = gmePath + source;
                    if (_inLoadOrUnload(res, absGmePath) === false) {
                        res.update[absGmePath] = true;
                    }

                    for (name in shards[i].items[source]) {
                        absGmePath = gmePath + shards[i].items[source][name];
                        if (_inLoadOrUnload(res, absGmePath) === false) {
                            res.partialUpdate[absGmePath] = true;
                        }
                    }
                }
            }
        }
    }

    function _getChangedNodesRec(patch, res, hash, gmePath) {
        var nodePatches = patch[hash] && patch[hash].patch, // Changes regarding node with hash
            i, j,
            ownChange = false,
            absGmePath,
            patchPath,
            subPath,
            pathPieces;

        if (!nodePatches) {
            // E.g. if the node was added the full data is given instead of a patch.
            return;
        }

        for (i = 0; i < nodePatches.length; i += 1) {
            patchPath = nodePatches[i].path;

            if (nodePatches[i].op === 'replace' && typeof nodePatches[i].preShardRelations === 'object') {
                //special case when the overlay is converted
                _getChangedNodesFromSharding(patch, nodePatches[i], res, gmePath);
            } else if (_isShardChange(nodePatches[i])) {
                _getChangedNodesFromShard(patch, res, nodePatches[i].value, gmePath);
            } else if (_isOvr(patchPath) === true) {
                // Now handle the updates
                for (j = 0; j < nodePatches[i].partialUpdates.length; j += 1) {
                    absGmePath = gmePath + nodePatches[i].partialUpdates[j];
                    if (_inLoadOrUnload(res, absGmePath) === false) {
                        res.partialUpdate[absGmePath] = true;
                    }
                }

                for (j = 0; j < nodePatches[i].updates.length; j += 1) {
                    absGmePath = gmePath + nodePatches[i].updates[j];
                    if (_inLoadOrUnload(res, absGmePath) === false) {
                        res.update[absGmePath] = true;
                    }
                }

                // #1438 This will capture set-owner updates.
                subPath = _strDecode(patchPath.substring('/ovr/'.length));
                pathPieces = subPath.split('/');
                if (pathPieces.length >= 3 && pathPieces[2] === CORE_CONSTANTS.ALL_SETS_PROPERTY) {
                    // Original path looks something like /ovr/<nodePath>/_sets/...
                    absGmePath = gmePath + '/' + pathPieces[1];

                    if (_isGmePath(absGmePath) && _inLoadOrUnload(res, absGmePath) === false) {
                        res.update[absGmePath] = true;
                    }
                }
            } else if (_isRelid(patchPath) === true) {
                // There was a change in one of the children..
                switch (nodePatches[i].op) {
                    case 'add':
                        res.load[gmePath + patchPath] = true;
                        _removeFromUpdates(res, gmePath + patchPath);
                        break;
                    case 'remove':
                        res.unload[gmePath + patchPath] = true;
                        _removeFromUpdates(res, gmePath + patchPath);
                        break;
                    case 'replace':
                        _getChangedNodesRec(patch, res, nodePatches[i].value, gmePath + patchPath);
                        break;
                    default:
                        throw new Error('Unexpected patch operation ' + nodePatches[i]);
                }
            } else if (patchPath !== MIN_RELID_LENGTH_PATH && patchPath !== '/__v') {
                ownChange = true;
            }
        }

        if (ownChange) {
            res.update[gmePath] = true;
        }
    }

    /**
     *
     * @param {object} patch
     * @returns {object}
     */
    // TODO check if all event related information could be set during patch creation,
    // so this function would only collect those information.
    function getChangedNodes(patch, rootHash) {
        var res;

        if (patch[rootHash] && patch[rootHash].patch) {
            res = {
                load: {},
                unload: {},
                update: {},
                partialUpdate: {}
            };

            _getChangedNodesRec(patch, res, rootHash, '');
        } else {
            res = null;
        }

        return res;
    }

    return {
        create: create,
        apply: apply,
        getChangedNodes: getChangedNodes
    };
});
/*eslint-disable*/
//SHA1 in Javascript 862 bytes, MIT License, http://antimatter15.com/
define('common/util/sha1',[],function() {
return function(l){function p(b,a){return b<<a|b>>>32-a}l+="";for(var n=Math,c=[1518500249,1859775393,2400959708,3395469782,1732584193,4023233417,2562383102,271733878,3285377520,4294967295],s=n.ceil(l.length/4)+2,q=n.ceil(s/16),g=[],a=0,h=[],j,d,e,f,m,i,b,k;a<q;a++){g[a]=[];for(k=0;k<16;k++){function o(b,c){return l.charCodeAt(a*64+k*4+b)<<c}g[a][k]=o(0,24)|o(1,16)|o(2,8)|o(3,0)}}i=l.length*8-8;a=q-1;g[a][14]=i/(c[9]+1);g[a][14]=n.floor(g[a][14]);g[a][15]=i&c[9];for(a=0;a<q;a++){for(b=0;b<16;b++)h[b]=g[a][b];for(b=16;b<80;b++)h[b]=p(h[b-3]^h[b-8]^h[b-14]^h[b-16],1);j=c[4];d=c[5];e=c[6];f=c[7];m=c[8];for(b=0;b<80;b++){var r=n.floor(b/20),t=p(j,5)+(r<1?d&e^~d&f:r==2?d&e^d&f^e&f:d^e^f)+m+c[r]+h[b]&c[9];m=f;f=e;e=p(d,30);d=j;j=t}c[4]+=j;c[5]+=d;c[6]+=e;c[7]+=f;c[8]+=m}i="";for(z=4;z<9;z++)for(a=7;a>=0;a--)i+=((c[z]&c[9])>>>a*4&15).toString(16);return i};
});

/*globals define, requirejs, wasm_bindgen*/
/*eslint-env node, browser*/
/*eslint camelcase: 0*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/util/key',[
    'common/util/sha1',
    'common/util/assert',
    'common/util/canon'
], function (generateSHA1, ASSERT, CANON) {
    'use strict';

    var wasm_node = null;
    function run() {
        requirejs(['common/util/rust/sha1/web/wasm-sha1'], function () {
            wasm_bindgen('common/util/rust/sha1/web/wasm-sha1_bg.wasm')
                .then(function () {
                    //nothing to do as wasm_bindgen holds the key
                });
        });
    }

    if (typeof window !== 'undefined') {
        run();
    } else {
        //TODO why does it have to be static full path???
        const path = require('path');
        wasm_node = require(
            path.join(requirejs.s.contexts._.config.baseUrl, 'common/util/rust/sha1/node/wasm-sha1-node')
        );
    }

    function rand160Bits() {
        var result = '',
            i, code;
        for (i = 0; i < 40; i++) {
            code = Math.floor(Math.random() * 16);
            code = code > 9 ? code + 87 : code + 48;
            result += String.fromCharCode(code);
        }
        return result;
    }

    return function KeyGenerator(object, gmeConfig) {
        const keyType = gmeConfig.storage.keyType;
        ASSERT(typeof keyType === 'string');

        switch (keyType) {
            case 'rand160Bits':
                return rand160Bits();
            case 'rustSHA1':
                if (wasm_node) {
                    return wasm_node.hash(CANON.stringify(object));
                } else {
                    return wasm_bindgen.hash(CANON.stringify(object));
                }
            default: //plainSHA1
                return generateSHA1(CANON.stringify(object));
        }
    };
});

/*globals define*/
/*eslint-env node, browser*/
/**
 * @author lattmann / https://github.com/lattmann
 */

define('common/storage/util',[
    'common/storage/constants',
    'common/util/jsonPatcher',
    'q',
    'common/regexp',
    'common/util/key'
], function (CONSTANTS, jsonPatcher, Q, REGEXP, generateKey) {
    'use strict';

    /**
     * @param {ProjectInterface} project
     * @param {object} parameters - If more than one is given, the order of precedence is:
     * branchName, commitHash, tagName and rootHash.
     * @param {string} [parameters.rootHash] - The hash of the tree root.
     * @param {string} [parameters.commitHash] - The tree associated with the commitHash.
     * @param {string} [parameters.tagName] - The tree at the given tag.
     * @param {string} [parameters.branchName] - The tree at the given branch.
     * @param {function} [callback]
     * @returns {Promise}
     */
    function getRootHash(project, parameters, callback) {
        var deferred = Q.defer();

        if (parameters.branchName) {
            Q.ninvoke(project, 'getBranchHash', parameters.branchName)
                .then(function (commitHash) {
                    parameters.commitHash = commitHash;
                    return Q.ninvoke(project, 'loadObject', commitHash);
                })
                .then(function (commitObject) {
                    parameters.rootHash = commitObject.root;
                    deferred.resolve(commitObject.root);
                })
                .catch(deferred.reject);
        } else if (parameters.commitHash) {
            Q.ninvoke(project, 'loadObject', parameters.commitHash)
                .then(function (commitObject) {
                    parameters.rootHash = commitObject.root;
                    deferred.resolve(commitObject.root);
                })
                .catch(deferred.reject);
        } else if (parameters.tagName) {
            Q.ninvoke(project, 'getTags')
                .then(function (tags) {
                    if (tags[parameters.tagName]) {
                        parameters.commitHash = tags[parameters.tagName];
                        return Q.ninvoke(project, 'loadObject', tags[parameters.tagName]);
                    } else {
                        throw new Error('Unknown tag name [' + parameters.tagName + ']');
                    }
                })
                .then(function (commitObject) {
                    parameters.rootHash = commitObject.root;
                    deferred.resolve(commitObject.root);
                })
                .catch(deferred.reject);
        } else if (parameters.rootHash) {
            deferred.resolve(parameters.rootHash);
        } else {
            deferred.reject(new Error('No valid input was given to search for rootHash'));
        }

        return deferred.promise.nodeify(callback);
    }

    function _collectObjects(project, objectHashArray) {
        var deferred = Q.defer(),
            promises = [],
            objects = [],
            i;

        for (i = 0; i < objectHashArray.length; i += 1) {
            promises.push(Q.ninvoke(project, 'loadObject', objectHashArray[i]));
        }

        Q.allSettled(promises)
            .then(function (results) {
                var error = null,
                    i;
                for (i = 0; i < results.length; i += 1) {
                    if (results[i].state === 'fulfilled') {
                        objects.push(results[i].value);
                    } else {
                        error = error || results[i].reason || new Error('unable to load');
                    }
                }

                if (error) {
                    deferred.reject(error);
                } else {
                    deferred.resolve(objects);
                }
            });
        return deferred.promise;
    }

    function _collectObjectAndAssetHashes(project, rootHash) {
        var deferred = Q.defer(),
            objects = {},
            assets = {},
            queue = [rootHash],
            task,
            error = null,
            working = false,
            timerId;

        timerId = setInterval(function () {
            if (!working) {
                task = queue.shift();
                if (task === undefined) {
                    clearInterval(timerId);
                    if (error) {
                        deferred.reject(error);
                    } else {
                        deferred.resolve({objects: Object.keys(objects), assets: Object.keys(assets)});
                    }
                    return;
                }

                if (!objects[task]) {
                    working = true;
                    project.loadObject(task, function (err, object) {
                        var key;

                        error = error || err;
                        if (!err && object) {
                            objects[task] = true;
                            if (object) {
                                //now put every sub-object on top of the queue
                                for (key in object) {
                                    if (typeof object[key] === 'string' && REGEXP.HASH.test(object[key])) {
                                        queue.push(object[key]);
                                    }
                                }

                                //looking for assets
                                if (object.atr) {
                                    for (key in object.atr) {
                                        //TODO why can't we inlcude BlobConfig???
                                        if (typeof object.atr[key] === 'string' &&
                                            REGEXP.BLOB_HASH.test(object.atr[key])) {
                                            assets[object.atr[key]] = true;
                                        }
                                    }
                                }

                                //checking if the node has a sharded overlay, we do not load the shards, yet
                                if (object.ovr && object.ovr.sharded === true) {
                                    for (key in object.ovr) {
                                        if (typeof object.ovr[key] === 'string' &&
                                            REGEXP.HASH.test(object.ovr[key])) {
                                            objects[object.ovr[key]] = true;
                                        }
                                    }
                                }
                            }
                        }
                        working = false;
                    });
                }

            }
        }, 1);

        return deferred.promise;
    }

    return {
        CONSTANTS: CONSTANTS,
        getProjectFullNameFromProjectId: function (projectId) {
            if (projectId) {
                return projectId.replace(CONSTANTS.PROJECT_ID_SEP, CONSTANTS.PROJECT_DISPLAYED_NAME_SEP);
            }
        },
        getProjectDisplayedNameFromProjectId: function (projectId) {
            if (projectId) {
                return projectId.replace(CONSTANTS.PROJECT_ID_SEP, ' ' + CONSTANTS.PROJECT_DISPLAYED_NAME_SEP + ' ');
            }
        },
        getProjectIdFromProjectFullName: function (projectFullName) {
            if (projectFullName) {
                return projectFullName.replace(CONSTANTS.PROJECT_DISPLAYED_NAME_SEP, CONSTANTS.PROJECT_ID_SEP);
            }
        },
        getProjectIdFromOwnerIdAndProjectName: function (userId, projectName) {
            return userId + CONSTANTS.PROJECT_ID_SEP + projectName;
        },
        getProjectNameFromProjectId: function (projectId) {
            if (projectId) {
                return projectId.substring(projectId.indexOf(CONSTANTS.PROJECT_ID_SEP) + 1);
            }
        },
        getOwnerFromProjectId: function (projectId) {
            if (projectId) {
                return projectId.substring(0, projectId.indexOf(CONSTANTS.PROJECT_ID_SEP));
            }
        },
        getHashTaggedHash: function (hash) {
            if (typeof hash === 'string') {
                return hash[0] === '#' ? hash : '#' + hash;
            }
            return hash;
        },
        getPatchObject: function (oldData, newData) {
            var patchObject = {
                type: 'patch',
                base: oldData[CONSTANTS.MONGO_ID],
                patch: jsonPatcher.create(oldData, newData)
            };
            patchObject[CONSTANTS.MONGO_ID] = newData[CONSTANTS.MONGO_ID];

            return patchObject;
        },
        coreObjectHasOldAndNewData: function (coreObj) {
            return !!(coreObj.oldHash && coreObj.newHash && coreObj.oldData && coreObj.newData);
        },
        getChangedNodes: jsonPatcher.getChangedNodes,
        applyPatch: jsonPatcher.apply,
        checkHashConsistency: function (gmeConfig, dataObj, hash) {
            var result;

            if (gmeConfig.storage.keyType === 'rand160Bits') {
                // Random hashes should not be checked.
                result = true;
            } else if (gmeConfig.storage.disableHashChecks === true) {
                // Configured to not check.
                result = true;
            } else {
                dataObj[CONSTANTS.MONGO_ID] = '';
                result = hash === '#' + generateKey(dataObj, gmeConfig);
            }

            return result;
        },

        /**
         * Extracts a serializable json representation of a project tree.
         * To specify starting point set one of the four options. If more than one is set the order of precedence is:
         * branchName, commitHash, tagName and rootHash.
         *
         * @param {ProjectInterface} project
         * @param {object} parameters - Specifies which project tree should be serialized:
         * @param {string} [parameters.rootHash] - The hash of the tree root.
         * @param {string} [parameters.commitHash] - The tree associated with the commitHash.
         * @param {string} [parameters.tagName] - The tree at the given tag.
         * @param {string} [parameters.branchName] - The tree at the given branch.
         * @param {string} [parameters.kind] - If not given will assign the one in project.
         * @param {function} callback
         */
        getProjectJson: function (project, parameters, callback) {
            var deferred = Q.defer(),
                rawJson;

            getRootHash(project, parameters || {})
                .then(function (rootHash) {
                    return Q.all([
                        _collectObjectAndAssetHashes(project, rootHash),
                        project.getProjectInfo()
                    ]);
                })
                .then(function (res) {
                    var hashes = res[0],
                        info = res[1];
                    rawJson = {
                        rootHash: parameters.rootHash,
                        projectId: project.projectId,
                        kind: typeof parameters.kind === 'string' ? parameters.kind : info.info.kind,
                        branchName: parameters.branchName,
                        commitHash: parameters.commitHash,
                        hashes: hashes,
                        objects: null
                    };
                    return _collectObjects(project, hashes.objects);
                })
                .then(function (objects) {
                    rawJson.objects = objects;
                    deferred.resolve(rawJson);
                })
                .catch(deferred.reject);

            return deferred.promise.nodeify(callback);
        },

        /**
         * Inserts a serialized project tree into the storage and associates it with a commitHash.
         *
         * @param {ProjectInterface} project
         * @param {object} [options]
         * @param {string} [options.branch] - Name of branch to update
         * @param {string} [options.parentCommit] - Array of parents for new commit
         * @param {string} [options.commitMessage=%defaultCommitMessage%] information about the insertion
         * @param {function(Error, hashes)} callback
         */
        insertProjectJson: function (project, projectJson, options, callback) {
            var deferred = Q.defer(),
                toPersist = {},
                rootHash = projectJson.rootHash,
                defaultCommitMessage = 'Importing contents of [' +
                    projectJson.projectId + '@' + rootHash + ']',
                objects = projectJson.objects,
                i;

            for (i = 0; i < objects.length; i += 1) {
                // we have to patch the object right before import, for smoother usage experience
                toPersist[objects[i]._id] = objects[i];
            }

            options = options || {};

            options.branch = options.branch || null;
            options.parentCommit = options.parentCommit || [];

            project.makeCommit(options.branch, options.parentCommit,
                rootHash, toPersist, options.commitMessage || defaultCommitMessage)
                .then(function (commitResult) {
                    deferred.resolve(commitResult);
                })
                .catch(deferred.reject);

            return deferred.promise.nodeify(callback);
        },
        getRootHash: getRootHash
    };
});

/*globals define*/
/*eslint-env node, browser*/
/**
 * This class (extracted functionality from cache implemented by mmaroti) caches objects associated
 * with a project.
 *
 * @author pmeijer / https://github.com/pmeijer
 * @author kecso / https://github.com/kecso
 * @author mmaroti / https://github.com/mmaroti
 */

define('common/storage/project/cache',[
    'common/util/assert',
    'common/storage/constants',
    'common/storage/util'
], function (ASSERT, CONSTANTS, UTIL) {
    'use strict';
    function ProjectCache(storage, projectId, mainLogger, gmeConfig) {
        var self = this,
            backup = {},
            cache = {},
            ongoingObjectRequests = {},
            ongoingPathsRequests = {},
            logger = mainLogger.fork('ProjectCache'),
            cacheSize = 0;

        logger.debug('ctor', projectId);

        this.queuedPersists = {};

        // Useful for debugging potential mutations, but not good for performance.
        function deepFreeze(obj) {
            Object.freeze(obj);

            if (obj instanceof Array) {
                for (var i = 0; i < obj.length; i += 1) {
                    if (obj[i] !== null && typeof obj[i] === 'object') {
                        deepFreeze(obj[i]);
                    }
                }
            } else {
                for (var key in obj) {
                    if (obj[key] !== null && typeof obj[key] === 'object') {
                        deepFreeze(obj[key]);
                    }
                }
            }
        }

        function cacheInsert(key, obj) {
            ASSERT(obj[CONSTANTS.MONGO_ID] === key);
            logger.debug('cacheInsert', key);

            if (gmeConfig.storage.freezeCache) {
                deepFreeze(obj);
            }

            if (!cache[key]) {
                cache[key] = obj;

                if (++cacheSize >= gmeConfig.storage.cache) {
                    logger.debug('Cache size reached - moved to backup');
                    backup = cache;
                    cache = {};
                    cacheSize = 0;
                }
                return true;
            } else {
                return false;
            }
        }

        function getFromCache(hash) {
            var obj = cache[hash],
                commitId;

            if (typeof obj === 'undefined') {
                obj = backup[hash];

                if (typeof obj === 'undefined') {
                    for (commitId in self.queuedPersists) {
                        if (self.queuedPersists.hasOwnProperty(commitId) && self.queuedPersists[commitId][hash]) {
                            obj = self.queuedPersists[commitId][hash];
                            break;
                        }
                    }
                }
            }

            return obj;
        }

        this.loadObject = function (key, callback) {
            var commitId,
                cachedObject;

            ASSERT(typeof key === 'string' && typeof callback === 'function');
            logger.debug('loadObject', {metadata: key});

            cachedObject = cache[key];
            if (typeof cachedObject === 'undefined') {
                cachedObject = backup[key];
                if (typeof cachedObject === 'undefined') {
                    for (commitId in self.queuedPersists) {
                        if (self.queuedPersists.hasOwnProperty(commitId) && self.queuedPersists[commitId][key]) {
                            cachedObject = self.queuedPersists[commitId][key];
                            break;
                        }
                    }

                    if (typeof cachedObject === 'undefined') {

                        if (typeof ongoingObjectRequests[key] === 'undefined') {
                            ongoingObjectRequests[key] = [callback];

                            logger.debug('object set to be loaded from storage', key);
                            storage.loadObject(projectId, key, function (err, loadResult) {
                                ASSERT(typeof loadResult === 'object' || typeof loadResult === 'undefined');
                                logger.debug('object loaded from database', key);
                                var callbacks,
                                    cb,
                                    subKey;

                                if ((loadResult || {}).multipleObjects === true) {
                                    for (subKey in loadResult.objects) {
                                        callbacks = ongoingObjectRequests[subKey] || [];
                                        delete ongoingObjectRequests[subKey];
                                        if (!err && loadResult.objects[subKey]) {
                                            cacheInsert(subKey, loadResult.objects[subKey]);
                                        }

                                        if (callbacks) {
                                            while ((cb = callbacks.pop())) {
                                                cb(err, loadResult.objects[subKey]);
                                            }
                                        }
                                    }
                                } else {
                                    callbacks = ongoingObjectRequests[key] || [];
                                    delete ongoingObjectRequests[key];
                                    if (!err && loadResult) {
                                        cacheInsert(key, loadResult);
                                    }

                                    while ((cb = callbacks.pop())) {
                                        cb(err, loadResult);
                                    }
                                }
                            });
                        } else {
                            logger.debug('object was already queued to be loaded', key);
                            ongoingObjectRequests[key].push(callback);
                        }
                        return;
                    } else {
                        logger.debug('object was erased from cache and backup but present in queuedPersists', key);
                        cacheInsert(key, cachedObject);
                    }
                } else {
                    logger.debug('object was in backup', key);
                    cacheInsert(key, cachedObject);
                }
            } else {
                logger.debug('object was in cache', key);
            }

            ASSERT(typeof cachedObject === 'object' &&
                cachedObject !== null &&
                cachedObject[CONSTANTS.MONGO_ID] === key);
            callback(null, cachedObject);
        };

        /**
         * Loads the necessary objects for the nodes corresponding to paths and inserts them in the cache.
         * If the rootKey is empty or does not exist - it won't attempt to load any nodes.
         *
         * Note that when the callback is called - all requested objects may or may not be in the cache. The resolving
         * of callback only indicates that between the call to loadPaths and the point of resolving - all objects have
         * been in the cache.
         *
         * @param {string} rootKey
         * @param {string[]} paths
         * @param {function(err)} callback
         */
        this.loadPaths = function (rootKey, paths, callback) {
            logger.debug('loadPaths', {metadata: {rootKey: rootKey, paths: paths}});
            var cachedObjects = {},
                excludes = [],
                pathsInfo = [],
                rootObj = getFromCache(rootKey),
                whenDone = {
                    cb: callback,
                    cnt: paths.length // When all paths are accounted for - callback will be invoked.
                },
                i,
                j,
                pathArray,
                obj,
                doRequest,
                key;

            if (!rootKey) {
                logger.debug('rootKey empty:', rootKey);
                callback(null);
                return;
            }

            // Filter out paths that are currently being requested.
            // We also need to keep track of when all requested paths are loaded
            // and make a final call to the callback at that point.
            paths = paths.filter(function (path) {
                var id = rootKey + path;
                if (ongoingPathsRequests[id]) {
                    ongoingPathsRequests[id].push(whenDone);
                    return false;
                } else {
                    return true;
                }
            });

            i = paths.length;

            if (rootObj) {
                // The root was loaded, so for each requested path we start from the root
                // and work our way down to the containment chain and add each object that is
                // already in the cache to 'excludes'.

                excludes.push(rootKey);
                cachedObjects[rootKey] = rootObj;
                while (i--) {
                    pathArray = paths[i].split('/');
                    pathArray.shift();

                    obj = rootObj;
                    doRequest = false;
                    for (j = 0; j < pathArray.length; j += 1) {
                        key = obj[pathArray[j]];
                        if (key) {
                            obj = getFromCache(key);
                            if (typeof obj !== 'undefined') {
                                excludes.push(key);
                                cachedObjects[key] = obj;
                            } else {
                                pathsInfo.push({
                                    parentHash: key,
                                    path: '/' + pathArray.slice(j + 1).join('/')
                                });
                                doRequest = true;
                                break;
                            }
                        } else {
                            // The given path does not exist anymore - break.
                            break;
                        }
                    }

                    if (doRequest) {
                        // A request is needed - therefore initialize a new entry to ongoing.
                        ongoingPathsRequests[rootKey + paths[i]] = [whenDone];
                    } else {
                        whenDone.cnt -= 1;
                        paths.splice(i, 1);
                    }
                }
            } else {
                pathsInfo = paths.map(function (path) {
                    ongoingPathsRequests[rootKey + path] = [whenDone];
                    return {
                        parentHash: rootKey,
                        path: path
                    };
                });
            }

            if (paths.length === 0) {
                logger.debug('No new paths to request.');
                if (whenDone.cnt === 0) {
                    logger.debug('All objects already in cache too.');
                    whenDone.cb(null);
                }
                return;
            }

            logger.debug('loadPaths will request from server, pathsInfo:', pathsInfo);
            storage.loadPaths(projectId, pathsInfo, excludes, function (err, serverObjects) {
                var callbacks = [],
                    keys,
                    id,
                    i;

                for (i = 0; i < paths.length; i += 1) {
                    id = rootKey + paths[i];
                    ongoingPathsRequests[id].forEach(function (doneEntry) {
                        // Account for a completed request...
                        doneEntry.cnt -= 1;
                        ASSERT(doneEntry.cnt >= 0, 'ongoingPathsRequests negative for an entry!?');
                        // if the last one for that entry - that call is completed.
                        if (doneEntry.cnt === 0) {
                            callbacks.push(doneEntry.cb);
                        }
                    });

                    // Finally clear out all entries stored for this id..
                    delete ongoingPathsRequests[id];
                }

                if (!err && serverObjects) {
                    // Insert every obtained object into the cache (that was not there before).
                    keys = Object.keys(serverObjects);
                    for (i = 0; i < keys.length; i += 1) {
                        if (!cacheInsert(keys[i], serverObjects[keys[i]])) {
                            logger.debug('Inserting same object again', keys[i]);
                        }
                    }

                    // Reinsert the cachedObjects.
                    keys = Object.keys(cachedObjects);
                    for (i = 0; i < keys.length; i += 1) {
                        cacheInsert(keys[i], cachedObjects[keys[i]]);
                    }

                    callbacks.forEach(function (cb) {
                        cb(null);
                    });
                } else {
                    logger.error('loadingPaths failed', err || new Error('no object arrived from server'));
                    callbacks.forEach(function (cb) {
                        cb(err);
                    });
                }
            });
        };

        this.insertObject = function (obj, stackedObjects) {
            ASSERT(typeof obj === 'object' && obj !== null);

            var key = obj[CONSTANTS.MONGO_ID];
            logger.debug('insertObject', {metadata: key});
            ASSERT(typeof key === 'string');

            if (cacheInsert(key, obj) === false) {
                // The storage on the server will return error if it's not the same..
                logger.debug('object inserted was already in cache');
            } else {
                var item = backup[key];

                if (typeof item !== 'undefined') {
                    // The storage on the server will return error if it's not the same..
                    logger.debug('object inserted was already in back-up');
                } else {
                    item = ongoingObjectRequests[key];
                    if (typeof item !== 'undefined') {
                        delete ongoingObjectRequests[key];

                        var cb;
                        while ((cb = item.pop())) {
                            cb(null, obj);
                        }
                    }
                }
            }
            if (stackedObjects) {
                stackedObjects[key] = obj;
            }
        };

        this.insertPatchObject = function (obj) {
            ASSERT(typeof obj === 'object' && obj !== null);

            var base,
                patch,
                key = obj[CONSTANTS.MONGO_ID];

            if (obj.base && typeof obj.patch === 'object' && key) {
                base = getFromCache(obj.base);

                if (base) {
                    patch = UTIL.applyPatch(base, obj.patch);
                    if (patch.status === 'success') {
                        patch.result[CONSTANTS.MONGO_ID] = key;
                        this.insertObject(patch.result);
                    } else {
                        logger.error('patch application failed', patch);
                    }
                } else {
                    logger.debug('the base [' +
                        obj.base + '] is not available from the cache so the patch object is ignored');
                }
            } else {
                logger.error('invalid patch object format', obj);
            }
        };
    }

    return ProjectCache;
});
/*globals define*/
/*eslint-env node, browser*/
/*eslint no-unused-vars: 0*/

/**
 * This class defines the common interface for a storage-project.
 *
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/project/interface',[
    'q',
    'common/storage/project/cache',
    'common/storage/constants',
    'common/storage/util',
    'common/regexp',
], function (Q, ProjectCache, CONSTANTS, UTIL, REGEXP) {
    'use strict';

    /**
     *
     * @param {string} projectId - Id of project to be opened.
     * @param {object} storageObjectsAccessor - Exposes loadObject towards the database.
     * @param {GmeLogger} mainLogger - Logger instance from instantiator.
     * @param {GmeConfig} gmeConfig
     * @alias ProjectInterface
     * @constructor
     */
    function ProjectInterface(projectId, storageObjectsAccessor, mainLogger, gmeConfig) {

        /**
         * Unique ID of project, built up by the ownerId and projectName.
         *
         * @example
         * 'guest+TestProject', 'organization+TestProject2'
         * @type {string}
         */
        this.projectId = projectId;
        this.projectName = UTIL.getProjectNameFromProjectId(projectId);

        this.CONSTANTS = CONSTANTS;

        this.ID_NAME = CONSTANTS.MONGO_ID;

        /**
         * @type {GmeConfig}
         */
        this.gmeConfig = gmeConfig;

        /**
         * @type {GmeLogger}
         */
        this.logger = mainLogger.fork('Project:' + this.projectId);

        this.logger.debug('ctor', projectId);
        this.projectCache = new ProjectCache(storageObjectsAccessor, this.projectId, this.logger, gmeConfig);

        // Functions forwarded to project cache.
        /**
         * Inserts the given object to project-cache.
         *
         * @param {module:Storage~CommitObject|module:Core~ObjectData} obj - Object to be inserted in database.
         * @param {Object.<module:Core~ObjectHash, module:Core~ObjectData>} [stackedObjects] - When used by the core,
         * inserts between persists are stored here.
         * @func
         * @private
         */
        this.insertObject = this.projectCache.insertObject;

        /**
         * Try to create the full object from the patch object by looking for the base object in the cache.
         * If the base has been found it applies the patch and inserts the result. If any step fails it simply
         * ignores the insert.
         *
         * @param {module:Storage~CommitObject|module:Core~ObjectData} obj - Object to be inserted in database.
         * @func
         * @private
         */
        this.insertPatchObject = this.projectCache.insertPatchObject;

        /**
         * Callback for loadObject.
         *
         * @callback ProjectInterface~loadObjectCallback
         * @param {Error} err - If error occurred.
         * @param {module:Storage~CommitObject|module:Core~ObjectData} object - Object loaded from database,
         * commit-object or model data-blob.
         */

        /**
         * Loads the object with hash key from the database or
         * directly from the cache if recently loaded.
         * @param {string} key - Hash of object to load.
         * @param {ProjectInterface~loadObjectCallback} callback - Invoked when object is loaded.
         * @func
         * @private
         */
        this.loadObject = this.projectCache.loadObject;

        /**
         * Collects the objects from the server and pre-loads them into the cache
         * making the load of multiple objects faster.
         * @private
         * @param {string} rootKey - Hash of the object at the entry point of the paths.
         * @param {string[]} paths - List of paths that needs to be pre-loaded.
         * @param {function} callback - Invoked when objects have been collected.
         * @func
         * @private
         */
        this.loadPaths = this.projectCache.loadPaths;

        // Public API

        /**
         * Makes a commit to data base. Based on the root hash and commit message a new
         * {@link module:Storage.CommitObject} (with returned hash)
         * is generated and insert together with the core objects to the database on the server.
         *
         * @example
         * var persisted = core.persist(rootNode);
         *
         * project.makeCommit('master', ['#thePreviousCommitHash'], persisted.rootHash, persisted.objects, 'new commit')
         *   .then(function (result) {
         *     // result = {
         *     //   status: 'SYNCED',
         *     //   hash: '#thisCommitHash'
         *     // }
         *   })
         *   .catch(function (error) {
         *     // error.message = 'Not authorized to read project: guest+project'
         *   });
         * @example
         * project.makeCommit('master', ['#notPreviousCommitHash'], persisted.rootHash, persisted.objects, 'new commit')
         *   .then(function (result) {
         *     // result = {
         *     //   status: 'FORKED',
         *     //   hash: '#thisCommitHash'
         *     // }
         *   })...
         * @example
         * project.makeCommit(null, ['#anExistingCommitHash'], persisted.rootHash, persisted.objects, 'new commit')
         *   .then(function (result) {
         *     // result = {
         *     //   hash: '#thisCommitHash'
         *     // }
         *   })...
         * @example
         * project.makeCommit('master', ['#aPreviousCommitHash'], previousRootHash, {}, 'adding a commit to master')
         *   .then(function (result) {
         *     // result = {
         *     //   status: 'SYNCED',
         *     //   hash: '#thisCommitHash'
         *     // }
         *   })...
         * @param {string} branchName - Name of branch to update (none if null).
         * @param {module:Storage~CommitHash[]} parents - Parent commit hashes.
         * @param {module:Core~ObjectHash} rootHash - Hash of root object.
         * @param {module:Core~DataObject} coreObjects - Core objects associated with the commit.
         * @param {string} msg='n/a' - Commit message.
         * @param {function} [callback] - If provided no promise will be returned.
         * @param {null|Error} callback.error - The result of the execution.
         * @param {module:Storage~CommitResult} callback.result - Status about the commit and branch update.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * {@link module:Storage~CommitResult} <b>result</b>.<br>
         * On error the promise will be rejected with {Error} <b>error</b>.
         */
        this.makeCommit = function (branchName, parents, rootHash, coreObjects, msg, callback) {
            throw new Error('makeCommit must be overridden in derived class');
        };

        /**
         * Retrieves the metadata of the project.
         * @example
         * {
         *  _id: 'guest+example',
         *  owner: 'guest',
         *  name: 'example',
         *  info: {
         *      createdAt: '2016-12-02T17:52:25.029Z',
         *      viewedAt: '2017-01-30T22:45:15.269Z',
         *      modifiedAt: '2017-01-20T00:15:34.593Z',
         *      creator: 'guest',
         *      viewer: 'guest',
         *      modifier': 'guest'
         *  },
         *  hooks: {
         *      ConstraintCheckerHook': {
         *          url: 'http://127.0.0.1:8080/ConstraintCheckerHook',
         *          description': 'Checks if there are any meta violations in the project',
         *          events: ['COMMIT'],
         *          active: true,
         *          createdAt: '2017-01-19T23:22:46.834Z',
         *          updatedAt: '2017-01-19T23:22:46.834Z'
         *      }
         *  },
         *  rights: {
         *      read: true,
         *      write: true,
         *      delete: true
         *  },
         *  branches: {
         *      b1: '#998067142c7ff8067cd0c04a0ec4ef80d865606c',
         *      master: '#36df6f8c17b2ccf4e35a2a75b1e0adb928f82a61'
         *  }
         * }
         * @param {function} [callback] - If provided no promise will be returned.
         * @param {null|Error} callback.error - The result of the execution.
         * @param {object} callback.projectInfo - An object with info about the project.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * {object} <b>projectInfo</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.getProjectInfo = function (callback) {
            throw new Error('getProjectInfo must be overridden in derived class');
        };

        /**
         * Updates the head of the branch.
         * @param {string} branchName - Name of branch to update.
         * @param {module:Storage~CommitHash} newHash - New commit hash for branch head.
         * @param {module:Storage~CommitHash} oldHash - Current state of the branch head inside the database.
         * @param {function} [callback] - If provided no promise will be returned.
         * @param {null|Error} callback.error - The result of the execution.
         * @param {module:Storage~CommitResult} callback.result - Status about the branch update.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * {@link module:Storage~CommitResult} <b>result</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.setBranchHash = function (branchName, newHash, oldHash, callback) {
            throw new Error('setBranchHash must be overridden in derived class');
        };

        /**
         * Retrieves the commit hash for the head of the branch.
         * @param {string} branchName - Name of branch.
         * @param {function} [callback] - If provided no promise will be returned.
         * @param {null|Error} callback.error - The result of the execution.
         * @param {module:Storage~CommitHash} callback.commitHash - The commit hash.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * {@link module:Storage~CommitHash} <b>commitHash</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.getBranchHash = function (branchName, callback) {
            throw new Error('getBranchHash must be overridden in derived class');
        };

        /**
         * Retrieves the root hash at the provided branch or commit-hash.
         * @param {string} branchNameOrCommitHash - Name of branch or a commit-hash.
         * @param {function} [callback] - If provided no promise will be returned.
         * @param {null|Error} callback.error - The result of the execution.
         * @param {module:Core~ObjectHash} callback.rootHash - The root hash.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * {@link module:Core~ObjectHash} <b>rootHash</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.getRootHash = function (branchNameOrCommitHash, callback) {
            return this.getCommitObject(branchNameOrCommitHash)
                .then(function (commitObj) {
                    return commitObj.root;
                })
                .nodeify(callback);
        };

        /**
         * Creates a new branch with head pointing to the provided commit hash.
         * @param {string} branchName - Name of branch to create.
         * @param {module:Storage~CommitHash} newHash - New commit hash for branch head.
         * @param {function} [callback] - If provided no promise will be returned.
         * @param {null|Error} callback.error - The result of the execution.
         * @param {module:Storage~CommitResult} callback.result - Status about the branch update.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * {@link module:Storage~CommitResult} <b>result</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.createBranch = function (branchName, newHash, callback) {
            throw new Error('createBranch must be overridden in derived class');
        };

        /**
         * Deletes the branch.
         * @param {string} branchName - Name of branch to create.
         * @param {module:Storage~CommitHash} oldHash - Previous commit hash for branch head.
         * @param {function} [callback] - If provided no promise will be returned.
         * @param {null|Error} callback.error - The result of the execution.
         * @param {module:Storage~CommitResult} callback.result - Status about the branch update.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * {@link module:Storage~CommitResult} <b>result</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.deleteBranch = function (branchName, oldHash, callback) {
            throw new Error('deleteBranch must be overridden in derived class');
        };

        /**
         * Retrieves all branches and their current heads within the project.
         * @param {function} [callback] - If provided no promise will be returned.
         * @param {null|Error} callback.error - The result of the execution.
         * @param {Object.<string, module:Storage~CommitHash>} callback.branches - An object with branch names as keys
         * and their commit-hashes as values.
         * @return {external:Promise}  On success the promise will be resolved with
         * Object.<string, {@link module:Storage~CommitHash}> <b>branches</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.getBranches = function (callback) {
            throw new Error('getBranches must be overridden in derived class');
        };

        /**
         * Retrieves the commit-object at the provided branch or commit-hash.
         * @param {string} branchNameOrCommitHash - Name of branch or a commit-hash.
         * @param {function} [callback] - If provided no promise will be returned.
         * @param {null|Error} callback.error - The result of the execution.
         * @param {module:Storage~CommitObject} callback.commit - The commit-object.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * {@link module:Storage~CommitObject} <b>commitObject</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.getCommitObject = function (branchNameOrCommitHash, callback) {
            var self = this,
                commitDeferred;

            if (REGEXP.HASH.test(branchNameOrCommitHash)) {
                commitDeferred = Q(branchNameOrCommitHash);
            } else {
                commitDeferred = this.getBranchHash(branchNameOrCommitHash);
            }

            return commitDeferred
                .then(function (commitHash) {
                    return Q.ninvoke(self, 'loadObject', commitHash);
                })
                .nodeify(callback);
        };

        /**
         * Retrieves an array of commits starting from a branch(es) and/or commitHash(es).
         * <br> The result is ordered by the rules (applied in order)
         * <br> 1. Descendants are always returned before their ancestors.
         * <br> 2. By their timestamp.
         * @param {string|module:Storage~CommitHash|string[]|module:Storage~CommitHash[]} start - Branch name,
         * commit hash or array of these.
         * @param {number} number - Number of commits to load.
         * @param {function} [callback] - If provided no promise will be returned.
         * @param {null|Error} callback.error - The result of the execution.
         * @param {Array.<module:Storage~CommitObject>} callback.commits - The commits that match the input ordered
         * as explained.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * Array.<{@link module:Storage~CommitObject}> <b>commits</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.getHistory = function (start, number, callback) {
            throw new Error('getHistory must be overridden in derived class');
        };

        /**
         * Retrieves and array of the latest (sorted by timestamp) commits for the project.
         * If timestamp is given it will get <b>number</b> of commits strictly before <b>before</b>.
         * If commit hash is specified that commit will be included too.
         * <br> N.B. due to slight time differences on different machines, ancestors may be returned before
         * their descendants. Unless looking for 'headless' commits 'getHistory' is the preferred method.
         * @param {number|module:Storage~CommitHash} before - Timestamp or commitHash to load history from.
         * @param {number} number - Number of commits to load.
         * @param {function} [callback] - If provided no promise will be returned.
         * @param {null|Error} callback.error - The result of the execution.
         * @param {Array.<module:Storage~CommitObject>} callback.commits - The commits that match the input, ordered
         * by their time of insertion.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * Array.<{@link module:Storage~CommitObject}> <b>commits</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.getCommits = function (before, number, callback) {
            throw new Error('getCommits must be overridden in derived class');
        };

        /**
         * Creates a new tag pointing to the provided commit hash.
         * @param {string} tagName - Name of tag to create.
         * @param {module:Storage~CommitHash} commitHash - Commit hash tag will point to.
         * @param {function} [callback] - If provided no promise will be returned.
         * @param {null|Error} callback.error - The result of the execution.
         *
         * @return {external:Promise}  On success the promise will be resolved with nothing.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.createTag = function (tagName, commitHash, callback) {
            throw new Error('createTag must be overridden in derived class');
        };

        /**
         * Deletes the given tag.
         * @param {string} tagName - Name of tag to delete.
         * @param {function} [callback] - If provided no promise will be returned.
         * @param {null|Error} callback.error - The result of the execution.
         *
         * @return {external:Promise}  On success the promise will be resolved with nothing.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.deleteTag = function (tagName, callback) {
            throw new Error('deleteTag must be overridden in derived class');
        };

        /**
         * Retrieves all tags and their commits hashes within the project.
         * @param {function} [callback] - If provided no promise will be returned.
         * @param {null|Error} callback.error - The result of the execution.
         * @param {Object.<string, module:Storage~CommitHash>} callback.tags - An object with tag names as keys and
         * their commit-hashes as values.
         * @return {external:Promise}  On success the promise will be resolved with
         * Object.<string, {@link module:Storage~CommitHash}> <b>tags</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.getTags = function (callback) {
            throw new Error('getTags must be overridden in derived class');
        };

        /**
         * Retrieves the common ancestor of two commits. If no ancestor exists it will result in an error.
         *
         * @param {module:Storage~CommitHash} commitA - Commit hash.
         * @param {module:Storage~CommitHash} commitB - Commit hash.
         * @param {function} [callback] - If provided no promise will be returned.
         * @param {null|Error} callback.error - The result of the execution (will be non-null if e.g. the commits do
         * not exist or have no common ancestor).
         * @param {module:Storage~CommitHash} callback.commitHash - The commit hash of the common ancestor.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * {@link module:Storage~CommitHash} <b>commitHash</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.getCommonAncestorCommit = function (commitA, commitB, callback) {
            throw new Error('getCommonAncestorCommit must be overridden in derived class');
        };

        /**
         * Return the identity of the current user of this project.
         * @return {string} the userId
         */
        this.getUserId = function () {
            throw new Error('getUserId must be overridden in derived class');
        };
    }

    return ProjectInterface;
});

/*globals define*/
/*eslint-env node, browser*/
/**
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/project/branch',['common/storage/constants'], function (CONSTANTS) {
    'use strict';

    function Branch(name, mainLogger) {
        var self = this,
            logger = mainLogger.fork('Branch:' + name),
            originHash = '',
            localHash = '',
            commitQueue = [],
            updateQueue = [],
            branchStatus = CONSTANTS.BRANCH_STATUS.SYNC;

        logger.debug('ctor');
        this.name = name;
        this.isOpen = true;
        this.inSync = true;

        this.branchStatusHandlers = [];
        this.hashUpdateHandlers = [];
        this.callbackQueue = [];

        this.pendingWorkerRequests = {};

        /**
         * @type {Error[]}
         */
        this.errorList = [];

        this._remoteUpdateHandler = null;

        this.cleanUp = function () {
            var commitHash,
                i,
                commitResult;

            self.isOpen = false;
            self.branchStatusHandlers = [];
            self.hashUpdateHandlers = [];

            self._remoteUpdateHandler = null;
            for (i = 0; i < self.callbackQueue.length; i += 1) {
                // Make sure there are no pending callbacks, invoke with status CANCELED.
                commitResult = {
                    status: CONSTANTS.CANCELED,
                    hash: commitQueue[i].commitObject[CONSTANTS.MONGO_ID]
                };
                self.callbackQueue[i](null, commitResult);
            }

            self.callbackQueue = [];

            for (commitHash in self.pendingWorkerRequests) {
                (this.pendingWorkerRequests[commitHash] || [])
                    .forEach(function (action) {
                        action.abort();
                    });
            }

            self.pendingWorkerRequests = {};
            commitQueue = [];
            updateQueue = [];
        };

        // Hash related functions
        this.getLocalHash = function () {
            return localHash;
        };

        this.getOriginHash = function () {
            return originHash;
        };

        this.getQueuedHashes = function () {
            return commitQueue
                .map(function (commitData) {
                    return commitData.commitObject[CONSTANTS.MONGO_ID];
                });
        };

        this.updateHashes = function (newLocal, newOrigin) {
            logger.debug('updatingHashes');
            if (newLocal !== null) {
                logger.debug('localHash: old, new', localHash, newLocal);
                localHash = newLocal;
            }
            if (newOrigin !== null) {
                logger.debug('originHash: old, new', originHash, newOrigin);
                originHash = newOrigin;
            }
        };

        // Queue related functions
        this.queueCommit = function (commitData, commitCallback) {
            commitQueue.push(commitData);
            self.callbackQueue.push(commitCallback);
            logger.debug('Adding new commit to queue', commitQueue.length);
        };

        this.getFirstCommit = function (shift) {
            var commitData;
            if (shift) {
                commitData = commitQueue.shift();
                self.callbackQueue.shift();
                logger.debug('Removed commit from queue', commitQueue.length);
            } else {
                commitData = commitQueue[0];
            }

            return commitData;
        };

        this.getMergedCommit = function (mergeHash) {
            var mergeCommit,
                i = updateQueue.length;

            while (i) {
                i -= 1;
                if (updateQueue[i].commitObject[CONSTANTS.MONGO_ID] === mergeHash) {
                    mergeCommit = updateQueue[i];
                    break;
                }
            }

            if (!mergeCommit) {
                logger.error('mergeCommit not available in updateQueue', mergeHash,
                    JSON.stringify(updateQueue, null, 2));
            }

            updateQueue = [];

            return mergeCommit;
        };

        this.getCommitQueue = function () {
            return commitQueue;
        };

        this.getCommitsForNewFork = function (upTillCommitHash) {
            var i,
                commitData,
                commitHash,
                commitHashExisted = false,
                subQueue = [];

            logger.debug('getCommitsForNewFork', upTillCommitHash);

            if (commitQueue.length === 0) {
                commitHash = localHash;

                logger.debug('No commits queued will fork from', commitHash);
                upTillCommitHash = upTillCommitHash || commitHash;
                commitHashExisted = upTillCommitHash === commitHash;
            } else {
                upTillCommitHash = upTillCommitHash ||
                    commitQueue[commitQueue.length - 1].commitObject[CONSTANTS.MONGO_ID];
            }

            logger.debug('Will fork up to commitHash', upTillCommitHash);

            // Move over all commit-data up till the chosen commitHash to the fork's queue,
            // except the commit that caused the fork (all its objects are already in the database).
            for (i = 0; i < commitQueue.length; i += 1) {
                commitData = commitQueue[i];
                commitHash = commitData.commitObject[CONSTANTS.MONGO_ID];
                if (i !== 0) {
                    subQueue.push(commitData);
                }
                if (commitData.commitObject[CONSTANTS.MONGO_ID] === upTillCommitHash) {
                    // The commitHash from where to fork has been reached.
                    // If any, the rest of the 'pending' commits will not be used.
                    commitHashExisted = true;
                    break;
                }
            }

            if (commitHashExisted === false) {
                logger.error('Could not find the specified commitHash', upTillCommitHash);
                return false;
            }

            return {commitHash: commitHash, queue: subQueue};
        };

        this.queueUpdate = function (updateData) {
            updateQueue.push(updateData);
            logger.debug('Adding new update to queue', updateQueue.length);
        };

        this.getUpdateQueue = function () {
            return updateQueue;
        };

        this.getFirstUpdate = function (shift) {
            var updateData;
            if (shift) {
                updateData = updateQueue.shift();
                logger.debug('Removed update from queue', updateQueue.length);
            } else {
                updateData = updateQueue[0];
            }

            return updateData;
        };

        // Event related functions
        this.addBranchStatusHandler = function (fn) {
            self.branchStatusHandlers.push(fn);
        };

        this.removeBranchStatusHandler = function (fn) {
            var i;

            for (i = 0; i < self.branchStatusHandlers.length; i += 1) {
                if (self.branchStatusHandlers[i] === fn) {
                    self.branchStatusHandlers.splice(i, 1);
                    return true;
                }
            }

            return false;
        };

        this.dispatchBranchStatus = function (newStatus, err) {
            var i;

            logger.debug('dispatchBranchStatus old, new', branchStatus, newStatus);

            if (branchStatus === CONSTANTS.BRANCH_STATUS.ERROR) {
                logger.error('In error state, action from user required!');
                newStatus = branchStatus;
            } else {
                branchStatus = newStatus;
            }

            if (err) {
                this.errorList.push(err instanceof Error ? err : new Error(err));
            }

            for (i = 0; i < self.branchStatusHandlers.length; i += 1) {
                self.branchStatusHandlers[i](newStatus, commitQueue, updateQueue);
            }
        };

        this.addHashUpdateHandler = function (fn) {
            self.hashUpdateHandlers.push(fn);
        };

        this.removeHashUpdateHandler = function (fn) {
            var i;

            for (i = 0; i < self.hashUpdateHandlers.length; i += 1) {
                if (self.hashUpdateHandlers[i] === fn) {
                    self.hashUpdateHandlers.splice(i, 1);
                    return true;
                }
            }

            return false;
        };

        this.dispatchHashUpdate = function (data, callback) {
            var i,
                error = null,
                counter = self.hashUpdateHandlers.length,
                allProceed = true,
                counterCallback = function (err, proceed) {
                    error = error || err; // Use the latest error
                    allProceed = allProceed && proceed === true;
                    counter -= 1;
                    if (counter === 0) {
                        callback(error, allProceed);
                    }
                };

            for (i = 0; i < self.hashUpdateHandlers.length; i += 1) {
                self.hashUpdateHandlers[i](data, commitQueue, updateQueue, counterCallback);
            }
        };

        this.queueWorkerRequest = function (commitHash, action) {
            this.pendingWorkerRequests[commitHash] = this.pendingWorkerRequests[commitHash] || [];

            this.pendingWorkerRequests[commitHash].push(action);
        };

        this.commitInserted = function (commitHash) {
            (this.pendingWorkerRequests[commitHash] || []).forEach(function (action) {
                action.release();
            });

            delete this.pendingWorkerRequests[commitHash];
        };
    }

    return Branch;
});

/*globals define*/
/*eslint-env node, browser*/
/**

 *
 * Storage.openProject resolves with an instance of this classes.
 *
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/project/project',[
    'common/storage/project/interface',
    'common/storage/project/branch',
    'q'
], function (ProjectInterface, Branch, Q) {
    'use strict';

    /**
     * This project uses a common storage to connect to the database on the server via web-sockets.
     * It can run under both nodeJS and in the browser.
     *
     *
     * @param {string} projectId - Id of project to be opened.
     * @param {object} storage - Storage connected to the server and database.
     * @param {object} mainLogger - Logger instance.
     * @param {GmeConfig} gmeConfig
     * @alias Project
     * @constructor
     * @augments ProjectInterface
     */
    function Project(projectId, storage, mainLogger, gmeConfig) {
        var self = this;
        this.branches = {};

        ProjectInterface.call(this, projectId, storage, mainLogger, gmeConfig);

        // Functions defined in ProjectInterface
        this.makeCommit = function (branchName, parents, rootHash, coreObjects, msg, callback) {
            return Q.ninvoke(storage, 'makeCommit', self.projectId, branchName, parents, rootHash, coreObjects, msg)
                .nodeify(callback);
        };

        this.getProjectInfo = function (callback) {
            return Q.ninvoke(storage, 'getProjectInfo', self.projectId)
                .nodeify(callback);
        };

        this.setBranchHash = function (branchName, newHash, oldHash, callback) {
            return Q.ninvoke(storage, 'setBranchHash', self.projectId, branchName, newHash, oldHash)
                .nodeify(callback);
        };

        this.getBranchHash = function (branchName, callback) {
            return Q.ninvoke(storage, 'getBranchHash', self.projectId, branchName)
                .nodeify(callback);
        };

        this.createBranch = function (branchName, newHash, callback) {
            return Q.ninvoke(storage, 'createBranch', self.projectId, branchName, newHash)
                .nodeify(callback);
        };

        this.deleteBranch = function (branchName, oldHash, callback) {
            return Q.ninvoke(storage, 'deleteBranch', self.projectId, branchName, oldHash)
                .nodeify(callback);
        };

        this.getBranches = function (callback) {
            return Q.ninvoke(storage, 'getBranches', self.projectId)
                .nodeify(callback);
        };

        this.createTag = function (tagName, commitHash, callback) {
            return Q.ninvoke(storage, 'createTag', self.projectId, tagName, commitHash)
                .nodeify(callback);
        };

        this.deleteTag = function (tagName, callback) {
            return Q.ninvoke(storage, 'deleteTag', self.projectId, tagName)
                .nodeify(callback);
        };

        this.getTags = function (callback) {
            return Q.ninvoke(storage, 'getTags', self.projectId)
                .nodeify(callback);
        };

        this.getCommits = function (before, number, callback) {
            return Q.ninvoke(storage, 'getCommits', self.projectId, before, number)
                .nodeify(callback);
        };

        this.getHistory = function (start, number, callback) {
            return Q.ninvoke(storage, 'getHistory', self.projectId, start, number)
                .nodeify(callback);
        };

        this.getCommonAncestorCommit = function (commitA, commitB, callback) {
            return Q.ninvoke(storage, 'getCommonAncestorCommit', self.projectId, commitA, commitB)
                .nodeify(callback);
        };

        this.squashCommits = function (fromCommit, toCommitOrBranch, message, callback) {
            return Q.ninvoke(storage, 'squashCommits', self.projectId, fromCommit, toCommitOrBranch, message)
                .nodeify(callback);
        };

        this.getUserId = function () {
            return storage.userId;
        };

        /**
         * Start watching the document at the provided context.
         * @param {object} data
         * @param {string} data.branchName
         * @param {string} data.nodeId
         * @param {string} data.attrName
         * @param {string} data.attrValue - If the first client entering the document the value will be used
         * @param {function} atOperation - Triggered when other clients' operations were applied
         * @param {ot.Operation} atOperation.operation - Triggered when other clients made changes
         * @param {function} atSelection - Triggered when other clients send their selection info
         * @param {object} atSelection.data
         * @param {ot.Selection | null} atSelection.data.selection - null is passed when other client leaves
         * @param {string} atSelection.data.userId - name/id of other user
         * @param {string} atSelection.data.socketId - unique id of other user
         * @param {function} [callback]
         * @param {Error | null} callback.err - If failed to watch the document
         * @param {object} callback.data
         * @param {string} callback.data.docId - Id of document
         * @param {string} callback.data.document - Current document on server
         * @param {number} callback.data.revision - Revision at server when connecting
         * @param {object} callback.data.users - Users that were connected when connecting
         * @returns {Promise}
         */
        this.watchDocument = function (data, atOperation, atSelection, callback) {
            data.projectId = self.projectId;
            return storage.watchDocument(data, atOperation, atSelection).nodeify(callback);
        };

        /**
         * Stop watching the document.
         * @param {object} data
         * @param {string} data.docId - document id, if not provided branchName, nodeId, attrName must be.
         * @param {string} [data.branchName]
         * @param {string} [data.nodeId]
         * @param {string} [data.attrName]
         * @param {function} [callback]
         * @param {Error | null} callback.err - If failed to unwatch the document
         * @returns {Promise}
         */
        this.unwatchDocument = function (data, callback) {
            if (!data.docId) {
                data.projectId = self.projectId;
            }

            return storage.unwatchDocument(data).nodeify(callback);
        };

        /**
         * Send operation made, and optionally selection, on document at docId.
         * @param {object} data
         * @param {string} data.docId
         * @param {ot.TextOperation} data.operation
         * @param {ot.Selection} [data.selection]
         */
        this.sendDocumentOperation = function (data) {
            return storage.sendDocumentOperation(data);
        };

        /**
         * Send selection on document at docId. (Will only be transmitted if client is Synchronized.)
         * @param {object} data
         * @param {string} data.docId
         * @param {ot.Selection} data.selection
         */
        this.sendDocumentSelection = function (data) {
            return storage.sendDocumentSelection(data);
        };
    }

    Project.prototype = Object.create(ProjectInterface.prototype);
    Project.prototype.constructor = Project;

    return Project;
});
/*globals define*/
/*eslint-env node*/
/**
 * This class implements the functionality needed to edit a model in a specific project and branch in a
 * collaborative fashion.
 *
 * It keeps a state of the open projects which in turn keeps track of the open branches.
 *
 * Each project is associated with a project-cache which is shared amongst the branches. So switching
 * between branches is (potentially) an operation that does not require lots of server round-trips.
 *
 * It is possible to have multiple projects open and multiple branches within each project. However
 * one instance of a storage can only hold a single instance of a project (or branch within a project).
 *
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/storageclasses/editorstorage',[
    'common/storage/storageclasses/objectloaders',
    'common/storage/constants',
    'common/storage/project/project',
    'common/storage/project/branch',
    'common/util/assert',
    'common/util/key',
    'common/storage/util',
    'q'
], function (StorageObjectLoaders, CONSTANTS, Project, Branch, assert, generateKey, UTIL, Q) {
    'use strict';

    /**
     *
     * @param webSocket
     * @param mainLogger
     * @param gmeConfig
     * @constructor
     */
    function EditorStorage(webSocket, mainLogger, gmeConfig) {
        var self = this,
            logger = mainLogger.fork('storage'),
            projects = {};

        self.logger = logger;
        self.userId = null;
        self.serverVersion = null;

        StorageObjectLoaders.call(this, webSocket, mainLogger, gmeConfig);

        function triggerNetworkChange(connectionState, networkHandler) {
            networkHandler(connectionState);
            self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, connectionState);
        }

        /**
         * Dig out the context for the server-worker request. Needed to determine if
         * the request needs be queued on the current commit-queue.
         * @param {object} swmParams
         * @returns {object} If the request contains a projectId and (branchName and/or commitHash). It
         * will return an object with projectId and (branchName and/or commitHash).
         */
        function extractSWMContext(swmParams) {
            var result = {};

            if (swmParams.projectId) {
                result.projectId = swmParams.projectId;
                if (swmParams.branchName || swmParams.branch || swmParams.commitHash || swmParams.commit) {
                    // Add any of these.
                    result.branchName = swmParams.branchName || swmParams.branch;
                    result.commitHash = swmParams.commitHash || swmParams.commit;
                }
            } else if (swmParams.context &&
                swmParams.context.managerConfig &&
                swmParams.context.managerConfig.project) {
                // This is a plugin request..
                result.projectId = swmParams.context.managerConfig.project;
                result.commitHash = swmParams.context.managerConfig.commitHash;
                result.branchName = swmParams.context.managerConfig.branchName;
            }

            return result;
        }

        this.open = function (networkHandler) {
            webSocket.connect(function (err, connectionState) {
                if (err) {
                    logger.error(err);
                    triggerNetworkChange(CONSTANTS.CONNECTION_ERROR, networkHandler);
                } else if (connectionState === CONSTANTS.CONNECTED) {
                    self.connected = true;
                    self.userId = webSocket.userId;
                    self.serverVersion = webSocket.serverVersion;
                    triggerNetworkChange(CONSTANTS.CONNECTED, networkHandler);
                } else if (connectionState === CONSTANTS.RECONNECTING) {
                    // This is an internal state only to handle rejoining of rooms.
                    // Technically the websocket is connected at this point.
                    self.reconnecting = true;
                } else if (connectionState === CONSTANTS.RECONNECTED) {
                    self.connected = true;
                    self._rejoinWatcherRooms()
                        .then(function () {
                            return self._rejoinBranchRooms();
                        })
                        .then(function () {
                            self.reconnecting = false;
                            triggerNetworkChange(CONSTANTS.RECONNECTED, networkHandler);
                        })
                        .catch(function (err) {
                            logger.error('failing during reconnect', err);
                            triggerNetworkChange(CONSTANTS.CONNECTION_ERROR, networkHandler);
                        });

                } else if (connectionState === CONSTANTS.DISCONNECTED) {
                    self.connected = false;
                    triggerNetworkChange(CONSTANTS.DISCONNECTED, networkHandler);
                } else if (connectionState === CONSTANTS.INCOMPATIBLE_CONNECTION) {
                    triggerNetworkChange(connectionState, networkHandler);
                } else if (connectionState === CONSTANTS.JWT_ABOUT_TO_EXPIRE) {
                    triggerNetworkChange(connectionState, networkHandler);
                } else if (connectionState === CONSTANTS.JWT_EXPIRED) {
                    triggerNetworkChange(connectionState, networkHandler);
                } else {
                    logger.error('unexpected connection state');
                    triggerNetworkChange(CONSTANTS.CONNECTION_ERROR, networkHandler);
                }
            });
        };

        this.close = function (callback) {
            logger.debug('Closing storage, openProjects', Object.keys(projects));

            return Q.allSettled(Object.keys(projects)
                .map(function (projectId) {
                    return self.closeProject(projectId);
                }))
                .then(function () {
                    // Remove the handler for the socket.io events 'connect' and 'disconnect'.
                    logger.debug('Removing connect and disconnect events');
                    webSocket.socket.removeAllListeners('connect');
                    webSocket.socket.removeAllListeners('disconnect');
                    // Disconnect from the server.
                    logger.debug('Disconnecting web-socket');
                    webSocket.disconnect();
                    self.connected = false;
                    // Remove all local event-listeners.
                    webSocket.clearAllEvents();
                    self.clearAllEvents();
                })
                .nodeify(callback);
        };

        this.getToken = function () {
            return webSocket.ioClient.getToken();
        };

        this.setToken = function (newToken) {
            return webSocket.ioClient.setToken(newToken);
        };

        /**
         * Callback for openProject.
         *
         * @callback EditorStorage~openProjectCallback
         * @param {string} err - error string.
         * @param {Project} project - the newly opened project.
         * @param {object} branches - the newly opened project.
         * @example
         * // branches is of the form
         * // { master: '#somevalidhash', b1: '#someothervalidhash' }
         */

        /**
         *
         * @param {string} projectId - name of project to open.
         * @param {EditorStorage~openProjectCallback} - callback
         */
        this.openProject = function (projectId, callback) {
            var deferred,
                data = {
                    projectId: projectId
                };

            if (projects[projectId]) {
                return Q.reject(new Error('project is already open ' + projectId)).nodeify(callback);
            }

            webSocket.openProject(data)
                .spread(function (branches, access) {
                    var project = new Project(projectId, self, logger, gmeConfig);
                    projects[projectId] = project;

                    if (callback) {
                        callback(null, project, branches, access);
                    } else {
                        deferred.resolve([project, branches, access]);
                    }
                })
                .catch(function (err) {
                    if (callback) {
                        callback(err);
                    } else {
                        deferred.reject(err);
                    }
                });

            if (!callback) {
                deferred = Q.defer();
                return deferred.promise;
            }
        };

        this.closeProject = function (projectId, callback) {
            logger.debug('closeProject', projectId);

            if (projects[projectId]) {
                return Q.allSettled(Object.keys(projects[projectId].branches)
                    .map(function (branchName) {
                        return self.closeBranch(projectId, branchName);
                    }))
                    .then(function () {
                        if (self.connected) {
                            return webSocket.closeProject({projectId: projectId});
                        } else {
                            logger.debug('Disconnected while closing project.. skipping webSocket request to server.');
                        }
                    })
                    .then(function () {
                        delete projects[projectId];
                    })
                    .nodeify(callback);
            } else {
                logger.warn('Project is not open ', projectId);
                return Q().nodeify(callback);
            }
        };

        this.openBranch = function (projectId, branchName, hashUpdateHandler, branchStatusHandler, callback) {
            var project = projects[projectId],
                data = {
                    projectId: projectId,
                    branchName: branchName
                },
                deferred,
                branch;

            if (!project) {
                return Q.reject(
                    new Error('Cannot open branch, ' + branchName + ', project ' + projectId + ' is not opened.'))
                    .nodeify(callback);
            }

            if (project.branches[branchName]) {
                return Q.reject(new Error('Branch is already open ' + branchName + ', project: ' + projectId))
                    .nodeify(callback);
            }

            logger.debug('openBranch, calling webSocket openBranch', projectId, branchName);

            deferred = Q.defer();

            webSocket.openBranch(data)
                .then(function (latestCommit) {
                    var branchHash;

                    branch = new Branch(branchName, project.logger);
                    project.branches[branchName] = branch;

                    // Update state of branch
                    branch.latestCommitData = latestCommit;
                    branchHash = latestCommit.commitObject[CONSTANTS.MONGO_ID];
                    branch.updateHashes(branchHash, branchHash);

                    // Add handlers to branch and set the remote update handler for the web-socket.
                    branch.addHashUpdateHandler(hashUpdateHandler);
                    branch.addBranchStatusHandler(branchStatusHandler);

                    branch._remoteUpdateHandler = function (_ws, updateData, initCallback) {
                        var j,
                            originHash = updateData.commitObject[CONSTANTS.MONGO_ID];
                        logger.debug('_remoteUpdateHandler invoked for project, branch', projectId, branchName);
                        for (j = 0; j < updateData.coreObjects.length; j += 1) {
                            if (updateData.coreObjects[j] && updateData.coreObjects[j].type === 'patch') {
                                project.insertPatchObject(updateData.coreObjects[j]);
                            } else {
                                project.insertObject(updateData.coreObjects[j]);
                            }
                        }

                        branch.queueUpdate(updateData);
                        branch.updateHashes(null, originHash);

                        if (branch.getCommitQueue().length === 0) {
                            if (branch.getUpdateQueue().length === 1) {
                                self._pullNextQueuedCommit(projectId, branchName, initCallback); // hashUpdateHandlers
                            }
                        } else {
                            logger.debug('commitQueue is not empty, only updating originHash.');
                        }
                    };

                    branch._remoteUpdateHandler(null, latestCommit, function (err) {
                        webSocket.addEventListener(webSocket.getBranchUpdateEventName(projectId, branchName),
                            branch._remoteUpdateHandler);

                        if (err) {
                            deferred.reject(err);
                        } else {
                            deferred.resolve(latestCommit);
                        }
                    });
                })
                .catch(deferred.reject);

            return deferred.promise.nodeify(callback);
        };

        this.closeBranch = function (projectId, branchName, callback) {
            var project = projects[projectId],
                branch;

            logger.debug('closeBranch', projectId, branchName);

            if (!project) {
                logger.warn('closeBranch: project is not open', projectId, branchName);
                return Q(null).nodeify(callback);
            }

            branch = project.branches[branchName];

            if (!branch) {
                logger.warn('closeBranch: project does not have given branch.', projectId, branchName);
                return Q(null).nodeify(callback);
            }

            // This will prevent memory leaks and expose if a commit is being
            // processed at the server this time (see last error in _pushNextQueuedCommit).
            branch.dispatchBranchStatus(null);

            // Stop listening to events from the server
            webSocket.removeEventListener(webSocket.getBranchUpdateEventName(projectId, branchName),
                branch._remoteUpdateHandler);

            branch.cleanUp();
            if (self.connected) {
                return webSocket.closeBranch({projectId: projectId, branchName: branchName})
                    .then(function () {
                        delete project.branches[branchName];
                    })
                    .nodeify(callback);
            } else {
                logger.debug('Disconnected while closing branch.. skipping webSocket request to server.');
                delete project.branches[branchName];
                return Q(null).nodeify(callback);
            }
        };

        this.forkBranch = function (projectId, branchName, forkName, commitHash, callback) {
            var project = projects[projectId],
                branch,
                forkData;

            this.logger.debug('forkBranch', projectId, branchName, forkName, commitHash);

            if (!project) {
                return Q.reject(new Error('Cannot fork branch, ' + branchName + ', project '
                    + projectId + ' is not opened.'))
                    .nodeify(callback);
            }

            branch = project.branches[branchName];

            if (!branch) {
                return Q.reject(new Error('Cannot fork branch, branch is not open ' + branchName +
                    ', project: ' + projectId))
                    .nodeify(callback);
            }

            forkData = branch.getCommitsForNewFork(commitHash, forkName); // commitHash = null defaults to latest commit
            self.logger.debug('forkBranch - forkData', forkData);

            if (forkData === false) {
                return Q.reject(new Error('Could not find specified commitHash: ' + commitHash)).nodeify(callback);
            }

            return self.persistCommits(forkData.queue)
                .then(function () {
                    return self.createBranch(projectId, forkName, forkData.commitHash);
                })
                .then(function () {
                    return forkData.commitHash;
                })
                .nodeify(callback);
        };

        this.persistCommits = function (commitQueue, callback) {
            var deferred = Q.defer(),
                commitHash;

            function commitNext(i) {
                var currentCommitData = commitQueue[i];

                if (i < commitQueue.length) {
                    currentCommitData = commitQueue[i];
                    logger.debug('persistCommits - commitNext, currentCommitData', currentCommitData);
                    delete currentCommitData.branchName;
                    commitHash = currentCommitData.commitObject[CONSTANTS.MONGO_ID];

                    webSocket.makeCommit(currentCommitData)
                        .then(function (result) {
                            logger.debug('persistCommits - commit successful, hash', result);
                            commitNext(i += 1);
                        })
                        .catch(deferred.reject);
                } else {
                    deferred.resolve(commitHash);
                }
            }

            commitNext(0);

            return deferred.promise.nodeify(callback);
        };

        this.makeCommit = function (projectId, branchName, parents, rootHash, coreObjects, msg, callback) {
            var project = projects[projectId],
                branch,
                commitId,
                commitCallback,
                persistQueueElement = {},
                commitData = {
                    rootHash: rootHash,
                    projectId: projectId,
                    commitObject: null,
                    coreObjects: {},
                    changedNodes: null
                },
                keys = Object.keys(coreObjects),
                i;

            //handling patch object creation
            // console.time('patch-computation');
            for (i = 0; i < keys.length; i += 1) {
                if (UTIL.coreObjectHasOldAndNewData(coreObjects[keys[i]])) {
                    // Patch type object.
                    persistQueueElement[keys[i]] = coreObjects[keys[i]].newData;
                    if (keys[i] === rootHash) {
                        // console.time('root-patch-computation');
                    }
                    commitData.coreObjects[keys[i]] = UTIL.getPatchObject(coreObjects[keys[i]].oldData,
                        coreObjects[keys[i]].newData);
                    //if (keys[i] === rootHash) {
                    // console.timeEnd('root-patch-computation');
                    //}
                } else if (coreObjects[keys[i]].newData && coreObjects[keys[i]].newHash) {
                    // A new object with no previous data (send the entire data).
                    commitData.coreObjects[keys[i]] = coreObjects[keys[i]].newData;
                    persistQueueElement[keys[i]] = coreObjects[keys[i]].newData;
                } else {
                    // A regular object.
                    commitData.coreObjects[keys[i]] = coreObjects[keys[i]];
                    persistQueueElement[keys[i]] = coreObjects[keys[i]];
                }
            }
            // console.timeEnd('patch-computation');
            // console.time('getChangedNodes');

            commitData.changedNodes = UTIL.getChangedNodes(commitData.coreObjects, rootHash);

            // console.timeEnd('getChangedNodes');

            commitData.commitObject = self._getCommitObject(projectId, parents, commitData.rootHash, msg);

            if (project) {
                project.insertObject(commitData.commitObject);
                commitId = commitData.commitObject[CONSTANTS.MONGO_ID];

                commitCallback = function commitCallback() {
                    delete project.projectCache.queuedPersists[commitId];
                    self.logger.debug('Removed now persisted core-objects from cache: ',
                        Object.keys(project.projectCache.queuedPersists).length);
                    callback.apply(null, arguments);
                };

                project.projectCache.queuedPersists[commitId] = persistQueueElement;
                logger.debug('Queued non-persisted core-objects in cache: ',
                    Object.keys(project.projectCache.queuedPersists).length);
            } else {
                commitCallback = callback;
            }

            if (typeof branchName === 'string') {
                commitData.branchName = branchName;
                branch = project ? project.branches[branchName] : null;
            }

            logger.debug('makeCommit', commitData);
            if (branch) {
                logger.debug('makeCommit, branch is open will commit using commitQueue. branchName:', branchName);
                self._commitToBranch(projectId, branchName, commitData, parents[0], commitCallback);
            } else {
                webSocket.makeCommit(commitData, commitCallback);
            }

            return commitData.commitObject;
        };

        this.setBranchHash = function (projectId, branchName, newHash, oldHash, callback) {
            var project = projects[projectId];

            logger.debug('setBranchHash', projectId, branchName, newHash, oldHash);
            if (project && project.branches[branchName]) {
                logger.debug('setBranchHash, branch is open, will notify other local users about change');
                project.loadObject(newHash, function (err, commitObject) {
                    var commitData;
                    if (err) {
                        logger.error('setBranchHash, failed to load in commitObject');
                        //branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.ERROR, err);
                        callback(err);
                        return;
                    }
                    logger.debug('setBranchHash, loaded commitObject');
                    commitData = {
                        projectId: projectId,
                        branchName: branchName,
                        coreObjects: {},
                        changedNodes: null,
                        commitObject: commitObject,
                        oldHash: oldHash
                    };
                    self._commitToBranch(projectId, branchName, commitData, oldHash, callback);
                });
            } else {
                StorageObjectLoaders.prototype.setBranchHash.call(self,
                    projectId, branchName, newHash, oldHash)
                    .nodeify(callback);
            }
        };

        this.simpleRequest = function (parameters, callback) {
            // This method is overridden here in order to avoid worker-requests
            // to be sent out referencing commits that haven't made it to the server yet.
            var context = extractSWMContext(parameters),
                commitHash,
                deferred,
                queuedInBranch;

            if (context.projectId && projects[context.projectId]) {
                // The request deals with a currently opened project - let's see if there is
                // a commitHash and/or branch associated with the request..
                if (context.commitHash) {
                    commitHash = context.commitHash;

                    if (context.branchName &&
                        projects[context.projectId].branches[context.branchName] &&
                        projects[context.projectId].branches[context.branchName].getQueuedHashes()
                            .indexOf(context.commitHash) > -1) {
                        // Since both commitHash and branchName was specified and the commitHash was queued
                        // in that branch - this is the branch to pick.
                        queuedInBranch = context.branchName;
                    } else {
                        // No branch was specified - let's see if the commit is queued in any opened branch.
                        // (Typically there's really only one open.)
                        Object.keys(projects[context.projectId].branches)
                            .forEach(function (branchName) {
                                if (projects[context.projectId].branches[branchName].getQueuedHashes()
                                    .indexOf(context.commitHash) > -1) {
                                    queuedInBranch = branchName;
                                }
                            });
                    }
                } else if (context.branchName && projects[context.projectId].branches[context.branchName]) {
                    // There is no specific commit-associated with request. However since branchName was passed
                    // we can only assume that it should run on the last commit in that branch.

                    commitHash = projects[context.projectId].branches[context.branchName].getQueuedHashes()[0];

                    if (commitHash) {
                        queuedInBranch = context.branchName;
                    }
                }

                if (queuedInBranch) {
                    deferred = Q.defer();

                    projects[context.projectId].branches[queuedInBranch].queueWorkerRequest(commitHash, {
                        release: function () {
                            StorageObjectLoaders.prototype.simpleRequest.call(self, parameters)
                                .then(deferred.resolve)
                                .catch(deferred.reject);
                        },
                        abort: function () {
                            deferred.reject(new Error('Queued worker request was aborted. Commit ' + commitHash +
                                ' in branch [' + queuedInBranch + '] never made it to the server.'));
                        }
                    });

                    return deferred.promise.nodeify(callback);
                }
            }

            return StorageObjectLoaders.prototype.simpleRequest.call(self, parameters).nodeify(callback);
        };

        this._commitToBranch = function (projectId, branchName, commitData, oldCommitHash, callback) {
            var project = projects[projectId],
                newCommitHash = commitData.commitObject._id,
                branch = project.branches[branchName],
                wasFirstInQueue,
                eventData = {
                    commitData: commitData,
                    local: true
                };

            logger.debug('_commitToBranch, [oldCommitHash, localHash]', oldCommitHash, branch.getLocalHash());

            if (oldCommitHash === branch.getLocalHash()) {
                branch.updateHashes(newCommitHash, null);
                branch.queueCommit(commitData, callback);

                if (branch.inSync === false) {
                    branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_NOT_SYNC);
                } else {
                    branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_SYNC);
                }

                // Get the queue length before dispatching because within the asynchrony,
                // the queue may get longer and we end up never pushing any commit.
                wasFirstInQueue = branch.getCommitQueue().length === 1;

                branch.dispatchHashUpdate(eventData, function (err, proceed) {
                    logger.debug('_commitToBranch, dispatchHashUpdate done. [err, proceed]', err, proceed);

                    if (err) {
                        branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.ERROR, err);
                        callback(new Error('Commit failed being loaded in users: ' + err));
                    } else if (proceed === true) {
                        if (wasFirstInQueue) {
                            logger.debug('_commitToBranch, commit was first in queue - will start pushing commit');
                            self._pushNextQueuedCommit(projectId, branchName);
                        } else {
                            logger.debug('_commitToBranch, commit was NOT first in queue');
                        }
                    } else {
                        callback(new Error('Commit halted when loaded in users (proceed was not true).'));
                    }
                });
            } else {
                // The current user is behind the local branch, e.g. plugin trying to save after client changes.
                logger.warn('_commitToBranch, incoming commit parent was not the same as the localHash ' +
                    'for the branch, commit will be canceled!');
                callback(null, {status: CONSTANTS.CANCELED, hash: newCommitHash});
            }
        };

        this._pushNextQueuedCommit = function (projectId, branchName) {
            var project = projects[projectId],
                branch = project.branches[branchName],
                commitData;

            logger.debug('_pushNextQueuedCommit, length=', branch.getCommitQueue().length);

            commitData = branch.getFirstCommit();

            logger.debug('_pushNextQueuedCommit, makeCommit [from# -> to#]',
                commitData.commitObject.parents[0], commitData.commitObject._id);

            webSocket.makeCommit(commitData, function (err, result) {
                var mergeCommitData;
                if (err) {
                    logger.error('makeCommit failed', err);
                }

                if (branch.isOpen) {
                    branch.callbackQueue[0](err, result);
                    if (!err && result) {
                        branch.commitInserted(result.hash);
                        if (result.status === CONSTANTS.SYNCED) {
                            branch.inSync = true;
                            branch.updateHashes(null, result.hash);
                            branch.getFirstCommit(true);
                            if (branch.getCommitQueue().length === 0) {
                                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.SYNC);
                            } else {
                                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_SYNC);
                                self._pushNextQueuedCommit(projectId, branchName);
                            }
                        } else if (result.status === CONSTANTS.MERGED) {
                            branch.inSync = true;
                            branch.updateHashes(null, result.mergeHash);

                            if (branch.getCommitQueue().length === 1) {
                                // Finds the MERGED commit-data and clears the update-queue.
                                mergeCommitData = branch.getMergedCommit(result.mergeHash);
                                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.MERGING);
                                branch.dispatchHashUpdate({commitData: mergeCommitData, local: false},
                                    function (err, proceed) {
                                        branch.getFirstCommit(true);
                                        if (err) {
                                            logger.error('Loading of merged commit failed with error', err,
                                                {metadata: mergeCommitData});
                                            branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.ERROR, err);
                                        } else if (proceed === true) {
                                            logger.debug('Merged commit was successfully loaded, updating localHash.');
                                            branch.updateHashes(result.mergeHash, null);
                                            // TODO: What if a commit is made during the hashUpdate?
                                            branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.SYNC);
                                            return;
                                        } else {
                                            logger.warn('Loading of update commit was aborted',
                                                {metadata: result.mergeHash});
                                        }
                                    }
                                );
                            } else {
                                branch.getFirstCommit(true);
                                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.MERGING);
                                self._pushNextQueuedCommit(projectId, branchName);
                            }
                        } else if (result.status === CONSTANTS.FORKED) {
                            branch.inSync = false;
                            branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_NOT_SYNC);
                        } else {
                            err = new Error('Unsupported commit status ' + result.status);
                            logger.error(err);
                            branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.ERROR, err);
                        }
                    } else {
                        branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.ERROR,
                            err || new Error('No result at commit.'));
                    }
                } else {
                    logger.error('_pushNextQueuedCommit returned from server but the branch was closed, ' +
                        'the branch has probably been closed while waiting for the response.', projectId, branchName);
                }
            });
        };

        this._pullNextQueuedCommit = function (projectId, branchName, callback) {
            assert(projects.hasOwnProperty(projectId), 'Project not opened: ' + projectId);
            var project = projects[projectId],
                branch = project.branches[branchName],
                error,
                updateData;

            if (!branch) {
                error = new Error('Branch, ' + branchName + ', not in project ' + projectId + '.');
                if (callback) {
                    callback(error);
                    return;
                } else {
                    throw error;
                }
            }

            logger.debug('About to update, updateQueue', {metadata: branch.getUpdateQueue()});
            if (branch.getUpdateQueue().length === 0) {
                logger.debug('No queued updates, returns');
                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.SYNC);
                if (callback) {
                    callback(null);
                }
                return;
            }

            updateData = branch.getFirstUpdate();

            if (branch.isOpen) {
                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.PULLING);
                branch.dispatchHashUpdate({commitData: updateData, local: false}, function (err, proceed) {
                    var originHash = updateData.commitObject[CONSTANTS.MONGO_ID];
                    if (err) {
                        logger.error('Loading of update commit failed with error', err, {metadata: updateData});
                        branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.ERROR, err);
                    } else if (proceed === true) {
                        logger.debug('New commit was successfully loaded, updating localHash.');
                        branch.updateHashes(originHash, null);
                        branch.getFirstUpdate(true);
                        if (branch.getCommitQueue().length === 0) {
                            self._pullNextQueuedCommit(projectId, branchName, callback);
                        }
                        return;
                    } else {
                        logger.warn('Loading of update commit was aborted', {metadata: updateData});
                    }
                    if (callback) {
                        callback(new Error('Loading the first commit was aborted'));
                    }
                });
            } else {
                logger.error('_pullNextQueuedCommit returned from server but the branch was closed.',
                    projectId, branchName);
            }
        };

        this._getCommitObject = function (projectId, parents, rootHash, msg) {
            msg = msg || 'n/a';
            var commitObj = {
                    root: rootHash,
                    parents: parents,
                    updater: [self.userId],
                    time: Date.now(),
                    message: msg,
                    type: CONSTANTS.COMMIT_TYPE,
                    __v: CONSTANTS.VERSION
                },
                commitHash = '#' + generateKey(commitObj, gmeConfig);

            commitObj[CONSTANTS.MONGO_ID] = commitHash;

            return commitObj;
        };

        this._rejoinBranchRooms = function (callback) {
            var projectId,
                project,
                branchName,
                branchRooms = [],
                promises = [];

            logger.debug('_rejoinBranchRooms');

            function afterRejoin(projectId, branchName) {
                var project = projects[projectId],
                    deferred = Q.defer();

                logger.debug('_rejoinBranchRooms, rejoined branch room', projectId, branchName);

                if (project) {
                    project.getBranchHash(branchName)
                        .then(function (branchHash) {
                            var branch = project.branches[branchName],
                                queuedCommitHash;
                            logger.debug('_rejoinBranchRooms received branchHash', projectId, branchName, branchHash);

                            if (!branch) {
                                throw new Error('_rejoinBranchRooms branch was closed ' + projectId + ':' + branchName);
                            }

                            if (branch.getCommitQueue().length > 0) {
                                queuedCommitHash = branch.getFirstCommit().commitObject._id;
                                logger.debug('_rejoinBranchRooms, commits were queued length=, firstQueuedCommitHash',
                                    branch.getCommitQueue().length, queuedCommitHash);

                                project.getCommonAncestorCommit(branchHash, queuedCommitHash)
                                    .then(function (commonCommitHash) {
                                        var result;
                                        // The commit made it to the server but the acknowledgement was
                                        // interrupted by the disconnect.

                                        logger.debug('_rejoinBranchRooms getCommonAncestorCommit',
                                            projectId, branchName, commonCommitHash);

                                        if (branch.isOpen === false) {
                                            throw new Error('_rejoinBranchRooms branch was closed ' +
                                                projectId + ':' + branchName);
                                        }

                                        function dispatchSynced() {
                                            result = {status: CONSTANTS.SYNCED, hash: branchHash};

                                            branch.callbackQueue[0](null, result);
                                            branch.inSync = true;
                                            branch.updateHashes(null, branchHash);
                                            branch.getFirstCommit(true);
                                            if (branch.getCommitQueue().length === 0) {
                                                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.SYNC);
                                            } else {
                                                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_SYNC);
                                                self._pushNextQueuedCommit(projectId, branchName);
                                            }
                                        }

                                        function dispatchForked() {
                                            result = {status: CONSTANTS.FORKED, hash: branchHash};

                                            branch.callbackQueue[0](null, result);
                                            branch.inSync = false;
                                            branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_NOT_SYNC);
                                        }

                                        // c - the commit made by this storage
                                        // H - the head of the branch
                                        if (commonCommitHash === queuedCommitHash) {
                                            // The commit is (or was) in sync with the branch.
                                            //  Hc  or  H
                                            //  |       c
                                            //  |       |
                                            // In case two the next commit made will be forked.
                                            dispatchSynced();
                                        } else if (commonCommitHash === branchHash) {
                                            // The branch has moved back since the commit was made.
                                            // Treat it like the commit was forked.
                                            //  c
                                            //  H
                                            dispatchForked();
                                        } else {
                                            // The branch has moved forward in a different direction.
                                            //  c   H
                                            //   \ /
                                            dispatchForked();
                                        }

                                        deferred.resolve();
                                    })
                                    .catch(function (err) {
                                        try {
                                            if (err.message.indexOf('Commit object does not exist [' +
                                                queuedCommitHash) > -1) {
                                                // Commit never made it to the server - push it.
                                                logger.debug('First queued commit never made it to the server - push!');
                                                self._pushNextQueuedCommit(projectId, branchName);
                                                deferred.resolve();
                                            } else {
                                                deferred.reject(err);
                                            }
                                        } catch (err) {
                                            deferred.reject(err);
                                        }
                                    });
                            } else {
                                logger.debug('_rejoinBranchRooms, no commits were queued during disconnect.');
                                deferred.resolve();
                            }
                        })
                        .catch(function (err) {
                            deferred.reject(err);
                        });
                } else {
                    deferred.reject(new Error('_rejoinBranchRooms project was closed ' + projectId + ':' + branchName));
                }

                return deferred.promise;
            }

            for (projectId in projects) {
                if (projects.hasOwnProperty(projectId)) {
                    project = projects[projectId];
                    logger.debug('_rejoinBranchRooms found project', projectId);
                    for (branchName in project.branches) {
                        if (project.branches.hasOwnProperty(branchName)) {
                            logger.debug('_rejoinBranchRooms joining branch', projectId, branchName);

                            branchRooms.push({
                                projectId: projectId,
                                branchName: branchName
                            });

                            promises.push(webSocket.watchBranch({
                                projectId: projectId,
                                branchName: branchName,
                                join: true
                            }));
                        }
                    }
                }
            }

            return Q.all(promises)
                .then(function () {
                    return Q.all(branchRooms.map(function (data) {
                        // Deal with commit queue for each room after rejoining.
                        return afterRejoin(data.projectId, data.branchName);
                    }));
                })
                .nodeify(callback);
        };

        this.sendWsRouterMessage = webSocket.sendWsRouterMessage;
        this.onWebsocketRouterMessage = webSocket.onWebsocketRouterMessage;
         
        this.CONSTANTS = CONSTANTS;
    }

    EditorStorage.prototype = Object.create(StorageObjectLoaders.prototype);
    EditorStorage.prototype.constructor = EditorStorage;

    EditorStorage.CONSTANTS = CONSTANTS;

    return EditorStorage;
});

/*globals define*/
/*eslint-env node, browser*/

/**
 * @author kecso / https://github.com/kecso
 *
 * FIXME: is there a built in function to JavaScript to parse cookies?
 */

define('common/util/url',[],function () {
    'use strict';

    function parseCookie(cookie) {
        var parsed,
            elements,
            i,
            pair;

        cookie = decodeURIComponent(cookie);
        parsed = {};
        elements = cookie.split(/[;] */);
        for (i = 0; i < elements.length; i++) {
            pair = elements[i].split('=');
            parsed[pair[0]] = pair[1];
        }
        return parsed;
    }

    function urlToRefObject(url) {
        return {
            $ref: url
        };
    }

    return {
        parseCookie: parseCookie,
        urlToRefObject: urlToRefObject
    };
});

/*globals define, require, document*/
/*eslint-env browser*/
/**
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/socketio/browserclient',['common/util/url'], function (URL) {
    'use strict';

    function IoClient(mainLogger, gmeConfig) {
        var logger = mainLogger.fork('socketio-browserclient');

        this.connect = function (callback) {
            var hostAddress = window.location.protocol + '//' + window.location.host,
                socketIoUrl;

            if (window.__karma__) {
                // TRICKY: karma uses web sockets too, we need to use the gme server's port
                hostAddress = window.location.protocol + '//localhost:' + gmeConfig.server.port;
            }

            socketIoUrl = hostAddress + gmeConfig.client.mountedPath + '/socket.io/socket.io.js';
            logger.debug('Will require socketIO from', socketIoUrl);

            require([socketIoUrl], function (io_) {
                var io = io_ || window.io,
                    socketOptions = gmeConfig.socketIO.clientOptions,
                    socket;

                if (gmeConfig.client.mountedPath && gmeConfig.socketIO.clientOptions.path === undefined) {
                    socketOptions.path = gmeConfig.client.mountedPath + '/socket.io';
                }
                logger.debug('Connecting to "' + hostAddress + '" with options', socketOptions);
                socket = io(hostAddress, socketOptions);
                callback(null, socket);
            });
        };

        this.getToken = function () {
            var cookies = URL.parseCookie(document.cookie);
            if (cookies[gmeConfig.authentication.jwt.cookieId]) {
                return cookies[gmeConfig.authentication.jwt.cookieId];
            }
        };

        this.setToken = function (newToken) {
            document.cookie = gmeConfig.authentication.jwt.cookieId + '=' + newToken;
        };
    }

    return IoClient;
});
/*globals define*/
/*eslint-env node, browser*/
/**
 * @author pmeijer / https://github.com/pmeijer
 */

// socket.io-client
//
define('common/storage/socketio/websocket',[
    'common/EventDispatcher',
    'common/storage/constants',
    'q'
], function (EventDispatcher, CONSTANTS, Q) {

    'use strict';

    function WebSocket(ioClient, mainLogger, gmeConfig) {
        var self = this,
            logger = mainLogger.fork('WebSocket'),
            forcedDisconnect,
            beenConnected = false;

        self.socket = null;
        self.userId = null;
        self.serverVersion = null;
        self.ioClient = ioClient;
        self._handleWebsocketRouterMessage = () => {};

        logger.debug('ctor');
        EventDispatcher.call(this);

        function emitWithToken(data, eventName, callback) {
            logger.debug('emitting event', eventName, {metadata: data});
            data.webgmeToken = ioClient.getToken();
            if (callback) {
                self.socket.emit(eventName, data, callback);
            } else {
                return Q.ninvoke(self.socket, 'emit', eventName, data);
            }
        }

        this.connect = function (networkHandler) {

            logger.debug('Connecting via ioClient.');
            forcedDisconnect = false;

            ioClient.connect(function (err, socket_) {
                if (err) {
                    networkHandler(err);
                    return;
                }

                self.socket = socket_;

                self.socket.on('connect', function () {
                    var i,
                        sendBufferSave = [];
                    if (beenConnected) {
                        logger.debug('Socket got reconnected.');
                        networkHandler(null, CONSTANTS.RECONNECTING);

                        // #368
                        for (i = 0; i < self.socket.sendBuffer.length; i += 1) {
                            // Clear all makeCommit and document operations.
                            // If pushed - they would be emitted back to the socket!
                            if (self.socket.sendBuffer[i].data[0] === 'makeCommit' ||
                                self.socket.sendBuffer[i].data[0] === CONSTANTS.DOCUMENT_OPERATION) {
                                logger.debug('Removed makeCommit from sendBuffer...');
                            } else {
                                sendBufferSave.push(self.socket.sendBuffer[i]);
                            }
                        }
                        if (self.socket.receiveBuffer.length > 0) {
                            // TODO: In which cases is this applicable??
                            logger.debug('receiveBuffer not empty after reconnect');
                        }
                        self.socket.sendBuffer = sendBufferSave;
                        self.socket.emit('getConnectionInfo', {webgmeToken: ioClient.getToken()}, function (err, info) {
                            if (err) {
                                networkHandler(new Error('Could not get info on reconnect'));
                            } else {
                                if (self.serverVersion === info.serverVersion) {
                                    networkHandler(null, CONSTANTS.RECONNECTED);
                                } else {
                                    logger.error('Got reconnected to different webgme version (old !== new)',
                                        self.serverVersion, '!==', info.serverVersion);
                                    networkHandler(null, CONSTANTS.INCOMPATIBLE_CONNECTION);
                                }
                            }
                        });
                    } else {
                        logger.debug('Socket got connected for the first time.');
                        beenConnected = true;
                        self.socket.emit('getConnectionInfo', {webgmeToken: ioClient.getToken()}, function (err, info) {
                            if (err) {
                                networkHandler(new Error('Could not get info on connect'));
                            } else {
                                self.userId = info.userId || gmeConfig.authentication.guestAccount;
                                self.serverVersion = info.serverVersion;
                                networkHandler(null, CONSTANTS.CONNECTED);
                            }
                        });
                    }
                });

                self.socket.on('disconnect', function () {
                    logger.debug('Socket got disconnected!');
                    networkHandler(null, CONSTANTS.DISCONNECTED);

                    // When the server is shut-down the skipReconnect is set to false
                    // create a new socket connect.
                    if (self.socket.io.skipReconnect === true && forcedDisconnect === false) {
                        self.connect(networkHandler);
                    }
                });

                self.socket.on(CONSTANTS.JWT_ABOUT_TO_EXPIRE, function (data) {
                    data.etype = CONSTANTS.JWT_ABOUT_TO_EXPIRE;
                    logger.debug('JWT_ABOUT_TO_EXPIRE event', {metadata: data});
                    networkHandler(null, CONSTANTS.JWT_ABOUT_TO_EXPIRE);
                });

                self.socket.on(CONSTANTS.JWT_EXPIRED, function (data) {
                    data.etype = CONSTANTS.JWT_EXPIRED;
                    logger.debug('JWT_EXPIRED event', {metadata: data});
                    networkHandler(null, CONSTANTS.JWT_EXPIRED);
                });

                self.socket.on(CONSTANTS.PROJECT_DELETED, function (data) {
                    data.etype = CONSTANTS.PROJECT_DELETED;
                    logger.debug('PROJECT_DELETED event', {metadata: data});
                    self.dispatchEvent(CONSTANTS.PROJECT_DELETED, data);
                });

                self.socket.on(CONSTANTS.PROJECT_CREATED, function (data) {
                    data.etype = CONSTANTS.PROJECT_CREATED;
                    logger.debug('PROJECT_CREATED event', {metadata: data});
                    self.dispatchEvent(CONSTANTS.PROJECT_CREATED, data);
                });

                self.socket.on(CONSTANTS.BRANCH_CREATED, function (data) {
                    data.etype = CONSTANTS.BRANCH_CREATED;
                    logger.debug('BRANCH_CREATED event', {metadata: data});
                    self.dispatchEvent(CONSTANTS.BRANCH_CREATED + data.projectId, data);
                });

                self.socket.on(CONSTANTS.BRANCH_DELETED, function (data) {
                    data.etype = CONSTANTS.BRANCH_DELETED;
                    logger.debug('BRANCH_DELETED event', {metadata: data});
                    self.dispatchEvent(CONSTANTS.BRANCH_DELETED + data.projectId, data);
                });

                self.socket.on(CONSTANTS.BRANCH_HASH_UPDATED, function (data) {
                    data.etype = CONSTANTS.BRANCH_HASH_UPDATED;
                    logger.debug('BRANCH_HASH_UPDATED event', {metadata: data});
                    self.dispatchEvent(CONSTANTS.BRANCH_HASH_UPDATED + data.projectId, data);
                });

                self.socket.on(CONSTANTS.TAG_CREATED, function (data) {
                    data.etype = CONSTANTS.TAG_CREATED;
                    logger.debug('TAG_CREATED event', {metadata: data});
                    self.dispatchEvent(CONSTANTS.TAG_CREATED + data.projectId, data);
                });

                self.socket.on(CONSTANTS.TAG_DELETED, function (data) {
                    data.etype = CONSTANTS.TAG_DELETED;
                    logger.debug('TAG_DELETED event', {metadata: data});
                    self.dispatchEvent(CONSTANTS.TAG_DELETED + data.projectId, data);
                });

                self.socket.on(CONSTANTS.BRANCH_UPDATED, function (data) {
                    logger.debug('BRANCH_UPDATED event', {metadata: data});
                    self.dispatchEvent(self.getBranchUpdateEventName(data.projectId, data.branchName), data);
                });

                self.socket.on(CONSTANTS.NOTIFICATION, function (data) {
                    logger.debug('NOTIFICATION event', {metadata: data});
                    self.dispatchEvent(CONSTANTS.NOTIFICATION, data);
                });

                self.socket.on(CONSTANTS.DOCUMENT_OPERATION, function (data) {
                    logger.debug('DOCUMENT_OPERATION event', {metadata: data});
                    self.dispatchEvent(self.getDocumentUpdatedEventName(data), data);
                });

                self.socket.on(CONSTANTS.DOCUMENT_SELECTION, function (data) {
                    logger.debug('DOCUMENT_SELECTION event', {metadata: data});
                    self.dispatchEvent(self.getDocumentSelectionEventName(data), data);
                });

                self.socket.on('websocketRouterMessage', function (data) {
                    logger.debug('websocketRouterMessage', {metadata: data});
                    self._handleWebsocketRouterMessage(data.routerId, data.messageType, data.payload);
                });
            });
        };

        this.disconnect = function () {
            forcedDisconnect = true;
            self.socket.disconnect();
            beenConnected = false; //This is a forced disconnect from the storage and all listeners are removed
        };

        // watcher functions
        this.watchDatabase = function (data, callback) {
            return emitWithToken(data, 'watchDatabase')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.watchProject = function (data, callback) {
            return emitWithToken(data, 'watchProject')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.watchBranch = function (data, callback) {
            return emitWithToken(data, 'watchBranch')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        // model editing functions
        this.openProject = function (data, callback) {
            return emitWithToken(data, 'openProject')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.closeProject = function (data, callback) {
            return emitWithToken(data, 'closeProject')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.openBranch = function (data, callback) {
            return emitWithToken(data, 'openBranch')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.closeBranch = function (data, callback) {
            return emitWithToken(data, 'closeBranch')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.makeCommit = function (data, callback) {
            return emitWithToken(data, 'makeCommit')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.loadObjects = function (data, callback) {
            return emitWithToken(data, 'loadObjects')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.loadPaths = function (data, callback) {
            return emitWithToken(data, 'loadPaths')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.setBranchHash = function (data, callback) {
            return emitWithToken(data, 'setBranchHash')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.getBranchHash = function (data, callback) {
            return emitWithToken(data, 'getBranchHash')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.squashCommits = function (data, callback) {
            return emitWithToken(data, 'squashCommits')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        // REST like functions
        this.getProjects = function (data, callback) {
            return emitWithToken(data, 'getProjects')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.deleteProject = function (data, callback) {
            return emitWithToken(data, 'deleteProject')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.createProject = function (data, callback) {
            return emitWithToken(data, 'createProject')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.transferProject = function (data, callback) {
            return emitWithToken(data, 'transferProject')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.duplicateProject = function (data, callback) {
            return emitWithToken(data, 'duplicateProject')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.getBranches = function (data, callback) {
            return emitWithToken(data, 'getBranches')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.createTag = function (data, callback) {
            return emitWithToken(data, 'createTag')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.deleteTag = function (data, callback) {
            return emitWithToken(data, 'deleteTag')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.getTags = function (data, callback) {
            return emitWithToken(data, 'getTags')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.getCommits = function (data, callback) {
            return emitWithToken(data, 'getCommits')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.getHistory = function (data, callback) {
            return emitWithToken(data, 'getHistory')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.getLatestCommitData = function (data, callback) {
            return emitWithToken(data, 'getLatestCommitData')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.getCommonAncestorCommit = function (data, callback) {
            return emitWithToken(data, 'getCommonAncestorCommit')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        //temporary simple request / result functions
        this.simpleRequest = function (data, callback) {
            var deferred = Q.defer();
            emitWithToken(data, 'simpleRequest', function (errStr, result) {
                var err;
                if (errStr) {
                    err = new Error(errStr);
                    if (result) {
                        // webgme #1570 For failed plugin executions we need the result details
                        err.result = result;
                    }

                    deferred.reject(err);
                } else {
                    deferred.resolve(result);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        this.simpleQuery = function (workerId, data, callback) {
            return Q.reject(new Error('Not implemented!')).nodeify(callback);
        };

        this.sendNotification = function (data, callback) {
            return emitWithToken(data, 'notification')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        // OT handling
        this.watchDocument = function (data, callback) {
            return emitWithToken(data, 'watchDocument')
                .catch(function (err) {
                    return Q.reject(new Error(err));
                })
                .nodeify(callback);
        };

        this.sendDocumentOperation = function (data, callback) {
            emitWithToken(data, CONSTANTS.DOCUMENT_OPERATION, function (err, res) {
                if (err) {
                    callback(new Error(err));
                } else {
                    callback(null, res);
                }
            });
        };

        this.sendDocumentSelection = function (data, callback) {
            emitWithToken(data, CONSTANTS.DOCUMENT_SELECTION, function (err, res) {
                if (err) {
                    callback(new Error(err));
                } else {
                    callback(null, res);
                }
            });
        };

        // Helper functions
        this.getBranchUpdateEventName = function (projectId, branchName) {
            return CONSTANTS.BRANCH_UPDATED + projectId + CONSTANTS.ROOM_DIVIDER + branchName;
        };

        this.getDocumentUpdatedEventName = function (data) {
            if (typeof data.docId === 'string') {
                return CONSTANTS.DOCUMENT_OPERATION + data.docId;
            } else {
                return [CONSTANTS.DOCUMENT_OPERATION + data.projectId, data.branchName, data.nodeId, data.attrName]
                    .join(CONSTANTS.ROOM_DIVIDER);
            }
        };

        this.getDocumentSelectionEventName = function (data) {
            if (typeof data.docId === 'string') {
                return CONSTANTS.DOCUMENT_SELECTION + data.docId;
            } else {
                return [CONSTANTS.DOCUMENT_SELECTION + data.projectId, data.branchName, data.nodeId, data.attrName]
                    .join(CONSTANTS.ROOM_DIVIDER);
            }
        };

        // Router websocket relay messaging
        this.sendWsRouterMessage = function (routerId, messageType, payload, callback) {
            const data = {
                routerId: routerId,
                messageType: messageType,
                payload: payload,
            };

            return emitWithToken(data, 'websocketRouterMessage', (err, result) => {
                if (err) {
                    callback(new Error(err), result);
                } else {
                    callback(err, result);
                }
            });
                
        };

        this.onWebsocketRouterMessage = function (handleFn) {
            self._handleWebsocketRouterMessage = handleFn;
        };
    }

    WebSocket.prototype = Object.create(EventDispatcher.prototype);
    WebSocket.prototype.constructor = WebSocket;

    return WebSocket;
});
/*globals define*/
/*eslint-env browser*/
/**
 *
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/browserstorage',[
    'common/storage/storageclasses/editorstorage',
    'common/storage/socketio/browserclient',
    'common/storage/socketio/websocket',
], function (EditorStorage, BrowserIoClient, WebSocket) {
    'use strict';

    var _storage;

    function _createStorage(logger, gmeConfig) {
        var ioClient = new BrowserIoClient(logger, gmeConfig),
            webSocket = new WebSocket(ioClient, logger, gmeConfig),
            storage = new EditorStorage(webSocket, logger, gmeConfig);

        return storage;
    }

    function getStorage(logger, gmeConfig, forceNew) {
        logger.debug('getStorage');

        if (!_storage) {
            logger.debug('No storage existed, will create new one..');
            _storage = _createStorage(logger, gmeConfig);
        } else {
            logger.debug('Storage existed...');

            if (forceNew === true) {
                logger.debug('Force new set to true, will create new one.');
                _storage = _createStorage(logger, gmeConfig);
            }
        }

        return _storage;
    }

    return {
        getStorage: getStorage
    };
});
/*globals define*/
/*eslint-env node, browser*/

/**
 * CoreInternalError should be thrown if some internal ASSERTION fails, it triggers some fault inside the core
 * and should typically be checked by the developer team, not the one who uses it.
 * @author kecso / https://github.com/kecso
 */

define('common/core/CoreInternalError',[], function () {
    'use strict';
    function CoreInternalError() {
        var error = Error.apply(this, arguments);
        error.name = this.name = 'CoreInternalError';
        this.message = error.message;
        this.stack = error.stack;

        return error;
    }

    CoreInternalError.prototype = Object.create(Error.prototype);
    CoreInternalError.prototype.constructor = CoreInternalError;

    return CoreInternalError;
});
/*globals define*/
/*eslint-env node, browser*/
/*eslint no-console: 0*/
/**
 * @author kecso / https://github.com/kecso
 */


define('common/core/CoreAssert',['common/core/CoreInternalError'], function (CoreInternalError) {
    'use strict';

    var assert = function (cond, msg) {
        if (!cond) {
            var error = new CoreInternalError(msg || 'ASSERT failed');

            if (typeof TESTING === 'undefined') {
                console.log('Throwing', error.stack);
                console.log();
            }

            throw error;
        }
    };

    return assert;
});

/*globals define*/
/*eslint-env node, browser*/
/*eslint camelcase: 0*/

/**
 * @author mmaroti / https://github.com/mmaroti
 */

(function () {
    'use strict';

    // ------- assert -------

    var TASYNC_TRACE_ENABLE = true;

    function setTrace(value) {
        TASYNC_TRACE_ENABLE = value;
    }

    function assert(cond) {
        if (!cond) {
            throw new Error('tasync internal error');
        }
    }

    // ------- Future -------

    var STATE_LISTEN = 0;
    var STATE_REJECTED = 1;
    var STATE_RESOLVED = 2;

    var Future = function () {
        this.state = STATE_LISTEN;
        this.value = [];
    };

    Future.prototype.register = function (target) {
        assert(this.state === STATE_LISTEN);
        assert(typeof target === 'object' && target !== null);

        this.value.push(target);
    };

    Future.prototype.resolve = function (value) {
        assert(this.state === STATE_LISTEN && !(value instanceof Future));

        var listeners = this.value;

        this.state = STATE_RESOLVED;
        this.value = value;

        var i;
        for (i = 0; i < listeners.length; ++i) {
            listeners[i].onResolved(value);
        }
    };

    Future.prototype.reject = function (error) {
        assert(this.state === STATE_LISTEN && error instanceof Error);

        var listeners = this.value;

        this.state = STATE_REJECTED;
        this.value = error;

        var i;
        for (i = 0; i < listeners.length; ++i) {
            listeners[i].onRejected(error);
        }
    };

    // ------- Delay -------

    function delay(timeout, value) {
        if (timeout < 0) {
            return value;
        }

        var future = new Future();
        setTimeout(function () {
            future.resolve(value);
        }, timeout);
        return future;
    }

    // ------- Lift -------

    var FutureLift = function (array, index) {
        Future.call(this);

        this.array = array;
        this.index = index;
    };

    FutureLift.prototype = Object.create(Future.prototype);

    FutureLift.prototype.onResolved = function (value) {
        assert(this.state === STATE_LISTEN);

        var array = this.array;
        array[this.index] = value;

        while (++this.index < array.length) {
            value = array[this.index];
            if (value instanceof Future) {
                if (value.state === STATE_RESOLVED) {
                    array[this.index] = value.value;
                } else if (value.state === STATE_LISTEN) {
                    value.register(this);
                    return;
                } else {
                    assert(value.state === STATE_REJECTED);
                    this.reject(value.value);
                    return;
                }
            }
        }

        this.array = null;
        this.resolve(array);
    };

    FutureLift.prototype.onRejected = function (error) {
        this.array = null;
        this.reject(error);
    };

    var lift = function (array) {
        if (!(array instanceof Array)) {
            throw new Error('array argument is expected');
        }

        var index;
        for (index = 0; index < array.length; ++index) {
            var value = array[index];
            if (value instanceof Future) {
                if (value.state === STATE_RESOLVED) {
                    array[index] = value.value;
                } else if (value.state === STATE_LISTEN) {
                    var future = new FutureLift(array, index);
                    value.register(future);
                    return future;
                } else {
                    assert(value.state === STATE_REJECTED);
                    return value;
                }
            }
        }

        return array;
    };

    // ------- Apply -------

    var ROOT = {
        subframes: 0
    };

    var FRAME = ROOT;

    var FutureApply = function tasync_trace_end(func, that, args, index) {
        Future.call(this);

        this.caller = FRAME;
        this.position = ++FRAME.subframes;
        this.subframes = 0;

        if (TASYNC_TRACE_ENABLE) {
            this.trace = new Error();
        }

        this.func = func;
        this.that = that;
        this.args = args;
        this.index = index;
    };

    FutureApply.prototype = Object.create(Future.prototype);

    FutureApply.prototype.getPath = function () {
        var future = this.caller,
            path = [this.position];

        while (future !== ROOT) {
            path.push(future.position);
            future = future.caller;
        }

        return path;
    };

    function getSlice(trace) {
        assert(typeof trace === 'string');

        var end = trace.indexOf('tasync_trace_start');
        if (end >= 0) {
            end = trace.lastIndexOf('\n', end) + 1;
        } else {
            if (trace.charAt(trace.length - 1) !== '\n') {
                // trace += '\n';
            }
            end = undefined;
        }

        var start = trace.indexOf('tasync_trace_end');
        if (start >= 0) {
            start = trace.indexOf('\n', start) + 1;
            if (start >= 0) {
                start = trace.indexOf('\n', start) + 1;
            }
        } else {
            start = 0;
        }

        return trace.substring(start, end);
    }

    function createError(error, future) {
        if (!(error instanceof Error)) {
            error = new Error(error);
        }

        if (TASYNC_TRACE_ENABLE) {
            error.trace = getSlice(error.stack);
            do {
                error.trace += '*** callback ***\n';
                error.trace += getSlice(future.trace.stack);
                future = future.caller;
            } while (future !== ROOT);
        }

        return error;
    }

    FutureApply.prototype.onRejected = function (error) {
        this.args = null;
        this.reject(error);
    };

    FutureApply.prototype.onResolved = function tasync_trace_start(value) {
        assert(this.state === STATE_LISTEN);

        var args = this.args;
        args[this.index] = value;

        while (--this.index >= 0) {
            value = args[this.index];
            if (value instanceof Future) {
                if (value.state === STATE_RESOLVED) {
                    args[this.index] = value.value;
                } else if (value.state === STATE_LISTEN) {
                    value.register(this);
                    return;
                } else {
                    assert(value.state === STATE_REJECTED);
                    this.reject(value.value);
                    return;
                }
            }
        }

        assert(FRAME === ROOT);
        FRAME = this;

        this.args = null;
        try {
            value = this.func.apply(this.that, args);
        } catch (error) {
            FRAME = ROOT;

            this.reject(createError(error, this));
            return;
        }

        FRAME = ROOT;

        if (value instanceof Future) {
            assert(value.state === STATE_LISTEN);

            this.onResolved = this.resolve;
            value.register(this);
        } else {
            this.resolve(value);
        }
    };

    var apply = function (func, args, that) {
        if (typeof func !== 'function') {
            throw new Error('function argument is expected');
        } else if (!(args instanceof Array)) {
            throw new Error('array argument is expected');
        }

        var index = args.length;
        while (--index >= 0) {
            var value = args[index];
            if (value instanceof Future) {
                if (value.state === STATE_LISTEN) {
                    var future = new FutureApply(func, that, args, index);
                    value.register(future);
                    return future;
                } else if (value.state === STATE_RESOLVED) {
                    args[index] = value.value;
                } else {
                    assert(value.state === STATE_REJECTED);
                    return value;
                }
            }
        }

        return func.apply(that, args);
    };

    // ------- Call -------

    var FutureCall = function tasync_trace_end(args, index) {
        Future.call(this);

        this.caller = FRAME;
        this.position = ++FRAME.subframes;
        this.subframes = 0;

        if (TASYNC_TRACE_ENABLE) {
            this.trace = new Error();
        }

        this.args = args;
        this.index = index;
    };

    FutureCall.prototype = Object.create(Future.prototype);

    FutureCall.prototype.getPath = FutureApply.prototype.getPath;
    FutureCall.prototype.onRejected = FutureApply.prototype.onRejected;

    var FUNCTION_CALL = Function.call;

    FutureCall.prototype.onResolved = function tasync_trace_start(value) {
        assert(this.state === STATE_LISTEN);

        var args = this.args;
        args[this.index] = value;

        while (--this.index >= 0) {
            value = args[this.index];
            if (value instanceof Future) {
                if (value.state === STATE_RESOLVED) {
                    args[this.index] = value.value;
                } else if (value.state === STATE_LISTEN) {
                    value.register(this);
                    return;
                } else {
                    assert(value.state === STATE_REJECTED);
                    this.reject(value.value);
                    return;
                }
            }
        }

        assert(FRAME === ROOT);
        FRAME = this;

        this.args = null;
        try {
            var func = args[0];
            args[0] = null;
            value = FUNCTION_CALL.apply(func, args);
        } catch (error) {
            FRAME = ROOT;

            this.reject(createError(error, this));
            return;
        }

        FRAME = ROOT;

        if (value instanceof Future) {
            assert(value.state === STATE_LISTEN);

            this.onResolved = this.resolve;
            value.register(this);
        } else {
            this.resolve(value);
        }
    };

    var call = function () {
        var index = arguments.length;
        while (--index >= 0) {
            var value = arguments[index];
            if (value instanceof Future) {
                if (value.state === STATE_LISTEN) {
                    var future = new FutureCall(arguments, index);
                    value.register(future);
                    return future;
                } else if (value.state === STATE_RESOLVED) {
                    arguments[index] = value.value;
                } else {
                    assert(value.state === STATE_REJECTED);
                    return value;
                }
            }
        }

        var func = arguments[0];
        return FUNCTION_CALL.apply(func, arguments);
    };

    // ------- TryCatch -------

    function FutureTryCatch(handler) {
        Future.call(this);

        this.handler = handler;
    }

    FutureTryCatch.prototype = Object.create(Future.prototype);

    FutureTryCatch.prototype.onRejected = function (error) {
        try {
            var value = this.handler(error);

            if (value instanceof Future) {
                this.onRejected = Future.prorotype.reject;
                value.register(this);
            } else {
                this.resolve(value);
            }
        } catch (err) {
            this.reject(err);
        }
    };

    FutureTryCatch.prototype.onResolved = Future.prototype.resolve;

    function trycatch(func, handler) {
        if (typeof func !== 'function' || typeof handler !== 'function') {
            throw new Error('function arguments are expected');
        }

        try {
            var value = func();

            if (value instanceof Future) {
                var future = new FutureTryCatch(handler);
                value.register(future);

                return future;
            } else {
                return value;
            }
        } catch (error) {
            return handler(error);
        }
    }

    // ------- Wrap -------

    function wrap(func) {
        if (typeof func !== 'function') {
            throw new Error('function argument is expected');
        }

        if (func.tasync_wraped === undefined) {
            func.tasync_wraped = function () {
                var args = arguments;
                var future = new Future();

                args[args.length++] = function (error, value) {
                    if (error) {
                        future.reject(error instanceof Error ? error : new Error(error));
                    } else {
                        future.resolve(value);
                    }
                };

                func.apply(this, args);

                if (future.state === STATE_LISTEN) {
                    return future;
                } else if (future.state === STATE_RESOLVED) {
                    return future.value;
                } else {
                    assert(future.state === STATE_REJECTED);
                    throw future.value;
                }
            };

            func.tasync_wraped.tasync_unwraped = func;
        }

        return func.tasync_wraped;
    }

    // ------- Unwrap -------

    function UnwrapListener(callback) {
        this.callback = callback;
    }

    UnwrapListener.prototype.onRejected = function (error) {
        this.callback(error);
    };

    UnwrapListener.prototype.onResolved = function (value) {
        this.callback(null, value);
    };

    function unwrap(func) {
        if (typeof func !== 'function') {
            throw new Error('function argument is expected');
        }

        if (func.tasync_unwraped === undefined) {
            func.tasync_unwraped = function () {
                var args = arguments;

                var callback = args[--args.length];
                assert(typeof callback === 'function');

                var value;
                try {
                    value = func.apply(this, args);
                } catch (error) {
                    callback(error);
                    return;
                }

                if (value instanceof Future) {
                    assert(value.state === STATE_LISTEN);

                    var listener = new UnwrapListener(callback);
                    value.register(listener);
                } else {
                    callback(null, value);
                }
            };

            func.tasync_unwraped.tasync_wraped = func;
        }

        return func.tasync_unwraped;
    }

    // ------- Throttle -------

    function FutureThrottle(func, that, args) {
        Future.call(this);

        this.func = func;
        this.that = that;
        this.args = args;

        this.caller = FRAME;
        this.position = ++FRAME.subframes;

        this.path = this.getPath();
    }

    FutureThrottle.prototype = Object.create(Future.prototype);

    FutureThrottle.prototype.execute = function () {
        var value;
        try {
            assert(FRAME === ROOT);
            FRAME = this;

            value = this.func.apply(this.that, this.args);

            FRAME = ROOT;
        } catch (error) {
            FRAME = ROOT;

            this.reject(error);
            return;
        }

        if (value instanceof Future) {
            assert(value.state === STATE_LISTEN);
            value.register(this);
        } else {
            this.resolve(value);
        }
    };

    FutureThrottle.prototype.getPath = FutureApply.prototype.getPath;
    FutureThrottle.prototype.onResolved = Future.prototype.resolve;
    FutureThrottle.prototype.onRejected = Future.prototype.reject;

    FutureThrottle.prototype.compare = function (second) {
        var first = this.path;
        second = second.path;

        var i, limit = first.length < second.length ? first.length : second.length;
        for (i = 0; i < limit; ++i) {
            if (first[i] !== second[i]) {
                return first[i] - second[i];
            }
        }

        return first.length - second.length;
    };

    function ThrottleListener(limit) {
        this.running = 0;
        this.limit = limit;
        this.queue = [];
    }

    function priorityQueueInsert(queue, elem) {
        var low = 0;
        var high = queue.length;

        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            assert(low <= mid && mid < high);

            if (elem.compare(queue[mid]) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }

        queue.splice(low, 0, elem);
    }

    ThrottleListener.prototype.execute = function (func, that, args) {
        if (this.running < this.limit) {
            var value = func.apply(that, args);

            if (value instanceof Future) {
                assert(value.state === STATE_LISTEN);

                ++this.running;
                value.register(this);
            }

            return value;
        } else {
            var future = new FutureThrottle(func, that, args);
            priorityQueueInsert(this.queue, future);

            return future;
        }
    };

    ThrottleListener.prototype.onResolved = function () {
        if (this.queue.length > 0) {
            var future = this.queue.pop();
            future.register(this);

            future.execute();
        } else {
            --this.running;
        }
    };

    ThrottleListener.prototype.onRejected = ThrottleListener.prototype.onResolved;

    // TODO: prevent recursion, otheriwise throttle will not work
    function throttle(func, limit) {
        if (typeof func !== 'function') {
            throw new Error('function argument is expected');
        } else if (typeof limit !== 'number') {
            throw new Error('number argument is expected');
        }

        var listener = new ThrottleListener(limit);

        return function () {
            return listener.execute(func, this, arguments);
        };
    }

    // ------- Join -------

    function FutureJoin(first) {
        Future.call(this);

        this.first = first;
        this.missing = first instanceof Future && first.state === STATE_LISTEN ? 1 : 0;
    }

    FutureJoin.prototype = Object.create(Future.prototype);

    FutureJoin.prototype.onResolved = function (/*value*/) {
        if (--this.missing === 0) {
            assert(this.state !== STATE_RESOLVED);

            if (this.state === STATE_LISTEN) {
                if (this.first instanceof Future) {
                    assert(this.first.state === STATE_RESOLVED);

                    this.resolve(this.first.value);
                } else {
                    this.resolve(this.first);
                }
            }
        }
    };

    FutureJoin.prototype.onRejected = function (error) {
        if (this.state === STATE_LISTEN) {
            this.reject(error);
        }
    };

    function join(first, second) {
        if (first instanceof Future && first.state === STATE_REJECTED) {
            return first;
        } else if (second instanceof Future) {
            if (second.state === STATE_RESOLVED) {
                return first;
            } else if (second.state === STATE_REJECTED) {
                return second;
            }
        } else {
            return first;
        }

        if (!(first instanceof FutureJoin)) {
            first = new FutureJoin(first);
        }

        first.missing += 1;
        second.register(first);

        return first;
    }

    // ------- TASYNC -------

    var TASYNC = {
        setTrace: setTrace,
        delay: delay,
        lift: lift,
        apply: apply,
        call: call,
        trycatch: trycatch,
        wrap: wrap,
        unwrap: unwrap,
        throttle: throttle,
        join: join
    };

    if (typeof define === 'function' && define.amd) {
        define('common/core/tasync',[], function () {
            return TASYNC;
        });
    } else {
        module.exports = TASYNC;
    }
}());

/*globals define*/
/*eslint-env node, browser*/

/**
 * @author mmaroti / https://github.com/mmaroti
 */

define('common/core/corerel',[
    'common/core/CoreAssert',
    'common/core/tasync',
    'common/util/random',
    'common/core/constants',
    'common/storage/constants',
    'common/util/key',
    'common/regexp'
], function (ASSERT, TASYNC, RANDOM, CONSTANTS, STORAGE_CONSTANTS, generateKey, REGEXP) {

    'use strict';

    function InverseOverlaysCache(maxSize, logger) {
        var self = this;

        maxSize = maxSize || 10000;
        this._backup = {};
        this._cache = {};
        this._size = 0;

        this.getItem = function (key) {
            if (self._cache[key]) {
                return self._cache[key];
            }

            if (self._backup[key]) {
                return self._backup[key];
            }

            return null;

        };

        this.setItem = function (key, data) {
            if (!self._cache[key]) {
                if (self._size === maxSize) {
                    self._size = 0;
                    self._backup = self._cache;
                    self._cache = {};
                }
                self._size += 1;
                self._cache[key] = data;

            } else {
                logger.warn('trying to add inverse relation object multiple times [#' + key + ']');
            }
        };

    }

    function CoreRel(innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof innerCore === 'object');

        var logger = innerCore.logger,
            self = this,
            _shardSize = options.globConf.core.overlayShardSize,
            _shardingLimit = Math.floor(_shardSize / 2),
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        //removing direct storage functions on this level
        delete this.loadObject;
        delete this.insertObject;

        this._inverseCache = new InverseOverlaysCache(options.globConf.core.inverseRelationsCacheSize,
            logger.fork('inverseCache'));

        logger.debug('initialized CoreRel');

        //<editor-fold=Helper Functions>
        function test(text, cond) {
            if (!cond) {
                throw new Error(text);
            }
        }

        function isObject(node) {
            node = innerCore.normalize(node);
            return typeof node.data === 'object' && node.data !== null;
        }

        function isValidNodeThrow(node) {
            test('coretree', innerCore.isValidNode(node));
            test('isobject', isObject(node));
        }

        function getRelativePointerPathFrom(node, source, name) {
            ASSERT(self.isValidNode(node) && typeof source === 'string' && typeof name === 'string');
            var target,
                ovrInfo;

            do {
                ovrInfo = self.overlayInquiry(node, source, name);
                if (typeof ovrInfo.value === 'string') {
                    target = ovrInfo.value;
                    break;
                }

                source = CONSTANTS.PATH_SEP + innerCore.getRelid(node) + source;
                node = innerCore.getParent(node);

            } while (node);

            return {
                target: target,
                node: node
            };
        }

        function storeNewInverseOverlays(node) {
            var hash = self.getHash(node),
                relid;

            if (hash && node.inverseOverlays && node.inverseOverlaysMutable) {
                self._inverseCache.setItem(hash, node.inverseOverlays);
                delete node.inverseOverlaysMutable;
                for (relid in node.children) {
                    storeNewInverseOverlays(node.children[relid]);
                }
            }
        }

        function hasShardedOverlays(node) {
            return (self.getProperty(node, CONSTANTS.OVERLAYS_PROPERTY) ||
                {})[CONSTANTS.OVERLAY_SHARD_INDICATOR] === true;
        }

        function updateSmallestOverlayShardIndex(node) {
            var shardId,
                minimalItemCount = _shardSize + 1;

            for (shardId in node.overlays) {
                if (node.overlays[shardId].itemCount < minimalItemCount) {
                    minimalItemCount = node.overlays[shardId].itemCount;
                    node.minimalOverlayShardId = shardId;
                }
            }
        }

        function attachOverlays(node) {

            if (hasShardedOverlays(node) !== true) {
                return node;
            }

            var overlays = self.getProperty(node, CONSTANTS.OVERLAYS_PROPERTY),
                shardId,
                shardIds = [],
                loadPromises = [];

            for (shardId in overlays) {
                if (REGEXP.DB_HASH.test(overlays[shardId]) === true) {
                    shardIds.push(shardId);
                    loadPromises.push(innerCore.loadObject(overlays[shardId]));
                }
            }

            return TASYNC.call(function (overlayShards) {
                var i;

                node.overlays = {};
                node.overlayMutations = {};
                node.overlayInitials = {};
                for (i = 0; i < overlayShards.length; i += 1) {
                    shardId = shardIds[i];
                    node.overlays[shardId] = overlayShards[i];
                    node.overlayInitials[shardId] = overlayShards[i];
                    node.overlayMutations[shardId] = false;
                }
                updateSmallestOverlayShardIndex(node);
                return node;
            }, TASYNC.lift(loadPromises));
        }

        // We only shard regular GME nodes, technical sub-nodes do not get sharded
        function shouldHaveShardedOverlays(node) {
            return Object.keys(self.getProperty(node, CONSTANTS.OVERLAYS_PROPERTY) || {}).length >=
                _shardingLimit && self.getPath(node).indexOf('_') === -1;
        }

        function addNewOverlayShard(node) {
            var overlaysNode = self.getChild(node, CONSTANTS.OVERLAYS_PROPERTY),
                shardId = RANDOM.generateRelid(overlaysNode.data),
                newShardObject = {
                    type: STORAGE_CONSTANTS.OVERLAY_SHARD_TYPE,
                    itemCount: 0,
                    items: {}
                };

            newShardObject[self.ID_NAME] = '';
            node.overlays[shardId] = newShardObject;
            node.overlayMutations[shardId] = true;

            self.setProperty(overlaysNode, shardId, null);
            return shardId;
        }

        function removeOverlayShard(node, shardId) {
            // At this point the node should always be mutated.
            var overlaysNode = self.getChild(node, CONSTANTS.OVERLAYS_PROPERTY);

            delete node.overlays[shardId];
            delete node.overlayMutations[shardId];
            self.deleteProperty(overlaysNode, shardId);
        }

        function transformOverlays(node) {
            var originalOverlays = self.getProperty(node, CONSTANTS.OVERLAYS_PROPERTY),
                count = _shardSize,
                source,
                name,
                shardId;

            self.deleteChild(node, CONSTANTS.OVERLAYS_PROPERTY);
            self.removeChildFromCache(node, CONSTANTS.OVERLAYS_PROPERTY);

            self.setProperty(self.getChild(node, CONSTANTS.OVERLAYS_PROPERTY), CONSTANTS.OVERLAY_SHARD_INDICATOR, true);

            node.overlays = {};
            node.overlayMutations = {};
            node.overlayInitials = {};
            node.minimalOverlayShardId = null;
            for (source in originalOverlays) {
                if (source !== CONSTANTS.MUTABLE_PROPERTY) {
                    for (name in originalOverlays[source]) {
                        if (name !== CONSTANTS.MUTABLE_PROPERTY) {
                            if (count >= _shardSize) {
                                shardId = addNewOverlayShard(node);
                                node.minimalOverlayShardId = shardId;
                                count = 0;
                            }

                            node.overlays[shardId].items[source] = node.overlays[shardId].items[source] || {};
                            node.overlays[shardId].items[source][name] = originalOverlays[source][name];
                            node.overlays[shardId].itemCount += 1;
                            count += 1;
                        }
                    }
                }
            }

            // In the unlikely event that during transition the original shard is empty.
            if (Object.keys(node.overlays).length === 0) {
                node.minimalOverlayShardId = addNewOverlayShard(node);
            }
        }

        function ensureOverlayShardMutated(node, shardId) {
            var overlayNode;

            if (node.overlayMutations[shardId] !== true) {
                node.overlayMutations[shardId] = true;
                node.overlays[shardId] = JSON.parse(JSON.stringify(node.overlays[shardId]));
                overlayNode = self.getChild(node, CONSTANTS.OVERLAYS_PROPERTY);
                self.setProperty(overlayNode, shardId, null);
            }
        }

        function putEntryIntoOverlayShard(node, shardId, source, name, target) {

            if (node.overlays[shardId].itemCount >= _shardSize &&
                node.overlays[shardId].items.hasOwnProperty(source) === false) {
                shardId = addNewOverlayShard(node);
                node.minimalOverlayShardId = shardId;
            }

            ensureOverlayShardMutated(node, shardId);

            node.overlays[shardId].items[source] = node.overlays[shardId].items[source] || {};
            node.overlays[shardId].items[source][name] = target;
            node.overlays[shardId].itemCount += 1;

            if (node.minimalOverlayShardId === shardId && node.overlays[shardId].itemCount >= _shardSize) {
                updateSmallestOverlayShardIndex(node);
            }
        }

        function putEntryIntoShardedOverlays(node, source, name, target) {
            // At this point we expect that everything was checked and we can simply look for
            // the proper place of the entry.
            var shardId;

            for (shardId in node.overlays) {
                if (node.overlays[shardId].items.hasOwnProperty(source)) {
                    putEntryIntoOverlayShard(node, shardId, source, name, target);
                    return;
                }
            }

            putEntryIntoOverlayShard(node, node.minimalOverlayShardId, source, name, target);
        }

        function removeEntryFromShardedOverlays(node, source, name) {
            var shardId;

            for (shardId in node.overlays) {
                if (node.overlays[shardId].items[source]) {
                    if (typeof node.overlays[shardId].items[source][name] === 'string') {

                        ensureOverlayShardMutated(node, shardId);

                        delete node.overlays[shardId].items[source][name];
                        node.overlays[shardId].itemCount -= 1;
                    }
                    break;
                }
            }
        }

        function persistShardedOverlays(node, stackedObjects) {
            // This recursive function will save objects, right before calling the underlying persist.
            var relids,
                shardId,
                source,
                hash,
                overlayNode,
                shouldUpdateSmallest = false,
                i;

            if (self.isMutable(node) !== true) {
                return;
            }

            relids = self.getChildrenRelids(node);

            for (i = 0; i < relids.length; i += 1) {
                if (self.childLoaded(node, relids[i]) === true) {
                    persistShardedOverlays(self.getChild(node, relids[i]), stackedObjects);
                }
            }

            overlayNode = self.getChild(node, CONSTANTS.OVERLAYS_PROPERTY);
            for (shardId in node.overlayMutations) {
                // We only remove shards if they were empty at loading as well. Otherwise
                // node eventing would be impossible.
                if (node.overlayMutations[shardId] === true) {
                    node.overlayMutations[shardId] = false;
                    node.overlays[shardId][self.ID_NAME] = '';
                    node.overlays[shardId].__v = STORAGE_CONSTANTS.VERSION;

                    // if we persist an empty shard we have to ensure that its hash will be unique
                    if (node.overlays[shardId].itemCount === 0) {
                        node.overlays[shardId].oldHash = node.overlayInitials[shardId] ?
                            node.overlayInitials[shardId][self.ID_NAME] || null : null;
                        node.overlays[shardId].items = {};
                    } else {
                        for (source in node.overlays[shardId].items) {
                            if (Object.keys(node.overlays[shardId].items[source]).length === 0) {
                                delete node.overlays[shardId].items[source];
                            }
                        }
                    }

                    hash = '#' + generateKey(node.overlays[shardId], options.globConf);
                    node.overlays[shardId][self.ID_NAME] = hash;
                    innerCore.insertObject(node.overlays[shardId], stackedObjects);
                    stackedObjects[hash] = {
                        oldHash: node.overlayInitials[shardId] ? node.overlayInitials[shardId][self.ID_NAME] : null,
                        oldData: node.overlayInitials[shardId],
                        newHash: hash,
                        newData: node.overlays[shardId]
                    };

                    self.setProperty(overlayNode, shardId, hash);
                    shouldUpdateSmallest = true;
                } else if (node.overlays[shardId].itemCount === 0) {
                    removeOverlayShard(node, shardId);
                    shouldUpdateSmallest = true;
                }
            }

            if (shouldUpdateSmallest) {
                updateSmallestOverlayShardIndex(node);
            }
        }

        //</editor-fold>

        //<editor-fold=Modified Methods>
        this.isValidNode = function (node) {
            try {
                isValidNodeThrow(node);

                return true;
            } catch (error) {
                logger.error(error.message, {metadata: {stack: error.stack, node: node}});
                return false;
            }
        };

        this.persist = function (node) {
            var stackedObjects = {},
                persisted;

            persistShardedOverlays(node, stackedObjects);
            persisted = innerCore.persist(node, stackedObjects);
            storeNewInverseOverlays(self.getRoot(node));

            return persisted;
        };

        this.loadRoot = function (hash) {
            return TASYNC.call(function (root) {
                return attachOverlays(root);
            }, innerCore.loadRoot(hash));
        };

        this.loadChild = function (node, relid) {
            return TASYNC.call(function (child) {
                return attachOverlays(child);
            }, innerCore.loadChild(node, relid));
        };

        this.loadByPath = function (node, relPath) {
            return TASYNC.call(function (target) {
                return attachOverlays(target);
            }, innerCore.loadByPath(node, relPath));
        };
        //</editor-fold>

        //<editor-fold=Added Methods>
        this.getInverseOverlayOfNode = function (node) {
            var hash,
                inverseOverlays = {},
                overlay,
                overlaysObject,
                shardId,
                source,
                name,
                target;

            // If the node already has inverse computed we return that
            if (node.inverseOverlays) {
                return node.inverseOverlays;
            }

            // If we find it in the cache we set that and use it
            hash = self.getHash(node);
            if (hash) {
                inverseOverlays = self._inverseCache.getItem(hash);
                if (inverseOverlays) {
                    node.inverseOverlays = inverseOverlays;
                    delete node.inverseOverlaysMutable;
                    return node.inverseOverlays;
                }
            }

            // Otherwise we have to compute it
            if (hasShardedOverlays(node)) {
                overlaysObject = node.overlays;
            } else {
                overlaysObject = {single: {items: self.getProperty(node, CONSTANTS.OVERLAYS_PROPERTY) || {}}};
            }

            inverseOverlays = {};
            for (shardId in overlaysObject) {
                overlay = overlaysObject[shardId];
                for (source in overlay.items) {
                    if (source !== CONSTANTS.MUTABLE_PROPERTY) {
                        for (name in overlay.items[source]) {
                            if (name !== CONSTANTS.MUTABLE_PROPERTY) {
                                target = overlay.items[source][name];
                                inverseOverlays[target] = inverseOverlays[target] || {};
                                inverseOverlays[target][name] = inverseOverlays[target][name] || [];
                                inverseOverlays[target][name].push(source);
                            }
                        }
                    }
                }
            }

            // If it is an unmodified node, we can store the inverse, otherwise it still can change
            if (hash) {
                self._inverseCache.setItem(hash, inverseOverlays);
                delete node.inverseOverlaysMutable;
            } else {
                node.inverseOverlaysMutable = true;
            }

            node.inverseOverlays = inverseOverlays;

            return node.inverseOverlays;

        };

        this.isPointerName = function (name) {
            ASSERT(typeof name === 'string');
            //TODO this is needed as now we work with modified data as well
            if (name === CONSTANTS.MUTABLE_PROPERTY) {
                return false;
            }
            // return name.slice(-CONSTANTS.COLLECTION_NAME_SUFFIX.length) !==
            //     CONSTANTS.COLLECTION_NAME_SUFFIX;

            return true;
        };

        this.getAttributeNames = function (node) {
            ASSERT(self.isValidNode(node));

            var data,
                keys,
                i,
                result = [],
                key;

            data = (innerCore.getProperty(node, CONSTANTS.ATTRIBUTES_PROPERTY) || {});
            keys = Object.keys(data);
            i = keys.length;
            while (--i >= 0) {
                key = keys[i];
                if (key.charAt(0) === '') {
                    logger.error('empty named attribute found in node [' + innerCore.getPath(node) + ']');
                    //keys.splice(i, 1);
                } else if (key.charAt(0) === '_') {
                    //keys.splice(i, 1);
                } else {
                    result.push(key);
                }
            }

            return result;
        };

        this.getRegistryNames = function (node) {
            ASSERT(self.isValidNode(node));

            var data,
                keys,
                i,
                result = [],
                key;

            data = (innerCore.getProperty(node, CONSTANTS.REGISTRY_PROPERTY) || {});
            keys = Object.keys(data);
            i = keys.length;
            while (--i >= 0) {
                key = keys[i];
                if (keys[i].charAt(0) === '') {
                    logger.error('empty named attribute found in node [' + innerCore.getPath(node) + ']');
                    //keys.splice(i, 1);
                } else if (keys[i].charAt(0) === '_') {
                    //keys.splice(i, 1);
                } else {
                    result.push(key);
                }
            }

            return result;
        };

        this.getAttribute = function (node, name) {
            /*node = coretree.getChild(node, coretree.constants.ATTRIBUTES_PROPERTY);
             return coretree.getProperty(node, name);*/
            return (innerCore.getProperty(node, CONSTANTS.ATTRIBUTES_PROPERTY) || {})[name];
        };

        this.delAttribute = function (node, name) {
            node = innerCore.getChild(node, CONSTANTS.ATTRIBUTES_PROPERTY);
            innerCore.deleteProperty(node, name);
        };

        this.setAttribute = function (node, name, value) {
            node = innerCore.getChild(node, CONSTANTS.ATTRIBUTES_PROPERTY);
            innerCore.setProperty(node, name, value);
        };

        this.renameAttribute = function (node, oldName, newName) {
            node = innerCore.getChild(node, CONSTANTS.ATTRIBUTES_PROPERTY);
            innerCore.renameProperty(node, oldName, newName);
        };

        this.getRegistry = function (node, name) {
            /*node = coretree.getChild(node, coretree.constants.REGISTRY_PROPERTY);
             return coretree.getProperty(node, name);*/
            return (innerCore.getProperty(node, CONSTANTS.REGISTRY_PROPERTY) || {})[name];
        };

        this.delRegistry = function (node, name) {
            node = innerCore.getChild(node, CONSTANTS.REGISTRY_PROPERTY);
            innerCore.deleteProperty(node, name);
        };

        this.setRegistry = function (node, name, value) {
            node = innerCore.getChild(node, CONSTANTS.REGISTRY_PROPERTY);
            innerCore.setProperty(node, name, value);
        };

        this.renameRegistry = function (node, oldName, newName) {
            node = innerCore.getChild(node, CONSTANTS.REGISTRY_PROPERTY);
            innerCore.renameProperty(node, oldName, newName);
        };

        this.overlayInquiry = function (node, source, name) {
            // If name is not given, then the whole object returned.
            // If no entry found, null is returned.
            var shardId,
                ordinaryOverlays,
                result = {
                    shardId: null,
                    value: null
                };

            if (hasShardedOverlays(node) === true) {
                for (shardId in node.overlays) {
                    if (node.overlays[shardId].items[source]) {
                        result.shardId = shardId;
                        if (typeof name === 'string') {
                            result.value = typeof node.overlays[shardId].items[source][name] === 'string' ?
                                node.overlays[shardId].items[source][name] : null;
                        } else {
                            result.value = node.overlays[shardId].items[source];
                        }
                        break;
                    }
                }
            } else {
                ordinaryOverlays = self.getProperty(node, CONSTANTS.OVERLAYS_PROPERTY) || {};
                if (ordinaryOverlays.hasOwnProperty(source)) {
                    if (typeof name === 'string') {
                        result.value = typeof ordinaryOverlays[source][name] === 'string' ?
                            ordinaryOverlays[source][name] : null;
                    } else {
                        result.value = ordinaryOverlays[source];
                    }
                }
            }

            return result;
        };

        this.overlayRemove = function (node, source, name, target) {
            ASSERT(self.isValidNode(node));
            ASSERT(innerCore.isValidPath(source) && innerCore.isValidPath(target) && self.isPointerName(name));
            ASSERT(innerCore.getCommonPathPrefixData(source, target).common === '');

            var currentOverlayInfo = self.overlayInquiry(node, source, name),
                index,
                overlays,
                overlayNode;

            ASSERT(currentOverlayInfo.value === target);

            if (hasShardedOverlays(node)) {
                removeEntryFromShardedOverlays(node, source, name);
            } else {
                overlays = self.getChild(node, CONSTANTS.OVERLAYS_PROPERTY);

                overlayNode = innerCore.getChild(overlays, source);
                innerCore.deleteProperty(overlayNode, name);

                if (innerCore.getKeys(overlayNode).length === 0) {
                    innerCore.deleteProperty(overlays, source);
                }
            }

            //Now we check if we need to mutate the inverse overlays
            if (node.inverseOverlays) {
                if (node.inverseOverlaysMutable !== true) {
                    node.inverseOverlays = JSON.parse(JSON.stringify(node.inverseOverlays));
                    node.inverseOverlaysMutable = true;
                }

                index = ((node.inverseOverlays[target] || {})[name] || []).indexOf(source);
                if (index !== -1) {
                    node.inverseOverlays[target][name].splice(index, 1);
                    if (node.inverseOverlays[target][name].length === 0) {
                        delete node.inverseOverlays[target][name];
                        if (Object.keys(node.inverseOverlays[target]).length === 0) {
                            delete node.inverseOverlays[target];
                        }
                    }
                }
            }
        };

        this.overlayQuery = function (node, prefix) {
            ASSERT(self.isValidNode(node) && innerCore.isValidPath(prefix));

            var overlays,
                overlaysObject,
                shardId,
                inverseOverlays = self.getInverseOverlayOfNode(node), // We necessarily have to compute at this point,
                i, path, name, list = [],
                prefix2 = prefix + CONSTANTS.PATH_SEP;

            if (hasShardedOverlays(node)) {
                overlaysObject = node.overlays;
            } else {
                overlaysObject = {single: {items: self.getProperty(node, CONSTANTS.OVERLAYS_PROPERTY) || {}}};
            }

            for (shardId in overlaysObject) {
                overlays = overlaysObject[shardId].items;
                for (path in overlays) {
                    if (path === prefix || path.substr(0, prefix2.length) === prefix2) {
                        for (name in overlays[path]) {
                            if (self.isPointerName(name)) {
                                list.push({
                                    s: path,                // source
                                    n: name,                // name
                                    t: overlays[path][name], // target
                                    p: true                 // is forward relation
                                });
                            }
                        }
                    }
                }
            }

            for (path in inverseOverlays) {
                if (path === prefix || path.substr(0, prefix2.length) === prefix2) {
                    for (name in inverseOverlays[path]) {
                        for (i = 0; i < inverseOverlays[path][name].length; i += 1) {
                            list.push({
                                s: inverseOverlays[path][name][i],
                                n: name,
                                t: path,
                                p: false
                            });
                        }
                    }
                }
            }

            return list;
        };

        this.overlayInsert = function (node, source, name, target) {
            ASSERT(self.isValidNode(node));
            ASSERT(innerCore.isValidPath(source) && innerCore.isValidPath(target) && self.isPointerName(name));
            ASSERT(innerCore.getCommonPathPrefixData(source, target).common === '');

            var currentOverlayInfo = self.overlayInquiry(node, source, name),
                overlays,
                overlay;

            ASSERT(currentOverlayInfo.value === null);

            if (hasShardedOverlays(node) === false && shouldHaveShardedOverlays(node)) {
                transformOverlays(node);
            }

            if (hasShardedOverlays(node) === true) {
                putEntryIntoShardedOverlays(node, source, name, target);
            } else {
                overlays = self.getChild(node, CONSTANTS.OVERLAYS_PROPERTY);
                overlay = self.getChild(overlays, source);

                self.setProperty(overlay, name, target);
            }

            //Now we check if we need to mutate the inverse overlays
            if (node.inverseOverlays) {
                if (node.inverseOverlaysMutable !== true) {
                    node.inverseOverlays = JSON.parse(JSON.stringify(node.inverseOverlays));
                    node.inverseOverlaysMutable = true;
                }

                node.inverseOverlays[target] = node.inverseOverlays[target] || {};
                node.inverseOverlays[target][name] = node.inverseOverlays[target][name] || [];
                node.inverseOverlays[target][name].push(source);
            }
        };

        this.createNode = function (parameters, takenRelids, relidLength) {
            parameters = parameters || {};
            var relid = parameters.relid,
                parent = parameters.parent;

            ASSERT(!parent || self.isValidNode(parent));
            // ASSERT(!relid || typeof relid === 'string');

            var node;
            if (parent) {
                if (relid) {
                    if ((takenRelids && takenRelids[relid]) || self.getChildrenRelids(parent).indexOf(relid) > -1) {
                        throw new Error('Given relid already used in parent "' + relid + '".');
                    } else {
                        node = innerCore.getChild(parent, relid);
                        parent.childrenRelids = null;
                    }
                } else {
                    node = self.createChild(parent, takenRelids, relidLength);
                }

                innerCore.setHashed(node, true);
            } else {
                node = innerCore.createRoot();
            }

            // As we just created the node, we can allocate an empty inverse object, that is appropriate this time
            node.inverseOverlays = {};
            node.inverseOverlayMutable = true;
            return node;
        };

        this.deleteNode = function (node) {
            ASSERT(self.isValidNode(node));

            var parent = innerCore.getParent(node);

            ASSERT(parent !== null);
            self.deleteChild(parent, innerCore.getRelid(node));
        };

        /**
         *
         * @param {Node} node - Node containing the child.
         * @param {string} relid - Relid of the child to be removed.
         */
        this.deleteChild = function (parent, relid) {
            var prefix = CONSTANTS.PATH_SEP + relid;
            innerCore.deleteProperty(parent, relid);
            innerCore.removeChildFromCache(parent, relid);
            if (parent.childrenRelids) {
                parent.childrenRelids = null;
            }

            while (parent) {

                var list = self.overlayQuery(parent, prefix);
                for (var i = 0; i < list.length; ++i) {
                    var entry = list[i];
                    self.overlayRemove(parent, entry.s, entry.n, entry.t);
                }

                prefix = CONSTANTS.PATH_SEP + innerCore.getRelid(parent) + prefix;
                parent = innerCore.getParent(parent);
            }
        };

        this.createChild = function (parent, takenRelids, relidLength) {
            var child = innerCore.createChild(parent, takenRelids, relidLength);

            parent.childrenRelids = null;

            return child;
        };

        this.copyNode = function (node, parent, takenRelids, relidLength) {
            ASSERT(self.isValidNode(node));
            ASSERT(!parent || self.isValidNode(parent));
            var newNode,
                ancestor,
                ancestorNewPath,
                nodeToChangeOverlay,
                base,
                baseOldPath,
                aboveAncestor,
                list,
                tempAncestor,
                i,
                entry,
                relativePath,
                source,
                target;

            node = innerCore.normalize(node);

            if (parent) {
                ancestor = innerCore.getAncestor(node, parent);

                // cannot copy inside of itself
                if (ancestor === node) {
                    return null;
                }

                newNode = self.createChild(parent, takenRelids, relidLength);
                innerCore.setHashed(newNode, true);
                innerCore.setData(newNode, innerCore.copyData(node));

                ancestorNewPath = innerCore.getPath(newNode, ancestor);

                base = innerCore.getParent(node);
                baseOldPath = CONSTANTS.PATH_SEP + innerCore.getRelid(node);
                aboveAncestor = 1;

                while (base) {
                    list = self.overlayQuery(base, baseOldPath);
                    tempAncestor = innerCore.getAncestor(base, ancestor);

                    aboveAncestor = (base === ancestor ? 0 : tempAncestor === base ? 1 : -1);

                    relativePath = aboveAncestor < 0 ?
                        innerCore.getPath(base, ancestor) : innerCore.getPath(ancestor, base);

                    for (i = 0; i < list.length; ++i) {
                        entry = list[i];

                        if (entry.p) {
                            ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);
                            ASSERT(entry.s === baseOldPath ||
                                entry.s.charAt(baseOldPath.length) === CONSTANTS.PATH_SEP);

                            if (aboveAncestor < 0) {
                                //below ancestor node - further from root
                                source = ancestorNewPath + entry.s.substr(baseOldPath.length);
                                target = innerCore.joinPaths(relativePath, entry.t);
                                nodeToChangeOverlay = ancestor;
                            } else if (aboveAncestor === 0) {
                                //at ancestor node
                                var data = innerCore.getCommonPathPrefixData(ancestorNewPath, entry.t);

                                nodeToChangeOverlay = newNode;
                                while (data.firstLength-- > 0) {
                                    nodeToChangeOverlay = innerCore.getParent(nodeToChangeOverlay);
                                }

                                source = innerCore.joinPaths(data.first, entry.s.substr(baseOldPath.length));
                                target = data.second;
                            } else {
                                //above ancestor node - closer to root
                                ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);

                                source = relativePath + ancestorNewPath + entry.s.substr(baseOldPath.length);
                                target = entry.t;
                                nodeToChangeOverlay = base;
                            }

                            self.overlayInsert(nodeToChangeOverlay, source, entry.n, target);
                        }
                    }

                    baseOldPath = CONSTANTS.PATH_SEP + innerCore.getRelid(base) + baseOldPath;
                    base = innerCore.getParent(base);
                }
            } else {
                newNode = innerCore.createRoot();
                innerCore.setData(newNode, innerCore.copyData(node));
            }

            if (node.inverseOverlaysMutable) {
                newNode.inverseOverlays = JSON.parse(JSON.stringify(node.inverseOverlays));
            } else {
                newNode.inverseOverlays = node.inverseOverlays;
            }
            newNode.inverseOverlaysMutable = node.inverseOverlaysMutable;

            if (hasShardedOverlays(node)) {
                // Copy the shards-info for nodes with sharded overlay #1343
                newNode.overlays = JSON.parse(JSON.stringify(node.overlays));
                newNode.overlayMutations = JSON.parse(JSON.stringify(node.overlayMutations));
                newNode.minimalOverlayShardId = node.minimalOverlayShardId;
            }

            var root = self.getRoot(newNode);
            root.initial[self.getPath(newNode)] = root.initial[self.getPath(node)];
            return newNode;
        };

        this.gatherRelationsAmongSubtrees = function (sourceRoot, targetRoot) {
            var relationInformation = [],
                overlaysToCheck,
                commonParent, i,
                commonPathInformation = innerCore.getCommonPathPrefixData(
                    self.getPath(sourceRoot),
                    self.getPath(targetRoot));

            commonParent = sourceRoot;
            while (self.getPath(commonParent) !== commonPathInformation.common) {
                commonParent = self.getParent(commonParent);
            }

            overlaysToCheck = self.overlayQuery(commonParent, commonPathInformation.first);
            for (i = 0; i < overlaysToCheck.length; i += 1) {
                if (self.isPathInSubTree(overlaysToCheck[i].t, commonPathInformation.second)) {
                    relationInformation.push({
                        source: innerCore.joinPaths(commonPathInformation.common, overlaysToCheck[i].s),
                        sourceBase: innerCore.joinPaths(commonPathInformation.common,
                            commonPathInformation.first),
                        target: innerCore.joinPaths(commonPathInformation.common, overlaysToCheck[i].t),
                        targetBase: innerCore.joinPaths(commonPathInformation.common,
                            commonPathInformation.second),
                        name: overlaysToCheck[i].n
                    });
                }
            }

            return relationInformation;
        };

        this.gatherRelationsOfSubtree = function (root, sourceRelPath, targetRelPath) {
            var relationInformation = [],
                rootPath = self.getPath(root),
                overlaysToCheck, i;

            overlaysToCheck = self.overlayQuery(root, sourceRelPath);
            for (i = 0; i < overlaysToCheck.length; i += 1) {
                if (self.isPathInSubTree(overlaysToCheck[i].t, targetRelPath)) {
                    relationInformation.push({
                        source: innerCore.joinPaths(rootPath, overlaysToCheck[i].s),
                        sourceBase: innerCore.joinPaths(rootPath, sourceRelPath),
                        target: innerCore.joinPaths(rootPath, overlaysToCheck[i].t),
                        targetBase: innerCore.joinPaths(rootPath, targetRelPath),
                        name: overlaysToCheck[i].n
                    });
                }
            }

            return relationInformation;
        };

        this.copyNodes = function (nodes, parent, takenRelids, relidLength) {
            var old2NewPath = {},
                paths = [],
                relationsToCopyOver = [],
                copies = [],
                source, target, oldTarget,
                gatherRelations = function (commonPathInformation, firstNode) {
                    var commonParent,
                        overlaysToCheck,
                        i;

                    commonParent = firstNode;
                    while (self.getPath(commonParent) !== commonPathInformation.common) {
                        commonParent = self.getParent(commonParent);
                    }

                    // first -> second
                    overlaysToCheck = self.overlayQuery(commonParent, commonPathInformation.first);
                    for (i = 0; i < overlaysToCheck.length; i += 1) {
                        if (self.isPathInSubTree(overlaysToCheck[i].t, commonPathInformation.second)) {
                            relationsToCopyOver.push({
                                source: innerCore.joinPaths(commonPathInformation.common, overlaysToCheck[i].s),
                                sourceBase: innerCore.joinPaths(commonPathInformation.common,
                                    commonPathInformation.first),
                                target: innerCore.joinPaths(commonPathInformation.common, overlaysToCheck[i].t),
                                targetBase: innerCore.joinPaths(commonPathInformation.common,
                                    commonPathInformation.second),
                                name: overlaysToCheck[i].n
                            });
                        }
                    }
                },
                i, j;

            //first we collect the relations that we need to preserve
            for (i = 0; i < nodes.length; i += 1) {
                paths.push(self.getPath(nodes[i]));
            }

            for (i = 0; i < nodes.length; i += 1) {
                for (j = 0; j < nodes.length; j += 1) {
                    if (j !== i) {
                        gatherRelations(innerCore.getCommonPathPrefixData(paths[i], paths[j]), nodes[i]);
                    }
                }
            }

            //do the actual copying
            for (i = 0; i < nodes.length; i += 1) {
                copies.push(self.copyNode(nodes[i], parent, takenRelids, relidLength));
                old2NewPath[paths[i]] = self.getPath(copies[i]);
                if (takenRelids) {
                    takenRelids[self.getRelid(copies[i])] = true;
                }
            }

            // create the relations, that have to be preserved
            for (i = 0; i < relationsToCopyOver.length; i += 1) {
                source = relationsToCopyOver[i].source.replace(
                    relationsToCopyOver[i].sourceBase,
                    old2NewPath[relationsToCopyOver[i].sourceBase]
                );
                target = relationsToCopyOver[i].target.replace(
                    relationsToCopyOver[i].targetBase,
                    old2NewPath[relationsToCopyOver[i].targetBase]
                );

                oldTarget = self.overlayInquiry(parent, source, relationsToCopyOver[i].name);
                if (oldTarget !== null && typeof oldTarget.value === 'string') {
                    self.overlayRemove(parent, source, relationsToCopyOver[i].name, oldTarget.value);
                }
                self.overlayInsert(parent, source, relationsToCopyOver[i].name, target);
            }

            return copies;
        };

        // this.copyNodes = function (nodes, parent, takenRelids, relidLength) {
        //     //copying multiple nodes at once for keeping their internal relations
        //     var paths = [],
        //         i, j, index, names, pointer, newNode,
        //         copiedNodes = [],
        //         // Every single element will be an object with the
        //         // internally pointing relations and the index of the target.
        //         internalRelationPaths = [];
        //
        //     for (i = 0; i < nodes.length; i++) {
        //         paths.push(innerCore.getPath(nodes[i]));
        //     }
        //
        //     for (i = 0; i < nodes.length; i++) {
        //         names = self.getPointerNames(nodes[i]);
        //         pointer = {};
        //         for (j = 0; j < names.length; j++) {
        //             index = paths.indexOf(self.getPointerPath(nodes[i], names[j]));
        //             if (index !== -1) {
        //                 pointer[names[j]] = index;
        //             }
        //         }
        //         internalRelationPaths.push(pointer);
        //     }
        //
        //     //now we use our simple copy
        //     for (i = 0; i < nodes.length; i++) {
        //         newNode = self.copyNode(nodes[i], parent, takenRelids, relidLength);
        //         copiedNodes.push(newNode);
        //         if (takenRelids) {
        //             takenRelids[self.getRelid(newNode)] = true;
        //         }
        //     }
        //
        //     //and now back to the relations
        //     for (i = 0; i < internalRelationPaths.length; i++) {
        //         names = Object.keys(internalRelationPaths[i]);
        //         for (j = 0; j < names.length; j++) {
        //             self.setPointer(copiedNodes[i], names[j], copiedNodes[internalRelationPaths[i][names[j]]]);
        //         }
        //     }
        //
        //     return copiedNodes;
        // };

        this.moveNode = function (node, parent, takenRelids, relidLength, newRelid) {
            ASSERT(self.isValidNode(node) && self.isValidNode(parent));

            var ancestor,
                base,
                baseOldPath,
                aboveAncestor,
                ancestorNewPath,
                list,
                tempAncestor,
                relativePath,
                i,
                source,
                target,
                nodeToModifyOverlays,
                entry,
                tmp;

            node = innerCore.normalize(node);
            ancestor = innerCore.getAncestor(node, parent);

            // cannot move inside of itself
            if (ancestor === node) {
                return null;
            }

            base = innerCore.getParent(node);
            baseOldPath = CONSTANTS.PATH_SEP + innerCore.getRelid(node);
            aboveAncestor = 1;

            var oldNode = node;
            if (typeof newRelid === 'string') {
                node = innerCore.getChild(parent, newRelid);
            } else {
                if (takenRelids) {
                    if (takenRelids[innerCore.getRelid(oldNode)]) {
                        node = innerCore.createChild(parent, takenRelids, relidLength);
                    } else {
                        node = innerCore.getChild(parent, innerCore.getRelid(oldNode));
                    }
                } else {
                    node = innerCore.getChild(parent, innerCore.getRelid(oldNode));
                    if (!innerCore.isEmpty(node)) {
                        // we have to change the relid of the node, to fit into its new
                        // place...
                        node = innerCore.createChild(parent);
                    }
                }
            }

            parent.childrenRelids = null;

            innerCore.setHashed(node, true);
            innerCore.setData(node, innerCore.copyData(oldNode));

            ancestorNewPath = innerCore.getPath(node, ancestor);

            while (base) {
                list = self.overlayQuery(base, baseOldPath);
                tempAncestor = innerCore.getAncestor(base, ancestor);

                aboveAncestor = (base === ancestor ? 0 : tempAncestor === base ? 1 : -1);

                relativePath = aboveAncestor < 0 ?
                    innerCore.getPath(base, ancestor) : innerCore.getPath(ancestor, base);

                for (i = 0; i < list.length; ++i) {
                    entry = list[i];

                    self.overlayRemove(base, entry.s, entry.n, entry.t);

                    if (!entry.p) {
                        tmp = entry.s;
                        entry.s = entry.t;
                        entry.t = tmp;
                    }

                    ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);
                    ASSERT(entry.s === baseOldPath || entry.s.charAt(baseOldPath.length) === CONSTANTS.PATH_SEP);

                    if (aboveAncestor < 0) {
                        //below ancestor node
                        source = ancestorNewPath + entry.s.substr(baseOldPath.length);
                        target = innerCore.joinPaths(relativePath, entry.t);
                        nodeToModifyOverlays = ancestor;
                    } else if (aboveAncestor === 0) {
                        //at ancestor node
                        var data = innerCore.getCommonPathPrefixData(ancestorNewPath, entry.t);

                        nodeToModifyOverlays = node;
                        while (data.firstLength-- > 0) {
                            nodeToModifyOverlays = innerCore.getParent(nodeToModifyOverlays);
                        }

                        source = innerCore.joinPaths(data.first, entry.s.substr(baseOldPath.length));
                        target = data.second;
                    } else {
                        //above ancestor node
                        ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);

                        source = relativePath + ancestorNewPath + entry.s.substr(baseOldPath.length);
                        target = entry.t;
                        nodeToModifyOverlays = base;
                    }

                    if (!entry.p) {
                        tmp = entry.s;
                        entry.s = entry.t;
                        entry.t = tmp;

                        tmp = source;
                        source = target;
                        target = tmp;
                    }

                    //console.log(source, target);
                    self.overlayInsert(nodeToModifyOverlays, source, entry.n, target);
                }

                baseOldPath = CONSTANTS.PATH_SEP + innerCore.getRelid(base) + baseOldPath;
                base = innerCore.getParent(base);
            }

            var root = self.getRoot(node);
            root.initial[self.getPath(node)] = root.initial[self.getPath(oldNode)];
            self.deleteNode(oldNode);

            return node;
        };

        this.getChildrenRelids = function (node) {
            ASSERT(self.isValidNode(node));

            // Check if they are already cached by the node
            if (!node.childrenRelids) {
                node.childrenRelids = innerCore.getKeys(node, self.isValidRelid);
            }

            return node.childrenRelids;
        };

        this.getChildrenPaths = function (node) {
            var path = innerCore.getPath(node),
                relids = self.getChildrenRelids(node),
                result = [],
                i;

            for (i = 0; i < relids.length; i += 1) {
                result.push(path + CONSTANTS.PATH_SEP + relids[i]);
            }

            return result;
        };

        this.loadChildren = function (node) {
            var children = self.getChildrenRelids(node),
                result = [],
                i;

            for (i = 0; i < children.length; i += 1) {
                result.push(self.loadChild(node, children[i]));
            }

            return TASYNC.lift(result);
        };

        this.getPointerNames = function (node) {
            return self.getPointerNamesFrom(node, '');
        };

        this.getPointerNamesFrom = function (node, source) {
            ASSERT(self.isValidNode(node));

            var names = [],
                name,
                overlayInfo;

            do {
                overlayInfo = self.overlayInquiry(node, source);
                if (overlayInfo.value !== null) {
                    for (name in overlayInfo.value) {
                        ASSERT(names.indexOf(name) === -1);
                        if (self.isPointerName(name)) {
                            names.push(name);
                        }
                    }
                }
                source = CONSTANTS.PATH_SEP + innerCore.getRelid(node) + source;
                node = innerCore.getParent(node);
            } while (node);

            return names;
        };

        this.getPointerPath = function (node, name) {
            return self.getPointerPathFrom(node, '', name);
        };

        this.getPointerPathFrom = function (node, source, name) {
            var res = getRelativePointerPathFrom(node, source, name),
                target;

            if (res.target !== undefined) {
                target = innerCore.joinPaths(innerCore.getPath(res.node), res.target);
            }

            return target;
        };

        this.loadPointer = function (node, name) {
            var res = getRelativePointerPathFrom(node, '', name);

            if (res.target !== undefined) {
                return self.loadByPath(res.node, res.target);
            } else {
                return null;
            }
        };

        this.getCollectionNames = function (node) {
            ASSERT(self.isValidNode(node));
            var names = [],
                target = '',
                name,
                inverseOverlays;

            do {
                inverseOverlays = self.getInverseOverlayOfNode(node);
                if (inverseOverlays[target]) {
                    for (name in inverseOverlays[target]) {
                        if (names.indexOf(name) === -1) {
                            names.push(name);
                        }
                    }
                }

                target = CONSTANTS.PATH_SEP + self.getRelid(node) + target;
                node = self.getParent(node);
            } while (node);

            return names;
        };

        this.loadCollection = function (node, name) {
            ASSERT(self.isValidNode(node) && self.isPointerName(name));

            var collection = [],
                target = '',
                i,
                inverseOverlays;

            do {
                inverseOverlays = self.getInverseOverlayOfNode(node);

                if (inverseOverlays[target] && inverseOverlays[target][name]) {
                    for (i = 0; i < inverseOverlays[target][name].length; i += 1) {
                        collection.push(self.loadByPath(node, inverseOverlays[target][name][i]));
                    }
                }

                target = CONSTANTS.PATH_SEP + self.getRelid(node) + target;
                node = self.getParent(node);
            } while (node);

            return TASYNC.lift(collection);
        };

        this.getCollectionPaths = function (node, name) {
            ASSERT(self.isValidNode(node) && self.isPointerName(name));

            var result = [],
                target = '',
                inverseOverlays,
                i,
                prefix = '';

            do {
                inverseOverlays = self.getInverseOverlayOfNode(node);
                if (inverseOverlays[target] && inverseOverlays[target][name]) {
                    prefix = self.getPath(node);
                    for (i = 0; i < inverseOverlays[target][name].length; i += 1) {
                        result.push(prefix + inverseOverlays[target][name][i]);
                    }
                }

                target = CONSTANTS.PATH_SEP + self.getRelid(node) + target;
                node = self.getParent(node);
            } while (node);

            return result;
        };

        this.deletePointer = function (node, name) {
            ASSERT(self.isValidNode(node) && typeof name === 'string');

            var source = '',
                overlayInfo;

            do {
                overlayInfo = self.overlayInquiry(node, source, name);
                if (typeof overlayInfo.value === 'string') {
                    self.overlayRemove(node, source, name, overlayInfo.value);
                    break;
                }
                source = CONSTANTS.PATH_SEP + self.getRelid(node) + source;
                node = self.getParent(node);
            } while (node);

            return false;
        };

        this.setPointer = function (node, name, target) {
            ASSERT(self.isValidNode(node) && typeof name === 'string' && (!target || self.isValidNode(target)));

            var ancestor,
                targetPath,
                sourcePath;

            self.deletePointer(node, name);

            if (target) {
                ancestor = innerCore.getAncestor(node, target);

                sourcePath = innerCore.getPath(node, ancestor);
                targetPath = innerCore.getPath(target, ancestor);

                self.overlayInsert(ancestor, sourcePath, name, targetPath);
            }
        };

        this.renamePointer = function (node, oldName, newName) {
            ASSERT(self.isValidNode(node) && typeof oldName === 'string' && typeof newName === 'string');
            var targetPath = self.getPointerPath(node, oldName),
                sourcePath = self.getPath(node),
                pointerNames = self.getPointerNames(node),
                commonInfo;

            ASSERT(targetPath !== undefined);

            if (pointerNames.indexOf(newName) !== -1) {
                self.deletePointer(node, newName);
            }

            commonInfo = innerCore.getCommonPathPrefixData(sourcePath, targetPath);

            while (commonInfo.firstLength-- > 0) {
                node = self.getParent(node);
            }

            self.overlayRemove(node, commonInfo.first, oldName, commonInfo.second);
            self.overlayInsert(node, commonInfo.first, newName, commonInfo.second);
        };

        this.getChildrenHashes = function (node) {
            var keys = self.getChildrenRelids(node),
                i, hashes = {};

            for (i = 0; i < keys.length; i++) {
                hashes[keys[i]] = innerCore.getChildHash(node, keys[i]);
            }

            return hashes;
        };

        this.isValidRelid = RANDOM.isValidRelid;

        this.isContainerPath = function (path, parentPath) {
            var pathArray = (path || '').split(CONSTANTS.PATH_SEP),
                parentArray = (parentPath || '').split(CONSTANTS.PATH_SEP),
                i;

            for (i = 0; i < parentArray.length; i += 1) {
                if (parentArray[i] !== pathArray[i]) {
                    return false;
                }
            }

            return true;
        };

        // by default the function removes any 'sub-node' relations
        this.getRawOverlayInformation = function (node) {
            var completeOverlayInfo = {},
                shardId,
                source,
                complexOverlayObject,
                name;

            if (hasShardedOverlays(node)) {
                complexOverlayObject = node.overlays;
            } else {
                complexOverlayObject = {single: {items: self.getProperty(node, CONSTANTS.OVERLAYS_PROPERTY) || {}}};
            }

            for (shardId in complexOverlayObject) {
                for (source in complexOverlayObject[shardId].items) {
                    if (source.indexOf('_') === -1) {
                        completeOverlayInfo[source] = {};
                        for (name in complexOverlayObject[shardId].items[source]) {
                            if (name.indexOf('_') === -1) {
                                if (complexOverlayObject[shardId].items[source][name] === '/_nullptr') {
                                    completeOverlayInfo[source][name] = null;
                                } else if (complexOverlayObject[shardId].items[source][name].indexOf('_') === -1) {
                                    completeOverlayInfo[source][name] =
                                        complexOverlayObject[shardId].items[source][name];
                                }
                            }
                        }
                    }
                }
            }

            return completeOverlayInfo;
        };
        //</editor-fold>
    }

    return CoreRel;
});
/*globals define*/
/*eslint-env node, browser*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/setcore',[
    'common/core/CoreAssert',
    'common/core/constants',
    'common/core/tasync'
], function (ASSERT, CONSTANTS, TASYNC) {
    'use strict';

    function SetCore(innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized SetCore');

        //<editor-fold=Helper Functions>
        function setModified(node) {
            innerCore.setRegistry(node, CONSTANTS.SET_MODIFIED_REGISTRY,
                (innerCore.getRegistry(node, CONSTANTS.SET_MODIFIED_REGISTRY) || 0) + 1);
        }

        function getSetNodeByName(node, setName) {
            return innerCore.getChild(innerCore.getChild(node, CONSTANTS.ALL_SETS_PROPERTY), setName);
        }

        function getSetInfoByName(node, setName) {
            ASSERT(typeof setName === 'string');
            var setsInfo = innerCore.getProperty(node, CONSTANTS.ALL_SETS_PROPERTY);

            return setsInfo && setsInfo[setName];
        }

        function getRelativeMemberPath(ownerPath, memberPath) {
            if (self.isPathInSubTree(memberPath, ownerPath)) {
                return self.getCommonPathPrefixData(ownerPath, memberPath).second;
            }

            return null;
        }

        function getOwnMemberRelId(node, setName, memberPath) {
            var setInfo,
                keys,
                i;

            setInfo = getSetInfoByName(node, setName);
            if (setInfo) {
                keys = self.getRawKeys(setInfo, self.isValidRelid);
                for (i = 0; i < keys.length; i += 1) {
                    if (innerCore.getPointerPathFrom(node,
                        '/' + CONSTANTS.ALL_SETS_PROPERTY + '/' + setName + '/' + keys[i],
                        CONSTANTS.MEMBER_RELATION) === memberPath) {

                        return keys[i];
                    }
                }
            }

            return null;
        }

        function getMemberRelId(node, setName, memberPath) {
            var relid = null,
                relativeMemberPath = null;

            do {
                if (relativeMemberPath !== null) {
                    relid = getOwnMemberRelId(node, setName, self.getPath(node) + relativeMemberPath);
                    if (relid) {
                        return relid;
                    }
                }
                relid = getOwnMemberRelId(node, setName, memberPath);
                if (relid) {
                    return relid;
                }

                typeof memberPath === 'string' ?
                    relativeMemberPath = getRelativeMemberPath(self.getPath(node), memberPath) : null;
                node = self.getBase(node);
            } while (node);

            return relid;
        }

        function getSetMemberNode(node, setName, memberPath) {
            var memberRelId = getMemberRelId(node, setName, memberPath);

            return typeof memberRelId === 'string' && innerCore.getChild(getSetNodeByName(node, setName), memberRelId);
        }

        function getOwnSetMemberNode(node, setName, memberPath) {
            var memberRelId = getOwnMemberRelId(node, setName, memberPath);

            return typeof memberRelId === 'string' && innerCore.getChild(getSetNodeByName(node, setName), memberRelId);
        }

        function collectOwnSetNames(node) {
            var sets = [],
                setsInfo,
                keys,
                i;

            setsInfo = self.getProperty(node, CONSTANTS.ALL_SETS_PROPERTY);
            if (setsInfo &&
                setsInfo[CONSTANTS.OVERLAYS_PROPERTY] &&
                setsInfo[CONSTANTS.OVERLAYS_PROPERTY]['']) {

                keys = Object.keys(setsInfo[CONSTANTS.OVERLAYS_PROPERTY]['']);

                for (i = 0; i < keys.length; i += 1) {
                    if (keys[i] !== CONSTANTS.MUTABLE_PROPERTY && sets.indexOf(keys[i]) === -1) {
                        sets.push(keys[i]);
                    }
                }
            }

            return sets;
        }

        function collectSetNames(node) {
            var sets = [],
                keys,
                i;

            do {
                keys = collectOwnSetNames(node);

                for (i = 0; i < keys.length; i += 1) {
                    if (sets.indexOf(keys[i]) === -1) {
                        sets.push(keys[i]);
                    }
                }

                node = self.getBase(node);
            } while (node);

            return sets;
        }

        function hasOwnSet(node, setName) {
            ASSERT(typeof setName === 'string');
            var setsInfo = self.getProperty(node, CONSTANTS.ALL_SETS_PROPERTY);
            if (setsInfo &&
                setsInfo[CONSTANTS.OVERLAYS_PROPERTY] &&
                setsInfo[CONSTANTS.OVERLAYS_PROPERTY][''] &&
                setsInfo[CONSTANTS.OVERLAYS_PROPERTY][''][setName]) {

                return true;
            }

            return false;
        }

        function hasSet(node, setName) {
            do {
                if (hasOwnSet(node, setName)) {
                    return true;
                }

                node = self.getBase(node);
            } while (node);

            return false;
        }

        function collectInternalMemberRelids(node, setName) {
            var setInfo,
                relids = [],
                keys,
                i;

            do {
                setInfo = getSetInfoByName(node, setName);
                if (setInfo) {

                    keys = self.getRawKeys(setInfo, self.isValidRelid);

                    for (i = 0; i < keys.length; i += 1) {
                        if (relids.indexOf(keys[i]) === -1) {
                            relids.push(keys[i]);
                        }
                    }
                }

                node = self.getBase(node);
            } while (node);

            return relids;
        }

        function getContainerNodePath(node) {
            var ownPath = self.getPath(node);
            return ownPath.substring(0, ownPath.indexOf('/_'));
        }

        function collectMemberPath(node, setName, innerRelid) {
            var source = '/' + CONSTANTS.ALL_SETS_PROPERTY + '/' + setName + '/' + innerRelid,
                path,
                tempPath;

            do {
                tempPath = innerCore.getPointerPathFrom(node, source, CONSTANTS.MEMBER_RELATION);
                if (tempPath !== undefined) {
                    path = tempPath;
                    if (path !== getContainerNodePath(node)) {
                        break;
                    }
                }

                node = self.getBase(node);
            } while (node);

            return path;
        }

        function getPropertyCollectionInfo(node, propertyCollectionName, setName, memberPath) {
            var setInfo = getSetInfoByName(node, setName),
                propertyCollectionInfo,
                relid;

            if (setInfo) {
                if (typeof memberPath === 'string') {
                    relid = getOwnMemberRelId(node, setName, memberPath);
                    propertyCollectionInfo = relid && setInfo[relid] && setInfo[relid][propertyCollectionName];
                } else {
                    propertyCollectionInfo = setInfo[propertyCollectionName];
                }
            }

            return propertyCollectionInfo;
        }

        function collectOwnPropertyNames(node, propertyCollectionName, setName, memberPath) {
            var propertyCollectionInfo = getPropertyCollectionInfo(node, propertyCollectionName, setName, memberPath);

            return propertyCollectionInfo ? innerCore.getRawKeys(propertyCollectionInfo) : [];
        }

        function collectPropertyNames(node, propertyCollectionName, setName, memberPath) {
            var names = [],
                keys,
                relativeMemberPath = null,
                i;

            do {
                if (relativeMemberPath !== null) {
                    keys = collectOwnPropertyNames(node, propertyCollectionName, setName,
                        self.getPath(node) + relativeMemberPath);
                    if (keys.length === 0) {
                        keys = collectOwnPropertyNames(node, propertyCollectionName, setName, memberPath);
                    } else {
                        memberPath = self.getPath(node) + relativeMemberPath;
                    }
                } else {
                    keys = collectOwnPropertyNames(node, propertyCollectionName, setName, memberPath);
                }

                for (i = 0; i < keys.length; i += 1) {
                    if (names.indexOf(keys[i]) === -1) {
                        names.push(keys[i]);
                    }
                }

                relativeMemberPath = typeof memberPath === 'string' ?
                    getRelativeMemberPath(self.getPath(node), memberPath) : null;
                node = self.getBase(node);
            } while (node);

            return names;
        }

        function getOwnPropertyValue(node, propertyCollectionName, propertyName, setName, memberPath) {
            var propertyCollectionInfo = getPropertyCollectionInfo(node, propertyCollectionName, setName, memberPath);

            return propertyCollectionInfo ? propertyCollectionInfo[propertyName] : undefined;
        }

        function getPropertyValue(node, propertyCollectionName, propertyName, setName, memberPath) {
            var value,
                relativeMemberPath = null;

            do {
                if (relativeMemberPath !== null) {
                    value = getOwnPropertyValue(node, propertyCollectionName, propertyName, setName,
                        self.getPath(node) + relativeMemberPath);
                    if (value === undefined) {
                        value = getOwnPropertyValue(node, propertyCollectionName, propertyName, setName, memberPath);
                    } else {
                        memberPath = self.getPath(node) + relativeMemberPath;
                    }
                } else {
                    value = getOwnPropertyValue(node, propertyCollectionName, propertyName, setName, memberPath);
                }
                if (value !== undefined) {
                    return value;
                }

                relativeMemberPath = typeof memberPath === 'string' ?
                    getRelativeMemberPath(self.getPath(node), memberPath) : null;
                node = self.getBase(node);
            } while (node);

            return undefined;
        }

        function createSetOnDemand(node, setName) {
            //the function checks if there is no set defined on the node's level and create it
            var setsNode = innerCore.getChild(node, CONSTANTS.ALL_SETS_PROPERTY);
            if (innerCore.getOwnPointerPath(setsNode, setName) === undefined) {
                self.createSet(node, setName);
            }
        }

        function loadNodesOfPaths(root, paths) {
            var nodes = [],
                i,
                rootHash = self.getHash(root);

            return TASYNC.call(function () {
                for (i = 0; i < paths.length; i += 1) {
                    nodes[i] = self.loadByPath(root, paths[i]);
                }
                return TASYNC.call(function (n) {
                    var newn = [];
                    for (var i = 0; i < n.length; i++) {
                        if (n[i] !== null) {
                            newn.push(n[i]);
                        }
                    }
                    return newn;
                }, TASYNC.lift(nodes));
            }, self.loadPaths(rootHash, paths));
        }

        //</editor-fold>

        //<editor-fold=Modified Methods>
        this.getCollectionNames = function (node) {
            var result = innerCore.getCollectionNames(node),
                i;

            for (i = 0; i < result.length; i++) {
                // The member collection is coming from being a member of a set and is not a defined relationship.
                if (result[i] === CONSTANTS.MEMBER_RELATION) {
                    result.splice(i, 1);
                    break;
                }
            }

            return result;
        };
        //</editor-fold>

        //<editor-fold=Added Methods>
        this.getSetNames = function (node) {
            return collectSetNames(node);
        };

        this.getOwnSetNames = function (node) {
            return collectOwnSetNames(node);
        };

        this.createSet = function (node, setName) {
            var setNode = getSetNodeByName(node, setName);
            innerCore.setPointer(innerCore.getChild(node, CONSTANTS.ALL_SETS_PROPERTY), setName, null);
            // Ensure the set-node is not deleted at persist.
            innerCore.setRegistry(setNode, '_', '_');
            setModified(node);
        };

        this.deleteSet = function (node, setName) {
            var setsNode = innerCore.getChild(node, CONSTANTS.ALL_SETS_PROPERTY),
                setNode = innerCore.getChild(setsNode, setName);

            innerCore.deletePointer(setsNode, setName);
            innerCore.deleteNode(setNode, true);
            setModified(node);
        };

        this.renameSet = function (node, oldName, newName) {
            var setsNode = innerCore.getChild(node, CONSTANTS.ALL_SETS_PROPERTY),
                setNode = innerCore.getChild(setsNode, oldName),
                ownSetNames = self.getOwnSetNames(node);

            if (ownSetNames.indexOf(newName) !== -1) {
                self.deleteSet(node, newName);
            }
            innerCore.renamePointer(setsNode, oldName, newName);
            innerCore.moveNode(setNode, setsNode, undefined, newName);
            setModified(node);
        };

        this.isMemberOf = function (node) {
            //TODO we should find a proper way to do this - or at least some support from lower layers would be fine
            var coll = self.getCollectionPaths(node, CONSTANTS.MEMBER_RELATION);
            var sets = {};
            for (var i = 0; i < coll.length; i++) {
                var pathArray = coll[i].split('/');
                if (pathArray.indexOf(CONSTANTS.META_NODE) === -1) {
                    //now we simply skip META sets...
                    var index = pathArray.indexOf(CONSTANTS.ALL_SETS_PROPERTY);
                    if (index > 0 && pathArray.length > index + 1) {
                        //otherwise it is not a real set
                        var ownerPath = pathArray.slice(0, index).join('/');
                        if (sets[ownerPath] === undefined) {
                            sets[ownerPath] = [];
                        }
                        sets[ownerPath].push(pathArray[index + 1]);
                    }
                }
            }
            return sets;
        };

        this.isFullyOverriddenMember = function (node, setName, memberPath) {
            var setNames = collectSetNames(node),
                ownRelId,
                baseRelId;

            if (setNames.indexOf(setName) === -1) {
                return false;
            }

            if (innerCore.getBase(node) === null) {
                return false;
            }

            ownRelId = getMemberRelId(node, setName, memberPath);
            baseRelId = getMemberRelId(innerCore.getBase(node), setName, memberPath);

            if (ownRelId && baseRelId && ownRelId !== baseRelId) {
                return true;
            }

            return false;
        };

        this.getMemberPaths = function (node, setName) {
            var memberRelids = collectInternalMemberRelids(node, setName),
                //pathPrefix = '/' + CONSTANTS.ALL_SETS_PROPERTY + '/' + setName + '/',
                i, path,
                memberPaths = [];
            for (i = 0; i < memberRelids.length; i += 1) {
                path = collectMemberPath(node, setName, memberRelids[i]);
                if (path !== undefined && memberPaths.indexOf(path) === -1) { //null and '' are valid targets
                    memberPaths.push(path);
                }
            }
            return memberPaths;
        };

        this.getOwnMemberPaths = function (node, setName) {
            var setInfo = getSetInfoByName(node, setName),
                relids = setInfo ? self.getRawKeys(setInfo, self.isValidRelid) : [],
                allPaths = self.getMemberPaths(node, setName),
                paths = [],
                i;

            for (i = 0; i < allPaths.length; i += 1) {
                if (relids.indexOf(getMemberRelId(node, setName, allPaths[i])) !== -1) {
                    paths.push(allPaths[i]);
                }
            }

            return paths;
        };

        this.delMember = function (node, setName, memberPath) {
            var setMemberNode;

            setMemberNode = getOwnSetMemberNode(node, setName, memberPath);
            if (setMemberNode) {
                innerCore.deleteNode(setMemberNode, true);
            }
        };

        this.addMember = function (node, setName, member) {
            var setNode = getSetNodeByName(node, setName),
                setMemberRelId = getMemberRelId(node, setName, self.getPath(member)),
                setMemberNode;

            if (setMemberRelId === null) {
                createSetOnDemand(node, setName);
                setMemberNode = innerCore.createChild(setNode, CONSTANTS.MAXIMUM_STARTING_RELID_LENGTH + 1);
            } else if (!self.isFullyOverriddenMember(node, setName, self.getPath(member))) {
                //it was an inherited member, now we override it
                // TODO: We pin down the expected behavior here..
                setMemberNode = innerCore.copyNode(innerCore.getChild(setNode, setMemberRelId),
                    setNode, CONSTANTS.MAXIMUM_STARTING_RELID_LENGTH + 1);
                innerCore.deleteNode(innerCore.getChild(setNode, setMemberRelId), true);
            }

            if (setMemberNode) {
                innerCore.setPointer(setMemberNode, CONSTANTS.MEMBER_RELATION, member);

                // Ensure the member-node entry is not deleted at persist.
                innerCore.setRegistry(setMemberNode, '_', '_');
                setModified(node);
            } else {
                logger.warn('member already in set');
            }
        };

        this.getMemberAttributeNames = function (node, setName, memberPath) {
            ASSERT(typeof memberPath === 'string');
            return collectPropertyNames(node, CONSTANTS.ATTRIBUTES_PROPERTY, setName, memberPath);
        };

        this.getMemberOwnAttributeNames = function (node, setName, memberPath) {
            ASSERT(typeof memberPath === 'string');
            return collectOwnPropertyNames(node, CONSTANTS.ATTRIBUTES_PROPERTY, setName, memberPath);
        };

        this.getMemberAttribute = function (node, setName, memberPath, attrName) {
            ASSERT(typeof memberPath === 'string');
            return getPropertyValue(node, CONSTANTS.ATTRIBUTES_PROPERTY, attrName, setName, memberPath);
        };

        this.getMemberOwnAttribute = function (node, setName, memberPath, attrName) {
            ASSERT(typeof memberPath === 'string');
            return getOwnPropertyValue(node, CONSTANTS.ATTRIBUTES_PROPERTY, attrName, setName, memberPath);
        };

        this.setMemberAttribute = function (node, setName, memberPath, attrName, attrValue) {
            ASSERT(attrValue !== undefined);
            var setMemberNode = getSetMemberNode(node, setName, memberPath);

            if (setMemberNode) {
                innerCore.setAttribute(setMemberNode, attrName, attrValue);
                setModified(node);
            }
        };

        this.delMemberAttribute = function (node, setName, memberPath, attrName) {
            var setMemberNode = getOwnSetMemberNode(node, setName, memberPath);

            if (setMemberNode) {
                innerCore.delAttribute(setMemberNode, attrName);
            }
        };

        this.getMemberRegistryNames = function (node, setName, memberPath) {
            ASSERT(typeof memberPath === 'string');
            return collectPropertyNames(node, CONSTANTS.REGISTRY_PROPERTY, setName, memberPath);
        };

        this.getMemberOwnRegistryNames = function (node, setName, memberPath) {
            ASSERT(typeof memberPath === 'string');
            return collectOwnPropertyNames(node, CONSTANTS.REGISTRY_PROPERTY, setName, memberPath);
        };

        this.getMemberRegistry = function (node, setName, memberPath, regName) {
            ASSERT(typeof memberPath === 'string');
            return getPropertyValue(node, CONSTANTS.REGISTRY_PROPERTY, regName, setName, memberPath);
        };

        this.getMemberOwnRegistry = function (node, setName, memberPath, regName) {
            ASSERT(typeof memberPath === 'string');
            return getOwnPropertyValue(node, CONSTANTS.REGISTRY_PROPERTY, regName, setName, memberPath);
        };

        this.setMemberRegistry = function (node, setName, memberPath, regName, regValue) {
            ASSERT(regValue !== undefined);
            var setMemberNode = getSetMemberNode(node, setName, memberPath);

            if (setMemberNode) {
                innerCore.setRegistry(setMemberNode, regName, regValue);
                setModified(node);
            }
        };

        this.delMemberRegistry = function (node, setName, memberPath, regName) {
            var setMemberNode = getOwnSetMemberNode(node, setName, memberPath);

            if (setMemberNode) {
                innerCore.delRegistry(setMemberNode, regName);
            }
        };

        this.getSetAttributeNames = function (node, setName) {
            return collectPropertyNames(node, CONSTANTS.ATTRIBUTES_PROPERTY, setName);
        };

        this.getOwnSetAttributeNames = function (node, setName) {
            return collectOwnPropertyNames(node, CONSTANTS.ATTRIBUTES_PROPERTY, setName);
        };

        this.getSetAttribute = function (node, setName, attrName) {
            return getPropertyValue(node, CONSTANTS.ATTRIBUTES_PROPERTY, attrName, setName);
        };

        this.getOwnSetAttribute = function (node, setName, attrName) {
            return getOwnPropertyValue(node, CONSTANTS.ATTRIBUTES_PROPERTY, attrName, setName);
        };

        this.setSetAttribute = function (node, setName, attrName, attrValue) {
            if (hasSet(node, setName)) {
                self.setAttribute(getSetNodeByName(node, setName), attrName, attrValue);
                setModified(node);
            }
        };

        this.delSetAttribute = function (node, setName, attrName) {
            var setInfo = getSetInfoByName(node, setName);
            if (setInfo) {
                self.delAttribute(getSetNodeByName(node, setName), attrName);
            }
        };

        this.getSetRegistryNames = function (node, setName) {
            return collectPropertyNames(node, CONSTANTS.REGISTRY_PROPERTY, setName);
        };

        this.getOwnSetRegistryNames = function (node, setName) {
            return collectOwnPropertyNames(node, CONSTANTS.REGISTRY_PROPERTY, setName);
        };

        this.getSetRegistry = function (node, setName, regName) {
            return getPropertyValue(node, CONSTANTS.REGISTRY_PROPERTY, regName, setName);
        };

        this.getOwnSetRegistry = function (node, setName, regName) {
            return getOwnPropertyValue(node, CONSTANTS.REGISTRY_PROPERTY, regName, setName);
        };

        this.setSetRegistry = function (node, setName, regName, regValue) {
            if (hasSet(node, setName)) {
                self.setRegistry(getSetNodeByName(node, setName), regName, regValue);
                setModified(node);
            }
        };

        this.delSetRegistry = function (node, setName, regName) {
            var setInfo = getSetInfoByName(node, setName);
            if (setInfo) {
                self.delRegistry(getSetNodeByName(node, setName), regName);
            }
        };

        this.loadMembers = function (node, setName) {
            return loadNodesOfPaths(self.getRoot(node), self.getMemberPaths(node, setName));
        };

        this.loadOwnMembers = function (node, setName) {
            return loadNodesOfPaths(self.getRoot(node), self.getOwnMemberPaths(node, setName));
        };

        // it only works for own members
        // if the target set has the same member, it will be removed first
        this.moveMember = function (node, memberPath, oldSetName, newSetName) {
            var oldSetNode = getSetNodeByName(node, oldSetName),
                oldMemberRelid = getOwnMemberRelId(node, oldSetName, memberPath),
                oldMemberNode,
                setNames = self.getSetNames(node),
                newMemberRelid = getOwnMemberRelId(node, newSetName, memberPath),
                newSetNode;

            ASSERT(oldMemberRelid !== null, 'Only own member can be moved!');

            if (setNames.indexOf(newSetName) === -1) {
                self.createSet(node, newSetName);
            }

            oldMemberNode = self.getChild(oldSetNode, oldMemberRelid);
            newSetNode = getSetNodeByName(node, newSetName);

            if (newMemberRelid !== null) {
                self.delMember(node, newSetName, memberPath);
            }

            self.moveNode(oldMemberNode, newSetNode);

            if (self.getOwnMemberPaths(node, oldSetName).length === 0) {
                self.deleteSet(node, oldSetName);
            }
        };
        //</editor-fold>
    }

    return SetCore;
});
/*globals define*/
/*eslint-env node, browser*/
/*eslint no-bitwise: 0*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/guidcore',[
    'common/core/CoreAssert',
    'common/core/tasync',
    'common/regexp',
    'common/util/random',
    'common/core/constants',
], function (ASSERT, TASYNC, REGEXP, RANDOM, CONSTANTS) {

    'use strict';

    var relidToInteger = RANDOM.relidToInteger,
        GUID = RANDOM.generateGuid;

    function GuidCore(innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized GuidCore');

        //<editor-fold=Helper Functions>
        function toInternalGuid(myGuid) {
            return myGuid.replace(/-/g, '');
        }

        function toExternalGuid(myGuid) {
            return myGuid.substr(0, 8) + '-' + myGuid.substr(8, 4) + '-' +
                myGuid.substr(12, 4) + '-' + myGuid.substr(16, 4) + '-' + myGuid.substr(20);
        }

        function guidToArray(guid) {
            if (guid === null || guid === undefined) {
                return [0, 0, 0, 0, 0, 0, 0, 0];
            }
            var array = new Array(8);
            for (var i = 0; i < guid.length / 4; i += 1) {
                array[i] = parseInt(guid.substr(4 * i, 4), 16);
            }
            return array;
        }

        function getRelidGuid(node) {
            //TODO we always should know what structure we should expect as a relid -
            // now we think it is a number so it can be converted to 0xsomething
            var relid = self.getRelid(node);
            //relid = Number(relid);
            relid = relidToInteger(relid);
            if (relid === 'NaN') {
                return null;
            }

            relid = relid.toString(16);

            //now we should fill up with 0's in the beggining
            while (relid.length < 32) {
                relid = relid + '0';
            }
            return relid;
        }

        function xorGuids(a, b) {
            var arrayA = guidToArray(a);
            var arrayB = guidToArray(b);

            ASSERT(arrayA.length === arrayB.length);

            var arrayOut = [];
            for (var i = 0; i < arrayA.length; i++) {
                arrayOut.push(arrayA[i] ^ arrayB[i]);
            }
            for (i = 0; i < arrayOut.length; i++) {
                arrayOut[i] = Number(arrayOut[i]).toString(16);
                var difi = 4 - arrayOut[i].length;
                while (difi > 0) {
                    arrayOut[i] = '0' + arrayOut[i];
                    difi--;
                }
            }
            return arrayOut.join('');
        }

        function setDataGuid(node, guid) {
            self.setAttribute(node, CONSTANTS.OWN_GUID,
                xorGuids(
                    toInternalGuid(guid),
                    xorGuids(
                        getRelidGuid(node),
                        toInternalGuid(
                            self.getGuid(
                                self.getParent(node)
                            )
                        )
                    )
                )
            );
        }

        //</editor-fold>

        //<editor-fold=Modified Methods>
        this.createNode = function (parameters) {
            parameters = parameters || {};

            var guid = parameters.guid || GUID(),
                node;

            ASSERT(REGEXP.GUID.test(guid));

            node = innerCore.createNode(parameters);

            setDataGuid(node, guid);

            return node;
        };

        this.moveNode = function (node, parent) {
            var oldGuid = self.getGuid(node);

            node = innerCore.moveNode(node, parent);

            setDataGuid(node, oldGuid);

            return node;
        };
        //</editor-fold>

        //<editor-fold=Added Methods>
        this.getGuid = function (node) {
            if (node) {
                return self.getDeducedGuid(node, self.getGuid(self.getParent(node)));
            } else {
                return CONSTANTS.NULL_GUID;
            }
        };

        this.setGuid = function (node, guid) {
            ASSERT(REGEXP.GUID.test(guid));
            return TASYNC.call(function (children) {
                var i,
                    childrenGuids = [];

                //save children guids
                for (i = 0; i < children.length; i += 1) {
                    childrenGuids.push(self.getGuid(children[i]));
                }

                //setting own dataGuid
                setDataGuid(node, guid);

                //changing children data guids
                for (i = 0; i < children.length; i += 1) {
                    setDataGuid(children[i], childrenGuids[i]);
                }
            }, self.loadChildren(node));
        };

        this.getDataGuid = function (node) {
            return toExternalGuid(self.getAttribute(node, CONSTANTS.OWN_GUID));
        };

        this.getDeducedGuid = function (node, baseGuid) {
            if (node && REGEXP.GUID.test(baseGuid)) {
                return toExternalGuid(
                    xorGuids(
                        getRelidGuid(node),
                        xorGuids(
                            self.getAttribute(node, CONSTANTS.OWN_GUID),
                            toInternalGuid(baseGuid)
                        )
                    )
                );
            } else {
                return CONSTANTS.NULL_GUID;
            }
        };

        this.copyNode = function (node, parent) {
            var newNode = innerCore.copyNode(node, parent);

            // Generate new guid at copy #1344
            setDataGuid(newNode, GUID());

            return newNode;
        };

        this.copyNodes = function (nodes, parent) {
            var newNodes = innerCore.copyNodes(nodes, parent),
                i;

            // Generate new guids at copy #1344
            for (i = 0; i < newNodes.length; i += 1) {
                setDataGuid(newNodes[i], GUID());
            }

            return newNodes;
        };
        //</editor-fold>
    }

    return GuidCore;
});

/*globals define*/
/*eslint-env node, browser*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/nullpointercore',['common/core/CoreAssert', 'common/core/constants'], function (ASSERT, CONSTANTS) {
    'use strict';

    function NullPointerCore(innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized NullPointerCore');

        //<editor-fold=Modified Methods>
        this.setPointer = function (node, name, target) {
            if (target === null) {
                var nullChild = innerCore.getChild(node, CONSTANTS.NULLPTR_RELID);
                innerCore.setAttribute(nullChild, 'name', CONSTANTS.NULLPTR_NAME);
                innerCore.setPointer(node, name, nullChild);
            } else {
                innerCore.setPointer(node, name, target);
            }
        };

        this.getPointerPath = function (node, name) {
            var path = innerCore.getPointerPath(node, name);
            if (path && path.indexOf(CONSTANTS.NULLPTR_RELID) !== -1) {
                return null;
            } else {
                return path;
            }
        };

        this.loadPointer = function (node, name) {
            var path = self.getPointerPath(node, name);
            if (path === null) {
                return null;
            } else {
                return innerCore.loadPointer(node, name);
            }
        };

        this.renamePointer = function (node, oldName, newName) {
            var oldPath = self.getPointerPath(node, oldName);
            if (oldPath === null) {
                self.deletePointer(node, oldName);
                self.setPointer(node, newName, null);
            } else {
                innerCore.renamePointer(node, oldName, newName);
            }
        };

        //</editor-fold>

        return self;
    }

    return NullPointerCore;
});
/*globals define*/
/*eslint-env node, browser*/

/**
 * @author mmaroti / https://github.com/mmaroti
 */

define('common/core/coreunwrap',['common/core/CoreAssert', 'common/core/tasync'], function (ASSERT, TASYNC) {
    'use strict';

    // ----------------- CoreUnwrap -----------------

    var CoreUnwrap = function (innercore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');
        var logger = options.logger.fork('coreunwrap');

        function checkNode(node) {
            if (node === null || innercore.isValidNode(node)) {
                return node;
            } else {
                throw new Error('Invalid result node');
            }
        }

        function checkNodes(nodes) {
            ASSERT(nodes instanceof Array);

            var i;
            for (i = 0; i < nodes.length; ++i) {
                if (!innercore.isValidNode(nodes[i])) {
                    throw new Error('Invalid result node array');
                }
            }

            return nodes;
        }

        // copy all operations
        var core = {};
        for (var key in innercore) {
            core[key] = innercore[key];
        }
        logger.debug('initialized');
        core.loadRoot = TASYNC.unwrap(innercore.loadRoot);
        //core.persist = TASYNC.unwrap(oldcore.persist);

        // core.loadChild = TASYNC.unwrap(oldcore.loadChild);
        core.loadChild = TASYNC.unwrap(function (node, relid) {
            return TASYNC.call(checkNode, innercore.loadChild(node, relid));
        });

        // core.loadByPath = TASYNC.unwrap(oldcore.loadByPath);
        core.loadByPath = TASYNC.unwrap(function (node, path) {
            return TASYNC.call(checkNode, innercore.loadByPath(node, path));
        });

        // core.loadChildren = TASYNC.unwrap(oldcore.loadChildren);
        core.loadChildren = TASYNC.unwrap(function (node) {
            return TASYNC.call(checkNodes, innercore.loadChildren(node));
        });

        // core.loadOwnChildren = TASYNC.unwrap(oldcore.loadOwnChildren);
        core.loadOwnChildren = TASYNC.unwrap(function (node) {
            return TASYNC.call(checkNodes, innercore.loadOwnChildren(node));
        });

        core.loadPointer = TASYNC.unwrap(innercore.loadPointer);
        core.loadCollection = TASYNC.unwrap(innercore.loadCollection);

        core.loadSubTree = TASYNC.unwrap(innercore.loadSubTree);
        core.loadOwnSubTree = TASYNC.unwrap(innercore.loadOwnSubTree);
        core.loadTree = TASYNC.unwrap(innercore.loadTree);
        core.traverse = TASYNC.unwrap(innercore.traverse);

        core.setGuid = TASYNC.unwrap(innercore.setGuid);

        //core diff async functions
        if (typeof innercore.generateTreeDiff === 'function') {
            core.generateTreeDiff = TASYNC.unwrap(innercore.generateTreeDiff);
        }

        if (typeof innercore.generateLightTreeDiff === 'function') {
            core.generateLightTreeDiff = TASYNC.unwrap(innercore.generateLightTreeDiff);
        }

        if (typeof innercore.applyTreeDiff === 'function') {
            core.applyTreeDiff = TASYNC.unwrap(innercore.applyTreeDiff);
        }

        //library functions

        core.addLibrary = TASYNC.unwrap(innercore.addLibrary);
        core.updateLibrary = TASYNC.unwrap(innercore.updateLibrary);

        // core.loadInstances = TASYNC.unwrap(oldcore.loadInstances);
        core.loadInstances = TASYNC.unwrap(function (node) {
            return TASYNC.call(checkNodes, innercore.loadInstances(node));
        });

        core.loadMembers = TASYNC.unwrap(innercore.loadMembers);
        core.loadOwnMembers = TASYNC.unwrap(innercore.loadOwnMembers);

        return core;
    };

    return CoreUnwrap;
});

/*globals define*/
/*eslint-env node, browser*/

/**
 * CoreIllegalOperationError should be thrown if the set of input parameters are correct but the request
 * or the operation do not apply to the current context. Here we followed the basic javascript principles
 * in terms that whenever the user try to access a 'field' of a 'field' that does not exist, we throw.
 * For example if someone tries to get the member attributes of an non-existing member.
 * Trying to modify read-only nodes are captured within this category.
 * @author kecso / https://github.com/kecso
 */

define('common/core/CoreIllegalOperationError',[], function () {
    'use strict';
    function CoreIllegalOperationError() {
        var error = Error.apply(this, arguments);
        error.name = this.name = 'CoreIllegalOperationError';
        this.message = error.message;
        this.stack = error.stack;

        return error;
    }

    CoreIllegalOperationError.prototype = Object.create(Error.prototype);
    CoreIllegalOperationError.prototype.constructor = CoreIllegalOperationError;

    return CoreIllegalOperationError;
});
/*globals define*/
/*eslint-env node, browser*/

/**
 * @author mmaroti / https://github.com/mmaroti
 */

define('common/core/coretype',[
    'common/core/CoreAssert',
    'common/core/tasync',
    'common/core/constants',
    'common/core/CoreIllegalOperationError'
], function (ASSERT, TASYNC, CONSTANTS, CoreIllegalOperationError) {
    'use strict';

    var CoreType = function (innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        // //isPointerName should be removed from API at this level
        // delete self.isPointerName;

        logger.debug('initialized CoreType');

        //<editor-fold=Helper Functions>
        function test(text, cond) {
            if (!cond) {
                throw new Error(text);
            }
        }

        function isFalseNode(node) {
            //TODO this hack should be removed, but now it seems just fine :)
            return innerCore.getPointerPath(node, CONSTANTS.BASE_POINTER) === undefined;
        }

        function loadRoot2(node) {
            ASSERT(node.base === undefined || node.base === null);
            //kecso - TODO it should be undefined, but maybe because of the cache it can be null

            node.base = null;
            return node;
        }

        function loadBase2(node, target) {
            if (node.base !== null && typeof node.base === 'object' &&
                (innerCore.getPath(node.base) === innerCore.getPath(target))) {
                //TODO somehow the object already loaded properly and we do no know about it!!!
                return node;
            } else {
                ASSERT(node.base === undefined || node.base === null); //kecso

                if (target === null) {
                    // At this point the base node should be a valid node
                    logger.warn('node [' + innerCore.getPath(node) +
                        '] removed due to missing base in inheritance chain');
                    innerCore.deleteNode(node);
                    //core.persist(core.getRoot(node));
                    return null;
                }

                node.base = target;

                if (!target) {
                    logger.error('No target in loadBase2', target);
                }

                return node;
            }
        }

        function loadBase(node) {
            var path = innerCore.getPath(node);
            ASSERT(node === null || node.base === undefined || typeof node.base === 'object');

            if (node.base === undefined) {
                if (self.isEmpty(node)) {
                    //empty nodes do not have a base
                    node.base = null;
                    return node;
                } else if (isFalseNode(node)) {
                    innerCore.deleteNode(node);
                    //core.persist(core.getRoot(node));
                    //TODO a notification should be generated towards the user
                    logger.warn('node [' + path + '] removed due to missing base');

                    //TODO check if some identification can be passed
                    return null;
                } else {
                    var basePath = innerCore.getPointerPath(node, CONSTANTS.BASE_POINTER);
                    ASSERT(basePath !== undefined);
                    if (basePath === null) {
                        node.base = null;
                        return node;
                    } else if (self.isContainerPath(basePath, path)) {
                        //contained base error
                        logger.error('node [' + path + '] contains its own base!');
                        innerCore.deleteNode(node);
                        //core.persist(core.getRoot(node));
                        return null;
                    } else {
                        return TASYNC.call(loadBase2, node, self.loadByPath(self.getRoot(node), basePath));
                    }
                }
            } else {
                //TODO can the base change at this point???
                return node;
            }
        }

        function loadChild(node, relid) {
            var child = null,
                base = self.getBase(node),
                basechild = null;
            if (base) {
                //the parent is inherited
                if (self.getChildrenRelids(base, true)[relid]) {
                    //inherited child
                    if (innerCore.getChildrenRelids(node).indexOf(relid) !== -1) {
                        //but it is overwritten so we should load it
                        child = innerCore.loadChild(node, relid);
                    }
                    basechild = self.loadChild(base, relid);
                    return TASYNC.call(function (b, c, n, r) {
                        if (c) {
                            child = c;
                            child.base = b;
                            return child;
                        } else {
                            child = innerCore.getChild(n, r);
                            self.setHashed(child, true, true);
                            child.base = b;

                            return child;
                        }
                    }, basechild, child, node, relid);
                }
            }
            //normal child - as every node should have a base, it is normally mean a direct child of the ROOT
            if (self.getChildrenRelids(node, true)[relid] !== true) {
                return null;
            }

            return TASYNC.call(loadBase, innerCore.loadChild(node, relid));
        }

        function loadDescendantByPath(node, pathArray, index) {
            if (node === null || index === pathArray.length) {
                return node;
            }

            var child = self.loadChild(node, pathArray[index]);
            return TASYNC.call(loadDescendantByPath, child, pathArray, index + 1);
        }

        function isInheritedChild(node) {
            var parent = self.getParent(node),
                base = self.getBase(node),
                parentBase = parent ? self.getBase(parent) : null,
                baseParent = base ? self.getParent(base) : null;

            if (baseParent && parentBase && self.getPath(baseParent) === self.getPath(parentBase)) {
                return true;
            }
            return false;
        }

        function getInstanceRoot(node) {

            while (isInheritedChild(node)) {
                node = self.getParent(node);
            }

            return node;
        }

        /**
         * This function collects the inherited collection names.
         * Although there is no collection inheritance, we know that if a model is instantiated its internal structure
         * is not duplicated or no new data will be created. This means that in a sense, to keep the prototypical
         * inheritance correct, we need to build the internal relations on the fly. This means that whenever the user
         * has a question about the inverse relations of an internal part of the instance, we have to check the
         * prototype for such 'internal' relations and provide them - like in case of inherited attributes.
         * The function goes up on the inheritance chain of the questioned node.
         * At every step, it searches the root of instantiation (the node that is the instance) and collect inverse
         * relation names that exist in the prototype structure and has purely internal endpoints.
         *
         * @param node - the node in question
         * @returns {Array} - the list of names of relations that has the node as target
         */
        function getInheritedCollectionNames(node) {
            var names = [],
                startNode = node,
                actualNode = node,
                endNode,
                inverseOverlays,
                name,
                target;

            while (startNode) {
                actualNode = self.getBase(startNode);
                endNode = self.getBase(getInstanceRoot(startNode));
                target = '';
                if (actualNode && endNode) {
                    while (actualNode && actualNode !== self.getParent(endNode)) {
                        inverseOverlays = innerCore.getInverseOverlayOfNode(actualNode);
                        if (inverseOverlays[target]) {
                            for (name in inverseOverlays[target]) {
                                if (names.indexOf(name) === -1) {
                                    names.push(name);
                                }
                            }
                        }
                        target = CONSTANTS.PATH_SEP + self.getRelid(actualNode) + target;
                        actualNode = self.getParent(actualNode);
                    }
                }
                startNode = self.getBase(startNode);
            }

            return names;
        }

        /**
         * This function gathers the paths of the nodes that are pointing to the questioned node. The set of relations
         * that are checked is the 'inherited' inverse relations.
         *
         * The method of this function is identical to getInheritedCollectionNames, except this function collects the
         * sources of the given relations and not just the name of all such relation. To return a correct path (as
         * the data exists in some bases of the actual nodes) the function always convert it back to the place of
         * inquiry.
         * @param node - the node in question
         * @param name - name of the relation that we are interested in
         * @returns {Array} - list of paths of sources of inherited relations by the given name
         */
        function getInheritedCollectionPaths(node, name) {
            var paths = [],
                startNode = node,
                actualNode = node,
                endNode,
                prefixNode,
                i,
                inverseOverlays,
                target;

            while (startNode) {
                actualNode = self.getBase(startNode);
                endNode = self.getBase(getInstanceRoot(startNode));
                target = '';
                if (actualNode && endNode) {
                    prefixNode = node;
                    while (actualNode && actualNode !== self.getParent(endNode)) {
                        inverseOverlays = innerCore.getInverseOverlayOfNode(actualNode);
                        if (inverseOverlays[target] && inverseOverlays[target][name]) {
                            for (i = 0; i < inverseOverlays[target][name].length; i += 1) {
                                paths.push(self.joinPaths(self.getPath(prefixNode), inverseOverlays[target][name][i]));
                            }
                        }
                        target = CONSTANTS.PATH_SEP + self.getRelid(actualNode) + target;
                        actualNode = self.getParent(actualNode);
                        prefixNode = self.getParent(prefixNode);
                    }
                }
                startNode = self.getBase(startNode);
            }

            return paths;
        }

        function isValidNodeThrow(node) {
            test('corerel', innerCore.isValidNode(node));
            test('base', typeof node.base === 'object');
        }

        // function getProperty(node, name) {
        //     var property;
        //     while (property === undefined && node !== null) {
        //         property = innerCore.getProperty(node, name);
        //         node = self.getBase(node);
        //     }
        //     return property;
        // }

        function isBase(node, compareNode) {
            while (compareNode) {
                if (compareNode === node) {
                    return true;
                }

                compareNode = self.getBase(compareNode);
            }

            return false;
        }

        function isParent(node, compareNode) {
            while (compareNode) {
                if (compareNode === node) {
                    return true;
                }

                compareNode = self.getParent(compareNode);
            }

            return false;
        }

        function isParentOrBaseRec(node, compareNode, visited, traverseContainment) {
            var comparePath = self.getPath(compareNode);

            if (traverseContainment) {
                if (visited.containment[comparePath]) {
                    //console.log('breaking recursion', traverseContainment, basePath);
                    return false;
                }

                visited.containment[comparePath] = true;
                compareNode = self.getParent(compareNode);
            } else {
                if (visited.inheritance[comparePath]) {
                    //console.log('breaking recursion', traverseContainment, basePath);
                    return false;
                }

                visited.inheritance[comparePath] = true;
                compareNode = self.getBase(compareNode);
            }

            while (compareNode) {
                //console.log('comparing with node', traverseContainment, basePath);
                if (node === compareNode || isParentOrBaseRec(node, compareNode, visited, !traverseContainment)) {
                    //console.log('Found one!');
                    return true;
                }

                if (traverseContainment) {
                    compareNode = self.getParent(compareNode);
                } else {
                    compareNode = self.getBase(compareNode);
                }
            }

            return false;
        }

        function getBaseAncestor(node, otherNode) {
            var bases = [],
                base;

            base = node;
            while (base) {
                bases.push(base);
                base = self.getBase(base);
            }

            base = otherNode;
            while (base) {
                if (bases.indexOf(base) > -1) {
                    return base;
                }

                base = self.getBase(base);
            }

            return null;
        }

        function childHasSameOrigin(node, otherNode, childRelid) {
            var ancestor = getBaseAncestor(node, otherNode),
                result = false;

            if (ancestor) {
                result = self.getChildrenRelids(ancestor, true).hasOwnProperty(childRelid);
            }

            return result;
        }

        function processNewRelidLength(node, newMinLength) {
            var currMinLength;

            if (newMinLength > CONSTANTS.MAXIMUM_STARTING_RELID_LENGTH + 1) {
                logger.debug('Minimum relid length surpassed threshold, not propagating at all', newMinLength);
                return;
            } else if (newMinLength > CONSTANTS.MAXIMUM_STARTING_RELID_LENGTH) {
                newMinLength = CONSTANTS.MAXIMUM_STARTING_RELID_LENGTH;
                logger.debug('Minimum relid length reached threshold, only propagating threshold', newMinLength);
            }

            node = node.base;
            while (node) {
                currMinLength = innerCore.getProperty(node, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY) || 0;
                if (currMinLength >= newMinLength) {
                    return;
                }

                // TODO: Check for library element here??
                innerCore.setProperty(node, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY, newMinLength);
                node = node.base;
            }
        }

        function collectInheritanceInternalRelations(sourceRoot, targetRoot) {
            var sourceBases = [],
                sourceBaseInfo = [],
                node, originalNode, nodePath, relPath, originalRelPath,
                targetBase = null,
                targetRelPath = '',
                relationsToCheck, i, index,
                originalSourcePath = self.getPath(sourceRoot),
                originalTargetPath = self.getPath(targetRoot),
                relations = [];

            node = sourceRoot;
            relPath = '';
            originalNode = sourceRoot;
            originalRelPath = '';
            while (node) {
                while (innerCore.getPointerPath(node, CONSTANTS.BASE_POINTER) === undefined) {
                    relPath = CONSTANTS.PATH_SEP + innerCore.getRelid(node);
                    originalSourcePath = self.getParentPath(originalSourcePath);
                    originalRelPath = CONSTANTS.PATH_SEP + self.getRelid(originalNode) + originalRelPath;
                    originalNode = self.getParent(originalNode);

                    node = innerCore.getParent(node);
                }
                sourceBases.push(node);
                sourceBaseInfo.push({
                    originalPath: originalSourcePath,
                    relPath: relPath,
                    originalRelPath: originalRelPath
                });
                node = self.getBase(node);
            }

            node = targetRoot;
            originalNode = targetRoot;
            originalRelPath = '';
            // while (node && targetBase === null) {
            //     while (innerCore.getPointerPath(node, CONSTANTS.BASE_POINTER) === undefined) {
            //         targetRelPath = CONSTANTS.PATH_SEP + innerCore.getRelid(node);
            //         originalTargetPath = self.getParentPath(originalTargetPath);
            //         originalRelPath = CONSTANTS.PATH_SEP + self.getRelid(originalNode) + originalRelPath;
            //         originalNode = self.getParent(originalNode);
            //         node = innerCore.getParent(node);
            //     }
            //     if (sourceBases.indexOf(node) !== -1) {
            //         targetBase = node;
            //     }
            //     node = self.getBase(node);
            // }
            while (innerCore.getPointerPath(node, CONSTANTS.BASE_POINTER) === undefined) {
                targetRelPath = CONSTANTS.PATH_SEP + innerCore.getRelid(node);
                originalTargetPath = self.getParentPath(originalTargetPath);
                originalRelPath = CONSTANTS.PATH_SEP + self.getRelid(originalNode) + originalRelPath;
                originalNode = self.getParent(originalNode);
                node = innerCore.getParent(node);
            }
            if (sourceBases.indexOf(node) !== -1) {
                targetBase = node;
            }

            if (targetBase === null) {
                return relations;
            }

            // We know that there is a common base/container that can hold inherited information...
            node = targetBase;
            index = sourceBases.indexOf(node);

            while (node) {
                relationsToCheck = innerCore.gatherRelationsOfSubtree(node,
                    sourceBaseInfo[index].relPath, targetRelPath);
                nodePath = self.getPath(node);
                for (i = 0; i < relationsToCheck.length; i += 1) {
                    relationsToCheck[i].source =
                        relationsToCheck[i].source.replace(
                            nodePath + sourceBaseInfo[index].relPath,
                            sourceBaseInfo[index].originalPath + sourceBaseInfo[index].originalRelPath);
                    relationsToCheck[i].sourceBase =
                        relationsToCheck[i].sourceBase.replace(
                            nodePath + sourceBaseInfo[index].relPath,
                            sourceBaseInfo[index].originalPath + sourceBaseInfo[index].originalRelPath);
                    relationsToCheck[i].target =
                        relationsToCheck[i].target.replace(
                            nodePath + targetRelPath,
                            originalTargetPath + originalRelPath);
                    relationsToCheck[i].targetBase =
                        relationsToCheck[i].targetBase.replace(
                            nodePath + targetRelPath,
                            originalTargetPath + originalRelPath);
                }
                relations = relationsToCheck.concat(relations);
                node = self.getBase(node);
            }

            return relations;
        }

        function getPointerPathFromRec(node, source, name) {
            var path, instanceRootPath, instanceRootBasePath, commonPathInfo;
            if (node === null) {
                return undefined;
            }

            path = innerCore.getPointerPathFrom(node, source, name);

            if (path !== undefined) {
                return path;
            }

            path = getPointerPathFromRec(self.getBase(node), source, name);

            if (typeof path !== 'string') {
                return path;
            }

            instanceRootPath = self.getPath(getInstanceRoot(node));
            instanceRootBasePath = self.getPath(self.getBase(getInstanceRoot(node)));

            commonPathInfo = self.getCommonPathPrefixData(instanceRootBasePath, path);

            if (commonPathInfo.common === instanceRootBasePath) {
                return instanceRootPath + commonPathInfo.second;
            }

            return path;
        }

        //</editor-fold>

        //<editor-fold=Modified Methods>
        this.isValidNode = function (node) {
            try {
                isValidNodeThrow(node);
                return true;
            } catch (error) {
                logger.error(error.message, {stack: error.stack, node: node});
                return false;
            }
        };

        this.loadRoot = function (hash) {
            return TASYNC.call(loadRoot2, innerCore.loadRoot(hash));
        };

        this.loadChild = function (node, relid) {
            return TASYNC.call(function (child) {
                if (child && self.isInheritanceContainmentCollision(child, self.getParent(child))) {
                    logger.error('node[' + self.getPath(child) +
                        '] was deleted due to inheritance-containment collision');
                    self.deleteNode(child);
                    //core.persist(core.getRoot(child));
                    return null;
                } else {
                    return child;
                }
            }, loadChild(node, relid));
        };

        this.loadByPath = function (node, path) {
            ASSERT(self.isValidNode(node));
            ASSERT(path === '' || path.charAt(0) === CONSTANTS.PATH_SEP);
            path = path.split(CONSTANTS.PATH_SEP);
            return loadDescendantByPath(node, path, 1);
        };

        this.loadPointer = function (node, name) {
            //TODO the pointer loading is totally based upon the loadByPath...
            var pointerPath = self.getPointerPath(node, name),
                root = self.getRoot(node);

            if (pointerPath === undefined) {
                return undefined;
            }
            if (pointerPath === null) {
                return null;
            }
            return TASYNC.call(function () {
                return self.loadByPath(root, pointerPath);
            }, self.loadPaths(self.getHash(root), [pointerPath]));
        };

        this.getChild = function (node, relid) {
            ASSERT(self.isValidNode(node) && (node.base === undefined || typeof node.base === 'object'));
            var child = innerCore.getChild(node, relid);
            if (node.base !== null && node.base !== undefined) {
                if (child.base === null || child.base === undefined) {
                    child.base = self.getChild(node.base, relid);
                }
            } else {
                child.base = null;
            }
            return child;
        };

        this.getChildrenRelids = function (node, asObject) {
            ASSERT(self.isValidNode(node));
            var base = node,
                relids,
                i;

            function basesHaveSameRelids() {
                var b = node,
                    cnt = 0,
                    len = node.allChildrenRelids.bases.length;

                while (b) {
                    if (cnt === len || b.childrenRelids !== node.allChildrenRelids.bases[cnt]) {
                        return false;
                    }

                    b = b.base;
                    cnt += 1;
                }

                return true;
            }

            if (!node.allChildrenRelids || basesHaveSameRelids() === false) {
                // If there is no cache or the childrenRelids caches are outdated,
                // rebuild the cache.
                node.allChildrenRelids = {
                    cached: {},
                    bases: []
                };

                while (base) {
                    relids = innerCore.getChildrenRelids(base);
                    node.allChildrenRelids.bases.push(relids);

                    for (i = 0; i < relids.length; i += 1) {
                        node.allChildrenRelids.cached[relids[i]] = true;
                    }

                    base = base.base;
                }
            }

            return asObject ? node.allChildrenRelids.cached : Object.keys(node.allChildrenRelids.cached);
        };

        this.loadChildren = function (node) {
            ASSERT(self.isValidNode(node));
            var relids = self.getChildrenRelids(node);
            var children = [];
            for (var i = 0; i < relids.length; i++) {
                children[i] = self.loadChild(node, relids[i]);
            }
            return TASYNC.call(function (n) {
                var newn = [];
                for (var i = 0; i < n.length; i++) {
                    if (n[i] !== null) {
                        newn.push(n[i]);
                    }
                }
                return newn;
            }, TASYNC.lift(children));
        };

        this.setPointer = function (node, name, target) {
            innerCore.setPointer(node, name, target);

            if (isInheritedChild(node)) {
                self.setProperty(node, CONSTANTS.INHERITED_CHILD_HAS_OWN_RELATION_PROPERTY, true);
                // #1232

                self.processRelidReservation(self.getParent(node), self.getRelid(node));
            }

            if (isInheritedChild(target)) {
                self.setProperty(target, CONSTANTS.INHERITED_CHILD_HAS_OWN_RELATION_PROPERTY, true);
                // #1232
                self.processRelidReservation(self.getParent(target), self.getRelid(target));
            }
        };

        this.getCollectionNames = function (node) {
            ASSERT(self.isValidNode(node));
            var ownNames = innerCore.getCollectionNames(node),
                inhNames = getInheritedCollectionNames(node),
                i;
            for (i = 0; i < ownNames.length; i++) {
                if (inhNames.indexOf(ownNames[i]) < 0) {
                    inhNames.push(ownNames[i]);
                }
            }

            return inhNames;
        };

        this.getCollectionPaths = function (node, name) {
            ASSERT(self.isValidNode(node) && name);
            var ownPaths = innerCore.getCollectionPaths(node, name),
                inhPaths = getInheritedCollectionPaths(node, name);

            inhPaths = inhPaths.concat(ownPaths);

            return inhPaths;
        };

        this.loadCollection = function (node, name) {
            var root = self.getRoot(node),
                paths = self.getCollectionPaths(node, name),
                nodes = [],
                i,
                rootHash = self.getHash(root);

            return TASYNC.call(function () {
                for (i = 0; i < paths.length; i += 1) {
                    nodes[i] = self.loadByPath(root, paths[i]);
                }
                return TASYNC.lift(nodes);
            }, self.loadPaths(rootHash, paths));
        };

        this.createChild = function (parent, relidLength) {
            var node = innerCore.createChild(parent, self.getChildrenRelids(parent, true), relidLength);

            this.processRelidReservation(parent, this.getRelid(node));

            return self.getChild(parent, this.getRelid(node));
        };

        this.createNode = function (parameters, relidLength) {
            parameters = parameters || {};
            var base = parameters.base || null,
                parent = parameters.parent,
                node,
                takenRelids;

            ASSERT(!parent || self.isValidNode(parent));
            ASSERT(!base || self.isValidNode(base));

            if (self.isValidNewChild(parent, base) === false) {
                throw new CoreIllegalOperationError('Not allowed to create node that would cause loop in the ' +
                    'combined containment inheritance graph.');
            }


            if (parent) {
                takenRelids = self.getChildrenRelids(parent, true);
                relidLength = relidLength || innerCore.getProperty(parent, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY);
            }

            node = innerCore.createNode(parameters, takenRelids, relidLength);
            node.base = base;
            innerCore.setPointer(node, CONSTANTS.BASE_POINTER, base);

            if (parent) {
                this.processRelidReservation(parent, this.getRelid(node));

                // Addition to #1232
                if (isInheritedChild(parent)) {
                    self.processRelidReservation(self.getParent(parent), self.getRelid(parent));
                }
            }

            return node;
        };

        this.isValidNewChild = function (parentNode, baseNode) {
            ASSERT(!parentNode || self.isValidNode(parentNode));
            ASSERT(!baseNode || self.isValidNode(baseNode));
            // When we look for a loop, we see relationship parent and instance as edges
            // The intended new node would make a path base->parent, if the node would cause a loop,
            // then there should already be a path parent->base

            if (!parentNode || !baseNode) {
                return true;
            }

            while (parentNode) {
                if (self.isInstanceOf(baseNode, parentNode)) {
                    return false;
                }
                parentNode = self.getParent(parentNode);
            }

            return true;
        };

        this.isValidNewParent = function (node, parent) {
            ASSERT(self.isValidNode(node) && self.isValidNode(parent));
            var visited = {
                    containment: {},
                    inheritance: {}
                },
                result = true;

            if (isBase(parent, node)) {
                result = false;
            } else if (isParentOrBaseRec(node, parent, visited, true)) {
                result = false;
            } else if (isParentOrBaseRec(node, parent, visited, false)) {
                result = false;
            }

            return result;
        };

        this.moveNode = function (node, parent, relidLength, newRelid) {
            var minRelidLength = innerCore.getProperty(parent, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY),
                takenRelids = self.getChildrenRelids(parent, true),
                currRelid = this.getRelid(node),
                base = node.base,
                moved;

            if (self.isValidNewParent(node, parent) === false) {
                throw new CoreIllegalOperationError('New parent would create loop in containment/inheritance tree.');
            }
            if (typeof minRelidLength === 'number' && currRelid.length < minRelidLength) {
                takenRelids[currRelid] = true;
            } else if (typeof relidLength === 'number' && currRelid.length < relidLength) {
                takenRelids[currRelid] = true;
            }

            moved = innerCore.moveNode(node, parent, takenRelids, relidLength || minRelidLength, newRelid);
            moved.base = base;

            this.processRelidReservation(parent, this.getRelid(moved));

            // Addition to #1232
            if (isInheritedChild(parent)) {
                self.processRelidReservation(self.getParent(parent), self.getRelid(parent));
            }

            return moved;
        };

        this.copyNode = function (node, parent, relidLength) {
            var newNode,
                base = self.getBase(node);

            if (base !== null && self.isValidNewChild(parent, base) === false) {
                throw new CoreIllegalOperationError('Not allowed to copy the node under a parent that would ' +
                    'cause loop in the combined containment inheritance graph.');
            }

            relidLength = relidLength || innerCore.getProperty(parent, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY);
            newNode = innerCore.copyNode(node, parent, self.getChildrenRelids(parent, true), relidLength);
            newNode.base = node.base;
            if (typeof self.getPointerPath(node, CONSTANTS.BASE_POINTER) === 'string') {
                innerCore.setPointer(newNode, CONSTANTS.BASE_POINTER, node.base);
            }

            // The copy does not have any instances at this point -> reset the property.
            innerCore.deleteProperty(newNode, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY);

            this.processRelidReservation(parent, this.getRelid(newNode));

            // Addition to #1232
            if (isInheritedChild(parent)) {
                self.processRelidReservation(self.getParent(parent), self.getRelid(parent));
            }

            return newNode;
        };

        this.copyNodes = function (nodes, parent, relidLength) {
            // Due to inheritance we have 3 types of relations, that needs to be preserved:
            // 1. Direct relations among any two subtrees involved in the copy (same as corerel level)
            // 2. Inherited relations that goes between affected subtrees but remain the scope of the copy
            // This option means that both ends of the relation is inside an inheritance that defines the
            // relation (Example: You have inherited child A that points to inherited child B, you copy them
            // together under the same parent. If their relationship would not be flatten, then copyA would
            // point to B instead of copy B).
            // 3. Inherited relationship, when the original target is in the copy. (Example: inherited child A
            // points to container B, we copy the container of A and B as well. We expect copyA to point to copyB
            // instead of the original container B).
            // +1. If for some reason we copy an inherited child, then its base should be set properly (otherwise
            // it would lose base information).

            var copiedNodes = [],
                old2NewPath = {},
                source,
                target,
                oldTarget,
                relationsToPreserve = [],
                longestNewRelid = 0,
                relations = [],
                basePath,
                nodePath,
                node,
                tempParent, tempSrc,
                i, j, k;

            // check for loop
            for (i = 0; i < nodes.length; i += 1) {
                if (self.isValidNewChild(parent, self.getBase(nodes[i])) === false) {
                    throw new CoreIllegalOperationError('Not allowed to copy the node under a parent that would ' +
                        'cause loop in the combined containment inheritance graph.');
                }
            }
            // This collects 1 and 3
            for (i = 0; i < nodes.length; i += 1) {
                node = nodes[i];
                basePath = self.getPath(node);
                for (j = 0; j < nodes.length; j += 1) {
                    if (i === j) {
                        continue;
                    }

                    if (nodes[i] === nodes[j]) {
                        continue;
                    }

                    node = nodes[i];
                    basePath = self.getPath(node);

                    while (node) {
                        relations = innerCore.gatherRelationsAmongSubtrees(node, nodes[j]);
                        nodePath = self.getPath(node);
                        if (basePath !== nodePath) {
                            for (k = 0; k < relations.length; k += 1) {
                                relations[k].source = relations[k].source.replace(nodePath, basePath);
                                relations[k].sourceBase = relations[k].sourceBase.replace(nodePath, basePath);
                            }
                        }

                        relationsToPreserve = relations.concat(relationsToPreserve);
                        node = self.getBase(node);
                    }
                }
            }

            // Then collecting 2
            for (i = 0; i < nodes.length; i += 1) {
                for (j = 0; j < nodes.length; j += 1) {
                    if (i === j) {
                        continue;
                    }

                    if (nodes[i] === nodes[j]) {
                        continue;
                    }

                    relationsToPreserve = collectInheritanceInternalRelations(nodes[i], nodes[j])
                        .concat(relationsToPreserve);
                }
            }

            // The actual copy of nodes
            relidLength = relidLength || innerCore.getProperty(parent, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY);
            for (i = 0; i < nodes.length; i += 1) {
                node = innerCore.copyNode(nodes[i], parent, self.getChildrenRelids(parent, true), relidLength);
                copiedNodes.push(node);
                old2NewPath[self.getPath(nodes[i])] = CONSTANTS.PATH_SEP + self.getRelid(node);
                j = (self.getRelid(node) || '').length;
                if (j > longestNewRelid) {
                    longestNewRelid = j;
                }
            }

            self.processRelidReservation(parent, longestNewRelid);

            // Setting the preserved relations
            // create the relations, that have to be preserved
            for (i = 0; i < relationsToPreserve.length; i += 1) {
                if (old2NewPath.hasOwnProperty(relationsToPreserve[i].sourceBase) &&
                    old2NewPath.hasOwnProperty(relationsToPreserve[i].targetBase)) {
                    source = relationsToPreserve[i].source.replace(
                        relationsToPreserve[i].sourceBase,
                        old2NewPath[relationsToPreserve[i].sourceBase]
                    );
                    target = relationsToPreserve[i].target.replace(
                        relationsToPreserve[i].targetBase,
                        old2NewPath[relationsToPreserve[i].targetBase]
                    );

                    tempParent = parent;
                    tempSrc = source;
                    while (tempParent !== null) {
                        oldTarget = self.overlayInquiry(tempParent, tempSrc, relationsToPreserve[i].name);
                        if (oldTarget !== null && typeof oldTarget.value === 'string') {
                            self.overlayRemove(tempParent, tempSrc, relationsToPreserve[i].name, oldTarget.value);
                            tempParent = null;
                        } else {
                            tempSrc = CONSTANTS.PATH_SEP + self.getRelid(tempParent) + tempSrc;
                            tempParent = self.getParent(tempParent);
                        }
                    }
                    self.overlayInsert(parent, source, relationsToPreserve[i].name, target);
                }
            }

            // Setting bases
            for (i = 0; i < nodes.length; i += 1) {
                innerCore.setPointer(copiedNodes[i], CONSTANTS.BASE_POINTER, self.getBase(nodes[i]));
                copiedNodes[i].base = nodes[i].base;
                innerCore.deleteProperty(copiedNodes[i], CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY);
            }

            // Addition to #1232
            if (isInheritedChild(parent)) {
                self.processRelidReservation(self.getParent(parent), self.getRelid(parent));
            }

            return copiedNodes;
        };

        this.deleteNode = function (node, technical) {
            //currently we only check if the node is inherited from its parents children
            if (node && (node.base !== null || technical === true)) {
                var parent = self.getParent(node),
                    parentsBase = parent ? self.getBase(node) : null,
                    base = self.getBase(node),
                    basesParent = base ? self.getParent(node) : null;

                if (parent && parentsBase && base && basesParent) {
                    if (self.getPath(parentsBase) !== self.getPath(basesParent)) {
                        innerCore.deleteNode(node);
                    }
                } else {
                    innerCore.deleteNode(node);
                }
            }
        };

        this.getAttributeNames = function (node) {
            ASSERT(self.isValidNode(node));

            var merged = {};
            do {
                var names = innerCore.getAttributeNames(node);
                for (var i = 0; i < names.length; ++i) {
                    if (!(names[i] in merged)) {
                        merged[names[i]] = true;
                    }
                }

                node = node.base;
            } while (node);

            return Object.keys(merged);
        };

        this.getRegistryNames = function (node) {
            ASSERT(self.isValidNode(node));

            var merged = {};
            do {
                var names = innerCore.getRegistryNames(node);
                for (var i = 0; i < names.length; ++i) {
                    if (!(names[i] in merged)) {
                        merged[names[i]] = true;
                    }
                }

                node = node.base;
            } while (node);

            return Object.keys(merged);
        };

        this.getAttribute = function (node, name) {
            ASSERT(self.isValidNode(node));
            var value;
            do {
                value = innerCore.getAttribute(node, name);
                node = node.base;
            } while (value === undefined && node !== null);

            return value;
        };

        this.getRegistry = function (node, name) {
            ASSERT(self.isValidNode(node));
            var value;
            do {
                value = innerCore.getRegistry(node, name);
                node = node.base;
            } while (value === undefined && node !== null);

            return value;
        };

        this.getPointerNames = function (node) {
            ASSERT(self.isValidNode(node));

            return self.getPointerNamesFrom(node, '');
            //var merged = {};
            //do {
            //    var names = oldcore.getPointerNames(node);
            //    for (var i = 0; i < names.length; ++i) {
            //        if (!(names[i] in merged)) {
            //            merged[names[i]] = true;
            //        }
            //    }
            //
            //    node = node.base;
            //} while (node);
            //
            //return Object.keys(merged);
        };

        this.getPointerNamesFrom = function (node, source) {
            ASSERT(self.isValidNode(node));

            var merged = {};
            do {
                var names = innerCore.getPointerNamesFrom(node, source);
                for (var i = 0; i < names.length; ++i) {
                    if (!(names[i] in merged)) {
                        merged[names[i]] = true;
                    }
                }

                node = node.base;
            } while (node);

            return Object.keys(merged);
        };

        this.getPointerPathFrom = function (node, source, name) {
            ASSERT(self.isValidNode(node) && typeof name === 'string');

            return getPointerPathFromRec(node, source, name);
        };

        this.getPointerPath = function (node, name) {
            return self.getPointerPathFrom(node, '', name);
        };

        this.getChildrenPaths = function (node) {
            var path = self.getPath(node);

            var relids = self.getChildrenRelids(node);
            // Remark: It's fine to mutate this array since we're using Object.keys on the cached object..
            for (var i = 0; i < relids.length; ++i) {
                relids[i] = path + CONSTANTS.PATH_SEP + relids[i];
            }

            return relids;
        };

        this.setAttribute = function (node, name, value) {
            innerCore.setAttribute(node, name, value);

            // #1232
            if (isInheritedChild(node)) {
                self.processRelidReservation(self.getParent(node), self.getRelid(node));
            }
        };

        this.setRegistry = function (node, name, value) {
            innerCore.setRegistry(node, name, value);

            // #1232
            if (isInheritedChild(node)) {
                self.processRelidReservation(self.getParent(node), self.getRelid(node));
            }
        };
        //</editor-fold>

        //<editor-fold=Added Methods>

        //check of inheritance chain and containment hierarchy collision
        this.isInheritanceContainmentCollision = function (node, parent) {
            var bases = [];

            while (node) {
                bases.push(self.getPath(node));
                node = self.getBase(node);
            }

            while (parent) {
                if (bases.indexOf(self.getPath(parent)) !== -1) {
                    return true;
                }
                parent = self.getParent(parent);
            }
            return false;
        };

        this.getBase = function (node) {
            ASSERT(self.isValidNode(node));

            // TODO: check if base has moved
            return node.base;
        };

        this.isValidNewBase = function (node, base) {
            ASSERT(self.isValidNode(node) && (base === undefined || base === null || self.isValidNode(base)));
            var visited = {
                    containment: {},
                    inheritance: {}
                },
                result = true;

            if (!base) {
                result = true;
            } else if (isParent(base, node)) {
                result = false;
            } else if (isParentOrBaseRec(node, base, visited, true)) {
                result = false;
            } else if (isParentOrBaseRec(node, base, visited, false)) {
                result = false;
            }

            return result;
        };

        this.setBase = function (node, base) {

            if (self.isValidNewBase(node, base) === false) {
                throw new CoreIllegalOperationError('New base would create loop in containment/inheritance tree.');
            }

            if (base) {
                //TODO maybe this is not the best way, needs to be double checked
                var parent = self.getParent(node),
                    nodeChildren = self.getOwnChildrenRelids(node), // We're only interested in the children with data.
                    minRelidLength = innerCore.getProperty(node, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY) || 0,
                    baseChildren = self.getChildrenRelids(base, true),
                    parentBase,
                    baseParent,
                    i;

                if (parent) {
                    parentBase = self.getBase(parent);
                    baseParent = self.getParent(base);
                    if (self.getPath(parentBase) !== self.getPath(baseParent)) {
                        //we have to set an exact pointer only if it is not inherited child
                        innerCore.setPointer(node, CONSTANTS.BASE_POINTER, base);

                        for (i = 0; i < nodeChildren.length; i += 1) {
                            if (baseChildren[nodeChildren[i]] && childHasSameOrigin(node, base, nodeChildren[i])) {
                                // Currently we only keep the children data for children with same origin.
                                // Meaning we delete all other children (including those that were created in node).
                            } else {
                                innerCore.deleteChild(node, nodeChildren[i]);
                            }
                        }
                    } else {
                        innerCore.deletePointer(node, CONSTANTS.BASE_POINTER); //we remove the pointer just in case
                    }
                } else {
                    //if for some reason the node doesn't have a parent it is surely not an inherited child
                    innerCore.setPointer(node, CONSTANTS.BASE_POINTER, base);
                }

                node.base = base;

                // Handle the minimal new length propagation to the new base chain.
                for (i = 0; i < nodeChildren.length; i += 1) {
                    // Do not account for old relids..
                    if (nodeChildren[i].length <= CONSTANTS.MAXIMUM_STARTING_RELID_LENGTH) {
                        minRelidLength = nodeChildren[i].length + 1 > minRelidLength ?
                            nodeChildren[i].length + 1 : minRelidLength;
                    }
                }

                if (minRelidLength >= 2) {
                    processNewRelidLength(node, minRelidLength);
                }
            } else {
                innerCore.setPointer(node, CONSTANTS.BASE_POINTER, null);
                node.base = null;
            }
        };

        // FIXME: Do we really need both of these??
        this.getBaseRoot = function (node) {
            ASSERT(self.isValidNode(node));
            while (node.base !== null) {
                node = node.base;
            }

            return node;
        };

        this.getTypeRoot = function (node) {
            if (node.base) {
                while (node.base !== null) {
                    node = self.getBase(node);
                }
                return node;
            } else {
                return null;
            }
        };

        this.getOwnChildrenRelids = function (node) {
            return innerCore.getChildrenRelids(node);
        };

        this.loadOwnChildren = function (node) {
            ASSERT(self.isValidNode(node));
            var relids = self.getOwnChildrenRelids(node);
            var children = [];
            for (var i = 0; i < relids.length; i++) {
                children[i] = self.loadChild(node, relids[i]);
            }
            return TASYNC.call(function (n) {
                var newn = [];
                for (var i = 0; i < n.length; i++) {
                    if (n[i] !== null) {
                        newn.push(n[i]);
                    }
                }
                return newn;
            }, TASYNC.lift(children));
        };

        this.getOwnAttributeNames = function (node) {
            return innerCore.getAttributeNames(node);
        };

        this.getOwnRegistryNames = function (node) {
            return innerCore.getRegistryNames(node);
        };

        this.getOwnAttribute = function (node, name) {
            return innerCore.getAttribute(node, name);
        };

        this.getOwnRegistry = function (node, name) {
            return innerCore.getRegistry(node, name);
        };

        this.getOwnPointerNames = function (node) {
            ASSERT(self.isValidNode(node));
            return innerCore.getPointerNames(node);
        };

        this.getOwnPointerNamesFrom = function (node, source) {
            return innerCore.getPointerNamesFrom(node, source);
        };

        this.getOwnPointerPath = function (node, name) {
            return innerCore.getPointerPath(node, name);
        };

        this.getOwnPointerPathFrom = function (node, source, name) {
            return innerCore.getPointerPathFrom(node, source, name);
        };

        this.getOwnChildrenPaths = function (node) {
            return innerCore.getChildrenPaths(node);
        };

        this.processRelidReservation = function (node, relid) {
            if (!CONSTANTS.DOES_NOT_HAVE_RELID_CHILDREN[self.getRelid(node)] && innerCore.isValidRelid(relid)) {
                // We do not process relids for e.g. _sets and _meta.
                processNewRelidLength(node, relid.length + 1);
            }
        };

        this.isInstanceOf = function (node, baseNodeOrPath) {
            var typePath = typeof baseNodeOrPath === 'string' ? baseNodeOrPath : self.getPath(baseNodeOrPath);

            while (node) {
                if (typePath === self.getPath(node)) {
                    return true;
                }

                node = node.base;
            }

            return false;
        };

        this.getInstancePaths = function (node) {
            var instances = [],
                directCollectionPaths,
                relPath = '',
                i;

            while (node) {
                directCollectionPaths = innerCore.getCollectionPaths(node, CONSTANTS.BASE_POINTER);
                for (i = 0; i < directCollectionPaths.length; i += 1) {
                    instances.push(directCollectionPaths[i] + relPath);
                }
                relPath = CONSTANTS.PATH_SEP + innerCore.getRelid(node) + relPath;
                node = innerCore.getParent(node);
            }

            return instances;
        };

        this.loadInstances = function (node) {
            ASSERT(self.isValidNode(node));

            var instancePaths = self.getInstancePaths(node),
                instances = [],
                root = self.getRoot(node),
                i;

            for (i = 0; i < instancePaths.length; i += 1) {
                instances[i] = self.loadByPath(root, instancePaths[i]);
            }

            return TASYNC.lift(instances);
        };
        //</editor-fold>
    };

    return CoreType;
});

/*globals define*/
/*eslint-env node, browser*/

/**
 * @author kecso / https://github.com/kecso
 *
 * example constraint structure for the outside world:
 * {
 *  script:string,
 *  priority:integer,
 *  name:string,
 *  message:string
 * }
 * provided API:
 * getConstraint(node,name) -> constraintObj
 * setConstraint(node,constraintObj)
 * getConstraintNames(node)
 * delConstraint(node,name)
 */

define('common/core/constraintcore',['common/util/assert', 'common/core/constants'], function (ASSERT, CONSTANTS) {
    'use strict';

    function ConstraintCore(innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized ConstraintCore');

        //<editor-fold=Helper Functions>
        function getConstraintRelId(constraintsNode, name) {
            var relIds = innerCore.getChildrenRelids(constraintsNode);
            var relId;
            for (var i = 0; i < relIds.length; i++) {
                if (name === innerCore.getAttribute(innerCore.getChild(constraintsNode, relIds[i]), 'name')) {
                    relId = relIds[i];
                    break;
                }
            }
            return relId;
        }

        function getRegConstName(name) {
            return CONSTANTS.CONSTRAINT_REGISTRY_PREFIX + name;
        }

        function getContraintNames(node, onlyOwn) {
            ASSERT(self.isValidNode(node));
            var constraintsNode = self.getChild(node, CONSTANTS.CONSTRAINTS_RELID),
                relIds = onlyOwn ? self.getOwnChildrenRelids(constraintsNode) : self.getChildrenRelids(constraintsNode),
                names = [];

            for (var i = 0; i < relIds.length; i += 1) {
                names.push(self.getAttribute(self.getChild(constraintsNode, relIds[i]), 'name'));
            }
            return names;
        }

        //</editor-fold>

        //<editor-fold=Added Methods>
        this.getConstraint = function (node, name) {
            ASSERT(innerCore.isValidNode(node));
            var constraintsNode = innerCore.getChild(node, CONSTANTS.CONSTRAINTS_RELID);
            var constRelId = getConstraintRelId(constraintsNode, name);
            if (constRelId) {
                var constraintNode = innerCore.getChild(constraintsNode, constRelId);
                return {
                    script: innerCore.getAttribute(constraintNode, 'script'),
                    priority: innerCore.getAttribute(constraintNode, 'priority'),
                    info: innerCore.getAttribute(constraintNode, 'info')
                };
            } else {
                return null;
            }
        };

        this.setConstraint = function (node, name, constraintObj) {
            ASSERT(innerCore.isValidNode(node));
            ASSERT(typeof constraintObj === 'object' && typeof name === 'string');
            var constraintsNode = innerCore.getChild(node, CONSTANTS.CONSTRAINTS_RELID),
                constRelId = getConstraintRelId(constraintsNode, name),
                constraintNode;

            if (constRelId) {
                constraintNode = innerCore.getChild(constraintsNode, constRelId);
            } else {
                constraintNode = innerCore.createChild(constraintsNode, CONSTANTS.MAXIMUM_STARTING_RELID_LENGTH + 1);
            }

            constraintObj.priority = constraintObj.priority || CONSTANTS.C_DEF_PRIORITY;
            constraintObj.script = constraintObj.script || 'console.log("empty constraint");';
            constraintObj.info = constraintObj.info || '';
            innerCore.setAttribute(constraintNode, 'name', name);
            innerCore.setAttribute(constraintNode, 'script', constraintObj.script);
            innerCore.setAttribute(constraintNode, 'priority', constraintObj.priority);
            innerCore.setAttribute(constraintNode, 'info', constraintObj.info);
            innerCore.setRegistry(node, getRegConstName(name),
                (innerCore.getRegistry(node, getRegConstName(name)) || 0) + 1);
        };

        this.delConstraint = function (node, name) {
            ASSERT(innerCore.isValidNode(node));
            var constraintsNode = innerCore.getChild(node, CONSTANTS.CONSTRAINTS_RELID);
            var constRelId = getConstraintRelId(constraintsNode, name);
            if (constRelId) {
                var constraintNode = innerCore.getChild(constraintsNode, constRelId);
                innerCore.deleteNode(constraintNode, true);
            }

            innerCore.delRegistry(node, getRegConstName(name));
        };

        this.getConstraintNames = function (node) {
            return getContraintNames(node, false);
        };

        //TODO this means we always have to have this layer above type/inheritance layer
        this.getOwnConstraintNames = function (node) {
            return getContraintNames(node, true);
        };
        //</editor-fold>
    }

    return ConstraintCore;
});

/*globals define*/
/*eslint-env node, browser*/
/**
 * @author kecso / https://github.com/kecso
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/core/convertData',['common/core/constants', 'common/storage/constants'], function (CORE_CONSTANTS, STORAGE_CONSTANTS) {
    'use strict';

    var dataConverters,
        APP_VERSION = STORAGE_CONSTANTS.VERSION,
        MAJOR_APP_VERSION = APP_VERSION.split('.')[0];

    function isCollectionName(name) {
        if (name.length > CORE_CONSTANTS.COLLECTION_NAME_SUFFIX.length &&
            CORE_CONSTANTS.COLLECTION_NAME_SUFFIX === name.slice(-CORE_CONSTANTS.COLLECTION_NAME_SUFFIX.length)) {
            return true;
        }
        return false;
    }

    function clearOvrOfInvRelations(overlay) {
        var sourcePath,
            relationName;

        for (sourcePath in overlay) {
            for (relationName in overlay[sourcePath]) {
                if (isCollectionName(relationName)) {
                    delete overlay[sourcePath][relationName];
                }
            }

            // Remove all empty overlay entries
            if (Object.keys(overlay[sourcePath]).length === 0) {
                delete overlay[sourcePath];
            }
        }
    }

    // 0.0.0 --> 1.0.0
    // - every inverse relation has to be removed from the overlay
    function zeroToOne(dataObject) {

        clearOvrOfInvRelations(dataObject[CORE_CONSTANTS.OVERLAYS_PROPERTY] || {});

        dataObject.__v = '1.0.0';
        return dataObject;
    }

    function oneToOnePointOne(dataObject) {
        var currentSet,
            metaEntry,
            key;

        // Clear direct _sets of inverse overlay relations.
        currentSet = dataObject[CORE_CONSTANTS.ALL_SETS_PROPERTY] || {};
        clearOvrOfInvRelations(currentSet[CORE_CONSTANTS.OVERLAYS_PROPERTY] || {});

        metaEntry = dataObject[CORE_CONSTANTS.META_NODE] || {};
        clearOvrOfInvRelations(metaEntry[CORE_CONSTANTS.OVERLAYS_PROPERTY] || {});

        for (key in metaEntry) {
            currentSet = metaEntry[key];
            currentSet = currentSet[CORE_CONSTANTS.ALL_SETS_PROPERTY] || {};
            clearOvrOfInvRelations(currentSet[CORE_CONSTANTS.OVERLAYS_PROPERTY] || {});
        }

        dataObject.__v = '1.1.0';

        return dataObject;
    }

    dataConverters = {
        '0.0.0': {
            '1.0.0': zeroToOne,
            '1.1.0': function (dataObject) {
                return oneToOnePointOne(zeroToOne(dataObject));
            },
            '1.2.0': function (dataObject) {
                return oneToOnePointOne(zeroToOne(dataObject));
            }
        },
        '1.0.0': {
            '1.1.0': oneToOnePointOne,
            '1.2.0': oneToOnePointOne
        }
    };

    /**
     * Converts the passed dataObject to an object (a copy) of the current app version unless the same version.
     * @param {object} dataObject
     * @returns {object} A new object if converted, otherwise the passed dataObject.
     */
    function convertData(dataObject) {
        var dataVersion = dataObject.__v || '0.0.0',
            majorDataVersion = dataVersion.split('.')[0];

        if (majorDataVersion > MAJOR_APP_VERSION) {
            throw new Error('Trying to load data of incompatible version. Current version "' +
                APP_VERSION + '", data version "' + dataVersion + '".');
        }

        if (dataVersion !== APP_VERSION &&
            dataConverters[dataVersion] &&
            typeof dataConverters[dataVersion][APP_VERSION] === 'function') {

            return dataConverters[dataVersion][APP_VERSION](JSON.parse(JSON.stringify(dataObject)));
        }

        return dataObject;
    }

    return convertData;
});
/*globals define*/
/*eslint-env node, browser*/

/**
 * CoreIllegalArgumentError should be thrown if the type of the input parameters is not what it should be.
 * @author kecso / https://github.com/kecso
 */

define('common/core/CoreIllegalArgumentError',[], function () {
    'use strict';
    function CoreIllegalArgumentError() {
        var error = Error.apply(this, arguments);
        error.name = this.name = 'CoreIllegalArgumentError';
        this.message = error.message;
        this.stack = error.stack;

        return error;
    }

    CoreIllegalArgumentError.prototype = Object.create(Error.prototype);
    CoreIllegalArgumentError.prototype.constructor = CoreIllegalArgumentError;

    return CoreIllegalArgumentError;
});
/*globals define*/
/**
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/util/util',[], function () {
    'use strict';

    function isTrueObject(value) {
        return typeof value === 'object' && value !== null && value instanceof Array === false;
    }

    /**
     * Overwrites/augments values in toData with values from fromData.
     *
     * @param {object} toData - Object that will be updated with matched keys from toData.
     * @param {object} fromData - Object that will overwrite the keys of toData.
     */
    function updateFieldsRec(toData, fromData) {
        var keys = Object.keys(fromData),
            i;

        for (i = 0; i < keys.length; i += 1) {
            if (isTrueObject(fromData[keys[i]]) && isTrueObject(toData[keys[i]])) {
                updateFieldsRec(toData[keys[i]], fromData[keys[i]]);
            } else {
                toData[keys[i]] = fromData[keys[i]];
            }
        }
    }

    function orderStringArrayByElementLength(strArray) {
        var ordered = [],
            i, j, index;

        for (i = 0; i < strArray.length; i += 1) {
            index = -1;
            j = 0;
            while (index === -1 && j < ordered.length) {
                if (ordered[j].length > strArray[i].length) {
                    index = j;
                }

                j += 1;
            }

            if (index === -1) {
                ordered.push(strArray[i]);
            } else {
                ordered.splice(index, 0, strArray[i]);
            }
        }

        return ordered;
    }

    function indexOfUntil(items, item, maxIndex) {
        var len = items.length > maxIndex ? maxIndex : items.length;
        while (len--) {
            if (items[len] === item) {
                return len;
            }
        }

        return -1;
    }

    function indexOfUntilInObjectArray(items, item, maxIndex, key) {
        var len = items.length > maxIndex ? maxIndex : items.length;
        while (len--) {
            if (items[len][key] === item[key]) {
                return len;
            }
        }

        return -1;
    }

    function extendArrayUnique(base, extension) {
        var originalLength = base.length,
            extensionLen = extension.length,
            item;

        while (extensionLen--) {
            item = extension[extensionLen];
            if (indexOfUntil(base, item, originalLength) === -1) {
                base.push(item);
            }
        }

    }

    function extendObjectArrayUnique(base, extension, key) {
        var originalLength = base.length,
            extensionLen = extension.length,
            item;

        while (extensionLen--) {
            item = extension[extensionLen];
            if (indexOfUntilInObjectArray(base, item, originalLength, key) === -1) {
                base.push(item);
            }
        }

    }

    return {
        isTrueObject: isTrueObject,
        updateFieldsRec: updateFieldsRec,
        orderStringArrayByElementLength: orderStringArrayByElementLength,
        extendArrayUnique: extendArrayUnique,
        extendObjectArrayUnique: extendObjectArrayUnique
    };
});
/*globals define*/
/*eslint-env node, browser*/

/**
 * @author mmaroti / https://github.com/mmaroti
 */

define('common/core/coretree',[
    'common/core/CoreAssert',
    'common/util/key',
    'common/core/tasync',
    'common/util/random',
    'common/regexp',
    'common/core/constants',
    'common/storage/constants',
    'common/core/convertData',
    'common/core/CoreIllegalArgumentError',
    'common/util/util',
], function (ASSERT,
             generateKey,
             TASYNC,
             RANDOM,
             REGEXP,
             CONSTANTS,
             STORAGE_CONSTANTS,
             convertData,
             IllegalArgumentError,
             UTIL) {

    'use strict';

    var rootCounter = 0;

    function CoreTree(storage, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var gmeConfig = options.globConf,
            logger = options.logger.fork('core'),
            ID_NAME = storage.ID_NAME,
            roots = [],
            ticks = 0,
            mutateCount = 0,
            self = this;

        this.loadObject = TASYNC.wrap(function (hash, callback) {
            storage.loadObject(hash, function (err, resultObject) {
                if (err) {
                    callback(err, null);
                    return;
                }
                if (resultObject && resultObject.type === STORAGE_CONSTANTS.COMMIT_TYPE) {
                    err = new IllegalArgumentError('Cannot load commit object [' + hash + '] as a root node.');
                    resultObject = null;
                }
                callback(err, resultObject);
            });
        });

        this.loadPaths = TASYNC.wrap(storage.loadPaths);
        this.insertObject = storage.insertObject;
        this.logger = logger;

        this.ID_NAME = ID_NAME;

        // ------- memory management

        function __detachChildren(node) {
            ASSERT(UTIL.isTrueObject(node.children));
            ASSERT(node.age >= CONSTANTS.MAX_AGE - 1);

            var children = node.children;
            node.children = null;
            node.age = CONSTANTS.MAX_AGE;

            for (var child in children) {
                __detachChildren(children[child]);
            }
        }

        function __ageNodes(nodes) {
            ASSERT(UTIL.isTrueObject(nodes));

            var keys = Object.keys(nodes),
                node,
                i;

            for (i = 0; i < keys.length; i += 1) {
                node = nodes[keys[i]];
                ASSERT(node.age < CONSTANTS.MAX_AGE);
                if (++node.age >= CONSTANTS.MAX_AGE) {
                    delete nodes[keys[i]];
                    __detachChildren(node);
                } else {
                    __ageNodes(node.children);
                }
            }
        }

        function __ageRoots() {
            var root,
                i;
            if (++ticks >= CONSTANTS.MAX_TICKS) {
                ticks = 0;
                i = roots.length;
                while (--i >= 0) {
                    root = roots[i];
                    ASSERT(root.age < CONSTANTS.MAX_AGE);
                    if (++root.age >= CONSTANTS.MAX_AGE) {
                        roots.splice(i, 1);
                        __detachChildren(root);
                    } else {
                        __ageNodes(root.children);
                    }
                }
            }
        }

        function __getChildNode(children, relid) {
            ASSERT(UTIL.isTrueObject(children));
            ASSERT(typeof relid === 'string');

            if (children.hasOwnProperty(relid)) {
                children[relid].age = 0;
                return children[relid];
            }

            return null;
        }

        function __getEmptyData() {
            return {};
        }

        function __getChildData(data, relid) {
            ASSERT(typeof relid === 'string');

            if (typeof data === 'object' && data !== null) {
                data = data[relid];
                return data === undefined ? __getEmptyData() : data;
            } else {
                return null;
            }
        }

        function __isMutableData(data) {
            return typeof data === 'object' && data !== null && data[CONSTANTS.MUTABLE_PROPERTY] === true;
        }

        function __isEmptyData(data) {
            if (typeof data === 'string') {
                return false;
            } else if (typeof data === 'object' && Object.keys(data).length === 0) {
                return true;
            } else {
                return false;
            }
        }

        function __areEquivalent(data1, data2) {
            return data1 === data2 || (typeof data1 === 'string' && data1 === __getChildData(data2, ID_NAME)) ||
                (__isEmptyData(data1) && __isEmptyData(data2));
        }

        function __reloadChildrenData(node) {
            var key,
                child;

            for (key in node.children) {
                child = node.children[key];

                var data = __getChildData(node.data, child.relid);
                if (!REGEXP.DB_HASH.test(data) || data !== __getChildData(child.data, ID_NAME)) {
                    child.data = data;
                    __reloadChildrenData(child);
                }
            }
        }

        function __noUnderscore(relid) {
            ASSERT(typeof relid === 'string');
            return relid.charAt(0) !== '_';
        }

        function __saveData(data, root, path, stackedObjects) {
            ASSERT(__isMutableData(data));
            var cleanData;

            var done = __getEmptyData(),
                keys,
                key,
                i, child, sub, hash;

            delete data[CONSTANTS.MUTABLE_PROPERTY];
            keys = Object.keys(data);

            for (i = 0; i < keys.length; i++) {
                key = keys[i];
                child = data[key];
                if (__isMutableData(child)) {
                    sub = __saveData(child, root, path + CONSTANTS.PATH_SEP + key, stackedObjects);
                    if (JSON.stringify(sub) === JSON.stringify(__getEmptyData())) {
                        delete data[key];
                    } else {
                        done = sub;
                        if (typeof child[ID_NAME] === 'string') {
                            data[key] = child[ID_NAME];
                        }
                    }
                } else {
                    done = undefined;
                }
            }

            if (done !== __getEmptyData()) {
                hash = data[ID_NAME];
                ASSERT(hash === '' || hash === undefined);

                if (hash === '') {
                    data.__v = STORAGE_CONSTANTS.VERSION;
                    //TODO: This is a temporary fix. We should modify CANON.
                    cleanData = JSON.parse(JSON.stringify(data));
                    hash = '#' + generateKey(cleanData, gmeConfig);
                    data[ID_NAME] = hash;
                    cleanData[ID_NAME] = hash;

                    done = cleanData;

                    storage.insertObject(cleanData, stackedObjects);
                    stackedObjects[hash] = {
                        newHash: hash,
                        newData: cleanData,
                        oldHash: root.initial[path] && root.initial[path].hash,
                        oldData: root.initial[path] && root.initial[path].data
                    };

                    root.initial[path] = {
                        hash: hash,
                        data: cleanData
                    };
                    //stackedObjects[hash] = data;
                }
            }

            return done;
        }

        function __loadRoot2(data) {
            var root = {
                parent: null,
                relid: null,
                age: 0,
                children: {},
                data: null,
                initial: {
                    '': {
                        hash: data[storage.ID_NAME],
                        data: data
                    }
                },
                rootid: ++rootCounter
            };

            // Ensure we get the correct version of the data.
            root.data = convertData(data);

            roots.push(root);

            __ageRoots();
            return root;
        }

        function __loadChild2(node, newdata) {
            var root = self.getRoot(node),
                path = self.getPath(node);

            node = self.normalize(node);

            // TODO: this is a hack, we should avoid loading it multiple times
            if (REGEXP.DB_HASH.test(node.data)) {
                ASSERT(node.data === newdata[ID_NAME]);

                root.initial[path] = {
                    hash: node.data,
                    data: newdata
                };

                // Ensure we get the correct version of the data.
                node.data = convertData(newdata);
                __reloadChildrenData(node);
            } else {
                // TODO: if this bites you, use the Cache
                /*if(node.data !== newdata){
                 console.log('kecso',node);
                 }
                 ASSERT(node.data === newdata);*/
            }

            return node;
        }

        function __loadDescendantByPath2(node, path, index) {
            if (node === null || index === path.length) {
                return node;
            }

            var child = self.loadChild(node, path[index]);
            return TASYNC.call(__loadDescendantByPath2, child, path, index + 1);
        }

        // function __printNode(node) {
        //     var str = '{';
        //     str += 'age:' + node.age;
        //
        //     if (typeof node.relid === 'string') {
        //         str += ', relid: "' + node.relid + '"';
        //     }
        //
        //     str += ', children:';
        //     if (node.children === null) {
        //         str += 'null';
        //     } else {
        //         str += '[';
        //         for (var i = 0; i < node.children.length; ++i) {
        //             if (i !== 0) {
        //                 str += ', ';
        //             }
        //             str += __printNode(node.children[i]);
        //         }
        //         str += ']';
        //     }
        //
        //     str += '}';
        //     return str;
        // }

        function __test(text, cond) {
            if (!cond) {
                throw new Error(text);
            }
        }

        function isValidNodeThrow(node) {
            __test('object', typeof node === 'object' && node !== null);
            __test('object 2', node.hasOwnProperty('parent') && node.hasOwnProperty('relid'));
            __test('parent', typeof node.parent === 'object');
            __test('relid', typeof node.relid === 'string' || node.relid === null);
            __test('parent 2', (node.parent === null) === (node.relid === null));
            __test('age', node.age >= 0 && node.age <= CONSTANTS.MAX_AGE);
            //__test('children', node.children === null || node.children instanceof Array);
            __test('children 2', (node.age === CONSTANTS.MAX_AGE) === (node.children === null));
            __test('data', typeof node.data === 'object' || typeof node.data === 'string' ||
                typeof node.data === 'number');

            if (node.parent !== null) {
                __test('age 2', node.age >= node.parent.age);
                __test('mutable', !__isMutableData(node.data) || __isMutableData(node.parent.data));
            }
        }

        // ------- static methods
        this.copyIfObject = function (val) {
            return typeof val === 'object' && val !== null ? JSON.parse(JSON.stringify(val)) : val;
        };

        this.getParent = function (node) {
            ASSERT(typeof node.parent === 'object');

            return node.parent;
        };

        this.getRelid = function (node) {
            ASSERT(node.relid === null || typeof node.relid === 'string');

            return node.relid;
        };

        this.getLevel = function (node) {
            var level = 0;
            while (node.parent !== null) {
                ++level;
                node = node.parent;
            }
            return level;
        };

        this.getRoot = function (node) {
            while (node.parent !== null) {
                node = node.parent;
            }
            return node;
        };

        this.getPath = function (node, base) {
            if (node === null) {
                return null;
            }

            var path = '';
            while (node.relid !== null && node !== base) {
                path = CONSTANTS.PATH_SEP + node.relid + path;
                node = node.parent;
            }
            return path;
        };

        this.isValidPath = function (path) {
            return typeof path === 'string' && (path === '' || path.charAt(0) === CONSTANTS.PATH_SEP);
        };

        this.splitPath = function (path) {
            ASSERT(self.isValidPath(path));

            path = path.split(CONSTANTS.PATH_SEP);
            path.splice(0, 1);

            return path;
        };

        this.getParentPath = function (path) {
            path = path.split(CONSTANTS.PATH_SEP);
            path.splice(-1, 1);
            return path.join(CONSTANTS.PATH_SEP);
        };

        this.buildPath = function (path) {
            ASSERT(path instanceof Array);

            return path.length === 0 ? '' : CONSTANTS.PATH_SEP + path.join(CONSTANTS.PATH_SEP);
        };

        this.joinPaths = function (first, second) {
            ASSERT(self.isValidPath(first) && self.isValidPath(second));

            return first + second;
        };

        this.getCommonPathPrefixData = function (first, second) {
            ASSERT(typeof first === 'string' && typeof second === 'string');

            first = self.splitPath(first);
            second = self.splitPath(second);

            var common = [];
            for (var i = 0; first[i] === second[i] && i < first.length; ++i) {
                common.push(first[i]);
            }

            return {
                common: self.buildPath(common),
                first: self.buildPath(first.slice(i)),
                firstLength: first.length - i,
                second: self.buildPath(second.slice(i)),
                secondLength: second.length - i
            };
        };

        this.isPathInSubTree = function (path, subTreeRoot) {
            return path === subTreeRoot || path.indexOf(subTreeRoot + CONSTANTS.PATH_SEP) === 0;
        };

        this.normalize = function (node) {
            ASSERT(self.isValidNode(node));
            // console.log('normalize start', printNode(getRoot(node)));

            var parent;

            if (node.children === null) {
                ASSERT(node.age === CONSTANTS.MAX_AGE);

                if (node.parent !== null) {
                    parent = self.normalize(node.parent);

                    var temp = __getChildNode(parent.children, node.relid);
                    if (temp !== null) {
                        // TODO: make the current node close to the returned one

                        // console.log('normalize end1',
                        // printNode(getRoot(temp)));
                        return temp;
                    }

                    ASSERT(node.parent.children === null || __getChildNode(node.parent.children, node.relid) === null);
                    ASSERT(__getChildNode(parent.children, node.relid) === null);

                    node.parent = parent;
                    parent.children[node.relid] = node;

                    temp = __getChildData(parent.data, node.relid);
                    if (!REGEXP.DB_HASH.test(temp) || temp !== __getChildData(node.data, ID_NAME)) {
                        node.data = temp;
                    }
                } else {
                    roots.push(node);
                }

                node.age = 0;
                node.children = {};
            } else if (node.age !== 0) {
                parent = node;
                do {
                    parent.age = 0;
                    parent = parent.parent;
                } while (parent !== null && parent.age !== 0);
            }

            // console.log('normalize end2', printNode(getRoot(node)));
            return node;
        };

        // ------- hierarchy

        this.getAncestor = function (first, second) {
            ASSERT(self.getRoot(first) === self.getRoot(second));

            first = self.normalize(first);
            second = self.normalize(second);

            var a = [];
            do {
                a.push(first);
                first = first.parent;
            } while (first !== null);

            var b = [];
            do {
                b.push(second);
                second = second.parent;
            } while (second !== null);

            var i = a.length - 1;
            var j = b.length - 1;
            while (i !== 0 && j !== 0 && a[i - 1] === b[j - 1]) {
                --i;
                --j;
            }

            ASSERT(a[i] === b[j]);
            return a[i];
        };

        this.isAncestor = function (node, ancestor) {
            ASSERT(self.getRoot(node) === self.getRoot(ancestor));

            node = self.normalize(node);
            ancestor = self.normalize(ancestor);

            do {
                if (node === ancestor) {
                    return true;
                }

                node = node.parent;
            } while (node !== null);

            return false;
        };

        this.createRoot = function () {
            var root = {
                parent: null,
                relid: null,
                age: 0,
                children: {},
                data: {
                    _mutable: true
                },
                initial: {
                    '': null
                },
                rootid: ++rootCounter
            };
            root.data[ID_NAME] = '';
            roots.push(root);

            __ageRoots();
            return root;
        };

        this.getChild = function (node, relid) {
            ASSERT(typeof relid === 'string' && relid !== ID_NAME);

            node = self.normalize(node);

            var child = __getChildNode(node.children, relid);
            if (child !== null) {
                return child;
            }

            child = {
                parent: node,
                relid: relid,
                age: 0,
                children: {},
                data: __getChildData(node.data, relid)
            };
            node.children[relid] = child;

            __ageRoots();
            return child;
        };

        this.childLoaded = function (node, relid) {
            ASSERT(typeof relid === 'string' && relid !== ID_NAME);
            node = self.normalize(node);
            return __getChildNode(node.children, relid) !== null;
        };

        this.createChild = function (node, takenRelids, minimumLength) {
            node = self.normalize(node);

            if (typeof node.data !== 'object' || node.data === null) {
                throw new Error('invalid node data');
            }

            return self.getChild(node, RANDOM.generateRelid(takenRelids || node.data, minimumLength));
        };

        // ------- data manipulation

        this.isMutable = function (node) {
            node = self.normalize(node);
            return __isMutableData(node.data);
        };

        this.isEmpty = function (node) {
            node = self.normalize(node);
            if (typeof node.data !== 'object' || node.data === null) {
                return false;
            } else if (node.data === __getEmptyData()) {
                return true;
            }

            return __isEmptyData(node.data);
        };

        this.mutate = function (node) {
            ASSERT(self.isValidNode(node));

            node = self.normalize(node);
            var data = node.data;

            if (typeof data !== 'object' || data === null) {
                return false;
            } else if (data[CONSTANTS.MUTABLE_PROPERTY] === true) {
                return true;
            }

            // TODO: infinite cycle if MAX_MUTATE is smaller than depth!
            // gmeConfig.storage.autoPersist is removed and always false
            var autoPersist = false;
            if (autoPersist && ++mutateCount > CONSTANTS.MAX_MUTATE) {
                mutateCount = 0;

                for (var i = 0; i < roots.length; ++i) {
                    if (__isMutableData(roots[i].data)) {
                        __saveData(roots[i].data, roots[i], '');
                    }
                }
            }

            if (node.parent !== null && !self.mutate(node.parent)) {
                // this should never happen
                return false;
            }

            var copy = __getEmptyData();

            for (var key in data) {
                copy[key] = data[key];
            }
            copy[CONSTANTS.MUTABLE_PROPERTY] = true;

            if (typeof data[ID_NAME] === 'string') {
                copy[ID_NAME] = '';
            }

            if (node.parent !== null) {
                //inherited child doesn't have an entry in the parent as long as it has not been modified
                ASSERT(node.parent.data[node.relid] === undefined ||
                    __areEquivalent(__getChildData(node.parent.data, node.relid), node.data));
                node.parent.data[node.relid] = copy;
            }

            node.data = copy;
            return true;
        };

        this.getData = function (node) {
            node = self.normalize(node);

            ASSERT(!__isMutableData(node.data));
            return node.data;
        };

        this.setData = function (node, data) {
            ASSERT(data !== null && typeof data !== 'undefined');

            node = self.normalize(node);
            if (node.parent !== null) {
                if (!self.mutate(node.parent)) {
                    throw new Error('incorrect node data');
                }

                node.parent.data[node.relid] = data;
            }

            node.data = data;
            __reloadChildrenData(node);
        };

        this.deleteData = function (node) {
            node = self.normalize(node);

            if (node.parent !== null) {
                if (!self.mutate(node.parent)) {
                    throw new Error('incorrect node data');
                }

                delete node.parent.data[node.relid];
            }

            var data = node.data;

            node.data = __getEmptyData();
            __reloadChildrenData(node);

            return data;
        };

        this.copyData = function (node) {
            node = self.normalize(node);

            if (typeof node.data !== 'object' || node.data === null) {
                return node.data;
            }

            // TODO: return immutable data without coping
            return JSON.parse(JSON.stringify(node.data));
        };

        this.getProperty = function (node, name) {
            ASSERT(typeof name === 'string' && name !== ID_NAME);

            var data;
            node = self.normalize(node);

            if (typeof node.data === 'object' && node.data !== null) {
                data = node.data[name];
            }

            // TODO: corerel uses getProperty to get the overlay content which can get mutable
            // ASSERT(!__isMutableData(data));
            return data;
        };

        this.setProperty = function (node, name, data) {
            ASSERT(typeof name === 'string' && name !== ID_NAME);
            ASSERT(!__isMutableData(data) /*&& data !== null*/ && data !== undefined);
            //TODO is the 'null' really can be a value of a property???

            node = self.normalize(node);
            if (!self.mutate(node)) {
                throw new Error('incorrect node data');
            }

            node.data[name] = data;

            var child = __getChildNode(node.children, name);
            if (child !== null) {
                child.data = data;
                __reloadChildrenData(child);
            }
        };

        this.deleteProperty = function (node, name) {
            ASSERT(typeof name === 'string' && name !== ID_NAME);

            node = self.normalize(node);
            if (!self.mutate(node)) {
                throw new Error('incorrect node data');
            }

            delete node.data[name];

            var child = __getChildNode(node.children, name);
            if (child !== null) {
                child.data = __getEmptyData();
                __reloadChildrenData(child);
            }
        };

        this.renameProperty = function (node, oldName, newName) {
            self.setProperty(node, newName, self.getProperty(node, oldName));
            self.deleteProperty(node, oldName);
        };

        this.getKeys = function (node, predicate) {
            var result;
            node = self.normalize(node);

            if (typeof node.data !== 'object' || node.data === null) {
                return null;
            }

            result = self.getRawKeys(node.data, predicate);
            return result;
        };

        this.getRawKeys = function (object, predicate) {
            predicate = predicate || __noUnderscore;

            var keys = Object.keys(object);

            var i = keys.length;
            while (--i >= 0 && !predicate(keys[i])) {
                keys.pop();
            }

            while (--i >= 0) {
                if (!predicate(keys[i])) {
                    keys[i] = keys.pop();
                }
            }

            return keys;
        };

        // ------- persistence

        this.getHash = function (node) {
            if (node === null) {
                return null;
            }

            var hash;
            node = self.normalize(node);
            if (typeof node.data === 'object' && node.data !== null) {
                hash = node.data[ID_NAME];
            }

            ASSERT(typeof hash === 'string' || hash === undefined);
            return hash;
        };

        this.isHashed = function (node) {
            node = self.normalize(node);
            return typeof node.data === 'object' && node.data !== null && typeof node.data[ID_NAME] === 'string';
        };

        this.setHashed = function (node, hashed, noMutate) {
            ASSERT(typeof hashed === 'boolean');

            node = self.normalize(node);
            if (!noMutate) {
                if (!self.mutate(node)) {
                    throw new Error('incorrect node data');
                }
            }

            if (hashed) {
                node.data[ID_NAME] = '';
            } else {
                delete node.data[ID_NAME];
            }

            ASSERT(node.children[ID_NAME] === undefined);
        };

        this.persist = function (node, stackedObjects) {
            var updated = false,
                result;

            stackedObjects = stackedObjects || {};
            node = self.normalize(node);

            //currently there is no reason to call the persist on a non-root object
            node = self.getRoot(node);

            if (!__isMutableData(node.data)) {
                return {rootHash: node.data[ID_NAME], objects: {}};
            }

            updated = __saveData(node.data, node, '', stackedObjects);
            if (updated !== __getEmptyData()) {
                result = {};
                result.objects = stackedObjects;
                result.rootHash = node.data[ID_NAME];
            } else {
                result = {rootHash: node.data[ID_NAME], objects: {}};
            }

            return result;
        };

        this.loadRoot = function (hash) {
            ASSERT(REGEXP.DB_HASH.test(hash));
            return TASYNC.call(__loadRoot2, self.loadObject(hash));
        };

        this.loadChild = function (node, relid) {
            ASSERT(self.isValidNode(node));

            node = self.getChild(node, relid);

            if (typeof node.data === 'object') {
                return node.data !== null ? node : null;
            } else if (REGEXP.DB_HASH.test(node.data)) {
                // TODO: this is a hack, we should avoid loading it multiple
                // times
                return TASYNC.call(__loadChild2, node, self.loadObject(node.data));
            } else {
                return null;
            }
        };

        this.getChildHash = function (node, relid) {
            ASSERT(self.isValidNode(node));

            node = self.getChild(node, relid);

            if (typeof node.data === 'object') {
                return node.data !== null ? self.getHash(node) : null;
            } else if (REGEXP.DB_HASH.test(node.data)) {
                // TODO: this is a hack, we should avoid loading it multiple
                // times
                return node.data;
            } else {
                return null;
            }
        };

        this.loadByPath = function (node, path) {
            ASSERT(self.isValidNode(node));
            ASSERT(path === '' || path.charAt(0) === CONSTANTS.PATH_SEP);

            path = path.split(CONSTANTS.PATH_SEP);
            return __loadDescendantByPath2(node, path, 1);
        };

        // ------- valid -------
        this.isValidNode = function (node) {
            try {
                isValidNodeThrow(node);
                return true;
            } catch (error) {
                logger.error(error.message, {stack: error.stack, node: node});
                return false;
            }
        };

        this.removeChildFromCache = function (node, relid) {
            delete node.children[relid];

            return node;
        };
    }

    return CoreTree;
});

/*globals define*/
/*eslint-env node, browser*/
/*eslint  no-console: 0*/

/**
 * @author mmaroti / https://github.com/mmaroti
 */

define('common/core/metacore',[
    'common/core/CoreAssert',
    'common/core/tasync',
    'common/util/canon',
    'common/core/constants'
], function (ASSERT, TASYNC, CANON, CONSTANTS) {
    'use strict';

    var MetaCore = function (innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized MetaCore');

        //<editor-fold=Helper Functions>
        function getMetaNode(node) {
            return self.getChild(node, CONSTANTS.META_NODE);
        }

        function getMetaChildrenNode(node) {
            return self.getChild(getMetaNode(node), CONSTANTS.META_CHILDREN);
        }

        function getMetaPointerNode(node, name) {
            var meta = getMetaNode(node),
                pointerNames = self.getPointerNames(meta) || [];
            if (pointerNames.indexOf(name) !== -1) {
                return self.getChild(meta, CONSTANTS.META_POINTER_PREFIX + name);
            }
            return null;
        }

        function metaPointerNode(node, name) {
            //this function always gives back a node, use this if you just want to create the node as well
            self.setPointer(getMetaNode(node), name, null);
            return self.getChild(getMetaNode(node), CONSTANTS.META_POINTER_PREFIX + name);
        }

        function getMetaAspectsNode(node) {
            return self.getChild(getMetaNode(node), CONSTANTS.META_ASPECTS);
        }

        function getMetaAspectNode(node, name) {
            var aspectNode = getMetaAspectsNode(node),
                names = self.getPointerNames(aspectNode) || [];
            if (names.indexOf(name) !== -1) {
                return self.getChild(aspectNode, CONSTANTS.META_ASPECT_PREFIX + name);
            }
            return null;
        }

        function metaAspectNode(node, name) {
            //this function always gives back a node, use this if you just want to create the node as well
            var aspectNode = self.getChild(getMetaNode(node), CONSTANTS.META_ASPECTS);

            self.setPointer(aspectNode, name, null);
            return self.getChild(aspectNode, CONSTANTS.META_ASPECT_PREFIX + name);
        }

        //type related extra query functions
        function isOnMetaSheet(node) {
            //MetaAspectSet
            var sets = self.isMemberOf(node);

            if (sets && sets[''] && sets[''].indexOf(CONSTANTS.META_SET_NAME) !== -1) {
                return true;
            }
            return false;
        }

        function isMetaNode(node) {
            var metaNodes = innerCore.getRoot(node).metaNodes;

            if (metaNodes) {
                return metaNodes.hasOwnProperty(innerCore.getPath(node));
            } else {
                // The meta-cache layer is not used - fallback to check if it's a member of the MetaAspectSet.
                return isOnMetaSheet(node);
            }
        }

        function getRelationDefinitionInfo(node, name, target) {
            var targetPath,
                result = {},
                definedTarget,
                validTargets;

            while (node) {
                if (self.isValidTargetOf(target, node, name)) {
                    result.ownerNode = node;
                    result.ownerPath = self.getPath(node);
                    validTargets = self.getOwnValidTargetPaths(node, name);
                    definedTarget = target;
                    while (definedTarget) {
                        targetPath = self.getPath(definedTarget);
                        if (validTargets.indexOf(targetPath) !== -1) {
                            result.targetPath = targetPath;
                            result.targetNode = definedTarget;
                            return result;
                        }
                        definedTarget = self.getBase(definedTarget);
                    }
                }
                node = self.getBase(node);
            }

            return null;
        }

        //</editor-fold>

        //<editor-fold=Added Methods>
        this.isTypeOf = function (node, typeNodeOrNode) {
            return innerCore.isInstanceOf(node, typeNodeOrNode);
        };

        this.isValidChildOf = function (node, parentNode) {
            var validChildTypePaths = self.getMemberPaths(getMetaChildrenNode(parentNode), CONSTANTS.SET_ITEMS) || [];
            while (node) {
                if (validChildTypePaths.indexOf(self.getPath(node)) !== -1) {
                    return true;
                }
                node = self.getBase(node);
            }
            return false;
        };

        this.getValidPointerNames = function (node) {
            var metaDefNode = getMetaNode(node),
                validNames = self.getPointerNames(metaDefNode) || [],
                i,
                validPointerNames = [],
                metaPointerNode, max;

            for (i = 0; i < validNames.length; i++) {
                metaPointerNode = self.getChild(metaDefNode, CONSTANTS.META_POINTER_PREFIX + validNames[i]);
                max = self.getAttribute(metaPointerNode, CONSTANTS.SET_ITEMS_MAX);
                if (max === 1) {
                    //TODO Specify what makes something a pointer and what a set???
                    //TODO Can you extend a pointer to a set????
                    validPointerNames.push(validNames[i]);
                }
            }

            return validPointerNames;
        };

        this.getOwnValidPointerNames = function (node) {
            var metaDefNode = getMetaNode(node),
                validNames = self.getOwnPointerNames(metaDefNode) || [],
                i,
                validPointerNames = [],
                metaPointerNode, max;

            for (i = 0; i < validNames.length; i++) {
                metaPointerNode = self.getChild(metaDefNode, CONSTANTS.META_POINTER_PREFIX + validNames[i]);
                max = self.getOwnAttribute(metaPointerNode, CONSTANTS.SET_ITEMS_MAX);
                if (max === 1) {
                    //TODO Specify what makes something a pointer and what a set???
                    //TODO Can you extend a pointer to a set????
                    validPointerNames.push(validNames[i]);
                }
            }

            return validPointerNames;
        };

        this.getValidSetNames = function (node) {
            var metaDefNode = getMetaNode(node),
                validNames = self.getPointerNames(metaDefNode) || [],
                i,
                validSetNames = [],
                metaPointerNode, max;

            for (i = 0; i < validNames.length; i++) {
                metaPointerNode = self.getChild(metaDefNode, CONSTANTS.META_POINTER_PREFIX + validNames[i]);
                max = self.getAttribute(metaPointerNode, CONSTANTS.SET_ITEMS_MAX);

                // FIXME: max seems to always be undefined - there is no such attribute on the set definitions
                if (max === undefined || max === -1 || max > 1) {
                    //TODO specify what makes something a pointer and what a set???
                    //TODO can you extend a pointer to a set????
                    validSetNames.push(validNames[i]);
                }
            }

            return validSetNames;
        };

        this.getOwnValidSetNames = function (node) {
            var metaDefNode = getMetaNode(node),
                validNames = self.getOwnPointerNames(metaDefNode) || [],
                i,
                validSetNames = [],
                metaPointerNode, max;

            for (i = 0; i < validNames.length; i++) {
                metaPointerNode = self.getChild(metaDefNode, CONSTANTS.META_POINTER_PREFIX + validNames[i]);
                max = self.getOwnAttribute(metaPointerNode, CONSTANTS.SET_ITEMS_MAX);

                // FIXME: max seems to always be undefined - there is no such attribute on the set definitions
                if (max === undefined || max === -1 || max > 1) {
                    //TODO specify what makes something a pointer and what a set???
                    //TODO can you extend a pointer to a set????
                    validSetNames.push(validNames[i]);
                }
            }

            return validSetNames;
        };

        this.isValidTargetOf = function (node, source, name) {
            var pointerMetaNode = getMetaPointerNode(source, name);

            if (pointerMetaNode) {
                var validTargetTypePaths = self.getMemberPaths(pointerMetaNode, CONSTANTS.SET_ITEMS) || [];
                while (node) {
                    if (validTargetTypePaths.indexOf(self.getPath(node)) !== -1) {
                        return true;
                    }
                    node = self.getBase(node);
                }
            }
            return false;
        };

        this.getValidAttributeNames = function (node) {
            return self.getAttributeNames(getMetaNode(node)) || [];
        };

        this.getOwnValidAttributeNames = function (node) {
            return self.getOwnAttributeNames(getMetaNode(node)) || [];
        };

        this.isValidAttributeValueOf = function (node, name, value) {
            var typedValue;

            if (self.getValidAttributeNames(node).indexOf(name) === -1) {
                return false;
            }
            var meta = self.getAttribute(getMetaNode(node), name);

            if (meta.enum && meta.enum instanceof Array) {
                return meta.enum.indexOf(value) !== -1; //TODO should we check type beforehand?
            }

            switch (meta.type) {
                case CONSTANTS.ATTRIBUTE_TYPES.BOOLEAN:
                    if (value === true || value === false) {
                        return true;
                    }
                    break;
                case CONSTANTS.ATTRIBUTE_TYPES.STRING:
                    if (typeof value === 'string') {
                        if (meta.regexp) {
                            return (new RegExp(meta.regexp).test(value));
                        }
                        return true;
                    }
                    break;
                case CONSTANTS.ATTRIBUTE_TYPES.ASSET:
                    if (typeof value === 'string') {
                        return true;
                    }
                    break;
                case CONSTANTS.ATTRIBUTE_TYPES.INTEGER:
                    typedValue = parseInt(value);
                    if (!isNaN(typedValue) && parseFloat(value) === typedValue) {
                        if ((typeof meta.min !== 'number' || typedValue >= meta.min) &&
                            (typeof meta.max !== 'number' || typedValue <= meta.max)) {
                            return true;
                        }
                        return false;
                    }
                    break;
                case CONSTANTS.ATTRIBUTE_TYPES.FLOAT:
                    typedValue = parseFloat(value);
                    if (!isNaN(typedValue)) {
                        if ((typeof meta.min !== 'number' || typedValue >= meta.min) &&
                            (typeof meta.max !== 'number' || typedValue <= meta.max)) {
                            return true;
                        }
                        return false;
                    }
                    break;
                default:
                    break;
            }

            return false;
        };

        this.getValidAspectNames = function (node) {
            return self.getPointerNames(getMetaAspectsNode(node)) || [];
        };

        this.getOwnValidAspectNames = function (node) {
            return self.getOwnPointerNames(getMetaAspectsNode(node)) || [];
        };

        this.getAspectMeta = function (node, name) {
            return self.getMemberPaths(getMetaAspectNode(node, name), CONSTANTS.SET_ITEMS);
        };

        //additional meta functions for getting meta definitions
        this.getJsonMeta = function (node) {
            var meta = {children: {}, attributes: {}, pointers: {}, aspects: {}, constraints: {}},
                tempNode,
                names,
                pointer,
                i, j;

            //fill children part
            tempNode = getMetaChildrenNode(node);

            meta.children.minItems = [];
            meta.children.maxItems = [];
            meta.children.items = self.getMemberPaths(tempNode, CONSTANTS.SET_ITEMS);
            for (i = 0; i < meta.children.items.length; i++) {
                meta.children.minItems.push(
                    self.getMemberAttribute(tempNode, CONSTANTS.SET_ITEMS, meta.children.items[i],
                        CONSTANTS.SET_ITEMS_MIN) || -1);

                meta.children.maxItems.push(
                    self.getMemberAttribute(tempNode, CONSTANTS.SET_ITEMS, meta.children.items[i],
                        CONSTANTS.SET_ITEMS_MAX) || -1);
            }
            meta.children.min = self.getAttribute(tempNode, CONSTANTS.SET_ITEMS_MIN);
            meta.children.max = self.getAttribute(tempNode, CONSTANTS.SET_ITEMS_MAX);

            //attributes
            names = self.getValidAttributeNames(node);
            for (i = 0; i < names.length; i++) {
                meta.attributes[names[i]] = self.copyIfObject(self.getAttribute(getMetaNode(node), names[i]));
            }

            //pointers
            names = self.getPointerNames(getMetaNode(node));
            for (i = 0; i < names.length; i++) {
                tempNode = getMetaPointerNode(node, names[i]);
                pointer = {};

                pointer.items = self.getMemberPaths(tempNode, CONSTANTS.SET_ITEMS);
                pointer.min = self.getAttribute(tempNode, CONSTANTS.SET_ITEMS_MIN);
                pointer.max = self.getAttribute(tempNode, CONSTANTS.SET_ITEMS_MAX);
                pointer.minItems = [];
                pointer.maxItems = [];

                for (j = 0; j < pointer.items.length; j++) {
                    pointer.minItems.push(self.getMemberAttribute(tempNode, CONSTANTS.SET_ITEMS, pointer.items[j],
                        CONSTANTS.SET_ITEMS_MIN) || -1);
                    pointer.maxItems.push(self.getMemberAttribute(tempNode, CONSTANTS.SET_ITEMS, pointer.items[j],
                        CONSTANTS.SET_ITEMS_MAX) || -1);

                }

                meta.pointers[names[i]] = pointer;
            }

            //aspects
            names = self.getValidAspectNames(node);

            for (i = 0; i < names.length; i++) {
                tempNode = getMetaAspectNode(node, names[i]);
                meta.aspects[names[i]] = self.getMemberPaths(tempNode, CONSTANTS.SET_ITEMS) || [];
            }

            //constraints
            names = self.getConstraintNames(node);
            for (i = 0; i < names.length; i++) {
                meta.constraints[names[i]] = self.getConstraint(node, names[i]);
            }

            return meta;
        };

        this.getOwnJsonMeta = function (node) {
            var meta = {children: {}, attributes: {}, pointers: {}, aspects: {}, constraints: {}},
                tempNode,
                metaNode = getMetaNode(node),
                childrenNode = self.getChild(metaNode, CONSTANTS.META_CHILDREN),
                aspectsNode = self.getChild(metaNode, CONSTANTS.META_ASPECTS),
                names,
                pointer,
                i, j;

            //fill children part

            meta.children.minItems = [];
            meta.children.maxItems = [];
            meta.children.items = self.getOwnMemberPaths(childrenNode, CONSTANTS.SET_ITEMS);
            if (meta.children.items.length > 0) {
                for (i = 0; i < meta.children.items.length; i++) {
                    meta.children.minItems.push(
                        self.getMemberAttribute(childrenNode, CONSTANTS.SET_ITEMS, meta.children.items[i],
                            CONSTANTS.SET_ITEMS_MIN) || -1);

                    meta.children.maxItems.push(
                        self.getMemberAttribute(childrenNode, CONSTANTS.SET_ITEMS, meta.children.items[i],
                            CONSTANTS.SET_ITEMS_MAX) || -1);
                }
                names = self.getOwnAttributeNames(childrenNode);
                if (names.indexOf('min') !== -1) {
                    meta.children.min = self.getAttribute(childrenNode, CONSTANTS.SET_ITEMS_MIN);
                }
                if (names.indexOf('max') !== -1) {
                    meta.children.max = self.getAttribute(childrenNode, CONSTANTS.SET_ITEMS_MAX);
                }
            } else {
                delete meta.children;
            }
            //attributes
            names = self.getOwnAttributeNames(metaNode) || [];
            if (names.length > 0) {
                for (i = 0; i < names.length; i++) {
                    meta.attributes[names[i]] = self.copyIfObject(self.getOwnAttribute(metaNode, names[i]));
                }
            } else {
                delete meta.attributes;
            }

            //pointers
            names = self.getOwnPointerNames(metaNode);
            if (names.length > 0) {
                for (i = 0; i < names.length; i++) {
                    tempNode = self.getChild(metaNode, CONSTANTS.META_POINTER_PREFIX + names[i]);
                    pointer = {};

                    pointer.items = self.getOwnMemberPaths(tempNode, CONSTANTS.SET_ITEMS);
                    pointer.min = self.getOwnAttribute(tempNode, CONSTANTS.SET_ITEMS_MIN);
                    pointer.max = self.getOwnAttribute(tempNode, CONSTANTS.SET_ITEMS_MAX);
                    pointer.minItems = [];
                    pointer.maxItems = [];

                    for (j = 0; j < pointer.items.length; j++) {
                        pointer.minItems.push(self.getMemberAttribute(tempNode, CONSTANTS.SET_ITEMS, pointer.items[j],
                            CONSTANTS.SET_ITEMS_MIN) || -1);
                        pointer.maxItems.push(self.getMemberAttribute(tempNode, CONSTANTS.SET_ITEMS, pointer.items[j],
                            CONSTANTS.SET_ITEMS_MAX) || -1);

                    }

                    meta.pointers[names[i]] = pointer;
                }
            } else {
                delete meta.pointers;
            }

            //aspects
            names = self.getOwnPointerNames(aspectsNode) || [];

            if (names.length > 0) {
                for (i = 0; i < names.length; i++) {
                    tempNode = self.getChild(aspectsNode, CONSTANTS.META_ASPECT_PREFIX + names[i]);
                    meta.aspects[names[i]] = self.getOwnMemberPaths(tempNode, CONSTANTS.SET_ITEMS) || [];
                }
            } else {
                delete meta.aspects;
            }

            //constraints
            names = self.getOwnConstraintNames(node);

            if (names.length > 0) {
                for (i = 0; i < names.length; i++) {
                    meta.constraints[names[i]] = self.getConstraint(node, names[i]);
                }
            } else {
                delete meta.constraints;
            }

            return meta;
        };

        this.clearMetaRules = function (node) {
            self.deleteNode(getMetaNode(node), true);
        };

        this.setAttributeMeta = function (node, name, value) {
            var defaultValue;

            if (value.hasOwnProperty('default')) {
                defaultValue = value.default;
                value = JSON.parse(JSON.stringify(value));
                delete value.default;
            }

            self.setAttribute(getMetaNode(node), name, value);

            if (typeof defaultValue !== 'undefined') {
                self.setAttribute(node, name, defaultValue);
            }
        };

        this.renameAttributeMeta = function (node, oldName, newName) {
            self.setAttributeMeta(node, newName, self.getAttributeMeta(node, oldName));
            self.delAttributeMeta(node, oldName);
            if (self.getOwnAttributeNames(node).indexOf(oldName) !== -1) {
                self.renameAttribute(node, oldName, newName);
            }
        };

        this.delAttributeMeta = function (node, name) {
            self.delAttribute(getMetaNode(node), name);
        };

        this.getAttributeMeta = function (node, name) {
            return self.getAttribute(getMetaNode(node), name);
        };

        this.getValidChildrenPaths = function (node) {
            return self.getMemberPaths(getMetaChildrenNode(node), CONSTANTS.SET_ITEMS);
        };

        this.getOwnValidChildrenPaths = function (node) {
            return self.getOwnMemberPaths(getMetaChildrenNode(node), CONSTANTS.SET_ITEMS);
        };

        this.getChildrenMeta = function (node) {
            var cMetaNode = getMetaChildrenNode(node),
                childrenMeta = {
                    min: self.getAttribute(cMetaNode, CONSTANTS.SET_ITEMS_MIN),
                    max: self.getAttribute(cMetaNode, CONSTANTS.SET_ITEMS_MAX)
                },
                paths = self.getMemberPaths(cMetaNode, CONSTANTS.SET_ITEMS),
                i;

            for (i = 0; i < paths.length; i += 1) {
                childrenMeta[paths[i]] = {
                    min: self.getMemberAttribute(cMetaNode, CONSTANTS.SET_ITEMS, paths[i], CONSTANTS.SET_ITEMS_MIN),
                    max: self.getMemberAttribute(cMetaNode, CONSTANTS.SET_ITEMS, paths[i], CONSTANTS.SET_ITEMS_MAX)
                };
            }

            if (paths.length > 0) {
                return childrenMeta;
            }

            return null;
        };

        this.setChildMeta = function (node, child, min, max) {
            self.addMember(getMetaChildrenNode(node), CONSTANTS.SET_ITEMS, child);
            min = min || -1;
            max = max || -1;
            self.setMemberAttribute(getMetaChildrenNode(node), CONSTANTS.SET_ITEMS, self.getPath(child),
                CONSTANTS.SET_ITEMS_MIN, min);
            self.setMemberAttribute(getMetaChildrenNode(node), CONSTANTS.SET_ITEMS, self.getPath(child),
                CONSTANTS.SET_ITEMS_MAX, max);
        };

        this.delChildMeta = function (node, childPath) {
            self.delMember(getMetaChildrenNode(node), CONSTANTS.SET_ITEMS, childPath);
        };

        this.setChildrenMetaLimits = function (node, min, max) {
            if (min) {
                self.setAttribute(getMetaChildrenNode(node), CONSTANTS.SET_ITEMS_MIN, min);
            }
            if (max) {
                self.setAttribute(getMetaChildrenNode(node), CONSTANTS.SET_ITEMS_MAX, max);
            }
        };

        this.setPointerMetaTarget = function (node, name, target, min, max) {
            self.addMember(metaPointerNode(node, name), CONSTANTS.SET_ITEMS, target);
            min = min === 0 ? 0 : (min || -1);
            self.setMemberAttribute(metaPointerNode(node, name), CONSTANTS.SET_ITEMS, self.getPath(target),
                CONSTANTS.SET_ITEMS_MIN, min);
            max = max === 0 ? 0 : (max || -1);
            self.setMemberAttribute(metaPointerNode(node, name), CONSTANTS.SET_ITEMS, self.getPath(target),
                CONSTANTS.SET_ITEMS_MAX, max);
        };

        this.movePointerMetaTarget = function (node, target, oldName, newName) {
            var targetPath = self.getPath(target),
                min, max;

            if (self.getOwnValidTargetPaths(node, newName).length === 0) {
                // The move introduces the newName relation
                min = self.getAttribute(metaPointerNode(node, oldName), CONSTANTS.SET_ITEMS_MIN);
                max = self.getAttribute(metaPointerNode(node, oldName), CONSTANTS.SET_ITEMS_MAX);
                self.setPointerMetaLimits(node, newName, min, max);
            }

            min = self.getMemberAttribute(metaPointerNode(node, oldName),
                CONSTANTS.SET_ITEMS, targetPath, CONSTANTS.SET_ITEMS_MIN);
            max = self.getMemberAttribute(metaPointerNode(node, oldName),
                CONSTANTS.SET_ITEMS, targetPath, CONSTANTS.SET_ITEMS_MAX);
            self.setPointerMetaTarget(node, newName, target, min, max);
            self.delPointerMetaTarget(node, oldName, targetPath);

            if (self.getOwnValidTargetPaths(node, oldName).length === 0) {
                self.delPointerMeta(node, oldName);
            }
        };

        this.delPointerMetaTarget = function (node, name, targetPath) {
            var metaNode = getMetaPointerNode(node, name);
            if (metaNode) {
                self.delMember(metaNode, CONSTANTS.SET_ITEMS, targetPath);
            }
        };

        this.setPointerMetaLimits = function (node, name, min, max) {
            if (min || min === 0) {
                self.setAttribute(metaPointerNode(node, name), CONSTANTS.SET_ITEMS_MIN, min);
            }
            if (max || max === 0) {
                self.setAttribute(metaPointerNode(node, name), CONSTANTS.SET_ITEMS_MAX, max);
            }
        };

        this.delPointerMeta = function (node, name) {
            self.deleteNode(metaPointerNode(node, name), true);
            self.deletePointer(getMetaNode(node), name);
        };

        this.getPointerMeta = function (node, name) {
            var pointerMeta = {},
                members,
                member,
                i,
                pointerMetaNode = getMetaPointerNode(node, name);

            if (pointerMetaNode === null) {
                return null;
            }

            //min
            pointerMeta.min = self.getAttribute(pointerMetaNode, CONSTANTS.SET_ITEMS_MIN);
            if (pointerMeta.min === undefined) {
                pointerMeta.min = -1;
            }

            //max
            pointerMeta.max = self.getAttribute(pointerMetaNode, CONSTANTS.SET_ITEMS_MAX);
            if (pointerMeta.max === undefined) {
                pointerMeta.max = -1;
            }

            members = self.getMemberPaths(pointerMetaNode, CONSTANTS.SET_ITEMS);
            for (i = 0; i < members.length; i++) {
                member = {
                    min: self.getMemberAttribute(pointerMetaNode, CONSTANTS.SET_ITEMS, members[i],
                        CONSTANTS.SET_ITEMS_MIN),
                    max: self.getMemberAttribute(pointerMetaNode, CONSTANTS.SET_ITEMS, members[i],
                        CONSTANTS.SET_ITEMS_MAX)
                };
                if (member.min === undefined) {
                    member.min = -1;
                }
                if (member.max === undefined) {
                    member.max = -1;
                }

                pointerMeta[members[i]] = member;
            }

            return pointerMeta;
        };

        this.getValidTargetPaths = function (node, name) {
            var pointerNode = getMetaPointerNode(node, name);
            if (pointerNode === null) {
                return [];
            }
            return self.getMemberPaths(pointerNode, CONSTANTS.SET_ITEMS);
        };

        this.getOwnValidTargetPaths = function (node, name) {
            var pointerNode = getMetaPointerNode(node, name);
            if (pointerNode === null) {
                return [];
            }
            return self.getOwnMemberPaths(pointerNode, CONSTANTS.SET_ITEMS);
        };

        this.setAspectMetaTarget = function (node, name, target) {
            self.addMember(metaAspectNode(node, name), CONSTANTS.SET_ITEMS, target);
        };

        this.moveAspectMetaTarget = function (node, target, oldName, newName) {
            self.delAspectMetaTarget(node, oldName, self.getPath(target));
            self.setAspectMetaTarget(node, newName, target);
        };

        this.delAspectMetaTarget = function (node, name, targetPath) {
            var metaNode = getMetaAspectNode(node, name);
            if (metaNode) {
                self.delMember(metaNode, CONSTANTS.SET_ITEMS, targetPath);

                if (self.getOwnMemberPaths(metaNode, CONSTANTS.SET_ITEMS).length === 0) {
                    self.delAspectMeta(node, name);
                }
            }
        };

        this.delAspectMeta = function (node, name) {
            self.deleteNode(metaAspectNode(node, name), true);
            self.deletePointer(getMetaAspectsNode(node), name);
        };

        this.getValidAspectTargetPaths = function (node, name) {
            var aspectNode = getMetaAspectNode(node, name);
            if (aspectNode === null) {
                return [];
            }
            return self.getMemberPaths(aspectNode, CONSTANTS.SET_ITEMS);
        };

        this.getOwnValidAspectTargetPaths = function (node, name) {
            var aspectNode = getMetaAspectNode(node, name);
            if (aspectNode === null) {
                return [];
            }
            return self.getOwnMemberPaths(aspectNode, CONSTANTS.SET_ITEMS);
        };

        this.isValidAspectMemberOf = function (node, parent, name) {
            var validPaths = self.getValidAspectTargetPaths(parent, name);

            if (self.getValidAspectNames(parent).indexOf(name) === -1) {
                return false;
            }

            while (node) {
                if (validPaths.indexOf(self.getPath(node)) !== -1) {
                    return true;
                }
            }

            return false;
        };

        this.getBaseType = function (node) {
            //TODO this functions now uses the fact that we think of META as the MetaSetContainer of the ROOT
            while (node) {
                if (isMetaNode(node)) {
                    return node;
                }
                node = self.getBase(node);
            }
            return null;
        };

        this.isInstanceOfDeprecated = function (node, name) {
            console.warn('Passing a name to isInstanceOf of is deprecated and will eventually be removed!');
            node = self.getBase(node);
            while (node) {
                if (self.getAttribute(node, 'name') === name) {
                    return true;
                }
                node = self.getBase(node);
            }

            return false;
        };

        this.getAttributeDefinitionOwner = function (node, name) {
            while (node) {
                if (self.getOwnValidAttributeNames(node).indexOf(name) !== -1) {
                    return node;
                }
                node = self.getBase(node);
            }

            return null;
        };

        this.getPointerDefinitionInfo = function (node, name, target) {
            return getRelationDefinitionInfo(node, name, target);
        };

        this.getSetDefinitionInfo = function (node, name, target) {
            return getRelationDefinitionInfo(node, name, target);
        };

        this.getAspectDefinitionInfo = function (node, name, target) {
            var result = {},
                validTargets,
                definedTarget,
                targetPath;

            while (node) {
                if (self.getOwnValidAspectNames(node).indexOf(name) !== -1) {
                    result.ownerPath = self.getPath(node);
                    result.ownerNode = node;
                    validTargets = self.getOwnValidAspectTargetPaths(node, name);
                    definedTarget = target;
                    while (definedTarget) {
                        targetPath = self.getPath(definedTarget);
                        if (validTargets.indexOf(targetPath) !== -1) {
                            result.targetPath = targetPath;
                            result.targetNode = definedTarget;
                            return result;
                        }
                        definedTarget = self.getBase(definedTarget);
                    }
                }
                node = self.getBase(node);
            }
            return null;
        };

        this.getAspectDefinitionOwner = function (node, name) {

            while (node) {
                if (self.getOwnValidAspectNames(node).indexOf(name) !== -1) {
                    break;
                }

                node = self.getBase(node);
            }

            return node;
        };

        this.getChildDefinitionInfo = function (node, child) {
            var result = {},
                validPaths,
                definedChild,
                childPath;

            while (node) {
                if (self.isValidChildOf(child, node)) {
                    validPaths = self.getOwnValidChildrenPaths(node);
                    result.ownerNode = node;
                    result.ownerPath = self.getPath(node);
                    definedChild = child;
                    while (definedChild) {
                        childPath = self.getPath(definedChild);
                        if (validPaths.indexOf(childPath) !== -1) {
                            result.targetPath = childPath;
                            result.targetNode = definedChild;
                            return result;
                        }
                        definedChild = self.getBase(definedChild);
                    }

                }
                node = self.getBase(node);
            }
            return null;
        };
        //</editor-fold>
    };

    return MetaCore;
});

/*globals define*/
/*eslint-env node, browser*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/coretreeloader',['common/core/CoreAssert', 'common/core/tasync'], function (ASSERT, TASYNC) {
    'use strict';

    var CoreTreeLoader = function (innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized CoreTreeLoader');

        //<editor-fold=Helper Functions>
        function loadSubTree(root, own) {
            var loadSubTrees = function (nodes) {
                    for (var i = 0; i < nodes.length; i++) {
                        nodes[i] = self.loadSubTree(nodes[i], own);
                    }
                    return TASYNC.lift(nodes);

                },
                childLoading = own === true ? self.loadOwnChildren : self.loadChildren;
            return TASYNC.call(function (children) {
                if (children.length < 1) {
                    return [root];
                } else {
                    return TASYNC.call(function (subArrays) {
                        var nodes = [],
                            i;
                        for (i = 0; i < subArrays.length; i++) {
                            nodes = nodes.concat(subArrays[i]);
                        }
                        nodes.unshift(root);
                        return nodes;
                    }, loadSubTrees(children));
                }
            }, childLoading(root));
        }

        //</editor-fold>

        //<editor-fold=Added Methods>
        this.loadTree = function (rootHash) {
            return TASYNC.call(self.loadSubTree, self.loadRoot(rootHash));
        };

        this.loadSubTree = function (root) {
            return loadSubTree(root, false);
        };

        this.loadOwnSubTree = function (root) {
            return loadSubTree(root, true);
        };

        function traverse(root, options, visitFn, callback) {
            ASSERT(self.isValidNode(root) && typeof visitFn === 'function' && typeof callback === 'function');

            var loadQueue = [],
                ongoingVisits = 0,
                error = null,
                projectRoot = self.getRoot(root),
                timerId,
                addToQueue,
                loadByPath = TASYNC.unwrap(self.loadByPath),
                extendLoadQueue = function (node) {
                    var keys = self.getChildrenPaths(node),
                        i;

                    if (self.getPath(node) !== self.getPath(root)) {
                        for (i = 0; i < keys.length; i += 1) {
                            addToQueue.call(loadQueue, keys[i]);
                        }
                    }

                },
                visitNext = function (err) {
                    error = error || err;
                    ongoingVisits -= 1;
                    if (error && options.stopOnError) {
                        loadQueue = [];
                    }
                },
                nodeLoaded = function (err, node) {
                    error = error || err;
                    if (!err && node) {
                        extendLoadQueue(node);
                    }

                    if (!node) {
                        visitNext(err);
                    } else {
                        visitFn(node, visitNext);
                    }
                };

            options = options || {};
            options.maxParallelLoad = options.maxParallelLoad || 100; //the amount of nodes we preload
            options.excludeRoot = options.excludeRoot === true || false;
            options.stopOnError = options.stopOnError === false ? false : true;

            if (options.order === 'DFS') {
                addToQueue = loadQueue.unshift;
            } else {
                addToQueue = loadQueue.push;
            }

            if (options.maxParallelLoad < 1 || options.order === 'DFS') {
                options.maxParallelLoad = 1;
            }

            loadQueue = self.getChildrenPaths(root);

            if (options.excludeRoot === false) {
                loadQueue.unshift(self.getPath(root));
            }

            timerId = setInterval(function () {
                if (loadQueue.length === 0 && ongoingVisits === 0) {
                    clearInterval(timerId);
                    callback(error);
                } else if (loadQueue.length > 0 && ongoingVisits < options.maxParallelLoad &&
                    (!error || options.stopOnError === false)) {
                    ongoingVisits += 1;
                    loadByPath(projectRoot, loadQueue.shift(), nodeLoaded);
                }
            }, 0);

        }

        this.traverse = TASYNC.wrap(traverse);
        //</editor-fold>
    };

    return CoreTreeLoader;
});

/*globals define*/
/*eslint-env node, browser*/

/**
 * @author kecso / https://github.com/kecso
 */
define('common/util/diff',['common/core/CoreAssert', 'common/core/constants'], function (ASSERT, CONSTANTS) {
    'use strict';

    var FORBIDDEN_WORDS = {
        guid: true,
        hash: true,
        attr: true,
        reg: true,
        pointer: true,
        set: true,
        meta: true,
        removed: true,
        movedFrom: true,
        childrenListChanged: true,
        oGuids: true,
        ooGuids: true,
        oBaseGuids: true,
        ooBaseGuids: true,
        min: true,
        max: true,
        collidingRelid: true
    };

    /**
     *
     * @param {string} path - arbitrary string where the legs of the path are separated with '/' character.
     * @return {object} The function returns an object with processed information about the path.
     *
     * @example
     * {
     *  full: "/a/b/set/mySet//a/c//reg/position",
     *  node: "/a/b",
     *  embededdNode: "/a/c",
     *  pathArray:["a","b","set","mySet","/a/c","reg","position"]
     *  }
     *
     */
    function pathToObject(path) {
        var object = {
                full: path,
                node: null,
                embeddedNode: null,
                pathArray: []
            },
            firstRun = path.split(CONSTANTS.PATH_SEP + CONSTANTS.PATH_SEP),
            i;

        ASSERT(firstRun.length >= 1 && firstRun.length <= 3);

        if (firstRun.length === 3) {
            object.embeddedNode = firstRun[1].length === 0 ? '' : CONSTANTS.PATH_SEP + firstRun[1];
            object.pathArray = firstRun[2].split(CONSTANTS.PATH_SEP);
            object.pathArray.unshift(object.embeddedNode);
            object.pathArray = firstRun[0].split(CONSTANTS.PATH_SEP).concat(object.pathArray);
        } else if (firstRun.length === 2) {
            object.embeddedNode = firstRun[1].length === 0 ? '' : CONSTANTS.PATH_SEP + firstRun[1];
            object.pathArray = firstRun[0].split(CONSTANTS.PATH_SEP);
            object.pathArray.push(object.embeddedNode);
        } else {
            object.pathArray = path.split(CONSTANTS.PATH_SEP);
        }
        object.pathArray.shift();

        object.node = '';
        for (i = 0; i < object.pathArray.length; i += 1) {
            if (FORBIDDEN_WORDS[object.pathArray[i]] !== true && object.pathArray[i].length > 0) {
                object.node += CONSTANTS.PATH_SEP + object.pathArray[i];
            } else {
                break;
            }
        }

        return object;
    }

    function getSetValueFromNode(core, node, memberPath, pathArray) {
        var setName = pathArray[0];

        if (typeof memberPath === 'string') {
            switch (pathArray[2]) {
                case 'attr':
                    return core.getMemberOwnAttribute(node, setName, memberPath, pathArray[3]);
                case 'reg':
                    return core.getMemberOwnRegistry(node, setName, memberPath, pathArray[3]);
            }
        } else {
            switch (pathArray[1]) {
                case 'attr':
                    return core.getOwnSetAttribute(node, setName, pathArray[2]);
                case 'reg':
                    return core.getOwnSetRegistry(node, setName, pathArray[2]);
            }
        }

        return undefined;
    }

    function getObjectValue(object, pathArray) {
        var value = object;
        while (value !== null && value !== undefined && pathArray.length > 0) {
            value = value[pathArray.shift()];
        }

        return value;
    }

    function getMetaValueFromNode(core, node, embeddedPath, pathArray) {
        switch (pathArray[0]) {
            case 'children':
                return getObjectValue(core.getChildrenMeta(node), pathArray.slice(1));
            case 'pointers':
                return getObjectValue(core.getPointerMeta(node, pathArray[1]), pathArray.slice(2));
            case 'attributes':
                return getObjectValue(core.getAttributeMeta(node, pathArray[1]), pathArray.slice(2));
            case 'aspects':
                // aspect changes cannot generate conflicts
                break;
            case 'constraints':
                return getObjectValue((core.getConstraint(node, pathArray[1])), pathArray.slice(2));
        }

        return undefined;
    }

    /**
     *
     * @param {object} core - the core object that allows access to the Core API
     * @param (module:Core~Node) node - the node whose value we are interested in
     * @param {string} subNodePath - a string that has the path structure and represents the sub-node location
     * of the value we are interested in.
     * @returns {undefined|*} - if the value is undefined, that means there is no such value, otherwise the value will
     * be returned back.
     */
    function getValueFromNode(core, node, subNodePath) {
        var pathObject = pathToObject(subNodePath);

        ASSERT(pathObject.node === '');
        ASSERT(FORBIDDEN_WORDS[pathObject.pathArray[0]] === true);

        switch (pathObject.pathArray[0]) {
            case 'guid':
                return core.getGuid(node);
            case 'attr':
                return core.getOwnAttribute(node, pathObject.pathArray[1]);
            case 'reg':
                return core.getOwnRegistry(node, pathObject.pathArray[1]);
            case 'pointer':
                return core.getOwnPointerPath(node, pathObject.pathArray[1]);
            case 'set':
                return getSetValueFromNode(core, node, pathObject.embeddedNode, pathObject.pathArray.slice(1));
            case 'meta':
                return getMetaValueFromNode(core, node, pathObject.embeddedNode, pathObject.pathArray.slice(1));
            default:
                return undefined;
        }
    }

    /**
     *
     * @param {object} completeDiff - a diff object, that we would like to process and gather information from.
     * @returns {string[]} An array of string of the paths of the affected nodes are returned. No partial update nodes
     * are returned as we cannot gather that intel completely.
     */
    function getChangedNodePaths(completeDiff) {
        var changedNodes = {},
            recGetNodePath = function (path, diff) {
                var key;

                changedNodes[path] = true;

                for (key in diff) {
                    if (FORBIDDEN_WORDS[key] !== true) {
                        recGetNodePath(path + CONSTANTS.PATH_SEP + key, diff[key]);
                    }
                }
            };

        recGetNodePath('', completeDiff);
        return Object.keys(changedNodes);
    }

    return {
        pathToObject: pathToObject,
        getValueFromNode: getValueFromNode,
        getChangedNodePaths: getChangedNodePaths,
        FORBIDDEN_WORDS: FORBIDDEN_WORDS
    };
});
/*globals define*/
/*eslint-env node, browser*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/corediff',[
    'common/util/canon',
    'common/core/tasync',
    'common/core/CoreAssert',
    'common/regexp',
    'common/util/random',
    'common/core/constants',
    'common/util/diff'
], function (CANON, TASYNC, ASSERT, REGEXP, RANDOM, CONSTANTS, DIFF) {
    'use strict';

    function DiffCore(innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key,
            _conflictMine,
            _conflictTheirs,
            _concatBase,
            _concatExtension,
            _concatBaseRemovals,
            _concatMoves;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized DiffCore');

        //<editor-fold=Helper Functions>
        function compareRelids(a, b) {
            var aRel = self.getRelid(a),
                bRel = self.getRelid(b);

            if (aRel < bRel) {
                return -1;
            } else if (aRel > bRel) {
                return 1;
            } else {
                return 0;
            }
        }

        function normalize(obj) {
            // TODO: Does this really need to be called as many times as it is?
            if (!obj) {
                return obj;
            }
            var keys = Object.keys(obj),
                i;

            if (JSON.stringify(obj.set) === JSON.stringify({})) {
                delete obj.set;
            }

            for (i = 0; i < keys.length; i++) {
                /*if (Array.isArray(obj[keys[i]])) {
                 if (obj[keys[i]].length === 0) {
                 delete obj[keys[i]];
                 }*/
                if (Array.isArray(obj[keys[i]])) {
                    //do nothing, leave the array as is
                } else if (obj[keys[i]] === undefined) {
                    delete obj[keys[i]]; //there cannot be undefined in the object
                } else if (keys[i] === 'set') {
                    //do nothing with set as it can include empty set's as well
                } else if (typeof obj[keys[i]] === 'object') {
                    normalize(obj[keys[i]]);
                    if (obj[keys[i]] && Object.keys(obj[keys[i]]).length === 0) {
                        delete obj[keys[i]];
                    }
                }
            }
            keys = JSON.parse(JSON.stringify(obj));
            delete keys.guid;
            delete keys.oGuids;
            delete keys.ooGuids;
            delete keys.oBaseGuids;
            delete keys.ooBaseGuids;
            if (Object.keys(keys).length === 0) {
                // it did not have additional information
                delete obj.guid;
                delete obj.oGuids;
                delete obj.ooGuids;
                delete obj.oBaseGuids;
                delete obj.ooBaseGuids;
            }
        }

        function attrDiff(source, target) {
            var sNames = self.getOwnAttributeNames(source),
                tNames = self.getOwnAttributeNames(target),
                diff = {},
                sAttr,
                tAttr,
                i;

            for (i = 0; i < sNames.length; i++) {
                if (tNames.indexOf(sNames[i]) === -1) {
                    diff[sNames[i]] = CONSTANTS.TO_DELETE_STRING;
                }
            }

            for (i = 0; i < tNames.length; i++) {
                sAttr = self.getOwnAttribute(source, tNames[i]);
                tAttr = self.getOwnAttribute(target, tNames[i]);

                if (CANON.stringify(sAttr) !== CANON.stringify(tAttr)) {
                    diff[tNames[i]] = tAttr;
                }
            }

            return diff;
        }

        function regDiff(source, target) {
            var sNames = self.getOwnRegistryNames(source),
                tNames = self.getOwnRegistryNames(target),
                diff = {},
                sReg,
                tReg,
                i;

            for (i = 0; i < sNames.length; i++) {
                if (tNames.indexOf(sNames[i]) === -1) {
                    diff[sNames[i]] = CONSTANTS.TO_DELETE_STRING;
                }
            }

            for (i = 0; i < tNames.length; i++) {
                sReg = self.getOwnRegistry(source, tNames[i]);
                tReg = self.getOwnRegistry(target, tNames[i]);
                if (CANON.stringify(sReg) !== CANON.stringify(tReg)) {
                    diff[tNames[i]] = tReg;
                }
            }

            return diff;
        }

        function childrenDiff(source, target) {
            var sRelids = self.getChildrenRelids(source, true),
                tRelids = self.getChildrenRelids(target, true),
                tHashes = self.getChildrenHashes(target),
                sHashes = self.getChildrenHashes(source),
                relid,
                diff = {added: [], removed: []};

            for (relid in sRelids) {
                if (tRelids.hasOwnProperty(relid) === false) {
                    diff.removed.push({relid: relid, hash: sHashes[relid]});
                }
            }

            for (relid in tRelids) {
                if (sRelids.hasOwnProperty(relid) === false) {
                    diff.added.push({relid: relid, hash: tHashes[relid]});
                }
            }

            return diff;
        }

        function pointerDiff(source, target) {
            // FIXME: Shouldn't these be ownPointerNames?
            var getPointerData = function (node) {
                    var data = {},
                        names = self.getPointerNames(node),
                        i;
                    for (i = 0; i < names.length; i++) {
                        data[names[i]] = self.getPointerPath(node, names[i]);
                    }
                    return data;
                },
                sPointer = getPointerData(source),
                tPointer = getPointerData(target);

            if (CANON.stringify(sPointer) !== CANON.stringify(tPointer)) {
                return {source: sPointer, target: tPointer};
            }
            return {};
        }

        function setDiff(source, target) {
            var getSetData = function (node) {
                    var data = {},
                        names, targets, keys, i, j, k;

                    names = self.getSetNames(node);
                    for (i = 0; i < names.length; i++) {
                        data[names[i]] = {attr: {}, reg: {}};
                        keys = self.getOwnSetAttributeNames(node, names[i]);
                        for (j = 0; j < keys.length; j += 1) {
                            data[names[i]].attr[keys[j]] = self.getOwnSetAttribute(node, names[i], keys[j]);
                        }
                        keys = self.getOwnSetRegistryNames(node, names[i]);
                        for (j = 0; j < keys.length; j += 1) {
                            data[names[i]].reg[keys[j]] = self.getOwnSetRegistry(node, names[i], keys[j]);
                        }

                        targets = self.getMemberPaths(node, names[i]);
                        for (j = 0; j < targets.length; j++) {
                            data[names[i]][targets[j]] = {attr: {}, reg: {}};
                            keys = self.getMemberOwnAttributeNames(node, names[i], targets[j]);
                            for (k = 0; k < keys.length; k++) {
                                data[names[i]][targets[j]].attr[keys[k]] = self.getMemberAttribute(node,
                                    names[i], targets[j], keys[k]);
                            }
                            keys = self.getMemberRegistryNames(node, names[i], targets[j]);
                            for (k = 0; k < keys.length; k++) {
                                data[names[i]][targets[j]].reg[keys[k]] = self.getMemberRegistry(node,
                                    names[i], targets[j], keys[k]);
                            }
                        }
                    }

                    return data;

                },
                sSet = getSetData(source),
                tSet = getSetData(target);

            if (CANON.stringify(sSet) !== CANON.stringify(tSet)) {
                return {source: sSet, target: tSet};
            }
            return {};
        }

        function ovrDiff(source, target) {
            var sOvr = self.getRawOverlayInformation(source),
                tOvr = self.getRawOverlayInformation(target);

            if (CANON.stringify(sOvr) !== CANON.stringify(tOvr)) {
                return {source: sOvr, target: tOvr};
            }
            return {};
        }

        function metaDiff(source, target) {
            var convertJsonMeta = function (jsonMeta) {
                    var i, j, names, itemsObject;
                    //children
                    if (jsonMeta.children) {
                        itemsObject = jsonMeta.children;
                        for (i = 0; i < itemsObject.items.length; i += 1) {
                            itemsObject[itemsObject.items[i]] = {
                                min: itemsObject.minItems[i],
                                max: itemsObject.maxItems[i]
                            };
                        }
                        delete itemsObject.items;
                        delete itemsObject.minItems;
                        delete itemsObject.maxItems;
                    }
                    //ptr
                    if (jsonMeta.pointers) {
                        names = Object.keys(jsonMeta.pointers);

                        for (j = 0; j < names.length; j += 1) {
                            itemsObject = jsonMeta.pointers[names[j]];
                            for (i = 0; i < itemsObject.items.length; i += 1) {
                                itemsObject[itemsObject.items[i]] = {
                                    min: itemsObject.minItems[i],
                                    max: itemsObject.maxItems[i]
                                };
                            }
                            delete itemsObject.items;
                            delete itemsObject.minItems;
                            delete itemsObject.maxItems;
                        }
                    }
                    return jsonMeta;
                },
                sMeta = convertJsonMeta(self.getOwnJsonMeta(source)),
                tMeta = convertJsonMeta(self.getOwnJsonMeta(target));
            if (CANON.stringify(sMeta) !== CANON.stringify(tMeta)) {
                return {source: sMeta, target: tMeta};
            }
            return {};
        }

        function combineMoveIntoMetaDiff(diff, diffMoves) {
            var keys = Object.keys(diff),
                i;
            for (i = 0; i < keys.length; i++) {
                if (diffMoves[keys[i]]) {
                    diff[diffMoves[keys[i]]] = diff[keys[i]];
                    delete diff[keys[i]];
                } else if (typeof diff[keys[i]] === 'object') {
                    combineMoveIntoMetaDiff(diff[keys[i]], diffMoves);
                }
            }
        }

        function combineMoveIntoPointerDiff(diff, diffMoves) {
            var keys = Object.keys(diff),
                i;
            for (i = 0; i < keys.length; i++) {
                if (diffMoves[diff[keys[i]]]) {
                    diff[keys[i]] = diffMoves[diff[keys[i]]];
                }
            }
        }

        function getDiffChildrenRelids(diff) {
            var keys = Object.keys(diff || {}),
                i,
                filteredKeys = [];

            for (i = 0; i < keys.length; i++) {
                if (DIFF.FORBIDDEN_WORDS[keys[i]] !== true) {
                    filteredKeys.push(keys[i]);
                }
            }
            return filteredKeys;
        }

        function arrayDiff(source, target) {
            var i,
                diff = {};
            for (i = 0; i < source.length; i += 1) {
                if (target.indexOf(source[i]) === -1) {
                    diff[source[i]] = CONSTANTS.TO_DELETE_STRING;
                }
            }

            for (i = 0; i < target.length; i += 1) {
                if (source.indexOf(target[i])) {
                    diff[target[i]] = true;
                }
            }
            return diff;
        }

        function diffObjects(source, target) {
            var diff = {},
                sKeys = Object.keys(source),
                tKeys = Object.keys(target),
                tDiff, i;
            for (i = 0; i < sKeys.length; i++) {
                if (tKeys.indexOf(sKeys[i]) === -1) {
                    diff[sKeys[i]] = CONSTANTS.TO_DELETE_STRING;
                }
            }
            for (i = 0; i < tKeys.length; i++) {
                if (sKeys.indexOf(tKeys[i]) === -1) {
                    diff[tKeys[i]] = target[tKeys[i]];
                } else {
                    if (typeof target[tKeys[i]] === typeof source[tKeys[i]]) {
                        tDiff = {};
                        if (source[tKeys[i]] instanceof Array && target[tKeys[i]] instanceof Array) {
                            tDiff = arrayDiff(source[tKeys[i]], target[tKeys[i]]);
                        } else if (typeof target[tKeys[i]] === 'object' &&
                            target[tKeys[i]] !== null && source[tKeys[i]] !== null) {
                            tDiff = diffObjects(source[tKeys[i]], target[tKeys[i]]);
                        } else if (source[tKeys[i]] !== target[tKeys[i]]) {
                            diff[tKeys[i]] = target[tKeys[i]];
                        }

                        if (Object.keys(tDiff).length > 0) {
                            diff[tKeys[i]] = tDiff;
                        }
                    }
                }
            }
            return diff;
        }

        function finalizeMetaDiff(diff, diffMoves) {
            // At this point diff is ready and the diffMoves are complete.
            var relids = getDiffChildrenRelids(diff),
                i, sMeta, tMeta;
            if (diff.meta) {
                sMeta = diff.meta.source || {};
                tMeta = diff.meta.target || {};
                combineMoveIntoMetaDiff(sMeta, diffMoves);
                diff.meta = diffObjects(sMeta, tMeta);
            }
            for (i = 0; i < relids.length; i++) {
                finalizeMetaDiff(diff[relids[i]], diffMoves);
            }
        }

        function finalizePointerDiff(diff, diffMoves) {
            var relids = getDiffChildrenRelids(diff),
                i, sPointer, tPointer;
            if (diff.pointer) {
                sPointer = diff.pointer.source || {};
                tPointer = diff.pointer.target || {};
                /*if(diff.movedFrom && !sPointer.base && tPointer.base){
                 delete tPointer.base;
                 }*/
                combineMoveIntoPointerDiff(sPointer, diffMoves);
                diff.pointer = diffObjects(sPointer, tPointer);
            }
            for (i = 0; i < relids.length; i++) {
                finalizePointerDiff(diff[relids[i]], diffMoves);
            }
        }

        function finalizeSetDiff(diff, diffMoves) {
            var relids = getDiffChildrenRelids(diff),
                i, sSet, tSet;
            if (diff.set) {
                sSet = diff.set.source || {};
                tSet = diff.set.target || {};
                combineMoveIntoMetaDiff(sSet, diffMoves);
                diff.set = diffObjects(sSet, tSet);
            }
            for (i = 0; i < relids.length; i++) {
                finalizeSetDiff(diff[relids[i]], diffMoves);
            }
        }

        function finalizeDiff(diff, diffMoves) {
            finalizeMetaDiff(diff, diffMoves);
            finalizePointerDiff(diff, diffMoves);
            finalizeSetDiff(diff, diffMoves);
            normalize(diff);
        }

        function isEmptyNodeDiff(diff) {
            // TODO: This could probably be reversed and optimized.
            if (
                Object.keys(diff.children || {}).length > 0 ||
                Object.keys(diff.attr || {}).length > 0 ||
                Object.keys(diff.reg || {}).length > 0 ||
                Object.keys(diff.pointer || {}).length > 0 ||
                Object.keys(diff.set || {}).length > 0 ||
                diff.meta
            ) {
                return false;
            }
            return true;
        }

        function getPathOfDiff(diff, path) {
            var pathArray = path.split('/'),
                i;
            pathArray.shift();
            for (i = 0; i < pathArray.length; i++) {
                diff[pathArray[i]] = diff[pathArray[i]] || {};
                diff = diff[pathArray[i]];
            }

            return diff;
        }

        function extendDiffWithOvr(diff, oDiff) {
            var i, paths, names, j, tDiff,
                onlyBaseRemoved = function (path) {
                    var sCopy = JSON.parse(JSON.stringify(oDiff.source[path] || {})),
                        tCopy = JSON.parse(JSON.stringify(oDiff.target[path] || {}));

                    if (tCopy.base) {
                        return false;
                    }

                    delete sCopy.base;

                    return CANON.stringify(sCopy) === CANON.stringify(tCopy);
                };

            //first extend sources
            paths = Object.keys(oDiff.source || {});
            for (i = 0; i < paths.length; i++) {
                tDiff = getPathOfDiff(diff, paths[i]);
                if (tDiff.removed !== true && !onlyBaseRemoved(paths[i])) {
                    tDiff.pointer = tDiff.pointer || {source: {}, target: {}};
                    tDiff.pointer.source = tDiff.pointer.source || {};
                    tDiff.pointer.target = tDiff.pointer.target || {};
                    names = Object.keys(oDiff.source[paths[i]]);
                    for (j = 0; j < names.length; j++) {
                        tDiff.pointer.source[names[j]] = oDiff.source[paths[i]][names[j]];
                    }
                }
            }
            //then targets
            paths = Object.keys(oDiff.target || {});
            for (i = 0; i < paths.length; i++) {
                tDiff = getPathOfDiff(diff, paths[i]);
                if (tDiff.removed !== true && !onlyBaseRemoved(paths[i])) {
                    tDiff.pointer = tDiff.pointer || {source: {}, target: {}};
                    names = Object.keys(oDiff.target[paths[i]]);
                    for (j = 0; j < names.length; j++) {
                        tDiff.pointer.target[names[j]] = oDiff.target[paths[i]][names[j]];
                    }
                }
            }
        }

        function gatherObstructiveGuids(node) {
            var result = {all: {}, bases: {}},
                putParents = function (n) {
                    result.bases[self.getGuid(n)] = true;
                    while (n) {
                        result.all[self.getGuid(n)] = true;
                        n = self.getParent(n);
                    }
                };
            while (node) {
                putParents(node);
                node = self.getBase(node);
            }
            return result;
        }

        function fillMissingGuid(root, sRoot, path, diff) {
            var relids = getDiffChildrenRelids(diff),
                i,
                done,
                subComputationFinished = function (cDiff, relid) {
                    diff[relid] = cDiff;
                    return null;
                };

            for (i = 0; i < relids.length; i++) {
                done = TASYNC.call(subComputationFinished,
                    fillMissingGuid(root, sRoot, path + '/' + relids[i], diff[relids[i]]), relids[i], done);
            }

            return TASYNC.call(function () {
                return TASYNC.call(function (child, sChild) {
                    if (!child) {
                        child = sChild;
                    }
                    diff.guid = self.getGuid(child);
                    diff.hash = self.getHash(child);
                    diff.oGuids = gatherObstructiveGuids(child);
                    diff.oBaseGuids = diff.oGuids.bases;
                    diff.oGuids = diff.oGuids.all;
                    return diff;
                }, self.loadByPath(root, path), self.loadByPath(sRoot, path));
            }, done);
        }

        function mergeObjects(source, target) {
            var merged = {},
                sKeys = Object.keys(source),
                tKeys = Object.keys(target),
                i;
            for (i = 0; i < sKeys.length; i++) {
                merged[sKeys[i]] = source[sKeys[i]];
            }
            for (i = 0; i < tKeys.length; i++) {
                if (sKeys.indexOf(tKeys[i]) === -1) {
                    merged[tKeys[i]] = target[tKeys[i]];
                } else {
                    if (typeof target[tKeys[i]] === typeof source[tKeys[i]] &&
                        typeof target[tKeys[i]] === 'object' && !(target instanceof Array)) {
                        merged[tKeys[i]] = mergeObjects(source[tKeys[i]], target[tKeys[i]]);
                    } else {
                        merged[tKeys[i]] = target[tKeys[i]];
                    }
                }
            }

            return merged;
        }

        function updateDiff(sourceRoot, targetRoot, yetToCompute) {
            var diff = self.nodeDiff(sourceRoot, targetRoot) || {},
                oDiff = ovrDiff(sourceRoot, targetRoot),
                getChild = function (childArray, relid) {
                    // TODO: This seems computational expensive - maybe core.loadChild is faster?
                    // TODO: Alt. created maps for sChildren and tChildren
                    for (var i = 0; i < childArray.length; i++) {
                        if (self.getRelid(childArray[i]) === relid) {
                            return childArray[i];
                        }
                    }
                    return null;
                };

            return TASYNC.call(function (sChildren, tChildren) {
                ASSERT(sChildren.length >= 0 && tChildren.length >= 0);

                sChildren.sort(compareRelids);
                tChildren.sort(compareRelids);

                var i, child, done, tDiff, guid, base,
                    childComputationFinished = function (cDiff, relid/*, d*/) {
                        diff[relid] = cDiff;
                        return null;
                    };

                tDiff = diff.children ? diff.children.removed || [] : [];
                for (i = 0; i < tDiff.length; i++) {
                    diff.childrenListChanged = true;
                    child = getChild(sChildren, tDiff[i].relid);
                    if (child) {
                        guid = self.getGuid(child);
                        // FIXME: Isn't the hash already given at childrenDiff?
                        diff[tDiff[i].relid] = {guid: guid, removed: true, hash: self.getHash(child)};
                        yetToCompute[guid] = yetToCompute[guid] || {};
                        yetToCompute[guid].from = child;
                        yetToCompute[guid].fromExpanded = false;
                    }
                }

                tDiff = diff.children ? diff.children.added || [] : [];
                for (i = 0; i < tDiff.length; i++) {
                    diff.childrenListChanged = true;
                    child = getChild(tChildren, tDiff[i].relid);
                    if (child) {
                        guid = self.getGuid(child);
                        base = self.getBase(child);
                        diff[tDiff[i].relid] = {
                            guid: guid,
                            removed: false,
                            hash: self.getHash(child),
                            pointer: {source: {}, target: {base: base === null ? null : self.getPath(base)}}
                        };
                        yetToCompute[guid] = yetToCompute[guid] || {};
                        yetToCompute[guid].to = child;
                        yetToCompute[guid].toExpanded = false;
                    }
                }

                for (i = 0; i < tChildren.length; i++) {
                    child = getChild(sChildren, self.getRelid(tChildren[i]));
                    if (child && self.getHash(tChildren[i]) !== self.getHash(child)) {
                        done = TASYNC.call(childComputationFinished,
                            updateDiff(child, tChildren[i], yetToCompute), self.getRelid(child), done);
                    }
                }

                return TASYNC.call(function () {
                    delete diff.children;
                    extendDiffWithOvr(diff, oDiff);

                    normalize(diff);

                    if (Object.keys(diff).length > 0) {
                        diff.guid = self.getGuid(targetRoot);
                        diff.hash = self.getHash(targetRoot);
                        diff.oGuids = gatherObstructiveGuids(targetRoot);
                        diff.oBaseGuids = diff.oGuids.bases;
                        diff.oGuids = diff.oGuids.all;
                        return TASYNC.call(function (finalDiff) {
                            return finalDiff;
                        }, fillMissingGuid(targetRoot, sourceRoot, '', diff));
                    } else {
                        return diff;
                    }

                }, done);
            }, self.loadChildren(sourceRoot), self.loadChildren(targetRoot));
        }

        function expandDiff(root, isDeleted, yetToCompute) {
            var diff = {
                guid: self.getGuid(root),
                hash: self.getHash(root),
                removed: isDeleted === true
            };
            return TASYNC.call(function (children) {
                var guid;
                for (var i = 0; i < children.length; i++) {
                    guid = self.getGuid(children[i]);
                    diff[self.getRelid(children[i])] = {
                        guid: guid,
                        hash: self.getHash(children[i]),
                        removed: isDeleted === true
                    };

                    if (isDeleted) {
                        yetToCompute[guid] = yetToCompute[guid] || {};
                        yetToCompute[guid].from = children[i];
                        yetToCompute[guid].fromExpanded = false;
                    } else {
                        yetToCompute[guid] = yetToCompute[guid] || {};
                        yetToCompute[guid].to = children[i];
                        yetToCompute[guid].toExpanded = false;
                    }
                }
                return diff;
            }, self.loadChildren(root));
        }

        function insertIntoDiff(path, diff, sDiff) {
            var pathObject = DIFF.pathToObject(path),
                pathArray = pathObject.pathArray,
                relid = pathArray.pop(),
                i;

            for (i = 0; i < pathArray.length; i++) {
                sDiff = sDiff[pathArray[i]];
            }
            //sDiff[relid] = diff;
            sDiff[relid] = mergeObjects(sDiff[relid], diff);
        }

        function removePathFromDiff(diff, path) {
            var relId, i,
                pathObject = DIFF.pathToObject(path),
                pathArray = pathObject.pathArray;

            relId = pathArray.pop();
            for (i = 0; i < pathArray.length; i++) {
                diff = diff[pathArray[i]];
            }
            delete diff[relId];
        }

        function shrinkDiff(rootDiff) {
            var _shrink = function (diff) {
                if (diff) {
                    var keys = getDiffChildrenRelids(diff),
                        i;
                    if (typeof diff.movedFrom === 'string') {
                        removePathFromDiff(rootDiff, diff.movedFrom);
                    }

                    if (diff.removed !== false || typeof diff.movedFrom === 'string') {
                        delete diff.hash;
                    }

                    if (diff.removed === true) {
                        for (i = 0; i < keys.length; i++) {
                            delete diff[keys[i]];
                        }
                    } else {

                        for (i = 0; i < keys.length; i++) {
                            _shrink(diff[keys[i]]);
                        }
                    }
                }
            };
            _shrink(rootDiff);
        }

        function insertAtPath(diff, path, object) {
            ASSERT(typeof path === 'string');
            var i, base,
                pathObject = DIFF.pathToObject(path),
                relid = pathObject.pathArray.pop();

            base = diff;
            for (i = 0; i < pathObject.pathArray.length; i += 1) {
                base[pathObject.pathArray[i]] = base[pathObject.pathArray[i]] || {};
                base = base[pathObject.pathArray[i]];
            }
            base[relid] = JSON.parse(JSON.stringify(object));
            return;
        }

        function checkRound(yetToCompute, diff, diffMoves, needChecking) {
            var guids = Object.keys(yetToCompute),
                done,
                ytc,
                i,
                computingMove = function (mDiff, info) {
                    mDiff.guid = self.getGuid(info.from);
                    mDiff.movedFrom = self.getPath(info.from);
                    mDiff.ooGuids = gatherObstructiveGuids(info.from);
                    mDiff.ooBaseGuids = mDiff.ooGuids.bases;
                    mDiff.ooGuids = mDiff.ooGuids.all;
                    diffMoves[self.getPath(info.from)] = self.getPath(info.to);
                    insertAtPath(diff, self.getPath(info.to), mDiff);
                    return null;
                },
                expandFrom = function (mDiff, info) {
                    mDiff.hash = self.getHash(info.from);
                    mDiff.removed = true;
                    insertIntoDiff(self.getPath(info.from), mDiff, diff);
                    return null;
                },
                expandTo = function (mDiff, info) {
                    if (!mDiff.hash) {
                        mDiff.hash = self.getHash(info.to);
                    }
                    mDiff.removed = false;
                    insertIntoDiff(self.getPath(info.to), mDiff, diff);
                    return null;
                };

            if (needChecking !== true || guids.length < 1) {
                shrinkDiff(diff);
                finalizeDiff(diff, diffMoves);
                return JSON.parse(JSON.stringify(diff));
            }

            needChecking = false;
            for (i = 0; i < guids.length; i++) {
                ytc = yetToCompute[guids[i]];
                if (ytc.from && ytc.to) {
                    //move
                    needChecking = true;
                    delete yetToCompute[guids[i]];
                    done = TASYNC.call(computingMove, updateDiff(ytc.from, ytc.to, yetToCompute), ytc, done);
                } else {
                    if (ytc.from && ytc.fromExpanded === false) {
                        //expand from
                        ytc.fromExpanded = true;
                        needChecking = true;
                        done = TASYNC.call(expandFrom, expandDiff(ytc.from, true, yetToCompute), ytc, done);
                    } else if (ytc.to && ytc.toExpanded === false) {
                        //expand to
                        ytc.toExpanded = true;
                        needChecking = true;
                        done = TASYNC.call(expandTo, expandDiff(ytc.to, false, yetToCompute), ytc, done);
                    }
                }
            }

            return TASYNC.call(checkRound, yetToCompute, diff, diffMoves, needChecking, done);
        }

        function hasRealChange(diffNode) {
            var keys = Object.keys(diffNode || {}),
                searchedKeywords = {
                    hash: true,
                    attr: true,
                    reg: true,
                    pointer: true,
                    set: true,
                    meta: true,
                    movedFrom: true,
                    removed: true,
                    childrenListChanged: true
                },
                i;

            for (i = 0; i < keys.length; i += 1) {
                if (searchedKeywords[keys[i]]) {
                    return true;
                }
            }

            return false;
        }

        function getMoveSources(diff, path, toFrom, fromTo) {
            var relids = getDiffChildrenRelids(diff),
                i;

            for (i = 0; i < relids.length; i++) {
                getMoveSources(diff[relids[i]], path + '/' + relids[i], toFrom, fromTo);
            }

            if (typeof diff.movedFrom === 'string') {
                toFrom[path] = diff.movedFrom;
                fromTo[diff.movedFrom] = path;
            }
        }

        function getParentPath(path) {
            path = path.split(CONSTANTS.PATH_SEP);
            path.splice(-1, 1);
            return path.join(CONSTANTS.PATH_SEP);
        }

        function getNodeByGuid(diff, guid) {
            var relids, i, node;

            if (REGEXP.GUID.test(guid) !== true) {
                return null;
            }

            if (diff.guid === guid) {
                return diff;
            }

            relids = getDiffChildrenRelids(diff);
            for (i = 0; i < relids.length; i++) {
                node = getNodeByGuid(diff[relids[i]], guid);
                if (node) {
                    return node;
                }
            }
            return null;
        }

        function _getPathOfGuidR(diff, guid, path) {
            var relids, i, result;

            if (diff.guid === guid) {
                return path;
            }

            relids = getDiffChildrenRelids(diff);
            for (i = 0; i < relids.length; i++) {
                result = _getPathOfGuidR(diff[relids[i]], guid, path + CONSTANTS.PATH_SEP + relids[i]);
                if (result !== null) {
                    return result;
                }
            }

            return null;
        }

        function getPathOfGuid(diff, guid) {

            if (REGEXP.GUID.test(guid) !== true) {
                return null;
            }
            return _getPathOfGuidR(diff, guid, '');
        }

        function getRelidFromPath(path) {
            path = path.split(CONSTANTS.PATH_SEP);
            return path.splice(-1, 1)[0];
        }

        function getParentGuid(diff, path) {
            return getPathOfDiff(diff, getParentPath(path)).guid || null;
        }

        function fixInheritanceCollision(path, diffBase, diffExtension, moveBase) {
            // a generic approach to check for complex collisions, when the same
            // path is being created by changes in the base of some container and
            // inside the container by either move or creation
            // also it moves new nodes whenever any of its container changed base -
            // not necessarily able to figure out, so it is safer to reallocate relid in this rare case
            var i,
                diff = getPathOfDiff(diffBase, path),
                keys = getDiffChildrenRelids(diff),
                newRelid,
                newPath,
                parent,
                src2dst,
                dst2src,
                checkContainer = function (containerGuid, relativePath) {
                    var usedDiff, path, containerDiff, baseGuids, i, baseDiff, dataKnownInExtension;

                    containerDiff = getNodeByGuid(diffExtension, containerGuid);
                    if (containerDiff === null) {
                        containerDiff = getNodeByGuid(diffBase, containerGuid);
                        usedDiff = diffBase;
                        path = getPathOfGuid(usedDiff, containerGuid);
                    } else {
                        dataKnownInExtension = true;
                        usedDiff = diffExtension;
                        path = getPathOfGuid(usedDiff, containerGuid);
                    }

                    baseGuids = Object.keys(containerDiff.oBaseGuids || {})
                        .concat(Object.keys(containerDiff.ooBaseGuids || {}));

                    for (i = 0; i < baseGuids.length; i += 1) {
                        baseDiff = getPathOfDiff(getNodeByGuid(diffExtension, baseGuids[i]) || {}, relativePath);
                        if (baseDiff.removed === false || typeof baseDiff.movedFrom === 'string') {
                            //the base exists / changed and new at the given path
                            return true;
                        }
                    }

                    if (dataKnownInExtension &&
                        containerDiff.pointer &&
                        typeof containerDiff.pointer.base === 'string') {
                        // the container changed its base
                        return true;
                    }
                    //this parent was fine, so let's go to the next one - except the root, that we do not have to check
                    relativePath = CONSTANTS.PATH_SEP + getRelidFromPath(path) + relativePath;
                    if (getParentPath(path)) {
                        // we should stop before the ROOT
                        return checkContainer(
                            getParentGuid(diffExtension, path) || getParentGuid(diffBase, path), 
                            relativePath
                        );
                    }

                    return false;
                };

            if (diff.removed === false || typeof diff.movedFrom === 'string') {
                // this is a new node at the given place, so let's check for base collisions
                if (checkContainer(getParentGuid(diffBase, path), CONSTANTS.PATH_SEP + getRelidFromPath(path))) {
                    // we have to move the node
                    if (moveBase === true) {
                        dst2src = _concatMoves.getBaseSourceFromDestination;
                        src2dst = _concatMoves.getBaseDestinationFromSource;
                    } else {
                        dst2src = _concatMoves.getExtensionSourceFromDestination;
                        src2dst = _concatMoves.getExtensionDestinationFromSource;
                    }

                    //TODO is there a safer way to ensure no collision with the new relid
                    newRelid = RANDOM.generateRelid({}, CONSTANTS.MAXIMUM_STARTING_RELID_LENGTH);
                    newPath = getParentPath(path) + '/' + newRelid;

                    //now the actual place switching
                    parent = getPathOfDiff(diffBase, getParentPath(path));
                    parent[newRelid] = diff;
                    parent[newRelid].collidingRelid = getRelidFromPath(path);
                    delete parent[getRelidFromPath(path)];
                    dst2src[newPath] = dst2src[path];
                    delete dst2src[path];
                    src2dst[dst2src[newPath]] = newPath;
                }
            }

            for (i = 0; i < keys.length; i += 1) {
                fixInheritanceCollision(path + CONSTANTS.PATH_SEP + keys[i], diffBase, diffExtension, moveBase);
            }
        }

        function fixCollision(path, relid, diffBase, diffExtension) {
            //a generic approach, to check if both diff has the same path
            // but for a different node
            //there is three types of path equality:
            //1. same guids -> same node
            //2. both was moved -> different nodes
            //3. one was moved and the other is created ->different nodes (here we always have to generate
            // new relid to the moved one)
            //4. both was created (we have to generate relid to one of them)
            var i,
                keys = getDiffChildrenRelids(diffBase),
                globalDiff,
                newRelid,
                newPath,
                nodeDiff,
                relids,
                dst2src,
                src2dst,
                relidObj = {},
                parent;

            if (diffBase.guid !== diffExtension.guid &&
                (typeof diffBase.guid === 'string' && typeof diffExtension.guid === 'string')) {
                if (diffBase.movedFrom && diffExtension.movedFrom) {
                    //relocate the extension
                    globalDiff = _concatExtension;
                    nodeDiff = diffExtension;
                    dst2src = _concatMoves.getExtensionSourceFromDestination;
                    src2dst = _concatMoves.getExtensionDestinationFromSource;
                } else if (diffBase.movedFrom && diffExtension.removed === false) {
                    globalDiff = _concatBase;
                    nodeDiff = diffBase;
                    dst2src = _concatMoves.getBaseSourceFromDestination;
                    src2dst = _concatMoves.getBaseDestinationFromSource;
                } else if (diffExtension.movedFrom && diffBase.removed === false) {
                    globalDiff = _concatExtension;
                    nodeDiff = diffExtension;
                    dst2src = _concatMoves.getExtensionSourceFromDestination;
                    src2dst = _concatMoves.getExtensionDestinationFromSource;
                } else if (diffBase.removed === false && diffExtension.removed === false) {
                    globalDiff = _concatExtension;
                    nodeDiff = diffExtension;
                    dst2src = _concatMoves.getExtensionSourceFromDestination;
                    src2dst = _concatMoves.getExtensionDestinationFromSource;
                } else {
                    throw new Error('there is a guid mismatch among the two diffs: ' +
                        diffBase.guid + ' vs ' + diffExtension.guid);
                }

                relids = getDiffChildrenRelids(getPathOfDiff(_concatBase, getParentPath(path)))
                    .concat(getDiffChildrenRelids(getPathOfDiff(_concatExtension, getParentPath(path))));

                relidObj = {};
                for (i = 0; i < relids.length; i += 1) {
                    relidObj[relids[i]] = {};
                }
                // TODO: Could this lead to collisions on bases/instances?
                newRelid = RANDOM.generateRelid(relidObj);
                newPath = getParentPath(path) + '/' + newRelid;

                //now the actual place switching
                parent = getPathOfDiff(globalDiff, getParentPath(path));
                parent[newRelid] = nodeDiff;
                parent[newRelid].collidingRelid = relid;
                delete parent[relid];
                dst2src[newPath] = dst2src[path];
                delete dst2src[path];
                src2dst[dst2src[newPath]] = newPath;
            }

            //recursive calls - only if there were no replacement due to collision
            for (i = 0; i < keys.length; i += 1) {
                if (diffExtension[keys[i]]) {
                    fixCollision(path + '/' + keys[i], keys[i], diffBase[keys[i]], diffExtension[keys[i]]);
                }
            }
        }

        function getAncestorPath(onePath, otherPath) {
            var ancestorPath = '',
                onePathArray = onePath.split('/'),
                otherPathArray = otherPath.split('/'),
                i = 0;
            onePathArray.shift();
            otherPathArray.shift();
            if (onePathArray.length > 0 && otherPathArray.length > 0) {
                while (i < onePathArray.length && onePathArray[i] === otherPathArray[i]) {
                    ancestorPath += '/' + onePathArray[i];
                    i += 1;
                }
            }
            return ancestorPath;
        }

        function setBaseOfNewNode(root, nodePath, basePath) {
            var ancestorPath = getAncestorPath(nodePath, basePath);
            return TASYNC.call(function (node) {
                var sourcePath = nodePath.substr(ancestorPath.length),
                    targetPath = basePath.substr(ancestorPath.length);
                innerCore.overlayInsert(node, sourcePath, 'base', targetPath);
            }, self.loadByPath(root, ancestorPath));
        }

        function getOrderedRelids(diffObject) {
            //those nodes that were changing relid as a result of move should be handled last
            var keys = getDiffChildrenRelids(diffObject),
                i,
                ordered = [],
                sourceRelid;
            for (i = 0; i < keys.length; i += 1) {
                if (diffObject[keys[i]].movedFrom) {
                    sourceRelid = diffObject[keys[i]].movedFrom;
                    sourceRelid = sourceRelid.split('/');
                    sourceRelid = sourceRelid[sourceRelid.length - 1];
                    if (sourceRelid !== keys[i]) {
                        ordered.push(keys[i]);
                    } else {
                        ordered.unshift(keys[i]);
                    }
                } else {
                    ordered.unshift(keys[i]);
                }
            }
            return ordered;
        }

        function makeInitialContainmentChanges(node, diff) {
            var relids = getOrderedRelids(diff),
                i, done, child, moved,
                moving = function (n, di, r, p, m, a/*, d*/) {
                    var nRelid;
                    if (m === true) {
                        n = self.moveNode(n, p);
                        nRelid = self.getRelid(n);

                        if (r !== nRelid) {
                            //we have to make additional changes to our move table
                            diff[nRelid] = JSON.parse(JSON.stringify(diff[r]));
                            delete diff[r];
                        }
                    }
                    return makeInitialContainmentChanges(n, di, a);
                };

            for (i = 0; i < relids.length; i++) {
                moved = false;
                if (diff[relids[i]].movedFrom) {
                    //moved node
                    moved = true;
                    child = self.loadByPath(self.getRoot(node), diff[relids[i]].movedFrom);
                    done = TASYNC.call(moving, child, diff[relids[i]], relids[i], node, moved, done);
                } else if (diff[relids[i]].removed === false) {
                    //added node
                    if (diff[relids[i]].hash) {
                        self.setProperty(node, relids[i], diff[relids[i]].hash);
                        node.childrenRelids = null;
                    }
                } else {
                    //simple node
                    child = self.loadChild(node, relids[i]);
                    done = TASYNC.call(moving, child, diff[relids[i]], relids[i], node, moved, done);
                }
            }

            return TASYNC.call(function (/*d*/) {
                return null;
            }, done);
        }

        function setBaseRelationsOfNewNodes(root, path, diff, added) {
            var relids = getOrderedRelids(diff),
                i,
                children = [],
                newNode = false;

            for (i = 0; i < relids.length; i += 1) {
                if ((diff[relids[i]].removed === false || added) &&
                    diff[relids[i]].pointer && diff[relids[i]].pointer.base) {
                    newNode = true;
                    children[i] = TASYNC.join(
                        setBaseOfNewNode(root, path + '/' + relids[i], diff[relids[i]].pointer.base),
                        setBaseRelationsOfNewNodes(root, path + '/' + relids[i], diff[relids[i]], added || newNode)
                    );
                } else {
                    children[i] = TASYNC.call(
                        setBaseRelationsOfNewNodes, root, path + '/' + relids[i], diff[relids[i]], added
                    );
                }
            }

            return TASYNC.lift(children);
        }

        function applyAttributeChanges(node, attrDiff) {
            var i, keys;
            keys = Object.keys(attrDiff);
            for (i = 0; i < keys.length; i++) {
                if (attrDiff[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                    self.delAttribute(node, keys[i]);
                } else {
                    self.setAttribute(node, keys[i], attrDiff[keys[i]]);
                }
            }
        }

        function applyRegistryChanges(node, regDiff) {
            var i, keys;
            keys = Object.keys(regDiff);
            for (i = 0; i < keys.length; i++) {
                if (regDiff[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                    self.delRegistry(node, keys[i]);
                } else {
                    self.setRegistry(node, keys[i], regDiff[keys[i]]);
                }
            }
        }

        function setPointer(node, name, target) {
            var targetNode;
            if (target === null) {
                targetNode = null;
            } else {
                targetNode = self.loadByPath(self.getRoot(node), target);
            }
            return TASYNC.call(function (t) {
                //TODO watch if handling of base changes!!!
                self.setPointer(node, name, t);
                return;
            }, targetNode);
        }

        function applyPointerChanges(node, diff) {
            var done,
                pointerDiff = diff.pointer || {},
                keys = Object.keys(pointerDiff),
                i;
            for (i = 0; i < keys.length; i++) {
                if (pointerDiff[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                    self.deletePointer(node, keys[i]);
                } else if (diff.removed !== false || keys[i] !== 'base') {
                    done = setPointer(node, keys[i], pointerDiff[keys[i]], done);
                }
            }

            return TASYNC.call(function (/*d*/) {
                return null;
            }, done);

        }

        function addMember(node, name, target, data) {
            var memberAttrSetting = function (diff) {
                    var keys, i;

                    keys = Object.keys(diff);
                    for (i = 0; i < keys.length; i++) {
                        if (diff[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                            self.delMemberAttribute(node, name, target, keys[i]);
                        } else {
                            self.setMemberAttribute(node, name, target, keys[i], diff[keys[i]]);
                        }
                    }
                },
                memberRegSetting = function (diff) {
                    var keys, i;

                    keys = Object.keys(diff);
                    for (i = 0; i < keys.length; i++) {
                        if (diff[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                            self.delMemberRegistry(node, name, target, keys[i]);
                        } else {
                            self.setMemberRegistry(node, name, target, keys[i], diff[keys[i]]);
                        }
                    }
                };
            return TASYNC.call(function (t) {
                self.addMember(node, name, t);
                memberAttrSetting(data.attr || {});
                memberRegSetting(data.reg || {});
                return;
            }, self.loadByPath(self.getRoot(node), target));
        }

        function applySetChanges(node, setDiff) {
            var done,
                setNames = Object.keys(setDiff),
                elements, i, j;
            for (i = 0; i < setNames.length; i++) {
                if (setDiff[setNames[i]] === CONSTANTS.TO_DELETE_STRING) {
                    self.deleteSet(node, setNames[i]);
                } else {
                    self.createSet(node, setNames[i]);
                    if (Object.keys(setDiff[setNames[i]].attr || {}).length > 0) {
                        elements = Object.keys(setDiff[setNames[i]].attr);
                        for (j = 0; j < elements.length; j += 1) {
                            if (setDiff[setNames[i]].attr[elements[j]] === CONSTANTS.TO_DELETE_STRING) {
                                self.delSetAttribute(node, setNames[i], elements[j]);
                            } else {
                                self.setSetAttribute(node, setNames[i], elements[j],
                                    setDiff[setNames[i]].attr[elements[j]]);
                            }
                        }
                    }
                    if ((Object.keys(setDiff[setNames[i]].reg || {})).length > 0) {
                        elements = Object.keys(setDiff[setNames[i]].reg);
                        for (j = 0; j < elements.length; j += 1) {
                            if (setDiff[setNames[i]].reg[elements[j]] === CONSTANTS.TO_DELETE_STRING) {
                                self.delSetRegistry(node, setNames[i], elements[j]);
                            } else {
                                self.setSetRegistry(node, setNames[i], elements[j],
                                    setDiff[setNames[i]].reg[elements[j]]);
                            }
                        }
                    }

                    elements = Object.keys(setDiff[setNames[i]]);
                    for (j = 0; j < elements.length; j++) {
                        if (RANDOM.isValidPath(elements[j])) {
                            if (setDiff[setNames[i]][elements[j]] === CONSTANTS.TO_DELETE_STRING) {
                                self.delMember(node, setNames[i], elements[j]);
                            } else {
                                done = addMember(node, setNames[i], elements[j], setDiff[setNames[i]][elements[j]],
                                    done);
                            }
                        }
                    }
                }
            }

            return TASYNC.call(function (/*d*/) {
                return null;
            }, done);

        }

        function jsonConcat(base, extension) {
            var baseKeys = Object.keys(base),
                extKeys = Object.keys(extension),
                concat = JSON.parse(JSON.stringify(base)),
                i;
            for (i = 0; i < extKeys.length; i++) {
                if (baseKeys.indexOf(extKeys[i]) === -1) {
                    concat[extKeys[i]] = JSON.parse(JSON.stringify(extension[extKeys[i]]));
                } else {
                    if (typeof base[extKeys[i]] === 'object' && typeof extension[extKeys[i]] === 'object') {
                        concat[extKeys[i]] = jsonConcat(base[extKeys[i]], extension[extKeys[i]]);
                    } else { //either from value to object or object from value we go with the extension
                        concat[extKeys[i]] = JSON.parse(JSON.stringify(extension[extKeys[i]]));
                    }
                }
            }
            return concat;
        }

        function applyMetaAttributes(node, metaAttrDiff) {
            var i, keys, newValue;
            if (metaAttrDiff === CONSTANTS.TO_DELETE_STRING) {
                //we should delete all MetaAttributes
                keys = self.getValidAttributeNames(node);
                for (i = 0; i < keys.length; i++) {
                    self.delAttributeMeta(node, keys[i]);
                }
            } else {
                keys = Object.keys(metaAttrDiff);
                for (i = 0; i < keys.length; i++) {
                    if (metaAttrDiff[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                        self.delAttributeMeta(node, keys[i]);
                    } else {
                        newValue = jsonConcat(self.getAttributeMeta(node, keys[i]) || {}, metaAttrDiff[keys[i]]);
                        self.setAttributeMeta(node, keys[i], newValue);
                    }
                }
            }
        }

        function applyMetaConstraints(node, metaConDiff) {
            var keys, i;
            if (metaConDiff === CONSTANTS.TO_DELETE_STRING) {
                //remove all constraints
                keys = self.getConstraintNames(node);
                for (i = 0; i < keys.length; i++) {
                    self.delConstraint(node, keys[i]);
                }
            } else {
                keys = Object.keys(metaConDiff);
                for (i = 0; i < keys.length; i++) {
                    if (metaConDiff[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                        self.delConstraint(node, keys[i]);
                    } else {
                        self.setConstraint(node, keys[i], jsonConcat(self.getConstraint(node, keys[i]) || {},
                            metaConDiff[keys[i]]));
                    }
                }
            }
        }

        function applyMetaChildren(node, metaChildrenDiff) {
            var keys, i, done,
                setChild = function (target, data/*, d*/) {
                    self.setChildMeta(node, target, data.min, data.max);
                };
            if (metaChildrenDiff === CONSTANTS.TO_DELETE_STRING) {
                //remove all valid child
                keys = self.getValidChildrenPaths(node);
                for (i = 0; i < keys.length; i++) {
                    self.delChildMeta(node, keys[i]);
                }
            } else {
                self.setChildrenMetaLimits(node, metaChildrenDiff.min, metaChildrenDiff.max);
                delete metaChildrenDiff.max; //TODO we do not need it anymore, but maybe there is a better way
                delete metaChildrenDiff.min;
                keys = Object.keys(metaChildrenDiff);
                for (i = 0; i < keys.length; i++) {
                    if (metaChildrenDiff[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                        self.delChildMeta(node, keys[i]);
                    } else {
                        done = TASYNC.call(setChild, self.loadByPath(self.getRoot(node), keys[i]),
                            metaChildrenDiff[keys[i]], done);
                    }
                }
            }

            TASYNC.call(function (/*d*/) {
                return null;
            }, done);
        }

        function applyMetaPointers(node, metaPointerDiff) {
            var names, targets, i, j, done,
                setPointer = function (name, target, data/*, d*/) {
                    self.setPointerMetaTarget(node, name, target, data.min, data.max);
                };
            if (metaPointerDiff === CONSTANTS.TO_DELETE_STRING) {
                //remove all pointers,sets and their targets
                names = self.getValidPointerNames(node);
                for (i = 0; i < names.length; i++) {
                    self.delPointerMeta(node, names[i]);
                }

                names = self.getValidSetNames(node);
                for (i = 0; i < names.length; i++) {
                    self.delPointerMeta(node, names[i]);
                }
                return;
            }

            names = Object.keys(metaPointerDiff);
            for (i = 0; i < names.length; i++) {
                if (metaPointerDiff[names[i]] === CONSTANTS.TO_DELETE_STRING) {
                    self.delPointerMeta(node, names[i]);
                } else {
                    self.setPointerMetaLimits(node, names[i], metaPointerDiff[names[i]].min,
                        metaPointerDiff[names[i]].max);
                    //TODO we do not need it anymore, but maybe there is a better way
                    delete metaPointerDiff[names[i]].max;
                    delete metaPointerDiff[names[i]].min;
                    targets = Object.keys(metaPointerDiff[names[i]]);
                    for (j = 0; j < targets.length; j++) {
                        if (metaPointerDiff[names[i]][targets[j]] === CONSTANTS.TO_DELETE_STRING) {
                            self.delPointerMetaTarget(node, names[i], targets[j]);
                        } else {
                            done = TASYNC.call(setPointer, names[i], self.loadByPath(self.getRoot(node), targets[j]),
                                metaPointerDiff[names[i]][targets[j]], done);
                        }
                    }
                }
            }

            TASYNC.call(function (/*d*/) {
                return null;
            }, done);
        }

        function applyMetaAspects(node, metaAspectsDiff) {
            var names, targets, i, j, done,
                setAspect = function (name, target/*, d*/) {
                    self.setAspectMetaTarget(node, name, target);
                };
            if (metaAspectsDiff === CONSTANTS.TO_DELETE_STRING) {
                //remove all aspects
                names = self.getValidAspectNames(node);
                for (i = 0; i < names.length; i++) {
                    self.delAspectMeta(node, names[i]);
                }
                return;
            }

            names = Object.keys(metaAspectsDiff);
            for (i = 0; i < names.length; i++) {
                if (metaAspectsDiff[names[i]] === CONSTANTS.TO_DELETE_STRING) {
                    self.delAspectMeta(node, names[i]);
                } else {
                    targets = metaAspectsDiff[names[i]];
                    for (j = 0; j < targets.length; j++) {
                        if (metaAspectsDiff[names[i]][targets[j]] === CONSTANTS.TO_DELETE_STRING) {
                            self.delAspectMetaTarget(node, names[i], targets[j]);
                        } else {
                            done = TASYNC.call(setAspect, names[i], self.loadByPath(self.getRoot(node), targets[j]),
                                done);
                        }
                    }
                }
            }

            TASYNC.call(function (/*d*/) {
                return null;
            }, done);
        }

        function applyMetaChanges(node, metaDiff) {
            var done;
            applyMetaAttributes(node, metaDiff.attributes || CONSTANTS.TO_DELETE_STRING);
            applyMetaConstraints(node, metaDiff.constraints || CONSTANTS.TO_DELETE_STRING);
            done = applyMetaChildren(node, metaDiff.children || CONSTANTS.TO_DELETE_STRING);
            done = TASYNC.call(applyMetaPointers, node, metaDiff.pointers || CONSTANTS.TO_DELETE_STRING, done);
            done = TASYNC.call(applyMetaAspects, node, metaDiff.aspects || CONSTANTS.TO_DELETE_STRING, done);

            TASYNC.call(function (/*d*/) {
                return null;
            }, done);
        }

        function applyNodeChange(root, path, nodeDiff) {
            //check for move
            var node;

            node = self.loadByPath(root, path);

            return TASYNC.call(function (n) {
                var done,
                    relids = getDiffChildrenRelids(nodeDiff),
                    i;
                if (n === null) {
                    logger.warn('Missing node [' + path + '] during patch application. ' +
                        'Could be a conflicting conflict resolution.');
                    return;
                }
                if (nodeDiff.removed === true) {
                    self.deleteNode(n);
                    return;
                }
                applyAttributeChanges(n, nodeDiff.attr || {});
                applyRegistryChanges(n, nodeDiff.reg || {});
                done = applyPointerChanges(n, nodeDiff);
                done = TASYNC.call(applySetChanges, n, nodeDiff.set || {}, done);
                if (nodeDiff.meta) {
                    delete nodeDiff.meta.empty;
                    done = TASYNC.call(applyMetaChanges, n, nodeDiff.meta, done);
                }
                for (i = 0; i < relids.length; i++) {
                    done = TASYNC.call(function () {
                        return null;
                    }, applyNodeChange(root, path + '/' + relids[i], nodeDiff[relids[i]]), done);
                    // done = TASYNC.join(done, applyNodeChange(root, path + '/' + relids[i], nodeDiff[relids[i]]));
                }
                /*TASYNC.call(function (d) {
                 return done;
                 }, done);*/

                //we should check for possible guid change and restore the expected guid
                if (self.getGuid(n) !== nodeDiff.guid && nodeDiff.guid) {
                    done = TASYNC.call(function () {
                        return null;
                    }, self.setGuid(n, nodeDiff.guid), done);
                }
                return done;
            }, node);
        }

        function getSingleNode(node) {
            //removes the children from the node
            var result = JSON.parse(JSON.stringify(node)),
                keys = getDiffChildrenRelids(result),
                i;
            for (i = 0; i < keys.length; i++) {
                delete result[keys[i]];
            }
            //changeMovedPaths(result);
            return result;
        }

        //FIXME are we going to use this function
        //function getConflictByGuid(conflict, guid) {
        //    var relids, i, result;
        //    if (conflict.guid === guid) {
        //        return conflict;
        //    }
        //    relids = getDiffChildrenRelids(conflict);
        //    for (i = 0; i < relids.length; i++) {
        //        result = getConflictByGuid(conflict[relids[i]], guid);
        //        if (result) {
        //            return result;
        //        }
        //    }
        //    return null;
        //}

        //now we try a different approach, which maybe more simple
        function getCommonPathForConcat(path) {
            if (_concatMoves.getExtensionSourceFromDestination[path]) {
                path = _concatMoves.getExtensionSourceFromDestination[path];
            }
            if (_concatMoves.getBaseDestinationFromSource[path]) {
                path = _concatMoves.getBaseDestinationFromSource[path];
            }
            return path;
        }

        function getConcatBaseRemovals(diff) {
            var relids = getDiffChildrenRelids(diff),
                i;
            if (diff.removed !== true) {
                if (diff.movedFrom) {
                    if (_concatBaseRemovals[diff.guid] !== undefined) {
                        delete _concatBaseRemovals[diff.guid];
                    } else {
                        _concatBaseRemovals[diff.guid] = false;
                    }
                }
                for (i = 0; i < relids.length; i++) {
                    getConcatBaseRemovals(diff[relids[i]]);
                }
            } else {
                if (_concatBaseRemovals[diff.guid] === false) {
                    delete _concatBaseRemovals[diff.guid];
                } else {
                    _concatBaseRemovals[diff.guid] = true;
                }
            }
        }

        function completeConcatBase(baseDiff, extensionDiff) {
            var recursiveComplete = function (base, extension, newItem) {
                var i, keys;
                if (newItem === true) {
                    if (extension.guid) {
                        base.guid = extension.guid;
                    }
                    if (extension.oGuids) {
                        base.oGuids = extension.oGuids;
                    }
                    if (extension.ooGuids) {
                        base.ooGuids = extension.ooGuids;
                    }

                    if (extension.oBaseGuids) {
                        base.oBaseGuids = extension.oBaseGuids;
                    }
                    if (extension.ooBaseGuids) {
                        base.ooBaseGuids = extension.ooBaseGuids;
                    }

                    if (typeof extension.removed === 'boolean' && !extension.removed) {
                        base.removed = extension.removed;
                    }

                    if (extension.hash) {
                        base.hash = extension.hash;
                    }

                    if (extension.childrenListChanged) {
                        base.childrenListChanged = true;
                    }
                }

                keys = getDiffChildrenRelids(extension);
                for (i = 0; i < keys.length; i += 1) {
                    if (base[keys[i]] === undefined) {
                        if (typeof extension[keys[i]].movedFrom !== 'string') {
                            base[keys[i]] = {};
                            recursiveComplete(base[keys[i]], extension[keys[i]], true);
                        }
                    } else {
                        recursiveComplete(base[keys[i]], extension[keys[i]], false);
                    }
                }
            };

            recursiveComplete(baseDiff, extensionDiff, Object.keys(baseDiff).length === 0);
        }

        function getObstructiveGuids(diffNode) {
            var result = [],
                keys, i;
            keys = Object.keys(diffNode.oGuids || {});
            for (i = 0; i < keys.length; i++) {
                if (_concatBaseRemovals[keys[i]]) {
                    result.push(keys[i]);
                }
            }
            keys = Object.keys(diffNode.ooGuids || {});
            for (i = 0; i < keys.length; i++) {
                if (_concatBaseRemovals[keys[i]]) {
                    result.push(keys[i]);
                }
            }
            return result;
        }

        function getWhomIObstructGuids(guid) {
            //this function is needed when the extension contains a deletion where the base did not delete the node
            var guids = [],
                reachedItself = false,
                checkNode = function (diffNode) {
                    var relids, i;
                    if ((diffNode.oGuids && diffNode.oGuids[guid]) || (diffNode.ooGuids && diffNode.ooGuids[guid])) {
                        guids.push(diffNode.guid);
                    }

                    if (reachedItself) {
                        guids.push(diffNode.guid);
                    } else if (diffNode.guid === guid) {
                        reachedItself = true;
                    }

                    relids = getDiffChildrenRelids(diffNode);
                    for (i = 0; i < relids.length; i++) {
                        checkNode(diffNode[relids[i]]);
                    }
                };
            checkNode(_concatBase);
            return guids;
        }

        function gatherFullMetaConflicts(diffMeta, mine, path, opposingPath) {
            var conflict, opposingConflict,
                relids, i, j, keys, tPath, key;

            if (mine) {
                conflict = _conflictMine;
                opposingConflict = _conflictTheirs[opposingPath];
            } else {
                conflict = _conflictTheirs;
                opposingConflict = _conflictMine[opposingPath];
            }

            if (diffMeta === CONSTANTS.TO_DELETE_STRING) {
                conflict[path] = conflict[path] || {value: CONSTANTS.TO_DELETE_STRING, conflictingPaths: {}};
                conflict[path].conflictingPaths[opposingPath] = true;
                opposingConflict.conflictingPaths[path] = true;
                return; //there is no other conflict
            }

            //children
            if (diffMeta.children) {
                if (diffMeta.children === CONSTANTS.TO_DELETE_STRING) {
                    conflict[path + '/children'] = conflict[path + '/children'] || {
                        value: CONSTANTS.TO_DELETE_STRING,
                        conflictingPaths: {}
                    };
                    conflict[path + '/children'].conflictingPaths[opposingPath] = true;
                    opposingConflict.conflictingPaths[path + '/children'] = true;
                } else {
                    if (diffMeta.children.max) {
                        conflict[path + '/children/max'] = conflict[path + '/children/max'] || {
                            value: diffMeta.children.max,
                            conflictingPaths: {}
                        };
                        conflict[path + '/children/max'].conflictingPaths[opposingPath] = true;
                        opposingConflict.conflictingPaths[path + '/children/max'] = true;
                    }
                    if (diffMeta.children.min) {
                        conflict[path + '/children/min'] = conflict[path + '/children/min'] || {
                            value: diffMeta.children.min,
                            conflictingPaths: {}
                        };
                        conflict[path + '/children/min'].conflictingPaths[opposingPath] = true;
                        opposingConflict.conflictingPaths[path + '/children/min'] = true;
                    }
                    relids = getDiffChildrenRelids(diffMeta.children);
                    for (i = 0; i < relids.length; i++) {
                        conflict[path + '/children/' + relids[i]] = conflict[path + '/children/' + relids[i]] || {
                            value: diffMeta.children[relids[i]],
                            conflictingPaths: {}
                        };
                        conflict[path + '/children/' + relids[i]].conflictingPaths[opposingPath] = true;
                        opposingConflict.conflictingPaths[path + '/children/' + relids[i]] = true;
                    }
                }
            }
            //attributes
            if (diffMeta.attributes) {
                if (diffMeta.attributes === CONSTANTS.TO_DELETE_STRING) {
                    conflict[path + '/attributes'] = conflict[path + '/attributes'] || {
                        value: CONSTANTS.TO_DELETE_STRING,
                        conflictingPaths: {}
                    };
                    conflict[path + '/attributes'].conflictingPaths[opposingPath] = true;
                    opposingConflict.conflictingPaths[path + '/attributes'] = true;
                } else {
                    keys = Object.keys(diffMeta.attributes);
                    for (i = 0; i < keys.length; i++) {
                        key = path + '/attributes/' + keys[i];
                        conflict[key] = conflict[key] || {
                            value: diffMeta.attributes[keys[i]],
                            conflictingPaths: {}
                        };
                        conflict[key].conflictingPaths[opposingPath] = true;
                        opposingConflict.conflictingPaths[key] = true;
                    }
                }
            }
            //pointers
            if (diffMeta.pointers) {
                if (diffMeta.pointers === CONSTANTS.TO_DELETE_STRING) {
                    conflict[path + '/pointers'] = conflict[path + '/pointers'] || {
                        value: CONSTANTS.TO_DELETE_STRING,
                        conflictingPaths: {}
                    };
                    conflict[path + '/pointers'].conflictingPaths[opposingPath] = true;
                    opposingConflict.conflictingPaths[path + '/pointers'] = true;
                } else {
                    keys = Object.keys(diffMeta.pointers);
                    for (i = 0; i < keys.length; i++) {
                        if (diffMeta.pointers[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                            conflict[path + '/pointers/' + keys[i]] = conflict[path + '/pointers/' + keys[i]] || {
                                value: CONSTANTS.TO_DELETE_STRING,
                                conflictingPaths: {}
                            };
                            conflict[path + '/pointers/' + keys[i]].conflictingPaths[opposingPath] = true;
                            opposingConflict.conflictingPaths[path + '/pointers/' + keys[i]] = true;
                        } else {
                            if (diffMeta.pointers[keys[i]].max) {
                                conflict[path + '/pointers/' + keys[i] + '/max'] =
                                    conflict[path + '/pointers/' + keys[i] + '/max'] || {
                                        value: diffMeta.pointers[keys[i]].max,
                                        conflictingPaths: {}
                                    };
                                conflict[path + '/pointers/' + keys[i] + '/max'].conflictingPaths[opposingPath] = true;
                                opposingConflict.conflictingPaths[path + '/pointers/' + keys[i] + '/max'] = true;
                            }
                            if (diffMeta.pointers[keys[i]].min) {
                                conflict[path + '/pointers/' + keys[i] + '/min'] =
                                    conflict[path + '/pointers/' + keys[i] + '/min'] || {
                                        value: diffMeta.pointers[keys[i]].min,
                                        conflictingPaths: {}
                                    };
                                conflict[path + '/pointers/' + keys[i] + '/min'].conflictingPaths[opposingPath] = true;
                                opposingConflict.conflictingPaths[path + '/pointers/' + keys[i] + '/min'] = true;
                            }
                            relids = getDiffChildrenRelids(diffMeta.pointers[keys[i]]);
                            for (j = 0; j < relids.length; j++) {
                                tPath = getCommonPathForConcat(relids[j]);
                                conflict[path + '/pointers/' + keys[i] + '/' + tPath + '//'] =
                                    conflict[path + '/pointers/' + keys[i] + '/' + tPath + '//'] || {
                                        value: diffMeta.pointers[keys[i]][relids[j]],
                                        conflictingPaths: {}
                                    };
                                conflict[path + '/pointers/' + keys[i] + '/' + tPath + '//']
                                    .conflictingPaths[opposingPath] = true;
                                opposingConflict.conflictingPaths[path + '/pointers/' +
                                keys[i] + '/' + tPath + '//'] = true;
                            }
                        }
                    }
                }
            }
            //aspects
            //TODO
        }

        function gatherFullSetConflicts(diffSet, mine, path, opposingPath) {
            var relids = getDiffChildrenRelids(diffSet),
                i, keys, j, conflict, opposingConflict;

            //setting the conflicts
            if (mine === true) {
                conflict = _conflictMine;
                opposingConflict = _conflictTheirs[opposingPath];
            } else {
                conflict = _conflictTheirs;
                opposingConflict = _conflictMine[opposingPath];
            }

            //set attributes and registry entries
            keys = Object.keys(diffSet.attr || {});
            for (j = 0; j < keys.length; j++) {
                conflict[path + '/attr/' + keys[j]] =
                    conflict[path + '/attr/' + keys[j]] || {
                        value: diffSet.attr[keys[j]],
                        conflictingPaths: {}
                    };
                conflict[path + '/attr/' + keys[j]].conflictingPaths[opposingPath] = true;
                opposingConflict.conflictingPaths[path + '/attr/' + keys[j]] = true;
            }
            keys = Object.keys(diffSet.reg || {});
            for (j = 0; j < keys.length; j++) {
                conflict[path + '/reg/' + keys[j]] =
                    conflict[path + '/reg/' + keys[j]] || {
                        value: diffSet.reg[keys[j]],
                        conflictingPaths: {}
                    };
                conflict[path + '/reg/' + keys[j]].conflictingPaths[opposingPath] = true;
                opposingConflict.conflictingPaths[path + '/reg/' + keys[j]] = true;
            }

            for (i = 0; i < relids.length; i++) {
                if (diffSet[relids[i]] === CONSTANTS.TO_DELETE_STRING) {
                    //single conflict as the element was removed
                    conflict[path + '/' + relids[i] + '/'] = conflict[path + '/' + relids[i] + '/'] || {
                        value: CONSTANTS.TO_DELETE_STRING,
                        conflictingPaths: {}
                    };
                    conflict[path + '/' + relids[i] + '/'].conflictingPaths[opposingPath] = true;
                    opposingConflict.conflictingPaths[path + '/' + relids[i] + '/'] = true;
                } else {
                    keys = Object.keys(diffSet[relids[i]].attr || {});
                    for (j = 0; j < keys.length; j++) {
                        conflict[path + '/' + relids[i] + '//attr/' + keys[j]] =
                            conflict[path + '/' + relids[i] + '//attr/' + keys[j]] || {
                                value: diffSet[relids[i]].attr[keys[j]],
                                conflictingPaths: {}
                            };
                        conflict[path + '/' + relids[i] + '//attr/' + keys[j]].conflictingPaths[opposingPath] = true;
                        opposingConflict.conflictingPaths[path + '/' + relids[i] + '//attr/' + keys[j]] = true;
                    }
                    keys = Object.keys(diffSet[relids[i]].reg || {});
                    for (j = 0; j < keys.length; j++) {
                        conflict[path + '/' + relids[i] + '//reg/' + keys[j]] =
                            conflict[path + '/' + relids[i] + '//reg/' + keys[j]] || {
                                value: diffSet[relids[i]].reg[keys[j]],
                                conflictingPaths: {}
                            };
                        conflict[path + '/' + relids[i] + '//reg/' + keys[j]].conflictingPaths[opposingPath] = true;
                        opposingConflict.conflictingPaths[path + '/' + relids[i] + '//reg/' + keys[j]] = true;
                    }
                }
            }
        }

        function gatherFullNodeConflicts(diffNode, mine, path, opposingPath) {
            var conflict,
                opposingConflict,
                keys, i,
                createSingleKeyValuePairConflicts = function (pathBase, data) {
                    var keys, i;
                    keys = Object.keys(data);
                    for (i = 0; i < keys.length; i++) {
                        conflict[pathBase + '/' + keys[i]] = conflict[pathBase + '/' + keys[i]] || {
                            value: data[keys[i]],
                            conflictingPaths: {}
                        };
                        conflict[pathBase + '/' + keys[i]].conflictingPaths[opposingPath] = true;
                        opposingConflict.conflictingPaths[pathBase + '/' + keys[i]] = true;
                    }
                };

            //setting the conflicts
            if (mine === true) {
                conflict = _conflictMine;
                opposingConflict = _conflictTheirs[opposingPath];
            } else {
                conflict = _conflictTheirs;
                opposingConflict = _conflictMine[opposingPath];
            }
            ASSERT(opposingConflict);
            //if the node was moved we should make a conflict for the whole node as well
            if (diffNode.movedFrom) {
                conflict[path] = conflict[path] || {value: path, conflictingPaths: {}};
                conflict[path].conflictingPaths[opposingPath] = true;
                opposingConflict.conflictingPaths[path] = true;
            }
            createSingleKeyValuePairConflicts(path + '/attr', diffNode.attr || {});
            createSingleKeyValuePairConflicts(path + '/reg', diffNode.reg || {});
            createSingleKeyValuePairConflicts(path + '/pointer', diffNode.pointer || {});

            if (diffNode.set) {
                if (diffNode.set === CONSTANTS.TO_DELETE_STRING) {
                    conflict[path + '/set'] = conflict[path + '/set'] || {
                        value: CONSTANTS.TO_DELETE_STRING,
                        conflictingPaths: {}
                    };
                    conflict[path + '/set'].conflictingPaths[opposingPath] = true;
                    opposingConflict.conflictingPaths[path + '/set'] = true;
                } else {
                    keys = Object.keys(diffNode.set);
                    for (i = 0; i < keys.length; i++) {
                        if (diffNode.set[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                            conflict[path + '/set/' + keys[i]] = conflict[path + '/set/' + keys[i]] || {
                                value: CONSTANTS.TO_DELETE_STRING,
                                conflictingPaths: {}
                            };
                            conflict[path + '/set/' + keys[i]].conflictingPaths[opposingPath] = true;
                            opposingConflict.conflictingPaths[path + '/set/' + keys[i]] = true;
                        } else {
                            gatherFullSetConflicts(diffNode.set[keys[i]], mine, path + '/set/' + keys[i], opposingPath);
                        }
                    }
                }
            }

            if (diffNode.meta) {
                gatherFullMetaConflicts(diffNode.meta, mine, path + '/meta', opposingPath);
            }

            //if the opposing item is theirs, we have to recursively go down in our changes
            if (mine) {
                keys = getDiffChildrenRelids(diffNode);
                for (i = 0; i < keys.length; i++) {
                    gatherFullNodeConflicts(diffNode[keys[i]], true, path + '/' + keys[i], opposingPath);
                }
            }

        }

        function concatSingleKeyValuePairs(path, base, extension) {
            var keys, i, temp;
            keys = Object.keys(extension);
            for (i = 0; i < keys.length; i++) {
                temp = extension[keys[i]];
                if (typeof temp === 'string' && temp !== CONSTANTS.TO_DELETE_STRING) {
                    temp = getCommonPathForConcat(temp);
                }
                if (base[keys[i]] !== undefined && CANON.stringify(base[keys[i]]) !== CANON.stringify(temp)) {
                    //conflict
                    _conflictMine[path + '/' + keys[i]] = {value: base[keys[i]], conflictingPaths: {}};
                    _conflictTheirs[path + '/' + keys[i]] = {value: extension[keys[i]], conflictingPaths: {}};
                    _conflictMine[path + '/' + keys[i]].conflictingPaths[path + '/' + keys[i]] = true;
                    _conflictTheirs[path + '/' + keys[i]].conflictingPaths[path + '/' + keys[i]] = true;
                } else {
                    base[keys[i]] = extension[keys[i]];
                }
            }
        }

        function concatSet(path, base, extension) {
            var names = Object.keys(extension),
                members, i, j, memberPath;

            for (i = 0; i < names.length; i++) {
                if (base[names[i]]) {
                    if (base[names[i]] === CONSTANTS.TO_DELETE_STRING) {
                        if (extension[names[i]] !== CONSTANTS.TO_DELETE_STRING) {
                            //whole set conflict
                            _conflictMine[path + '/' + names[i]] = {
                                value: CONSTANTS.TO_DELETE_STRING,
                                conflictingPaths: {}
                            };
                            gatherFullSetConflicts(extension[names[i]],
                                false, path + '/' + names[i], path + '/' + names[i]);
                        }
                    } else {
                        if (extension[names[i]] === CONSTANTS.TO_DELETE_STRING) {
                            //whole set conflict
                            _conflictTheirs[path + '/' + names[i]] = {
                                value: CONSTANTS.TO_DELETE_STRING,
                                conflictingPaths: {}
                            };
                            gatherFullSetConflicts(base[names[i]], true, path + '/' + names[i], path + '/' + names[i]);
                        } else {
                            //now check the set attribute and registry differences
                            if (base[names[i]].attr && extension[names[i]].attr) {
                                concatSingleKeyValuePairs(path + '/' + names[i] + '/attr',
                                    base[names[i]].attr,
                                    extension[names[i]].attr);
                            }
                            if (base[names[i]].reg && extension[names[i]].reg) {
                                concatSingleKeyValuePairs(path + '/' + names[i] + '/reg',
                                    base[names[i]].reg,
                                    extension[names[i]].reg);
                            }
                            //now we can only have member or sub-member conflicts...
                            members = getDiffChildrenRelids(extension[names[i]]);
                            for (j = 0; j < members.length; j++) {
                                memberPath = getCommonPathForConcat(members[j]);
                                if (base[names[i]][memberPath]) {
                                    if (base[names[i]][memberPath] === CONSTANTS.TO_DELETE_STRING) {
                                        if (extension[names[i]][members[j]] !== CONSTANTS.TO_DELETE_STRING) {
                                            //whole member conflict
                                            _conflictMine[path + '/' + names[i] + '/' + memberPath + '//'] = {
                                                value: CONSTANTS.TO_DELETE_STRING,
                                                conflictingPaths: {}
                                            };
                                            gatherFullNodeConflicts(extension[names[i]][members[j]],
                                                false,
                                                path + '/' + names[i] + '/' + memberPath + '//', path +
                                                '/' + names[i] + '/' + memberPath + '//');
                                        }
                                    } else {
                                        if (extension[names[i]][members[j]] === CONSTANTS.TO_DELETE_STRING) {
                                            //whole member conflict
                                            _conflictTheirs[path + '/' + names[i] + '/' + memberPath + '//'] = {
                                                value: CONSTANTS.TO_DELETE_STRING,
                                                conflictingPaths: {}
                                            };
                                            gatherFullNodeConflicts(base[names[i]][memberPath],
                                                true,
                                                path + '/' + names[i] + '/' + memberPath + '//', path +
                                                '/' + names[i] + '/' + memberPath + '//');
                                        } else {
                                            if (extension[names[i]][members[j]].attr) {
                                                if (base[names[i]][memberPath].attr) {
                                                    concatSingleKeyValuePairs(
                                                        path + '/' + names[i] + '/' + memberPath + '/' + '/attr',
                                                        base[names[i]][memberPath].attr,
                                                        extension[names[i]][members[j]].attr);
                                                } else {
                                                    base[names[i]][memberPath].attr =
                                                        extension[names[i]][members[j]].attr;
                                                }
                                            }
                                            if (extension[names[i]][members[j]].reg) {
                                                if (base[names[i]][memberPath].reg) {
                                                    concatSingleKeyValuePairs(
                                                        path + '/' + names[i] + '/' + memberPath + '/' + '/reg',
                                                        base[names[i]][memberPath].reg,
                                                        extension[names[i]][members[j]].reg);
                                                } else {
                                                    base[names[i]][memberPath].reg =
                                                        extension[names[i]][members[j]].reg;
                                                }
                                            }

                                        }
                                    }
                                } else {
                                    //concat
                                    base[names[i]][memberPath] = extension[names[i]][members[j]];
                                }
                            }
                        }
                    }
                } else {
                    //simple concatenation
                    //TODO the path for members should be replaced here as well...
                    base[names[i]] = extension[names[i]];
                }
            }
        }

        function concatMeta(path, base, extension) {
            var keys, i, tPath, j, paths, t2Path,
                mergeMetaItems = function (bPath, bData, eData) {
                    var bKeys, tKeys, i, tPath, t2Path;
                    //delete checks
                    if (bData === CONSTANTS.TO_DELETE_STRING || eData === CONSTANTS.TO_DELETE_STRING) {
                        if (CANON.stringify(bData) !== CANON.stringify(eData)) {
                            _conflictMine[bPath] = _conflictMine[bPath] || {value: bData, conflictingPaths: {}};
                            _conflictMine[bPath].conflictingPaths[bPath] = true;
                            _conflictTheirs[bPath] = _conflictTheirs[bPath] || {value: eData, conflictingPaths: {}};
                            _conflictTheirs[bPath].conflictingPaths[bPath] = true;
                        }
                    } else {
                        //max
                        if (eData.max) {
                            if (bData.max && bData.max !== eData.max) {
                                tPath = bPath + '/max';
                                _conflictMine[tPath] = _conflictMine[tPath] || {
                                    value: bData.max,
                                    conflictingPaths: {}
                                };
                                _conflictMine[tPath].conflictingPaths[tPath] = true;
                                _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                    value: eData.max,
                                    conflictingPaths: {}
                                };
                                _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                            } else {
                                bData.max = eData.max;
                            }
                        }
                        //min
                        if (eData.min) {
                            if (bData.min && bData.min !== eData.min) {
                                tPath = bPath + '/min';
                                _conflictMine[tPath] = _conflictMine[tPath] || {
                                    value: bData.min,
                                    conflictingPaths: {}
                                };
                                _conflictMine[tPath].conflictingPaths[tPath] = true;
                                _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                    value: eData.min,
                                    conflictingPaths: {}
                                };
                                _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                            } else {
                                bData.min = eData.min;
                            }
                        }
                        //targets
                        bKeys = getDiffChildrenRelids(bData);
                        tKeys = getDiffChildrenRelids(eData);
                        for (i = 0; i < tKeys.length; i++) {
                            tPath = getCommonPathForConcat(tKeys[i]);
                            if (bKeys.indexOf(tPath) !== -1 && CANON.stringify(bData[tPath]) !==
                                CANON.stringify(eData[tKeys[i]])) {

                                t2Path = tPath;
                                tPath = bPath + '/' + tPath + '//';
                                _conflictMine[tPath] = _conflictMine[tPath] || {
                                    value: bData[t2Path],
                                    conflictingPaths: {}
                                };
                                _conflictMine[tPath].conflictingPaths[tPath] = true;
                                _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                    value: eData[tKeys[i]],
                                    conflictingPaths: {}
                                };
                                _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                            } else {
                                bData[tPath] = eData[tKeys[i]];
                            }
                        }
                    }
                };
            if (CANON.stringify(base) !== CANON.stringify(extension)) {
                if (base === CONSTANTS.TO_DELETE_STRING) {
                    _conflictMine[path] = _conflictMine[path] || {
                        value: CONSTANTS.TO_DELETE_STRING,
                        conflictingPaths: {}
                    };
                    gatherFullMetaConflicts(extension, false, path, path);
                } else {
                    if (extension === CONSTANTS.TO_DELETE_STRING) {
                        _conflictTheirs[path] = _conflictTheirs[path] || {
                            value: CONSTANTS.TO_DELETE_STRING,
                            conflictingPaths: {}
                        };
                        gatherFullMetaConflicts(base, true, path, path);
                    } else {
                        //now check for sub-meta conflicts

                        //children
                        if (extension.children) {
                            if (base.children) {
                                mergeMetaItems(path + '/children', base.children, extension.children);
                            } else {
                                //we just simply merge the extension's
                                base.children = extension.children;
                            }
                        }
                        //pointers
                        if (extension.pointers) {
                            if (base.pointers) {
                                //complete deletion
                                if (base.pointers === CONSTANTS.TO_DELETE_STRING ||
                                    extension.pointers === CONSTANTS.TO_DELETE_STRING) {
                                    if (CANON.stringify(base.pointers) !== CANON.stringify(extension.pointers)) {
                                        tPath = path + '/pointers';
                                        _conflictMine[tPath] = _conflictMine[tPath] || {
                                            value: base.pointers,
                                            conflictingPaths: {}
                                        };
                                        _conflictMine[tPath].conflictingPaths[tPath] = true;
                                        _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                            value: extension.pointers,
                                            conflictingPaths: {}
                                        };
                                        _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                                    }
                                } else {
                                    keys = Object.keys(extension.pointers);
                                    for (i = 0; i < keys.length; i++) {
                                        if (base.pointers[keys[i]]) {
                                            mergeMetaItems(path + '/pointers/' + keys[i], base.pointers[keys[i]],
                                                extension.pointers[keys[i]]);
                                        } else {
                                            base.pointers[keys[i]] = extension.pointers[keys[i]];
                                        }
                                    }
                                }
                            } else {
                                base.pointers = extension.pointers;
                            }
                        }
                        //attributes
                        if (extension.attributes) {
                            if (base.attributes) {
                                if (extension.attributes === CONSTANTS.TO_DELETE_STRING ||
                                    base.attributes === CONSTANTS.TO_DELETE_STRING) {
                                    if (CANON.stringify(base.attributes) !== CANON.stringify(extension.attributes)) {
                                        tPath = path + '/attributes';
                                        _conflictMine[tPath] = _conflictMine[tPath] || {
                                            value: base.attributes,
                                            conflictingPaths: {}
                                        };
                                        _conflictMine[tPath].conflictingPaths[tPath] = true;
                                        _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                            value: extension.attributes,
                                            conflictingPaths: {}
                                        };
                                        _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                                    }
                                } else {
                                    keys = Object.keys(extension.attributes);
                                    for (i = 0; i < keys.length; i++) {
                                        if (base.attributes[keys[i]]) {
                                            if (extension.attributes[keys[i]] === CONSTANTS.TO_DELETE_STRING ||
                                                base.attributes[keys[i]] === CONSTANTS.TO_DELETE_STRING) {

                                                if (CANON.stringify(base.attributes[keys[i]]) !==
                                                    CANON.stringify(extension.attributes[keys[i]])) {

                                                    tPath = path + '/attributes/' + [keys[i]];
                                                    _conflictMine[tPath] = _conflictMine[tPath] || {
                                                        value: base.attributes[keys[i]],
                                                        conflictingPaths: {}
                                                    };
                                                    _conflictMine[tPath].conflictingPaths[tPath] = true;
                                                    _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                                        value: extension.attributes[keys[i]],
                                                        conflictingPaths: {}
                                                    };
                                                    _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                                                }
                                            } else {
                                                concatSingleKeyValuePairs(path + '/attributes/' + keys[i],
                                                    base.attributes[keys[i]], extension.attributes[keys[i]]);
                                            }
                                        } else {
                                            base.attributes[keys[i]] = extension.attributes[keys[i]];
                                        }
                                    }

                                }
                            } else {
                                base.attributes = extension.attributes;
                            }
                        }

                        //aspects
                        if (extension.aspects) {
                            if (base.aspects) {
                                if (extension.aspects === CONSTANTS.TO_DELETE_STRING ||
                                    base.aspects === CONSTANTS.TO_DELETE_STRING) {
                                    if (CANON.stringify(base.aspects) !== CANON.stringify(extension.aspects)) {
                                        tPath = path + '/aspects';
                                        _conflictMine[tPath] = _conflictMine[tPath] || {
                                            value: base.aspects,
                                            conflictingPaths: {}
                                        };
                                        _conflictMine[tPath].conflictingPaths[tPath] = true;
                                        _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                            value: extension.aspects,
                                            conflictingPaths: {}
                                        };
                                        _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                                    }
                                } else {
                                    keys = Object.keys(extension.aspects);
                                    for (i = 0; i < keys.length; i++) {
                                        if (base.aspects[keys[i]]) {
                                            if (extension.aspects[keys[i]] === CONSTANTS.TO_DELETE_STRING ||
                                                base.aspects[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                                                if (CANON.stringify(base.aspects[keys[i]]) !==
                                                    CANON.stringify(extension.aspects[keys[i]])) {
                                                    tPath = path + '/aspects/' + keys[i];
                                                    _conflictMine[tPath] = _conflictMine[tPath] || {
                                                        value: base.aspects[keys[i]],
                                                        conflictingPaths: {}
                                                    };
                                                    _conflictMine[tPath].conflictingPaths[tPath] = true;
                                                    _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                                        value: extension.aspects[keys[i]],
                                                        conflictingPaths: {}
                                                    };
                                                    _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                                                }
                                            } else {
                                                paths = Object.keys(extension.aspects[keys[i]]);
                                                for (j = 0; j < paths.length; j++) {
                                                    tPath = getCommonPathForConcat(paths[j]);
                                                    if (base.aspects[keys[i]][tPath]) {
                                                        if (CANON.stringify(base.aspects[keys[i]][tPath]) !==
                                                            CANON.stringify(extension.aspects[keys[i]][paths[j]])) {
                                                            t2Path = tPath;
                                                            tPath = path + '/aspects/' + keys[i] + '/' + tPath + '//';
                                                            _conflictMine[tPath] = _conflictMine[tPath] || {
                                                                value: base.aspects[keys[i]][t2Path],
                                                                conflictingPaths: {}
                                                            };
                                                            _conflictMine[tPath].conflictingPaths[tPath] = true;
                                                            _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                                                value: extension.aspects[keys[i]][paths[j]],
                                                                conflictingPaths: {}
                                                            };
                                                            _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                                                        }
                                                    } else {
                                                        base.aspects[keys[i]][tPath] =
                                                            extension.aspects[keys[i]][paths[j]];
                                                    }
                                                }
                                            }
                                        } else {
                                            base.aspects[keys[i]] = extension.aspects[keys[i]];
                                        }
                                    }
                                }
                            } else {
                                base.aspects = extension.aspects;
                            }
                        }
                    }
                }
            }
        }

        function tryToConcatNodeChange(extNode, path) {
            var guid = extNode.guid,
                oGuids = getObstructiveGuids(extNode),
                baseNode = getNodeByGuid(_concatBase, guid),
                basePath = getPathOfGuid(_concatBase, guid),
                realBaseNode = baseNode,
                i, tPath,
                relids = getDiffChildrenRelids(extNode);

            if (extNode.removed === true) {
                if (baseNode !== null && baseNode.removed !== true && hasRealChange(baseNode)) {
                    // we cannot simply merge the removal data-wise
                } else {
                    //we simply concat the deletion
                    insertAtPath(_concatBase, path, extNode);
                }
                //we still need to check if some instance go changed in the other branch
                oGuids = getWhomIObstructGuids(guid);
                ASSERT(oGuids.length > 0);
                for (i = 0; i < oGuids.length; i++) {
                    baseNode = getNodeByGuid(_concatBase, oGuids[i]);
                    if (baseNode !== null && baseNode.removed !== true && hasRealChange(baseNode)) {
                        tPath = path + '/removed';
                        _conflictTheirs[tPath] = _conflictTheirs[tPath] || {value: true, conflictingPaths: {}};
                        basePath = getPathOfGuid(_concatBase, oGuids[i]);
                        gatherFullNodeConflicts(baseNode, true, basePath, tPath);
                    }
                }
            } else {
                if (oGuids.length > 0) {
                    for (i = 0; i < oGuids.length; i++) {
                        baseNode = getNodeByGuid(_concatBase, oGuids[i]);
                        basePath = getPathOfGuid(_concatBase, oGuids[i]);
                        if (hasRealChange(extNode)) {
                            _conflictMine[basePath + '/removed'] = _conflictMine[basePath + '/removed'] || {
                                value: true,
                                conflictingPaths: {}
                            };
                            gatherFullNodeConflicts(extNode, false, path, basePath + '/removed');
                        } else {
                            _conflictTheirs[basePath + '/removed'] = _conflictTheirs[basePath + '/removed'] || {
                                value: true,
                                conflictingPaths: {}
                            };
                            gatherFullNodeConflicts(realBaseNode, true, path, basePath + '/removed');
                        }
                    }
                } else if (baseNode) {
                    //here we are able to check the sub-node conflicts
                    //check double moves - we do not care if they moved under the same parent
                    if (extNode.movedFrom) {
                        if (baseNode.movedFrom && path !== basePath) {
                            _conflictMine[basePath] = _conflictMine[basePath] || {
                                value: 'move',
                                conflictingPaths: {}
                            };
                            _conflictTheirs[path] = _conflictTheirs[path] || {value: 'move', conflictingPaths: {}};
                            _conflictMine[basePath].conflictingPaths[path] = true;
                            _conflictTheirs[path].conflictingPaths[basePath] = true;
                            //we keep the node where it is, but synchronize the paths
                            path = basePath;
                        } else if (path !== basePath) {
                            //first we move the base object to its new path
                            //we copy the moved from information right here
                            baseNode.movedFrom = extNode.movedFrom;
                            insertAtPath(_concatBase, path, baseNode);
                            removePathFromDiff(_concatBase, basePath);
                            baseNode = getNodeByGuid(_concatBase, guid);
                            basePath = getPathOfGuid(_concatBase, guid);
                            ASSERT(path === basePath);
                        }
                    }

                    ASSERT(basePath === path || baseNode.movedFrom === path);
                    path = basePath; //the base was moved

                    //and now the sub-node conflicts
                    if (extNode.attr) {
                        if (baseNode.attr) {
                            concatSingleKeyValuePairs(path + '/attr', baseNode.attr, extNode.attr);
                        } else {
                            insertAtPath(_concatBase, path + '/attr', extNode.attr);
                        }
                    }
                    if (extNode.reg) {
                        if (baseNode.reg) {
                            concatSingleKeyValuePairs(path + '/reg', baseNode.reg, extNode.reg);
                        } else {
                            insertAtPath(_concatBase, path + '/reg', extNode.reg);
                        }
                    }
                    if (extNode.pointer) {
                        if (baseNode.pointer) {
                            concatSingleKeyValuePairs(path + '/pointer', baseNode.pointer, extNode.pointer);
                        } else {
                            insertAtPath(_concatBase, path + '/pointer', extNode.pointer);
                        }
                    }
                    if (extNode.set) {
                        if (baseNode.set) {
                            concatSet(path + '/set', baseNode.set, extNode.set);
                        } else {
                            insertAtPath(_concatBase, path + '/set', extNode.set);
                        }
                    }
                    if (extNode.meta) {
                        if (baseNode.meta) {
                            concatMeta(path + '/meta', baseNode.meta, extNode.meta);
                        } else {
                            insertAtPath(_concatBase, path + '/meta', extNode.meta);
                        }
                    }
                } else if (typeof path === 'string' && path.length > 0) {
                    //there is no basenode so we can concat the whole node
                    insertAtPath(_concatBase, path, getSingleNode(extNode));
                }
            }

            //here comes the recursion
            for (i = 0; i < relids.length; i++) {
                tryToConcatNodeChange(extNode[relids[i]], path + CONSTANTS.PATH_SEP + relids[i]);
            }

        }

        function generateConflictItems(mine, theirs) {
            var items = [], item,
                keys, i, j, conflicts, diffNode;
            keys = Object.keys(_conflictMine);

            for (i = 0; i < keys.length; i++) {
                conflicts = Object.keys(_conflictMine[keys[i]].conflictingPaths || {});
                ASSERT(conflicts.length > 0);
                for (j = 0; j < conflicts.length; j++) {
                    item = {
                        selected: 'mine',
                        mine: {
                            path: keys[i],
                            info: keys[i].replace(/\//g, ' / '),
                            value: _conflictMine[keys[i]].value,
                            nodePath: DIFF.pathToObject(keys[i]).node
                        },
                        theirs: {
                            path: conflicts[j],
                            info: conflicts[j].replace(/\//g, ' / '),
                            value: _conflictTheirs[conflicts[j]].value,
                            nodePath: DIFF.pathToObject(conflicts[j]).node
                        }
                    };
                    diffNode = getPathOfDiff(mine, item.mine.nodePath);
                    if (typeof diffNode.collidingRelid === 'string') {
                        item.mine.originalNodePath = getParentPath(item.mine.nodePath) +
                            CONSTANTS.PATH_SEP + diffNode.collidingRelid;
                    }

                    diffNode = getPathOfDiff(theirs, item.theirs.nodePath);
                    if (typeof diffNode.collidingRelid === 'string') {
                        item.theirs.originalNodePath = getParentPath(item.theirs.nodePath) +
                            CONSTANTS.PATH_SEP + diffNode.collidingRelid;
                    }
                    items.push(item);

                }
            }
            return items;
        }

        function harmonizeConflictPaths(diff) {
            var relids = getDiffChildrenRelids(diff),
                keys, i, members, j;

            keys = Object.keys(diff.pointer || {});
            for (i = 0; i < keys.length; i++) {
                diff.pointer[keys[i]] = getCommonPathForConcat(diff.pointer[keys[i]]);
            }
            keys = Object.keys(diff.set || {});
            for (i = 0; i < keys.length; i++) {
                members = Object.keys(diff.set[keys[i]] || {});
                for (j = 0; j < members.length; j++) {
                    if (members[j] !== getCommonPathForConcat(members[j])) {
                        diff.set[keys[i]][getCommonPathForConcat(members[j])] = diff.set[keys[i]][members[j]];
                        delete diff.set[keys[i]][members[j]];
                    }
                }
            }

            //TODO we have to do the meta as well
            for (i = 0; i < relids.length; i++) {
                harmonizeConflictPaths(diff[relids[i]]);
            }
        }

        function depthOfPath(path) {
            ASSERT(typeof path === 'string');
            return path.split('/').length;
        }

        function resolveMoves(resolveObject) {
            var i, moves = {},
                filteredItems = [],
                path,
                moveBaseOfPath = function (path) {
                    var keys = Object.keys(moves),
                        i, maxDepth = -1,
                        base = null;
                    for (i = 0; i < keys.length; i++) {
                        if (path.indexOf(keys[i]) === 1 && depthOfPath(keys[i]) > maxDepth) {
                            base = keys[i];
                            maxDepth = depthOfPath(keys[i]);
                        }
                    }
                    return base;
                };
            for (i = 0; i < resolveObject.items.length; i++) {
                if (resolveObject.items[i].selected === 'theirs' && resolveObject.items[i].theirs.value === 'move') {
                    moves[resolveObject.items[i].mine.path] = resolveObject.items[i].theirs.path;
                    //and we also make the move
                    insertAtPath(resolveObject.merge,
                        resolveObject.items[i].theirs.path,
                        getPathOfDiff(resolveObject.merge, resolveObject.items[i].mine.path));
                    removePathFromDiff(resolveObject.merge, resolveObject.items[i].mine.path);
                } else {
                    filteredItems.push(resolveObject.items[i]);
                }
            }
            resolveObject.items = filteredItems;

            //in a second run we modify all sub-path of the moves paths
            for (i = 0; i < resolveObject.items.length; i++) {
                if (resolveObject.items[i].selected === 'theirs') {
                    path = moveBaseOfPath(resolveObject.items[i].theirs.path);
                    if (path) {
                        resolveObject.items[i].theirs.path =
                            resolveObject.items[i].theirs.path.replace(path, moves[path]);
                    }
                    path = moveBaseOfPath(resolveObject.items[i].mine.path);
                    if (path) {
                        resolveObject.items[i].mine.path = resolveObject.items[i].mine.path.replace(path, moves[path]);
                    }
                }
            }
        }

        //</editor-fold>

        //<editor-fold=Added Methods>

        // FIXME: It really looks like the diff requires that no nodes are mutated. This must be documented somewhere.
        // FIXME: Maybe checking for isMutated in core.js at the roots are enough..
        this.nodeDiff = function (source, target) {
            var diff = {
                children: childrenDiff(source, target),
                attr: attrDiff(source, target),
                reg: regDiff(source, target),
                pointer: pointerDiff(source, target),
                set: setDiff(source, target),
                meta: metaDiff(source, target)
            };

            normalize(diff);

            return isEmptyNodeDiff(diff) ? null : diff;
        };

        this.generateTreeDiff = function (sRoot, tRoot) {
            var yetToCompute = {},
                diffMoves = {};

            return TASYNC.call(function (diff) {

                return checkRound(yetToCompute, diff, diffMoves, true);
            }, updateDiff(sRoot, tRoot, yetToCompute));
        };

        this.generateLightTreeDiff = function (sRoot, tRoot) {
            var yetToCompute = {};
            return updateDiff(sRoot, tRoot, yetToCompute);
        };

        this.applyTreeDiff = function (root, diff) {
            // return TASYNC.join(makeInitialContainmentChanges(root, diff), applyNodeChange(root, '', diff));
            // return makeInitialContainmentChanges(root,diff);
            var done = makeInitialContainmentChanges(root, diff);

            done = TASYNC.call(setBaseRelationsOfNewNodes, root, '', diff, done);

            return TASYNC.call(function () {
                return applyNodeChange(root, '', diff);
            }, done);
            // done = TASYNC.call(applyNodeChange, root, '', diff, done);

            // return done;
        };

        /**
         *
         * @param {object} base - diff1
         * @param {object} extension - diff2
         *
         * @returns {object}
         */
        this.tryToConcatChanges = function (base, extension) {
            var result = {};
            _conflictMine = {};
            _conflictTheirs = {};
            _concatBase = JSON.parse(JSON.stringify(base));
            _concatExtension = JSON.parse(JSON.stringify(extension));
            _concatBaseRemovals = {};
            _concatMoves = {
                getBaseSourceFromDestination: {},
                getBaseDestinationFromSource: {},
                getExtensionSourceFromDestination: {},
                getExtensionDestinationFromSource: {}
            };

            fixInheritanceCollision('', _concatBase, _concatExtension, true);
            fixInheritanceCollision('', _concatExtension, _concatBase, false);
            normalize(_concatBase);
            normalize(_concatExtension);

            completeConcatBase(_concatBase, _concatExtension);
            getMoveSources(_concatBase,
                '', _concatMoves.getBaseSourceFromDestination, _concatMoves.getBaseDestinationFromSource);
            getMoveSources(_concatExtension,
                '', _concatMoves.getExtensionSourceFromDestination, _concatMoves.getExtensionDestinationFromSource);
            getConcatBaseRemovals(_concatBase);
            getConcatBaseRemovals(_concatExtension);

            fixCollision('', null, _concatBase, _concatExtension);
            tryToConcatNodeChange(_concatExtension, '');

            result.items = generateConflictItems(_concatBase, _concatExtension);
            result.mine = _conflictMine;
            result.theirs = _conflictTheirs;
            result.merge = _concatBase;
            harmonizeConflictPaths(result.merge);

            return result;
        };

        this.applyResolution = function (conflictObject) {
            //we apply conflict items to the merge and return it as a diff
            var i;
            resolveMoves(conflictObject);
            for (i = 0; i < conflictObject.items.length; i++) {
                if (conflictObject.items[i].selected !== 'mine') {
                    removePathFromDiff(conflictObject.merge, conflictObject.items[i].mine.path);
                    if (conflictObject.items[i].selected === 'theirs') {
                        insertAtPath(conflictObject.merge,
                            conflictObject.items[i].theirs.path, conflictObject.items[i].theirs.value);
                    } else {
                        insertAtPath(conflictObject.merge,
                            conflictObject.items[i].other.path, conflictObject.items[i].other.value);
                    }

                }
            }

            return conflictObject.merge;
        };
        //</editor-fold>
    }

    return DiffCore;
});

/*globals define*/
/*eslint-env node, browser*/
/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/metacachecore',[
    'common/core/CoreAssert',
    'common/core/tasync',
    'common/core/constants'
], function (ASSERT, TASYNC, CONSTANTS) {
    'use strict';

    var MetaCacheCore = function (innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized MetaCacheCore');

        //<editor-fold=Helper Functions>
        function loadMetaSet(root) {
            var paths = innerCore.getMemberPaths(root, CONSTANTS.META_SET_NAME),
                i,
                metaNodes = [];

            return TASYNC.call(function () {
                for (i = 0; i < paths.length; i += 1) {
                    metaNodes.push(innerCore.loadByPath(root, paths[i]));
                }

                return TASYNC.lift(metaNodes);
            }, self.loadPaths(self.getHash(root), JSON.parse(JSON.stringify(paths))));
        }

        //</editor-fold>

        //<editor-fold=Modified Methods>
        this.loadRoot = function (hash) {
            return TASYNC.call(function (root) {
                return TASYNC.call(function (elements) {
                    var i = 0;
                    root.metaNodes = {};
                    for (i = 0; i < elements.length; i += 1) {
                        // It can happen that some elements just been removed during load because of missing base.
                        if (elements[i]) {
                            root.metaNodes[innerCore.getPath(elements[i])] = elements[i];
                        }
                    }
                    return root;
                }, loadMetaSet(root));
            }, innerCore.loadRoot(hash));
        };

        //functions where the cache may needs to be updated
        this.createNode = function (parameters) {
            var node = innerCore.createNode(parameters);

            if (!parameters || !parameters.parent) {
                //a root just have been created
                node.metaNodes = {};
            }

            return node;
        };

        this.addMember = function (node, setName, member) {
            var root = self.getRoot(node);
            innerCore.addMember(node, setName, member);

            //check if our cache needs to be updated
            if (setName === CONSTANTS.META_SET_NAME && self.getPath(node) === self.getPath(root)) {
                root.metaNodes[self.getPath(member)] = member;
            }
        };

        this.delMember = function (node, setName, memberPath) {
            var root = self.getRoot(node);
            innerCore.delMember(node, setName, memberPath);

            //check if our cache needs to be updated
            if (setName === CONSTANTS.META_SET_NAME && self.getPath(node) === self.getPath(root)) {
                delete root.metaNodes[memberPath];
            }
        };

        this.deleteNode = function (node, technical) {
            var root = self.getRoot(node);
            if (root.metaNodes[self.getPath(node)]) {
                delete root.metaNodes[self.getPath(node)];
            }
            innerCore.deleteNode(node, technical);
        };

        this.moveNode = function (node, parent) {
            var root = self.getRoot(node),
                oldpath = self.getPath(node),
                moved = innerCore.moveNode(node, parent);

            if (root.metaNodes[oldpath]) {
                delete root.metaNodes[oldpath];
                root.metaNodes[self.getPath(moved)] = moved;
            }

            return moved;
        };
        //</editor-fold>

        //<editor-fold=Added Methods>
        this.isMetaNode = function (node) {
            var root = self.getRoot(node);
            if (root.metaNodes && root.metaNodes[self.getPath(node)]) {
                return true;
            }

            return false;
        };

        this.getAllMetaNodes = function (node) {
            var root = self.getRoot(node);

            if (root.metaNodes) {
                return root.metaNodes;
            }

            return {};
        };

        this.getFCO = function (node) {
            var root = self.getRoot(node),
                key;

            for (key in root.metaNodes) {
                return self.getBaseRoot(root.metaNodes[key]);
            }

            return null; //if there is no object on META, there is no FCO!!! 
        };

        //</editor-fold>
    };

    return MetaCacheCore;
}
);
/*globals define*/
/*eslint-env node, browser*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/mixincore',[
    'common/core/CoreAssert',
    'common/core/tasync',
    'common/util/canon',
    'common/core/constants'
], function (ASSERT, TASYNC, CANON, CONSTANTS) {
    'use strict';

    var MixinCore = function (innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            key,
            self = this;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized MixinCore');

        //<editor-fold=Helper Functions>

        function realNode(node) { //TODO we have to make some more sophisticated distinction
            if (self.getPath(node).indexOf('_') !== -1) {
                return false;
            }
            return true;
        }

        function getOrderedMixinList(node, cache) {
            var path = innerCore.getPath(node),
                paths,
                metaNodes,
                helper,
                orderedList,
                guid,
                i;

            if (cache && cache.orderedMixinList && cache.orderedMixinList[path]) {
                return cache.orderedMixinList[path];
            }

            paths = innerCore.getOwnMemberPaths(node, CONSTANTS.MIXINS_SET);
            helper = {};
            orderedList = [];

            if (paths.length > 0) {
                metaNodes = self.getAllMetaNodes(node);

                for (i = 0; i < paths.length; i += 1) {
                    if (metaNodes[paths[i]]) {
                        guid = self.getGuid(metaNodes[paths[i]]);
                        helper[guid] = paths[i];
                        orderedList.push(guid);
                    }

                }

                orderedList.sort();

                for (i = 0; i < orderedList.length; i += 1) {
                    orderedList[i] = metaNodes[helper[orderedList[i]]];
                }
            }

            if (cache && cache.orderedMixinList) {
                cache.orderedMixinList[path] = orderedList;
            }

            return orderedList;
        }

        function getNodeDictionary(node, paths) {
            var allMetaNodes = self.getAllMetaNodes(node),
                dictionary = {},
                i;

            for (i = 0; i < paths.length; i += 1) {
                if (allMetaNodes[paths[i]]) {
                    dictionary[paths[i]] = allMetaNodes[paths[i]];
                }
            }

            return dictionary;
        }

        function extendUniqueArray(base, extension) {
            var i;

            for (i = 0; i < extension.length; i += 1) {
                if (base.indexOf(extension[i]) === -1) {
                    base.push(extension[i]);
                }
            }
        }

        function getExtendedUniqueKeyedObject(base, extension) {
            var extended = {},
                key;
            for (key in base) {
                extended[key] = base[key];
            }

            for (key in extension) {
                if (!base[key]) {
                    extended[key] = extension[key];
                }
            }

            return extended;
        }

        function getValidNames(node, getter, alreadyVisited) {
            var base = self.getBase(node),
                path = self.getPath(node),
                names,
                mixins = getOrderedMixinList(node),
                i;

            if (alreadyVisited[path]) {
                return [];
            }

            if (base) {
                names = getValidNames(base, getter, alreadyVisited);
            } else {
                names = [];
            }

            extendUniqueArray(names, getter(node));
            alreadyVisited[path] = true;

            for (i = 0; i < mixins.length; i += 1) {
                extendUniqueArray(names, getValidNames(mixins[i], getter, alreadyVisited));
            }

            return names;
        }

        function getFirstMatchingRuleHolder(node, name, getter, alreadyVisited) {
            var base = self.getBase(node),
                path = self.getPath(node),
                mixins = getOrderedMixinList(node),
                ruleHolder = null,
                i;

            if (alreadyVisited[path]) {
                return null;
            }

            //when it comes to rule holder, always the given node's own rule-set is the first
            alreadyVisited[path] = true;
            if (getter(node).indexOf(name) !== -1) {
                return node;
            }

            if (base) {
                ruleHolder = getFirstMatchingRuleHolder(base, name, getter, alreadyVisited);

                if (ruleHolder) {
                    return ruleHolder;
                }
            }

            for (i = 0; i < mixins.length; i += 1) {
                ruleHolder = getFirstMatchingRuleHolder(mixins[i], name, getter, alreadyVisited);
                if (ruleHolder) {
                    return ruleHolder;
                }
            }

            return null;
        }

        function getOwnRuleInfoTarget(target, validTargetPaths, alreadyVisited) {
            var orderedMixins = getOrderedMixinList(target),
                path = self.getPath(target),
                base = self.getBase(target),
                result,
                i;
            if (alreadyVisited[path]) {
                return null;
            }

            alreadyVisited[path] = true;

            if (validTargetPaths.indexOf(path) !== -1) {
                return target;
            }

            if (base) {
                result = getOwnRuleInfoTarget(base, validTargetPaths, alreadyVisited);
                if (result) {
                    return result;
                }
            }

            for (i = 0; i < orderedMixins.length; i += 1) {
                result = getOwnRuleInfoTarget(orderedMixins[i], validTargetPaths, alreadyVisited);
                if (result) {
                    return result;
                }
            }

            return null;
        }

        function getOwnRuleInfo(node, name, target, getter) {
            var definedTarget = getOwnRuleInfoTarget(target, getter(node, name), {});

            if (definedTarget) {
                return {
                    ownerNode: node,
                    ownerPath: self.getPath(node),
                    targetPath: self.getPath(definedTarget),
                    targetNode: definedTarget
                };
            }

            return null;
        }

        function getFirstMatchingRuleInfo(node, name, target, getter, alreadyVisited) {
            var base = self.getBase(node),
                path = self.getPath(node),
                mixins = getOrderedMixinList(node),
                info,
                i;

            if (alreadyVisited[path]) {
                return null;
            }

            //when it comes to rule holder, always the given node's own rule-set is the first
            alreadyVisited[path] = true;
            info = getOwnRuleInfo(node, name, target, getter);
            if (info) {
                return info;
            }

            if (base) {
                info = getFirstMatchingRuleInfo(base, name, target, getter, alreadyVisited);
                if (info) {
                    return info;
                }
            }

            for (i = 0; i < mixins.length; i += 1) {
                info = getFirstMatchingRuleInfo(mixins[i], name, target, getter, alreadyVisited);
                if (info) {
                    return info;
                }
            }

            return null;
        }

        function getAllMatchingRuleHolders(node, name, getter, alreadyVisited) {
            var base = self.getBase(node),
                path = self.getPath(node),
                mixins = getOrderedMixinList(node),
                ruleHolders = [],
                i;

            if (alreadyVisited[path]) {
                return [];
            }

            //when it comes to rule holder, always the given node's own rule-set is the first
            alreadyVisited[path] = true;
            if (getter(node).indexOf(name) !== -1) {
                ruleHolders.push(node);
            }

            if (base) {
                ruleHolders = ruleHolders.concat(getAllMatchingRuleHolders(base, name, getter, alreadyVisited));
            }

            for (i = 0; i < mixins.length; i += 1) {
                ruleHolders = ruleHolders.concat(getAllMatchingRuleHolders(mixins[i], name, getter, alreadyVisited));

            }

            return ruleHolders;
        }

        function getFirstMatchingMeta(node, name, matchFuction, getFunction) {
            var metaRuleHolder = getFirstMatchingRuleHolder(node, name, matchFuction, {});

            if (metaRuleHolder) {
                return getFunction(metaRuleHolder, name);
            }

            return undefined;
        }

        function allValidRelationsNameGetter(node) {
            return innerCore.getOwnValidPointerNames(node).concat(innerCore.getOwnValidSetNames(node));
        }

        function containmentGetter(/*node*/) {
            return ['containment'];
        }

        function isTypeOf(node, typePath, alreadyVisited, cache) {
            var base, mixins, i,
                path = self.getPath(node);

            if (alreadyVisited[path]) {
                return false;
            }

            alreadyVisited[path] = true;

            if (path === typePath) {
                return true;
            }

            base = self.getBase(node);
            if (base && isTypeOf(base, typePath, alreadyVisited, cache)) {
                return true;
            }

            mixins = getOrderedMixinList(node, cache);
            for (i = 0; i < mixins.length; i += 1) {
                if (isTypeOf(mixins[i], typePath, alreadyVisited, cache)) {
                    return true;
                }
            }

            return false;
        }

        function convertRuleToItemizedArraySet(rule) {
            var items = [],
                minItems = [],
                maxItems = [],
                i;

            for (i in rule) {
                if (i !== 'min' && i !== 'max') {
                    items.push(i);
                    minItems.push(rule[i].min || -1);
                    maxItems.push(rule[i].max || -1);
                    delete rule[i];
                }
            }

            rule.items = items;
            rule.minItems = minItems;
            rule.maxItems = maxItems;
        }

        //</editor-fold>

        //<editor-fold=Modified Methods>

        this.isTypeOf = function (node, typeNodeOrPath, cache) {
            if (!realNode(node)) {
                return false;
            }

            cache = cache || {};
            cache.orderedMixinList = cache.orderedMixinList || {};

            return isTypeOf(node,
                typeof typeNodeOrPath === 'string' ? typeNodeOrPath : innerCore.getPath(typeNodeOrPath),
                {},
                cache);
        };

        this.isValidChildOf = function (node, parentNode, cache) {
            if (!realNode(node)) {
                return true;
            }
            var childrenPaths,
                metaNodes,
                i;

            cache = cache || cache;

            // TODO: this is only needed when the containment definition is outside of meta..
            // TODO: (That is when it's defined between non-meta nodes)
            if (innerCore.isValidChildOf(node, parentNode)) {
                return true;
            }

            // Now we have to look deeper as containment rule may come from a mixin
            childrenPaths = self.getValidChildrenPaths(parentNode, cache);
            metaNodes = self.getAllMetaNodes(node);

            for (i = 0; i < childrenPaths.length; i += 1) {
                if (metaNodes[childrenPaths[i]] && self.isTypeOf(node, childrenPaths[i], cache)) {
                    return true;
                }
            }

            return false;
        };

        this.isValidTargetOf = function (node, source, name) {
            if (!realNode(source) || node === null) {
                return true;
            }

            var targetPaths,
                metaNodes,
                i;

            // TODO: this is only needed when the set/pointer definition is outside of meta..
            // TODO: (That is when it's defined between non-meta nodes)
            if (innerCore.isValidTargetOf(node, source, name)) {
                return true;
            }

            // Now we have to look deeper as pointer rule may come from a mixin
            targetPaths = self.getValidTargetPaths(source, name);
            metaNodes = self.getAllMetaNodes(node);

            for (i = 0; i < targetPaths.length; i += 1) {
                if (metaNodes[targetPaths[i]] && self.isTypeOf(node, metaNodes[targetPaths[i]])) {
                    return true;
                }
            }

            return false;
        };

        this.isValidAttributeValueOf = function (node, name, value) {
            if (!realNode(node)) {
                return true;
            }

            var ruleHolder = getFirstMatchingRuleHolder(node, name, innerCore.getOwnValidAttributeNames, {}),
                attributeDescriptor = self.getAttributeMeta(ruleHolder, name);


            //issue #51 - readonly should be taken into account
            if (attributeDescriptor.readonly && self.isMetaNode(node) === false) {
                return false;
            }

            if (ruleHolder) {
                return innerCore.isValidAttributeValueOf(ruleHolder, name, value);
            }

            return false;
        };

        this.getValidPointerNames = function (node) {
            //console.count('getValidPointerNames');
            return getValidNames(node, innerCore.getOwnValidPointerNames, {});
        };

        this.getValidSetNames = function (node) {
            //console.count('getValidSetNames');
            return getValidNames(node, innerCore.getOwnValidSetNames, {});
        };

        this.getValidAttributeNames = function (node) {
            if (!realNode(node)) {
                return [];
            }

            return getValidNames(node, innerCore.getOwnValidAttributeNames, {});
        };

        this.getValidAspectNames = function (node) {
            //console.count('getValidAspectNames');
            return getValidNames(node, innerCore.getOwnValidAspectNames, {});
        };

        this.getConstraintNames = function (node) {
            return getValidNames(node, innerCore.getConstraintNames, {});
        };

        this.getConstraint = function (node, name) {
            var constraintOwner = getFirstMatchingRuleHolder(node, name, innerCore.getOwnConstraintNames, {});

            if (constraintOwner) {
                return innerCore.getConstraint(constraintOwner, name);
            } else {
                return null;
            }
        };

        this.getJsonMeta = function (node) {
            var meta = {children: {}, attributes: {}, pointers: {}, aspects: {}, constraints: {}},
                nullRule = {items: [], minItems: [], maxItems: []},
                names,
                i;

            meta.children = self.getChildrenMeta(node);
            if (meta.children) {
                convertRuleToItemizedArraySet(meta.children);
            } else {
                meta.children = nullRule;
            }

            //attributes
            names = self.getValidAttributeNames(node);
            for (i = 0; i < names.length; i += 1) {
                meta.attributes[names[i]] = self.copyIfObject(self.getAttributeMeta(node, names[i]));
            }

            //pointers
            names = self.getValidPointerNames(node);
            for (i = 0; i < names.length; i += 1) {
                meta.pointers[names[i]] = self.getPointerMeta(node, names[i]);
                convertRuleToItemizedArraySet(meta.pointers[names[i]]);
            }

            //sets
            names = self.getValidSetNames(node);
            for (i = 0; i < names.length; i += 1) {
                meta.pointers[names[i]] = self.getPointerMeta(node, names[i]);
                convertRuleToItemizedArraySet(meta.pointers[names[i]]);
            }

            //aspects
            names = self.getValidAspectNames(node);

            for (i = 0; i < names.length; i += 1) {
                meta.aspects[names[i]] = self.getAspectMeta(node, names[i]);
            }

            //constraints
            names = self.getConstraintNames(node);
            for (i = 0; i < names.length; i += 1) {
                meta.constraints[names[i]] = self.getConstraint(node, names[i]);
            }

            return meta;
        };

        this.getOwnJsonMeta = function (node) {
            // We have to extend the meta definition by the mixins, but only if we talk about the own rule-set.
            var jsonMeta = innerCore.getOwnJsonMeta(node),
                mixins = this.getMixinPaths(node);

            if (mixins.length > 0) {
                jsonMeta.mixins = mixins;
            }

            return jsonMeta;
        };

        this.getValidChildrenPaths = function (node, cache) {
            cache = cache || {};
            cache.validChildrenPaths = cache.validChildrenPaths || {};

            function wrapper(testNode) {
                var path = innerCore.getPath(testNode);
                if (!cache.validChildrenPaths[path]) {
                    // getOwnValidChildrenPaths is slower
                    cache.validChildrenPaths[path] = innerCore.getValidChildrenPaths(testNode);
                }

                return cache.validChildrenPaths[path];
            }

            return getValidNames(node, wrapper, {});
        };

        this.getChildrenMeta = function (node) {
            var ruleHolders = getAllMatchingRuleHolders(node, 'containment', containmentGetter, {}),
                childrenMeta = {},
                i;

            for (i = 0; i < ruleHolders.length; i += 1) {
                childrenMeta = getExtendedUniqueKeyedObject(childrenMeta, innerCore.getChildrenMeta(ruleHolders[i]));
            }

            if (Object.keys(childrenMeta).length === 0) {
                return null;
            }

            return childrenMeta;
        };

        this.getPointerMeta = function (node, name) {
            var ruleHolders = getAllMatchingRuleHolders(node, name, allValidRelationsNameGetter, {}),
                i,
                pointerMeta = {};

            if (ruleHolders.length === 0) {
                return undefined;
            }

            for (i = 0; i < ruleHolders.length; i += 1) {
                pointerMeta = getExtendedUniqueKeyedObject(pointerMeta, innerCore.getPointerMeta(ruleHolders[i], name));
            }
            return pointerMeta;
        };

        this.getValidTargetPaths = function (node, name) {
            var getTargetPaths = function (getNode) {
                return innerCore.getValidTargetPaths(getNode, name);
            };

            return getValidNames(node, getTargetPaths, {});
        };

        this.getAttributeMeta = function (node, name) {
            return getFirstMatchingMeta(node, name, innerCore.getOwnValidAttributeNames, innerCore.getAttributeMeta);
        };

        this.getAspectMeta = function (node, name) {
            return getFirstMatchingMeta(node, name, innerCore.getOwnValidAspectNames, innerCore.getAspectMeta);
        };

        this.isValidAspectMemberOf = function (node, parent, name) {
            var aspectMeta = self.getAspectMeta(parent, name) || [],
                i;

            for (i = 0; i < aspectMeta.length; i += 1) {
                if (self.isTypeOf(node, aspectMeta[i])) {
                    return true;
                }
            }

            return false;
        };

        this.getSetNames = function (node) {
            var rawNames = innerCore.getSetNames(node),
                index = rawNames.indexOf(CONSTANTS.MIXINS_SET);

            if (index !== -1) {
                rawNames.splice(index, 1);
            }

            return rawNames;
        };

        this.getAttributeDefinitionOwner = function (node, name) {
            return getFirstMatchingRuleHolder(node, name, self.getOwnValidAttributeNames, {});
        };

        this.getAspectDefinitionOwner = function (node, name) {
            return getFirstMatchingRuleHolder(node, name, self.getOwnValidAspectNames, {});
        };

        this.getAspectDefinitionInfo = function (node, name, member) {
            return getFirstMatchingRuleInfo(node, name, member, self.getOwnValidAspectTargetPaths, {});
        };

        this.getPointerDefinitionInfo = function (node, name, target) {
            return getFirstMatchingRuleInfo(node, name, target, self.getOwnValidTargetPaths, {});
        };

        this.getSetDefinitionInfo = function (node, name, target) {
            return getFirstMatchingRuleInfo(node, name, target, self.getOwnValidTargetPaths, {});
        };

        this.getChildDefinitionInfo = function (node, child) {
            return getFirstMatchingRuleInfo(node, undefined, child, self.getOwnValidChildrenPaths, {});
        };
        //</editor-fold>

        //<editor-fold=Added Methods>

        this.getMixinErrors = function (node) {
            var errors = [],
                mixinPaths = self.getMixinPaths(node),
                allMetaNodes = self.getAllMetaNodes(node),
                mixinNodes = getOrderedMixinList(node),
                targetNode,
                targetInfoTxt,
                definitions,
                ownName = self.getAttribute(node, 'name'),
                names,
                base = self.getBase(node),
                ownKeys,
                keys,
                name,
                path,
                i, j, k;

            logger.debug('getMixinErrors(' + ownName + ')');

            //mixin is missing from meta
            for (i = 0; i < mixinPaths.length; i += 1) {
                if (!allMetaNodes[mixinPaths[i]]) {
                    logger.error('mixin node is missing from Meta [' + mixinPaths[i] + ']');
                    errors.push({
                        severity: 'error',
                        nodeName: ownName,
                        type: CONSTANTS.MIXIN_ERROR_TYPE.MISSING,
                        targetInfo: mixinPaths[i],
                        message: '[' + ownName + ']: mixin node \'' + mixinPaths[i] + '\' is missing from the Meta',
                        hint: 'Remove mixin or add to the Meta'
                    });
                }
            }

            //attribute definition collisions
            definitions = {};
            ownKeys = [];
            if (base) {
                ownKeys = self.getValidAttributeNames(base);
            }
            extendUniqueArray(ownKeys, self.getOwnValidAttributeNames(node));

            for (i = 0; i < mixinNodes.length; i += 1) {
                name = self.getAttribute(mixinNodes[i], 'name');
                path = self.getPath(mixinNodes[i]);
                keys = self.getValidAttributeNames(mixinNodes[i]);

                for (j = 0; j < keys.length; j += 1) {
                    if (ownKeys.indexOf(keys[j]) === -1) {
                        if (definitions[keys[j]]) {
                            logger.warn('colliding attribute (' + keys[j] + ') definition [' +
                                definitions[keys[j]].name + ']vs[' + name + ']');
                            errors.push({
                                severity: 'warning',
                                type: CONSTANTS.MIXIN_ERROR_TYPE.ATTRIBUTE_COLLISION,
                                nodeName: ownName,
                                ruleName: keys[j],
                                collisionPaths: [definitions[keys[j]].path, path],
                                collisionNodes: [mixinNodes[definitions[keys[j]].index], mixinNodes[i]],
                                message: '[' + ownName + ']: inherits attribute definition \'' +
                                keys[j] + '\' from [' + definitions[keys[j]].name + '] and [' + name + ']',
                                hint: 'Remove one of the mixin relations'
                            });
                        } else {
                            definitions[keys[j]] = {name: name, path: path, index: i};
                        }
                    }
                }
            }

            //containment collisions
            definitions = {};
            ownKeys = [];
            if (base) {
                ownKeys = self.getValidChildrenPaths(base);
            }
            extendUniqueArray(ownKeys, self.getOwnValidChildrenPaths(node));

            for (i = 0; i < mixinNodes.length; i += 1) {
                name = self.getAttribute(mixinNodes[i], 'name');
                keys = self.getValidChildrenPaths(mixinNodes[i]);
                path = self.getPath(mixinNodes[i]);

                for (j = 0; j < keys.length; j += 1) {
                    if (ownKeys.indexOf(keys[j]) === -1) {
                        if (definitions[keys[j]]) {
                            targetNode = allMetaNodes[keys[j]];
                            if (targetNode) {
                                targetInfoTxt = '[' + self.getAttribute(targetNode, 'name') + ']';
                            } else {
                                targetInfoTxt = '\'' + keys[j] + '\'';
                            }
                            logger.warn('colliding child (' + keys[j] + ') definition [' +
                                definitions[keys[j]].name + ']vs[' + name + ']');
                            errors.push({
                                severity: 'warning',
                                type: CONSTANTS.MIXIN_ERROR_TYPE.CONTAINMENT_COLLISION,
                                nodeName: ownName,
                                targetInfo: keys[j],
                                targetNode: targetNode,
                                collisionPaths: [definitions[keys[j]].path, path],
                                collisionNodes: [mixinNodes[definitions[keys[j]].index], mixinNodes[i]],
                                message: '[' + ownName + ']: inherits child definition for ' +
                                targetInfoTxt + ' from [' + definitions[keys[j]].name + '] and [' + name + ']',
                                hint: 'Remove one of the mixin relations'
                            });
                        } else {
                            definitions[keys[j]] = {name: name, path: path, index: i};
                        }
                    }
                }
            }

            //pointer target collisions
            names = this.getValidPointerNames(node);
            for (i = 0; i < names.length; i += 1) {
                definitions = {};
                ownKeys = [];
                if (base) {
                    ownKeys = self.getValidTargetPaths(base, names[i]);
                }
                extendUniqueArray(ownKeys, self.getOwnValidTargetPaths(node, names[i]));
                for (j = 0; j < mixinNodes.length; j += 1) {
                    keys = self.getValidTargetPaths(mixinNodes[j], names[i]);
                    name = self.getAttribute(mixinNodes[j], 'name');
                    path = self.getPath(mixinNodes[j]);
                    for (k = 0; k < keys.length; k += 1) {
                        if (ownKeys.indexOf(keys[k]) === -1 && keys[k] !== 'min' && keys[k] !== 'max') {
                            if (definitions[keys[k]]) {
                                targetNode = allMetaNodes[keys[k]];
                                if (targetNode) {
                                    targetInfoTxt = '[' + self.getAttribute(targetNode, 'name') + ']';
                                } else {
                                    targetInfoTxt = '\'' + keys[k] + '\'';
                                }
                                logger.warn('colliding pointer (' + names[i] + ') target (' + keys[k] +
                                    ') definition [' + definitions[keys[k]].name + ']vs[' + name + ']');
                                errors.push({
                                    severity: 'warning',
                                    type: CONSTANTS.MIXIN_ERROR_TYPE.POINTER_COLLISION,
                                    nodeName: ownName,
                                    ruleName: names[i],
                                    targetInfo: keys[k],
                                    targetNode: targetNode,
                                    collisionPaths: [definitions[keys[k]].path, path],
                                    collisionNodes: [mixinNodes[definitions[keys[k]].index], mixinNodes[j]],
                                    message: '[' + ownName + ']: inherits pointer (' + names[i] +
                                    ') target definition of ' + targetInfoTxt +
                                    ' from [' + definitions[keys[k]].name + '] and [' + name + ']',
                                    hint: 'Remove one of the mixin relations'
                                });
                            } else {
                                definitions[keys[k]] = {name: name, path: path, index: i};
                            }
                        }
                    }
                }
            }

            //set member collisions
            names = this.getValidSetNames(node);
            for (i = 0; i < names.length; i += 1) {
                definitions = {};
                ownKeys = [];
                if (base) {
                    ownKeys = self.getValidTargetPaths(base, names[i]);
                }
                extendUniqueArray(ownKeys, self.getOwnValidTargetPaths(node, names[i]));
                for (j = 0; j < mixinNodes.length; j += 1) {
                    keys = self.getValidTargetPaths(mixinNodes[j], names[i]);
                    name = self.getAttribute(mixinNodes[j], 'name');
                    path = self.getPath(mixinNodes[j]);
                    for (k = 0; k < keys.length; k += 1) {
                        if (ownKeys.indexOf(keys[k]) === -1 && keys[k] !== 'min' && keys[k] !== 'max') {
                            if (definitions[keys[k]]) {
                                targetNode = allMetaNodes[keys[k]];
                                if (targetNode) {
                                    targetInfoTxt = '[' + self.getAttribute(targetNode, 'name') + ']';
                                } else {
                                    targetInfoTxt = '\'' + keys[k] + '\'';
                                }
                                logger.warn('colliding set (' + names[i] + ') member (' + keys[k] +
                                    ') definition [' + definitions[keys[k]].name + ']vs[' + name + ']');
                                errors.push({
                                    severity: 'warning',
                                    type: CONSTANTS.MIXIN_ERROR_TYPE.SET_COLLISION,
                                    nodeName: ownName,
                                    ruleName: names[i],
                                    targetInfo: keys[k],
                                    targetNode: targetNode,
                                    collisionPaths: [definitions[keys[k]].path, path],
                                    collisionNodes: [mixinNodes[definitions[keys[k]].index], mixinNodes[j]],
                                    message: '[' + ownName + ']: inherits set (' + names[i] +
                                    ') member definition of ' + targetInfoTxt +
                                    ' from [' + definitions[keys[k]].name + '] and [' + name + ']',
                                    hint: 'Remove one of the mixin relations'
                                });
                            } else {
                                definitions[keys[k]] = {name: name, path: path, index: i};
                            }
                        }
                    }
                }
            }

            //aspect collisions
            definitions = {};
            ownKeys = [];
            if (base) {
                ownKeys = self.getValidAspectNames(base);
            }
            extendUniqueArray(ownKeys, self.getOwnValidAspectNames(node));
            for (i = 0; i < mixinNodes.length; i += 1) {
                keys = self.getValidAspectNames(mixinNodes[i]);
                name = self.getAttribute(mixinNodes[i], 'name');
                path = self.getPath(mixinNodes[i]);
                for (j = 0; j < keys.length; j += 1) {
                    if (ownKeys.indexOf(keys[j]) === -1) {
                        if (definitions[keys[j]]) {
                            logger.warn('colliding aspect (' + keys[j] + ') definition [' +
                                definitions[keys[j]].name + ']vs[' + name + ']');
                            errors.push({
                                severity: 'warning',
                                type: CONSTANTS.MIXIN_ERROR_TYPE.ASPECT_COLLISION,
                                nodeName: ownName,
                                ruleName: keys[j],
                                collisionPaths: [definitions[keys[j]].path, path],
                                collisionNodes: [mixinNodes[definitions[keys[j]].index], mixinNodes[i]],
                                message: '[' + ownName + ']: inherits aspect definition \'' + keys[j] +
                                '\' from [' + definitions[keys[j]].name + '] and [' + name + ']',
                                hint: 'Remove one of the mixin relations'
                            });
                        } else {
                            definitions[keys[j]] = {name: name, path: path, index: i};
                        }
                    }
                }
            }

            //constraint collision
            definitions = {};
            ownKeys = [];
            if (base) {
                ownKeys = self.getConstraintNames(base);
            }
            extendUniqueArray(ownKeys, self.getOwnConstraintNames(node));
            for (i = 0; i < mixinNodes.length; i += 1) {
                keys = self.getConstraintNames(mixinNodes[i]);
                name = self.getAttribute(mixinNodes[i], 'name');
                for (j = 0; j < keys.length; j += 1) {
                    if (ownKeys.indexOf(keys[j]) === -1) {
                        if (definitions[keys[j]]) {
                            logger.warn('colliding constraint (' + keys[j] + ') definition [' +
                                definitions[keys[j]].name + ']vs[' + name + ']');
                            errors.push({
                                severity: 'warning',
                                type: CONSTANTS.MIXIN_ERROR_TYPE.CONSTRAINT_COLLISION,
                                nodeName: ownName,
                                ruleName: keys[j],
                                collisionPaths: [definitions[keys[j]].path, path],
                                collisionNodes: [mixinNodes[definitions[keys[j]].index], mixinNodes[i]],
                                message: '[' + ownName + ']: inherits constraint definition \'' + keys[j] +
                                '\' from [' + definitions[keys[j]].name + '] and [' + name + ']',
                                hint: 'Remove one of the mixin relations'
                            });
                        } else {
                            definitions[keys[j]] = {name: name, path: path, index: i};
                        }
                    }
                }
            }

            logger.debug('getMixinErrors(' + ownName + ') finished');
            return errors;
        };

        this.getMixinPaths = function (node) {
            var paths = [],
                nodes = getOrderedMixinList(node),
                raw = innerCore.getOwnMemberPaths(node, CONSTANTS.MIXINS_SET),
                i;

            for (i = 0; i < nodes.length; i += 1) {
                paths.push(self.getPath(nodes[i]));
            }

            for (i = 0; i < raw.length; i += 1) {
                if (paths.indexOf(raw[i]) === -1) {
                    paths.push(raw[i]);
                }
            }

            return paths;
        };

        this.getMixinNodes = function (node) {
            var paths = self.getMixinPaths(node);
            return getNodeDictionary(node, paths);
        };

        this.delMixin = function (node, mixinPath) {
            // var metaNodes = innerCore.getAllMetaNodes(node);

            innerCore.delMember(node, CONSTANTS.MIXINS_SET, mixinPath);
        };

        this.addMixin = function (node, mixinPath) {
            var metaNodes = innerCore.getAllMetaNodes(node);

            if (metaNodes[mixinPath]) {
                innerCore.addMember(node, CONSTANTS.MIXINS_SET, metaNodes[mixinPath]);
            }
        };

        this.clearMixins = function (node) {
            self.deleteSet(node, CONSTANTS.MIXINS_SET);
        };

        this.getBaseTypes = function (node) {
            var metaType = innerCore.getBaseType(node),
                metaTypes = [];

            if (metaType) {
                metaTypes = getOrderedMixinList(metaType);
                metaTypes.unshift(metaType);
            }

            return metaTypes;
        };

        this.canSetAsMixin = function (node, mixinPath) {
            var result = {
                    isOk: true,
                    reason: ''
                },
                mixinNode = self.getAllMetaNodes(node)[mixinPath];

            if (self.getPath(node) === mixinPath) {
                result.isOk = false;
                result.reason = 'Node cannot be mixin of itself!';
            } else if (!mixinNode) {
                result.isOk = false;
                result.reason = 'Mixin must be on the Meta!';
            } else if (innerCore.isTypeOf(node, mixinNode)) {
                result.isOk = false;
                result.reason = 'Base of node cannot be its mixin as well!';
            }

            return result;
        };
        //</editor-fold>
    };

    return MixinCore;
});
/*globals define*/
/*eslint-env node, browser*/
/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/metaquerycore',[
    'common/core/CoreAssert'
], function (ASSERT) {
    'use strict';

    var MetaQueryCore = function (innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized MetaQueryCore');

        //<editor-fold=Helper Functions>
        function sensitiveFilter(validNodes) {
            var i;

            i = validNodes.length;
            while (i--) {
                if (self.isConnection(validNodes[i]) || self.isAbstract(validNodes[i])) {
                    validNodes.splice(i, 1);
                }
            }
        }

        //</editor-fold>

        //<editor-fold=Modified Methods>
        //</editor-fold>

        //<editor-fold=Added Methods>
        this.isAbstract = function (node) {
            return self.getRegistry(node, 'isAbstract') === true;
        };

        this.isConnection = function (node) {
            var validPtrNames = innerCore.getValidPointerNames(node);

            return validPtrNames.indexOf('dst') !== -1 && validPtrNames.indexOf('src') !== -1;
        };

        this.getValidChildrenMetaNodes = function (parameters) {
            var validNodes = [],
                node = parameters.node,
                metaNodes = self.getAllMetaNodes(node),
                keys = Object.keys(metaNodes || {}),
                validChildren = innerCore.getValidChildrenPaths(node),
                i, j,
                typeCounters = {},
                children = parameters.children || [],
                cache = parameters.cache || {},
                rules,
                inAspect;

            rules = innerCore.getChildrenMeta(node) || {};

            for (i = 0; i < keys.length; i += 1) {
                for (j = 0; j < validChildren.length; j += 1) {
                    if (innerCore.isTypeOf(metaNodes[keys[i]], validChildren[j], cache)) {
                        validNodes.push(metaNodes[keys[i]]);
                    }
                }
            }

            //before every next step we check if we still have potential nodes
            if (validNodes.length === 0) {
                return validNodes;
            }

            if (parameters.sensitive === true) {
                sensitiveFilter(validNodes);
            }

            //before every next step we check if we still have potential nodes
            if (validNodes.length === 0) {
                return validNodes;
            }

            if (parameters.multiplicity === true) {
                if (rules.max && rules.max > -1 && innerCore.getChildrenRelids(node).length >= rules.max) {
                    validNodes = [];
                    return validNodes;
                }
                if (children.length === 0) {
                    return validNodes; //we cannot check type-multiplicity without children
                }

                delete rules.max;
                delete rules.min;

                keys = Object.keys(rules);
                for (i = 0; i < children.length; i += 1) {
                    for (j = 0; j < keys.length; j += 1) {
                        if (innerCore.isTypeOf(children[i], keys[j])) {
                            if (!typeCounters[keys[j]]) {
                                typeCounters[keys[j]] = 0;
                            }
                            typeCounters[keys[j]] += 1;
                        }
                    }
                }

                i = validNodes.length;
                keys = Object.keys(typeCounters);
                while (i--) {
                    for (j = 0; j < keys.length; j += 1) {
                        if (rules[keys[j]].max &&
                            rules[keys[j]].max > -1 &&
                            rules[keys[j]].max <= typeCounters[keys[j]] &&
                            innerCore.isTypeOf(validNodes[i], keys[j])) {
                            validNodes.splice(i, 1); //FIXME slow, use only push instead
                            break;
                        }
                    }
                }
            }

            //before every next step we check if we still have potential nodes
            if (validNodes.length === 0) {
                return validNodes;
            }

            if (parameters.aspect) {
                keys = innerCore.getAspectMeta(node, parameters.aspect) || [];
                i = validNodes.length;

                while (i--) {
                    inAspect = false;
                    for (j = 0; j < keys.length; j += 1) {
                        if (innerCore.isTypeOf(validNodes[i], keys[j])) {
                            inAspect = true;
                            break;
                        }
                    }
                    if (!inAspect) {
                        validNodes.splice(i, 1);
                    }
                }
            }
            return validNodes;
        };

        this.getValidSetElementsMetaNodes = function (parameters) {
            var validNodes = [],
                node = parameters.node,
                name = parameters.name,
                metaNodes = self.getAllMetaNodes(node),
                keys = Object.keys(metaNodes || {}),
                i, j,
                typeCounters = {},
                members = parameters.members || [],
                rules = self.getPointerMeta(node, name) || {};

            for (i = 0; i < keys.length; i += 1) {
                if (metaNodes[keys[i]] && self.isValidTargetOf(metaNodes[keys[i]], node, name)) {
                    validNodes.push(metaNodes[keys[i]]);
                }
            }

            //before every next step we check if we still have potential nodes
            if (validNodes.length === 0) {
                return validNodes;
            }

            if (parameters.sensitive === true) {
                sensitiveFilter(validNodes);
            }

            //before every next step we check if we still have potential nodes
            if (validNodes.length === 0) {
                return validNodes;
            }

            if (parameters.multiplicity === true) {
                if (rules.max && rules.max > -1 && innerCore.getMemberPaths(node).length >= rules.max) {
                    validNodes = [];
                    return validNodes;
                }

                if (members.length === 0) {
                    return validNodes; //we cannot check type-multiplicity without children
                }

                delete rules.max;
                delete rules.min;

                //we need to clear nodes that are not on the meta sheet
                // and we have to initialize the counters
                keys = Object.keys(rules);
                for (i = 0; i < keys.length; i += 1) {
                    if (!metaNodes[keys[i]]) {
                        delete rules[keys[i]];
                    } else {
                        typeCounters[keys[i]] = 0;
                    }
                }

                keys = Object.keys(rules);
                for (i = 0; i < members.length; i += 1) {
                    for (j = 0; j < keys.length; j += 1) {
                        if (innerCore.isTypeOf(members[i], keys[j])) {
                            typeCounters[keys[j]] += 1;
                        }
                    }
                }

                i = validNodes.length;
                keys = Object.keys(typeCounters);
                while (i--) {
                    for (j = 0; j < keys.length; j += 1) {
                        if (rules[keys[j]].max &&
                            rules[keys[j]].max > -1 &&
                            rules[keys[j]].max <= typeCounters[keys[j]] &&
                            innerCore.isTypeOf(validNodes[i], keys[j])) {
                            validNodes.splice(i, 1); //FIXME slow, use only push instead
                            break;
                        }
                    }
                }
            }

            return validNodes;
        };
        //</editor-fold>
    };

    return MetaQueryCore;
});
/*globals define*/
/*eslint-env node, browser*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/librarycore',[
    'common/core/CoreAssert',
    'common/core/tasync',
    'common/core/constants',
    'common/util/random',
    'common/core/CoreIllegalOperationError'
], function (ASSERT, TASYNC, CONSTANTS, RANDOM, CoreIllegalOperationError) {
    'use strict';

    var LibraryCore = function (innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized LibraryCore');

        //<editor-fold=Helper Functions>
        function getAllLibraryRoots(node) {
            var roots = [];
            while (node) {
                if (self.isLibraryRoot(node)) {
                    roots.push(node);
                }
                node = self.getParent(node);
            }

            return roots;
        }

        function getLibraryName(node) {
            ASSERT(self.isValidNode(node));
            var name = '';

            node = self.getParent(node);

            while (node) {
                if (self.isLibraryRoot(node) && self.getParent(node) !== null) {
                    name = self.getAttribute(node, 'name') + CONSTANTS.NAMESPACE_SEPARATOR + name;
                }
                node = self.getParent(node);
            }

            return name;
        }

        function getLibraryRootsInfo(node) {
            var allMetaNodes = self.getAllMetaNodes(node),
                libraryRoots = {},
                path,
                roots,
                i,
                name;

            for (path in allMetaNodes) {
                roots = getAllLibraryRoots(allMetaNodes[path]);
                for (i = 0; i < roots.length; i += 1) {
                    name = getLibraryName(roots[i]) + self.getAttribute(roots[i], 'name');
                    if (!libraryRoots[name]) {
                        libraryRoots[name] = roots[i];
                    }
                }
            }

            return libraryRoots;
        }

        function getRootOfLibrary(node, name) {
            return self.getRoot(node).libraryRoots[name];
        }

        function getLibraryRoot(node) {
            while (node) {
                if (self.isLibraryRoot(node)) {
                    return node;
                }
                node = self.getParent(node);
            }

            return null;
        }

        function getLibraryInfo(libraryRootHashOrNode) {
            var isNode = typeof libraryRootHashOrNode === 'object',
                libraryName = '',
                libraryNamePrefix = '',
                getPath = function (node) {
                    if (isNode) {
                        return self.getPath(node, libraryRootHashOrNode);
                    } else {
                        return self.getPath(node);
                    }
                },
                getName = function (node) {
                    return self.getFullyQualifiedName(node).substr(libraryNamePrefix.length);
                },
                getGuid = function (node) {
                    if (isNode) {
                        return self.getLibraryGuid(node, libraryName);
                    } else {
                        return self.getGuid(node);
                    }
                },
                load = function () {
                    if (isNode) {
                        return self.loadSubTree(libraryRootHashOrNode);
                    } else {
                        return self.loadTree(libraryRootHashOrNode);
                    }
                };

            if (isNode) {
                libraryName = self.getAttribute(libraryRootHashOrNode, 'name');
                libraryNamePrefix = libraryName + '.';
            }

            return TASYNC.call(function (libraryNodes) {
                var info = {},
                    infoItem,
                    i,
                    inMeta = self.getMemberPaths(libraryNodes[0], CONSTANTS.META_SET_NAME);

                for (i = 1; i < libraryNodes.length; i += 1) {
                    infoItem = {
                        path: getPath(libraryNodes[i]),
                        hash: self.getHash(libraryNodes[i]),
                        fcn: getName(libraryNodes[i]),
                        isMeta: inMeta.indexOf(self.getPath(libraryNodes[i])) !== -1,
                    };

                    info[getGuid(libraryNodes[i])] = infoItem;
                }

                return info;
            }, load());
            //we use that the root of the library is always the first element
        }

        function removeLibraryRelations(root, path) {
            var overlayItems = self.overlayQuery(root, path),
                i;

            for (i = 0; i < overlayItems.length; i += 1) {
                if (overlayItems[i].s === path || overlayItems.t === path) {
                    self.overlayRemove(root, overlayItems[i].s, overlayItems[i].n, overlayItems[i].t);
                }
            }
        }

        function moveLibraryRelations(root, from, to) {
            var overlayItems = self.overlayQuery(root, from),
                i;

            for (i = 0; i < overlayItems.length; i += 1) {
                if (overlayItems[i].s === from) {
                    self.overlayRemove(root, overlayItems[i].s, overlayItems[i].n, overlayItems[i].t);
                    self.overlayInsert(root, to, overlayItems[i].n, overlayItems[i].t);

                } else if (overlayItems[i].t === from) {
                    self.overlayRemove(root, overlayItems[i].s, overlayItems[i].n, overlayItems[i].t);
                    self.overlayInsert(root, overlayItems[i].s, overlayItems[i].n, to);
                }
            }

        }

        function isPathInSubTree(fullPath, subTreePath) {
            if (fullPath === subTreePath) {
                return true;
            }
            if (fullPath.indexOf(subTreePath + CONSTANTS.PATH_SEP) === 0) {
                return true;
            }

            return false;
        }

        function isClosureInternalTarget(targetPath, closureInfo) {
            var selectionPath;

            for (selectionPath in closureInfo.selection) {
                if (isPathInSubTree(targetPath, selectionPath)) {
                    return true;
                }
            }

            return false;
        }

        function collectBaseInformation(baseNode, closureInfo) {
            var libraryRoots = getAllLibraryRoots(baseNode),
                namespaceInfo = {},
                i,
                namespace;

            for (i = 0; i < libraryRoots.length; i += 1) {
                namespace = self.getFullyQualifiedName(libraryRoots[i]);
                namespaceInfo[namespace] = {
                    info: self.getLibraryInfo(libraryRoots[i], namespace),
                    guid: self.getLibraryGuid(baseNode, namespace)
                };
                if (namespaceInfo[namespace].info && namespaceInfo[namespace].info.hash) {
                    namespaceInfo[namespace].hash = namespaceInfo[namespace].info.hash;
                }
            }

            closureInfo.bases[self.getGuid(baseNode)] = {
                originGuid: libraryRoots.length > 0 ? self.getLibraryGuid(baseNode) : self.getGuid(baseNode),
                name: self.getAttribute(baseNode, 'name'),
                fullName: self.getFullyQualifiedName(baseNode),
                namsespaces: namespaceInfo
            };
        }

        function addRelationsFromNodeToClosureInfo(node, allMetaNodes, closureInfo) {
            var basePath = self.getPath(node),
                overlayInfo = self.getRawOverlayInformation(node),
                overlayKey,
                pointerName,
                path,
                targetPath;

            for (overlayKey in overlayInfo) {
                path = basePath + overlayKey;
                if (isClosureInternalTarget(path, closureInfo)) {
                    for (pointerName in overlayInfo[overlayKey]) {
                        if (self.isPointerName(pointerName)) {
                            targetPath = basePath + overlayInfo[overlayKey][pointerName];
                            if (pointerName === CONSTANTS.BASE_POINTER) {
                                if (allMetaNodes[targetPath]) {
                                    collectBaseInformation(allMetaNodes[targetPath], closureInfo);
                                    closureInfo.relations.preserved[path] =
                                            closureInfo.relations.preserved[path] || {};
                                    closureInfo.relations.preserved[path][CONSTANTS.BASE_POINTER] =
                                            self.getGuid(allMetaNodes[targetPath]);
                                } else if (isClosureInternalTarget(targetPath, closureInfo)) {
                                    closureInfo.relations.preserved[path] =
                                            closureInfo.relations.preserved[path] || {};
                                    closureInfo.relations.preserved[path][CONSTANTS.BASE_POINTER] = targetPath;
                                } else {
                                    closureInfo.relations.lost[path] = closureInfo.relations.lost[path] || {};
                                    closureInfo.relations.lost[path][CONSTANTS.BASE_POINTER] = targetPath;
                                }
                            } else {
                                if (isClosureInternalTarget(targetPath, closureInfo)) {
                                    closureInfo.relations.preserved[path] =
                                            closureInfo.relations.preserved[path] || {};
                                    closureInfo.relations.preserved[path][pointerName] = targetPath;
                                } else {
                                    closureInfo.relations.lost[path] = closureInfo.relations.lost[path] || {};
                                    closureInfo.relations.lost[path][pointerName] = targetPath;
                                }
                            }
                        }
                    }
                }
            }
        }

        function normalizeSelectionForClosure(nodes) {
            var paths = [],
                i, j,
                nodesToKeep = [],
                nodesToCut = {};

            for (i = 0; i < nodes.length; i += 1) {
                paths.push(self.getPath(nodes[i]));
            }

            for (i = 0; i < paths.length; i += 1) {
                for (j = 0; j < paths.length; j += 1) {
                    if (i !== j && isPathInSubTree(paths[j], paths[i])) {
                        nodesToCut[paths[j]] = true;
                    }
                }
            }

            for (i = 0; i < paths.length; i += 1) {
                if (nodesToCut[paths[i]] !== true) {
                    nodesToKeep.push(nodes[i]);
                }
            }

            return nodesToKeep;

        }

        function getBasePathOfPath(path, closureInfo) {
            var basePath;

            for (basePath in closureInfo.hashes) {
                if (isPathInSubTree(path, basePath)) {
                    return basePath;
                }
            }

            return '';
        }

        function mapRelationEndings(closureInfo) {
            var source,
                sourceInfo,
                name,
                basePath;

            for (source in closureInfo.relations.preserved) {
                sourceInfo = closureInfo.relations.preserved[source];
                for (name in sourceInfo) {
                    if (!closureInfo.bases[sourceInfo[name]]) {
                        basePath = getBasePathOfPath(sourceInfo[name], closureInfo);
                        if (basePath) {
                            sourceInfo[name] = sourceInfo[name].replace(basePath, closureInfo.hashes[basePath]);
                        } else {
                            logger.error('during closure generation unknown based target [' +
                                    sourceInfo[name] + '] remained.');
                            delete sourceInfo[name];
                        }
                    }
                }

                basePath = getBasePathOfPath(source, closureInfo);
                if (basePath) {
                    closureInfo.relations.preserved[source.replace(basePath, closureInfo.hashes[basePath])] =
                            closureInfo.relations.preserved[source];
                    delete closureInfo.relations.preserved[source];
                } else {
                    logger.error('during closure generation unknown based source [' +
                            source + '] remained.');
                    delete closureInfo.relations.preserved[source];
                }

            }
        }

        function gatherOccurancesOfType(baseGuid, closureInformation, allMetaNodes) {
            var keys = Object.keys(allMetaNodes),
                occurrences = [],
                i;

            for (i = 0; i < keys.length; i += 1) {
                if ((self.isLibraryElement(allMetaNodes[keys[i]]) &&
                        closureInformation.bases[baseGuid].originGuid === self.getLibraryGuid(allMetaNodes[keys[i]])) ||
                        closureInformation.bases[baseGuid].originGuid === self.getGuid(allMetaNodes[keys[i]])) {
                    occurrences.push(allMetaNodes[keys[i]]);
                }
            }

            return occurrences;
        }

        function checkClosure(allMetaNodes, closureInformation) {
            var keys = Object.keys(allMetaNodes),
                occurrences, i, j, errorTxt;

                // First check against direct GUID matches..
            closureInformation.destinationBases = {};
            for (i = 0; i < keys.length; i += 1) {
                closureInformation.destinationBases[self.getGuid(allMetaNodes[keys[i]])] = keys[i];
            }

            keys = Object.keys(closureInformation.bases || {});

            for (i = 0; i < keys.length; i += 1) {
                if (!closureInformation.destinationBases[keys[i]]) {
                    // ... if no match try to find a unique match based on library GUIDs.
                    occurrences = gatherOccurancesOfType(keys[i], closureInformation, allMetaNodes);
                    if (occurrences.length === 0) {
                        throw new CoreIllegalOperationError('Cannot find necessary base [' +
                                closureInformation.bases[keys[i]].fullName + ' : ' + keys[i] + ']');
                    } else if (occurrences.length === 1) {
                        closureInformation.destinationBases[keys[i]] = self.getPath(occurrences[0]);
                    } else {
                        errorTxt = 'Ambiguous occurrences of base [' +
                                closureInformation.bases[keys[i]].fullName + ' : ' + keys[i] + '] ( ';
                        for (j = 0; j < occurrences.length; j += 1) {
                            errorTxt += '[' + self.getFullyQualifiedName(occurrences[j]) +
                                    ' : ' + self.getPath(occurrences[j]) + '] ';
                        }
                        errorTxt += ')';
                        throw new CoreIllegalOperationError(errorTxt);
                    }

                }
            }

            return null;
        }

        function getAncestor(node, from, to) {
            var fromArray = from.split(CONSTANTS.PATH_SEP),
                toArray = to.split(CONSTANTS.PATH_SEP),
                commonAncestorPath = '',
                i;

            fromArray.shift();
            toArray.shift();

            for (i = 0; i < fromArray.length && i < toArray.length; i += 1) {
                if (fromArray[i] === toArray[i]) {
                    commonAncestorPath += CONSTANTS.PATH_SEP + fromArray[i];
                } else {
                    break;
                }
            }

            while (self.getPath(node) !== commonAncestorPath && node !== null) {
                node = self.getParent(node);
            }

            return node;
        }

        function addRelation(parent, from, to, name) {
            var commonAncestor = getAncestor(parent, from, to),
                relFrom, relTo;

            if (commonAncestor) {
                relFrom = from.substr(self.getPath(commonAncestor).length);
                relTo = to.substr(self.getPath(commonAncestor).length);

                self.overlayInsert(commonAncestor, relFrom, name, relTo);
            } else {
                logger.error('unable to add relation: ' + name + '(' + from + '->' + to + ')');
            }
        }

        function getFinalPath(path, closureInformation) {
            // #9ab4 1eaad 98572 de827 49f0d 54520 3ad99 6b564 7 => 41 char is the hash length
            var hash = path.substr(0, 41),
                resultPath = '';

            if (closureInformation.relids[hash]) {
                resultPath = closureInformation.parent + CONSTANTS.PATH_SEP + closureInformation.relids[hash];
                resultPath += path.substr(41);
            }

            return resultPath;
        }

        function computePaths(closureInformation) {
            var source, name, sourceInfo;

            for (source in closureInformation.relations.preserved) {
                sourceInfo = closureInformation.relations.preserved[source];
                for (name in sourceInfo) {
                    if (closureInformation.destinationBases[sourceInfo[name]]) {
                        sourceInfo[name] = closureInformation.destinationBases[sourceInfo[name]];
                    } else {
                        sourceInfo[name] = getFinalPath(sourceInfo[name], closureInformation);
                    }
                }
            }

            for (source in closureInformation.relations.preserved) {
                closureInformation.relations.preserved[getFinalPath(source, closureInformation)] =
                        closureInformation.relations.preserved[source];
                delete closureInformation.relations.preserved[source];
            }
        }

        //</editor-fold>

        //<editor-fold=Modified Methods>
        this.loadRoot = function (hash) {
            return TASYNC.call(function (root) {
                root.libraryRoots = getLibraryRootsInfo(root);
                return root;
            }, innerCore.loadRoot(hash));
        };

        this.createNode = function (parameters) {
            var node;

            if (parameters && parameters.parent &&
                    (self.isLibraryRoot(parameters.parent) || self.isLibraryElement(parameters.parent))) {
                throw new CoreIllegalOperationError('Not allowed to create new node inside library.');
            }

            if (parameters && parameters.base && self.isLibraryRoot(parameters.base)) {
                throw new CoreIllegalOperationError('Not allowed to instantiate library root.');
            }

            node = innerCore.createNode(parameters);
            if (node.parent === null) {
                node.libraryRoots = {};
            }

            return node;
        };

        this.deleteNode = function (node, technical) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to remove library node by simply deleting them.');

            }

            return innerCore.deleteNode(node, technical);
        };

        this.copyNode = function (node, parent) {
            if (self.isLibraryRoot(parent) || self.isLibraryElement(parent)) {
                throw new CoreIllegalOperationError('Not allowed to add nodes inside a library.');
            }

            if (self.isLibraryRoot(node)) {
                throw new CoreIllegalOperationError('Not allowed to copy library root.');
            }

            return innerCore.copyNode(node, parent);
        };

        this.copyNodes = function (nodes, parent) {
            var i;
            if (self.isLibraryRoot(parent) || self.isLibraryElement(parent)) {
                throw new CoreIllegalOperationError('Not allowed to add nodes inside a library.');
            }

            for (i = 0; i < nodes.length; i += 1) {
                if (self.isLibraryRoot(nodes[i])) {
                    throw new CoreIllegalOperationError('Not allowed to copy library root.');
                }
            }

            return innerCore.copyNodes(nodes, parent);
        };

        this.moveNode = function (node, parent) {
            if (self.isLibraryRoot(parent) || self.isLibraryElement(parent)) {
                throw new CoreIllegalOperationError('Not allowed to add nodes inside a library.');
            }

            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to move library elements.');
            }

            return innerCore.moveNode(node, parent);
        };

        this.setAttribute = function (node, name, value) {
            if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.setAttribute(node, name, value);
        };

        this.delAttribute = function (node, name) {
            if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.delAttribute(node, name);
        };

        this.setRegistry = function (node, name, value) {
            if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.setRegistry(node, name, value);
        };

        this.delRegistry = function (node, name) {
            if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.delRegistry(node, name);
        };

        this.setPointer = function (node, name, target) {
            if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.setPointer(node, name, target);
        };

        this.deletePointer = function (node, name) {
            if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.deletePointer(node, name);
        };

        this.setBase = function (node, base) {
            if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            if (base && self.isLibraryRoot(base)) {
                throw new CoreIllegalOperationError('Not allowed to instantiate library root.');
            }

            return innerCore.setBase(node, base);
        };

        this.addMember = function (node, name, member) {
            if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.addMember(node, name, member);
        };

        this.delMember = function (node, name, path) {
            if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.delMember(node, name, path);
        };

        this.setMemberAttribute = function (node, setName, memberPath, attrName, value) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }
            return innerCore.setMemberAttribute(node, setName, memberPath, attrName, value);
        };

        this.delMemberAttribute = function (node, setName, memberPath, attrName) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }
            return innerCore.delMemberAttribute(node, setName, memberPath, attrName);
        };

        this.setMemberRegistry = function (node, setName, memberPath, regName, value) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }
            return innerCore.setMemberRegistry(node, setName, memberPath, regName, value);
        };

        this.delMemberRegistry = function (node, setName, memberPath, regName) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }
            return innerCore.delMemberRegistry(node, setName, memberPath, regName);
        };

        this.createSet = function (node, name) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }
            return innerCore.createSet(node, name);
        };

        this.deleteSet = function (node, name) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }
            return innerCore.deleteSet(node, name);
        };

        this.setSetAttribute = function (node, setName, regName, regValue) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }
            return innerCore.setSetAttribute(node, setName, regName, regValue);
        };

        this.delSetAttribute = function (node, setName, regName) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }
            return innerCore.delSetAttribute(node, setName, regName);
        };

        this.setSetRegistry = function (node, setName, regName, regValue) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }
            return innerCore.setSetRegistry(node, setName, regName, regValue);
        };

        this.delSetRegistry = function (node, setName, regName) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }
            return innerCore.delSetRegistry(node, setName, regName);
        };

        this.setGuid = function (node, guid) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                //FIXME cannot return any error in async functions :/
                // /throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            } else {
                return innerCore.setGuid(node, guid);
            }
        };

        this.setConstraint = function (node, name, constraint) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }
            return innerCore.setConstraint(node, name, constraint);
        };

        this.delConstraint = function (node, name) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }
            return innerCore.delConstraint(node, name);
        };

        this.clearMetaRules = function (node) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.clearMetaRules(node);
        };

        this.setAttributeMeta = function (node, name, rule) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.setAttributeMeta(node, name, rule);
        };

        this.delAttributeMeta = function (node, name) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.delAttributeMeta(node, name);
        };

        this.setChildMeta = function (node, child, min, max) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            if (self.isLibraryRoot(child)) {
                throw new CoreIllegalOperationError('Not allowed to use library root as valid child.');
            }

            return innerCore.setChildMeta(node, child, min, max);
        };

        this.delChildMeta = function (node, childPath) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.delChildMeta(node, childPath);
        };

        this.setChildrenMetaLimits = function (node, min, max) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.setChildrenMetaLimits(node, min, max);
        };

        this.setPointerMetaTarget = function (node, name, target, min, max) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.setPointerMetaTarget(node, name, target, min, max);
        };

        this.delPointerMetaTarget = function (node, name, targetPath) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.delPointerMetaTarget(node, name, targetPath);
        };

        this.setPointerMetaLimits = function (node, name, min, max) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.setPointerMetaLimits(node, name, min, max);
        };

        this.delPointerMeta = function (node, name) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.delPointerMeta(node, name);
        };

        this.setAspectMetaTarget = function (node, name, target) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.setAspectMetaTarget(node, name, target);
        };

        this.delAspectMetaTarget = function (node, name, targetPath) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.delAspectMetaTarget(node, name, targetPath);
        };

        this.delAspectMeta = function (node, name) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.delAspectMeta(node, name);
        };

        this.delMixin = function (node, mixinPath) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.delMixin(node, mixinPath);
        };

        this.addMixin = function (node, mixinPath) {
            var libraryName,
                root = self.getRoot(node);

            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            for (libraryName in root.libraryRoots) {
                if (self.getPath(root.libraryRoots[libraryName]) === mixinPath) {
                    throw new CoreIllegalOperationError('Not allowed to use library root as mixin.');
                }
            }

            return innerCore.addMixin(node, mixinPath);
        };

        this.clearMixins = function (node) {
            if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                throw new CoreIllegalOperationError('Not allowed to modify library elements.');
            }

            return innerCore.clearMixins(node);
        };
        //</editor-fold>

        //<editor-fold=Added Methods>

        this.getLibraryRoot = function (node, name) {
            var root = self.getRoot(node);

            return root.libraryRoots[name] || null;
        };

        this.isLibraryElement = function (node) {
            var parent = self.getParent(node);

            while (parent) {
                if (self.isLibraryRoot(parent)) {
                    return true;
                }
                parent = self.getParent(parent);
            }

            return false;
        };

        this.isLibraryRoot = function (node) {
            if (innerCore.getAttribute(node, '_libraryInfo')) {
                return true;
            }
            return false;
        };

        this.getNamespace = function (node) {
            var libPrefix = getLibraryName(node);

            if (libPrefix) {
                // Trim the trailing dot..
                libPrefix = libPrefix.substring(0, libPrefix.length - 1);
            }

            return libPrefix;
        };

        this.getFullyQualifiedName = function (node) {
            ASSERT(self.isValidNode(node));
            return getLibraryName(node) + self.getAttribute(node, 'name');
        };

        this.getLibraryGuid = function (node, name) {
            ASSERT(self.isValidNode(node));
            var libraryRoot;

            if (!self.isLibraryElement(node) && !self.isLibraryRoot(node)) {
                throw new CoreIllegalOperationError('Node is not a library member');
            }

            if (!name) {
                libraryRoot = getLibraryRoot(node);
            } else {
                libraryRoot = getRootOfLibrary(node, name);
            }

            if (!libraryRoot) {
                throw new CoreIllegalOperationError('Unknown library was given');
            }

            if (self.getFullyQualifiedName(node).indexOf(self.getFullyQualifiedName(libraryRoot)) !== 0) {
                throw new CoreIllegalOperationError('Node is not a member of the library');
            }

            if (self.isLibraryRoot(node) && self.getPath(node) === self.getPath(libraryRoot)) {
                return innerCore.getDataGuid(node);
            }

            return innerCore.getDeducedGuid(node, self.getLibraryGuid(self.getParent(node), name));
        };

        this.addLibrary = function (node, name, libraryRootHash, libraryInfo) {
            var root = self.getRoot(node),
                libraryRelid = RANDOM.generateRelid(root.data);

            innerCore.setProperty(root, libraryRelid, libraryRootHash);
            root.childrenRelids = null;

            return TASYNC.call(function (newLibraryRoot) {
                return TASYNC.call(function (libraryNodes) {
                    var inMeta = self.getMemberPaths(newLibraryRoot, CONSTANTS.META_SET_NAME),
                        libraryInfoAttribute = libraryInfo;
                        //remove the libraryRoot from the libraryNodes
                    libraryNodes.shift();

                    //set the name of the library root
                    innerCore.setAttribute(newLibraryRoot, 'name', name);

                    //add library_info
                    libraryInfoAttribute.hash = libraryRootHash;
                    innerCore.setAttribute(newLibraryRoot, '_libraryInfo', libraryInfoAttribute);

                    if (libraryNodes.length > 0) {
                        //connect the FCO as base of libraryFCO
                        innerCore.setBase(self.getBaseRoot(libraryNodes[0]), self.getFCO(root));

                        //adding nodes to the global META
                        var i;
                        for (i = 0; i < libraryNodes.length; i += 1) {
                            if (inMeta.indexOf(self.getPath(libraryNodes[i])) !== -1) {
                                innerCore.addMember(root, CONSTANTS.META_SET_NAME, libraryNodes[i]);
                            }
                        }
                    }
                    //refreshing libraryInfo
                    root.libraryRoots[name] = newLibraryRoot;
                }, self.loadSubTree(newLibraryRoot));
            }, self.loadChild(root, libraryRelid));
        };

        this.updateLibrary = function (node, name, updatedLibraryRootHash, libraryInfo/*, updateInstructions*/) {
            var logs = {added: {}, updated: {}, moved: {}, removed: {}},
                root = self.getRoot(node),
                libraryRoot = getRootOfLibrary(root, name),
                relid,
                FCO = self.getFCO(root);

            if (!libraryRoot) { //do nothing if not valid library
                return logs;
            }

            relid = self.getRelid(libraryRoot);

            return TASYNC.call(function (oldInfo, newInfo) {
                var newNodePaths = [],
                    removedNodePaths = [],
                    removedNodeInMeta = [],
                    addedToMetaPaths = [],
                    removedFromMetaPaths = [],
                    i,
                    moves = [],
                    guid;

                for (guid in newInfo) {
                    if (!oldInfo[guid]) {
                        newNodePaths.push('/' + relid + newInfo[guid].path);
                    } else if (oldInfo[guid].path !== newInfo[guid].path) {
                        moves.push({from: '/' + relid + oldInfo[guid].path, to: '/' + relid + newInfo[guid].path});
                    }
                }

                for (guid in oldInfo) {
                    if (!newInfo[guid]) {
                        removedNodePaths.push('/' + relid + oldInfo[guid].path);
                        removedNodeInMeta.push(oldInfo[guid].isMeta);
                    }
                }

                for (i = 0; i < removedNodePaths.length; i += 1) {
                    removeLibraryRelations(root, removedNodePaths[i]);
                }

                for (i = 0; i < moves.length; i += 1) {
                    moveLibraryRelations(root, moves[i].from, moves[i].to);
                }

                //finally address the changes in the meta element of the library
                for (guid in newInfo) {
                    if (oldInfo[guid]) {
                        if (newInfo[guid].isMeta && !oldInfo[guid].isMeta) {
                            addedToMetaPaths.push('/' + relid + newInfo[guid].path);
                        }
                        if (!newInfo[guid].isMeta && oldInfo[guid].isMeta) {
                            removedFromMetaPaths.push('/' + relid + newInfo[guid].path);
                        }
                    }
                }

                innerCore.setProperty(root, relid, updatedLibraryRootHash);
                root = self.removeChildFromCache(root, relid);
                return TASYNC.call(function (newLibraryRoot) {
                    return TASYNC.call(function (newLibraryNodes) {
                        var i,
                            inMeta = self.getMemberPaths(newLibraryRoot, CONSTANTS.META_SET_NAME),
                            libraryInfoAttribute = libraryInfo,
                            libraryFCO;

                        newLibraryNodes.shift();
                        //set the name of the library root
                        innerCore.setAttribute(newLibraryRoot, 'name', name);

                        //add library_info
                        libraryInfoAttribute.hash = updatedLibraryRootHash;
                        innerCore.setAttribute(newLibraryRoot, '_libraryInfo', libraryInfoAttribute);

                        if (newLibraryNodes.length > 0) {
                            //connect the FCO as base of libraryFCO, but be sure to remove the nullPtr

                            libraryFCO = self.getBaseRoot(newLibraryNodes[0]);
                            innerCore.deletePointer(libraryFCO, 'base');
                            innerCore.setBase(libraryFCO, FCO);

                            for (i = 0; i < newLibraryNodes.length; i += 1) {
                                //adding new nodes to the global META
                                if (newNodePaths.indexOf(self.getPath(newLibraryNodes[i])) !== -1 &&
                                        inMeta.indexOf(self.getPath(newLibraryNodes[i])) !== -1) {
                                    innerCore.addMember(root, CONSTANTS.META_SET_NAME, newLibraryNodes[i]);
                                }
                                //adding existing nodes to the global META
                                if (addedToMetaPaths.indexOf(self.getPath(newLibraryNodes[i])) !== -1) {
                                    innerCore.addMember(root, CONSTANTS.META_SET_NAME, newLibraryNodes[i]);
                                }
                                //removing existing nodes from the global META
                                if (removedFromMetaPaths.indexOf(self.getPath(newLibraryNodes[i])) !== -1) {
                                    innerCore.delMember(
                                        root, 
                                        CONSTANTS.META_SET_NAME, 
                                        self.getPath(newLibraryNodes[i])
                                    );
                                    let sets = self.isMemberOf(newLibraryNodes[i]);
                                    sets = sets[''] || [];
                                    sets.forEach((set) => {
                                        if (set.indexOf(CONSTANTS.META_SET_NAME) === 0) {
                                            innerCore.addMember(
                                                root, 
                                                CONSTANTS.META_SET_NAME, 
                                                newLibraryNodes[i]
                                            );                                            
                                        }
                                    });
                                }
                            }
                        }

                        //for bookkeping purposes we need to remove the to-delete nodes from the all-META set
                        if (removedNodePaths.length > 0) {
                            for (i = 0; i < removedNodePaths.length; i += 1) {
                                if (removedNodeInMeta[i]) {
                                    innerCore.delMember(
                                        root,
                                        CONSTANTS.META_SET_NAME,
                                        removedNodePaths[i]
                                    );
                                }
                            }
                        }

                        root.libraryRoots[name] = newLibraryRoot;

                        return logs;
                    }, self.loadSubTree(newLibraryRoot));
                }, self.loadChild(root, relid));
            }, getLibraryInfo(libraryRoot), getLibraryInfo(updatedLibraryRootHash));

        };

        this.removeLibrary = function (node, name) {
            ASSERT(self.isValidNode(node));
            var root = self.getRoot(node),
                libraryRoot = root.libraryRoots[name];

            if (libraryRoot && !self.isLibraryElement(libraryRoot)) {
                innerCore.deleteNode(root.libraryRoots[name], true);
                delete root.libraryRoots[name];
            }

        };

        this.renameLibrary = function (node, oldName, newName) {
            ASSERT(self.isValidNode(node));
            var root = self.getRoot(node);

            ASSERT(typeof oldName === 'string' && typeof newName === 'string' &&
                    oldName.indexOf(CONSTANTS.NAMESPACE_SEPARATOR) === -1 &&
                    newName.indexOf(CONSTANTS.NAMESPACE_SEPARATOR) === -1 &&
                    root.libraryRoots[oldName]);

            if (oldName !== newName) {
                ASSERT(!root.libraryRoots[newName], 'Library already exists [' + newName + ']');
                innerCore.setAttribute(root.libraryRoots[oldName], 'name', newName);
                root.libraryRoots[newName] = root.libraryRoots[oldName];
                delete root.libraryRoots[oldName];
            }
        };

        this.getLibraryNames = function (node) {
            ASSERT(self.isValidNode(node));
            return Object.keys(self.getRoot(node).libraryRoots);
        };

        this.getLibraryMetaNodes = function (node, name, onlyOwn) {
            var allNodes = self.getAllMetaNodes(node),
                libraryNodes = {},
                path;

            for (path in allNodes) {
                try {
                    if (onlyOwn) {
                        if (self.getNamespace(allNodes[path]) === name) {
                            libraryNodes[path] = allNodes[path];
                        }
                    } else {
                        if (self.getNamespace(allNodes[path]).indexOf(name) === 0) {
                            libraryNodes[path] = allNodes[path];
                        }
                    }
                } catch (e) {
                    // There is the occasional occurance that the list contains
                    // already removed nodes, so they will throw exceptions...
                }
            }

            return libraryNodes;
        };

        this.getLibraryInfo = function (node, name) {
            var libroot = getRootOfLibrary(node, name);
            return self.getAttribute(libroot, '_libraryInfo');
        };

        this.getClosureInformation = function (nodes) {
            ASSERT(nodes.length > 0);
            var closureInfo = {
                    hashes: {},
                    selection: {},
                    bases: {},
                    relations: {preserved: {}, lost: {}}
                },
                // infoLosses = {},
                allMetaNodes,
                path,
                node,
                keys,
                i;

            nodes = normalizeSelectionForClosure(nodes);
            allMetaNodes = this.getAllMetaNodes(nodes[0]);

            // We first collect the absolute paths of the selected nodes
            for (i = 0; i < nodes.length; i += 1) {
                // The selection cannot contain library elements as that would violate read-only
                if (this.isLibraryElement(nodes[i]) || this.isLibraryRoot(nodes[i])) {
                    throw new CoreIllegalOperationError('Cannot select node[' +
                            this.getPath(nodes[i]) + '] because it is library content!'
                    );
                }
                if (this.getParent(nodes[i]) === null) {
                    throw new CoreIllegalOperationError('Cannot select the project root!');
                }
                closureInfo.selection[this.getPath(nodes[i])] = this.getGuid(nodes[i]);
                closureInfo.hashes[this.getPath(nodes[i])] = this.getHash(nodes[i]);
            }

            // Secondly, we collect relation information (the first order ones).
            // We leave the handling of the root node's overlay info for a separate step
            for (i = 0; i < nodes.length; i += 1) {
                node = this.getParent(nodes[i]);
                while (this.getPath(node)) { // until it is not the root
                    addRelationsFromNodeToClosureInfo(node, allMetaNodes, closureInfo);
                    node = this.getParent(node);
                }
            }

            // Finally we process the relations of the root
            addRelationsFromNodeToClosureInfo(this.getRoot(nodes[0]), allMetaNodes, closureInfo);

            //now we combine the selection and hashes info
            keys = Object.keys(closureInfo.selection);
            for (i = 0; i < keys.length; i += 1) {
                closureInfo.selection[closureInfo.selection[keys[i]]] = closureInfo.hashes[keys[i]];
                delete closureInfo.selection[keys[i]];
            }

            //now map the paths to some guid+relpath format
            mapRelationEndings(closureInfo);

            //remove hashes field from closure information
            delete closureInfo.hashes;

            //checking and logging lost relation information
            logger.debug('Closure creation finished!', closureInfo);
            for (path in closureInfo.relations.lost) {
                if (closureInfo.relations.lost[path][CONSTANTS.BASE_POINTER]) {
                    //we do not allow external non-Meta bases
                    throw new CoreIllegalOperationError('Closure cannot be created due to [' + path +
                            '] misses its base [' + closureInfo.relations.lost[path][CONSTANTS.BASE_POINTER] + '].');
                }
            }

            return closureInfo;
        };

        this.importClosure = function (parent, closureInformation) {
            //at this point we can assume that the database has the necessary blobs
            var allMetaNodes = this.getAllMetaNodes(parent),
                checkResult,
                key,
                name,
                longestNewRelid = '',
                reservedRelids = this.getChildrenRelids(parent, true),
                newRelid;

            checkResult = checkClosure(allMetaNodes, closureInformation);

            if (checkResult) {
                return checkResult;
            }

            closureInformation.relids = {};
            closureInformation.parent = this.getPath(parent);

            // Attaching the selected nodes under the parent node
            for (key in closureInformation.selection) {
                newRelid = RANDOM.generateRelid(reservedRelids,
                    innerCore.getProperty(parent, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY));
                reservedRelids[newRelid] = true;
                innerCore.setProperty(parent, newRelid, closureInformation.selection[key]);
                closureInformation.relids[closureInformation.selection[key]] = newRelid;
                if (newRelid.length > longestNewRelid.length) {
                    longestNewRelid = newRelid;
                }
            }

            parent.childrenRelids = null;

            // Now processing the new relid creations
            innerCore.processRelidReservation(parent, longestNewRelid);

            // Replacing the paths in the closure information with actual paths in the target project
            computePaths(closureInformation);

            // Creating all the relations
            for (key in closureInformation.relations.preserved) {
                for (name in closureInformation.relations.preserved[key]) {
                    addRelation(parent, key, closureInformation.relations.preserved[key][name], name);
                }
            }

            logger.debug('Closure import finished!', closureInformation);

            return closureInformation;
        };
        //</editor-fold>
    };

    return LibraryCore;
}
);
/*globals define*/
/*eslint-env node, browser*/

/**
 * This class defines the public API of the WebGME-Core
 *
 * @author kecso / https://github.com/kecso
 * @module Core
 */

/**
 * @typedef {object} Node - the object that represents the atomic element of the containment hierarchy.
 */

/**
 * @typedef {object} DataObject - Inner data of {@link module:Core~Node} that can be serialized
 * and saved in the storage.
 */

/**
 * @typedef {object} GmePersisted - the result object of a persist which contains information about the newly
 * created data objects.
 * @prop {module:Core~ObjectHash} rootHash - Hash of the root node.
 * @prop {object.<module:Core~ObjectHash, module:Core~DataObject>} objects - Hash of the root node.
 */

/**
 * @typedef {string} ObjectHash - Unique SHA-1 hash for the node object.
 * @example
 * '#5496cf226542fcceccf89056f0d27564abc88c99'
 */

/**
 * @typedef {string} GUID - Globally unique identifier. A formatted string containing hexadecimal characters. If some
 * projects share some GUIDs that can only be because the node with the given identification represents the same
 * concept.
 * @example
 * 'cd891e7b-e2ea-e929-f6cd-9faf4f1fc045'
 */

/**
 * @typedef {object} Constraint - An object that represents some additional rule regarding some node of the project.
 * @prop {string} script - The script which checks if the constraint is met.
 * @prop {string} info - Short description of the constraint.
 * @prop {string} priority - Gives instructions on how to deal with violations of the constraint.
 */

/**
 * @typedef {object} DefinitionInfo - Contains the owner and the target of the meta-rule that makes the
 * relationship between the given node and related node a valid one. There can be multiple meta-rules that make
 * the relationship valid, but this is the first one that answers the question isValidChildOf, isValidTargetOf etc.
 * @prop {Core~Node} ownerNode - The meta-node where the meta-rule is stored.
 * @prop {Core~Node} targetNode - The meta-node the meta-rule is targeting.
 */

/**
 * @typedef {object} RelationRule - An object that represents a relational type rule-set (pointer/set).
 * @prop {integer} [min] - The minimum amount of target necessary for the relationship (if not present or '-1'
 * then there is no minimum rule that applies)
 * @prop {integer} [max] - The minimum amount of target necessary for the relationship (if not present or '-1'
 * then there is no minimum rule that applies)
 * @prop {object} [absolutePathOfTarget] - special rules regarding the given type (if the object is empty, it still
 * represents that the type is a valid target of the relationship)
 * @prop {integer} [absolutePathOfTarget.min] - The minimum amount of target necessary for the relationship
 * from the given type (if not present or '-1' then there is no minimum rule that applies)
 * @prop {integer} [absolutePathOfTarget.max] - The minimum amount of target necessary for the relationship
 * from the given type (if not present or '-1' then there is no minimum rule that applies)
 * @example
 * '{
 *  'min': 1,
 *  'max': -1,
 *  'any/path/of/node':{
 *   'min':-1,
 *   'max':2
 *   },
 *   'any/other/valid/path':{
 *   }
 * }'
 */

/**
 * @typedef {object} MixinViolation - An object that has information about a mixin violation in the given node.
 * @prop {string} [severity] - The severity of the given error ('error','warning').
 * @prop {string} [type] - 'missing', 'attribute collision', 'set collision',
 * 'pointer collision', 'containment collision', 'aspect collision', 'constraint collision'
 * @prop {string|undefined} [ruleName] - The name of the affected rule definition  (if available).
 * @prop {string|undefined} [targetInfo] - The path of the target of the violation (if available).
 * @prop {module:Core~Node|undefined} [targetNode] - The target node of the violation (if available).
 * @prop {string[]} [collisionPaths] - The list of paths of colliding nodes (if any).
 * @prop {module:Core~Node[]} [collisionNodes] - The colliding mixin nodes (if any).
 * @prop {string} [message] - The description of the violation.
 * @prop {string} [hint] - Hint on how to resolve the issue.
 * @example
 * '{
 * 'severity': 'error',
 * 'type': 'missing',
 * 'targetInfo': '/E/b',
 * 'message': '[MyObject]: mixin node "E/b" is missing from the Meta',
 * 'hint': 'Remove mixin or add to the Meta'
 * }'
 * @example
 * '{
 * 'severity': 'warning',
 * 'type': 'attribute collision',
 * 'ruleName': 'value',
 * 'collisionPaths': ['/E/a','/E/Z'],
 * 'collisionNodes': [Object,Object],
 * 'message':'[MyObject]: inherits attribute definition "value" from [TypeA] and [TypeB]',
 * 'hint': 'Remove one of the mixin relations'
 * }'
 */

define('common/core/core',[
    'common/core/corerel',
    'common/core/setcore',
    'common/core/guidcore',
    'common/core/nullpointercore',
    'common/core/coreunwrap',
    'common/core/coretype',
    'common/core/constraintcore',
    'common/core/coretree',
    'common/core/metacore',
    'common/core/coretreeloader',
    'common/core/corediff',
    'common/core/metacachecore',
    'common/core/mixincore',
    'common/core/metaquerycore',
    'common/regexp',
    'common/core/librarycore',
    'common/core/CoreIllegalArgumentError',
    'common/core/CoreIllegalOperationError',
    'common/core/constants'
], function (CoreRel,
             Set,
             Guid,
             NullPtr,
             UnWrap,
             Type,
             Constraint,
             CoreTree,
             MetaCore,
             TreeLoader,
             CoreDiff,
             MetaCacheCore,
             MixinCore,
             MetaQueryCore,
             REGEXP,
             LibraryCore,
             CoreIllegalArgumentError,
             CoreIllegalOperationError,
             CONSTANTS) {
    'use strict';

    var isValidNode,
        isValidPath;

    function ensureType(input, nameOfInput, type, isAsync) {
        var error;
        if (typeof input !== type) {
            error = new CoreIllegalArgumentError('Parameter \'' + nameOfInput + '\' is not of type ' + type + '.');
            if (isAsync) {
                return error;
            } else {
                throw error;
            }
        }
    }

    function ensureValue(input, nameOfInput, isAsync) {
        var error;
        if (input === undefined) {
            error = new CoreIllegalArgumentError('Parameter \'' + nameOfInput + '\' cannot be undefined.');
            if (isAsync) {
                return error;
            } else {
                throw error;
            }
        }
    }

    function ensureInstanceOf(input, nameOfInput, type, isAsync) {
        var error;
        if (input instanceof type === false) {
            error = new CoreIllegalArgumentError('Parameter \'' + nameOfInput + '\' is not of type ' + type + '.');
            if (isAsync) {
                return error;
            } else {
                throw error;
            }
        }
    }

    function ensurePath(input, nameOfInput, isAsync) {
        var error;
        if (isValidPath(input) === false) {
            error = new CoreIllegalArgumentError('Parameter \'' + nameOfInput + '\' is not a valid path.');
            if (isAsync) {
                return error;
            } else {
                throw error;
            }
        }
    }

    function ensureNode(input, nameOfInput, isAsync) {
        var error;
        if (isValidNode(input) === false) {
            error = new CoreIllegalArgumentError('Parameter \'' + nameOfInput + '\' is not a valid node.');
            if (isAsync) {
                return error;
            } else {
                throw error;
            }
        }
    }

    function ensureHash(input, nameOfInput, isAsync) {
        var error;
        if (REGEXP.DB_HASH.test(input) === false) {
            error = new CoreIllegalArgumentError('Parameter \'' + nameOfInput + '\' is not a valid hash.');
            if (isAsync) {
                return error;
            } else {
                throw error;
            }
        }
    }

    function ensureGuid(input, nameOfInput, isAsync) {
        var error;
        if (REGEXP.GUID.test(input) === false) {
            error = new CoreIllegalArgumentError('Parameter \'' + nameOfInput + '\' is not a valid GUID.');
            if (isAsync) {
                return error;
            } else {
                throw error;
            }
        }
    }

    function ensureMinMax(input, nameOfInput, isAsync) {
        var error;

        if (input === null || input === undefined) {
            return;
        }

        if (typeof input === 'number' && Number.isSafeInteger(input) && input >= -1) {
            return;
        }

        error = new CoreIllegalArgumentError('Parameter ' + nameOfInput + ' is not a safe integer from [-1,∞).');

        if (error) {
            if (isAsync) {
                return error;
            } else {
                throw error;
            }
        }
    }

    function ensureRelationName(input, nameOfInput, isAsync) {
        var error,
            reserved = [
                CONSTANTS.BASE_POINTER,
                CONSTANTS.OVERLAYS_PROPERTY,
                CONSTANTS.MEMBER_RELATION
            ];

        if (typeof input !== 'string') {
            error = new CoreIllegalArgumentError('Parameter ' + nameOfInput + ' is not of type string.');
        } else {
            if (input.indexOf('_') === 0 ||
                reserved.indexOf(input) !== -1) {
                error = new CoreIllegalArgumentError('Parameter ' + nameOfInput + ' cannot start with \'_\'' +
                    ', or be equal with any of the reserved ' + reserved + ' words.');
            }
        }

        if (error) {
            if (isAsync) {
                return error;
            } else {
                throw error;
            }
        }
    }

    function ensureMongoCompatibleKey(input, nameOfInput, hiddenIsFine, isAsync) {
        var error = null,
            realInput = input;

        if (hiddenIsFine === true && input[0] === '_') {
            realInput = input.substr(1);
        }

        if (REGEXP.DOCUMENT_KEY.test(realInput) === false) {
            error = new CoreIllegalArgumentError('Parameter ' + nameOfInput +
                ' is not a valid key (cannot contain "." or "$"' +
                (hiddenIsFine ? '' : ', or start with "_"') + ').');
        }

        if (error) {
            if (isAsync) {
                return error;
            } else {
                throw error;
            }
        }
    }

    function getCommonAncestor(node1, node2, getter) {
        function getChain(node) {
            var ancestors = [];

            while (node) {
                ancestors.push(node);
                node = getter(node);
            }

            return ancestors;
        }

        var ancestors2 = getChain(node2),
            i;

        while (node1) {
            for (i = 0; i < ancestors2.length; i += 1) {
                if (node1 === ancestors2[i]) {
                    return node1;
                }
            }

            node1 = getter(node1);
        }

        return null;
    }

    /**
     * @param {ProjectInterface} project - project connected to storage
     * @param {object} options - contains logging information
     * @param {object} options.logger - gmeLogger
     * @param {object} options.globConf - gmeConfig
     * @alias Core
     * @description The Core defines the main API for model manipulation and traversal. It is important to note, that
     * all 'Path' function must be used with caution as the returned information is just an estimate and does not
     * guarantee that the actual node will exist (as in certain scenarios they might become invalid and need to
     * be removed, but said removal can only take place during their load). Try to always 'Load' every
     * node before depending on their paths.
     * @constructor
     */
    function Core(project, options) {
        var core,
            coreLayers = [];
        coreLayers.push(CoreRel);
        coreLayers.push(NullPtr);
        coreLayers.push(Type);
        coreLayers.push(NullPtr);
        coreLayers.push(Set);
        coreLayers.push(Guid);
        coreLayers.push(Constraint);
        coreLayers.push(MetaCore);
        coreLayers.push(MetaCacheCore);
        coreLayers.push(MixinCore);
        coreLayers.push(MetaQueryCore);
        coreLayers.push(CoreDiff);

        coreLayers.push(TreeLoader);

        coreLayers.push(LibraryCore);

        // TODO check how we should handle the TASYNC error handling...
        // if (options.usertype !== 'tasync') {
        //     coreLayers.push(UnWrap);
        // }
        coreLayers.push(UnWrap);

        core = coreLayers.reduce(function (inner, Class) {
            return new Class(inner, options);
        }, new CoreTree(project, options));

        isValidNode = core.isValidNode;
        isValidPath = core.isValidPath;

        /**
         * Returns the parent of the node.
         * @param {module:Core~Node} node - the node in question
         *
         * @return {module:Core~Node|null} Returns the parent of the node or NULL if it has no parent.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getParent = function (node) {
            ensureNode(node, 'node');

            return core.getParent(node);
        };

        /**
         * Returns the common parent node of all supplied nodes. Note that if a node and its parent are passed,
         * the method will return the parent of the parent.
         * @param {...module:Core~Node} nodes - a variable number of nodes to compare
         *
         * @return {module:Core~Node|null} The common parent. Will be null whenever the root-node is passed in.
         * @example
         * core.getCommonParent(node1, node2, node3);
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getCommonParent = function () {
            var nodesArr = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)),
                result,
                i;

            nodesArr.forEach(function (node, idx) {
                ensureNode(node, 'arguments[' + idx + ']');
            });

            result = nodesArr[0];

            for (i = 1; i < nodesArr.length; i += 1) {
                result = getCommonAncestor(result, nodesArr[i], core.getParent);
            }

            if (result && nodesArr.indexOf(result) > -1) {
                result = core.getParent(result);
            }

            return result || null;
        };

        /**
         * Returns the parent-relative identifier of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string|null} Returns the last segment of the node path.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getRelid = function (node) {
            ensureNode(node, 'node');

            return core.getRelid(node);
        };

        /**
         * Returns the root node of the containment tree that node is part of.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {module:Core~Node} Returns the root of the containment hierarchy (it can be the node itself).
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getRoot = function (node) {
            ensureNode(node, 'node');

            return core.getRoot(node);
        };

        /**
         * Returns the complete path of the node in the containment hierarchy.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string} Returns a path string where each portion is a relative id and they are separated by '/'.
         * The path can be empty as well if the node in question is the  root itself, otherwise it should be a chain
         * of relative ids from the root of the containment hierarchy.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getPath = function (node) {
            ensureNode(node, 'node');

            return core.getPath(node);
        };

        /**
         * Retrieves the child of the input node at the given relative id. It is not an asynchronous load
         * and it automatically creates the child under the given relative id if no child was there beforehand.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} relativeId - the relative id which our child in question has.
         *
         * @return {module:Core~Node} Return an empty node if it was created as a result of the function or
         * return the already existing and loaded node if it found.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getChild = function (node, relativeId) {
            ensureNode(node, 'node');
            ensureType(relativeId, 'relativeId', 'string');

            return core.getChild(node, relativeId);
        };

        /**
         * Checks if the node in question has some actual data.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {bool} Returns true if the node is 'empty' meaning that it is not reserved by real data.
         * Returns false if the node is exists and have some meaningful value.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isEmpty = function (node) {
            ensureNode(node, 'node');

            return core.isEmpty(node);
        };

        /**
         * Returns the calculated hash and database id of the data for the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {module:Core~ObjectHash} Returns the hash value of the data for the given node.
         * An empty string is returned when the node was mutated and not persisted.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getHash = function (node) {
            ensureNode(node, 'node');

            return core.getHash(node);
        };

        /**
         * Persists the changes made in memory and computed the data blobs that needs to be saved into the database
         * to make the change and allow other users to see the new state of the project.
         * @param {module:Core~Node} node - some node element of the modified containment hierarchy (usually the root).
         *
         * @return {module:Core~GmePersisted} The function returns an object which collects all the changes
         * on data level and necessary to update the database on server side. Keys of the returned object are 'rootHash'
         * and 'objects'. The values of these should be passed to project.makeCommit.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.persist = function (node) {
            ensureNode(node, 'node');

            return core.persist(node);
        };

        /**
         * Loads the data object with the given hash and makes it a root of a containment hierarchy.
         * @param {module:Core~ObjectHash} hash - the hash of the data object we like to load as root.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreInternalError|null} callback.error - the result of the execution
         * @param {module:Core~Node} callback.node - the resulting root node
         *
         * @return {external:Promise} If no callback is given, the result will be provided in
         * a promiselike manner.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.loadRoot = function (hash, callback) {
            var error = null;

            ensureType(callback, 'callback', 'function');
            error = ensureHash(hash, 'hash', true);

            if (error) {
                callback(error);
            } else {
                core.loadRoot(hash, callback);
            }
        };

        /**
         * Loads the child of the given parent pointed by the relative id. Behind the scenes, it means
         * that it actually loads the data pointed by a hash stored inside the parent under the given id
         * and wraps it in a node object which will be connected to the parent as a child in the containment
         * hierarchy. If there is no such relative id reserved, the call will return with null.
         * @param {module:Core~Node} parent - the container node in question.
         * @param {string} relativeId - the relative id of the child in question.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreInternalError|null} callback.error - the result of the execution
         * @param {module:Core~Node} callback.node - the resulting child
         *
         * @return {external:Promise} If no callback is given, the result will be provided in a promise.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.loadChild = function (node, relativeId, callback) {
            var error = null;

            ensureType(callback, 'callback', 'function');
            error = ensureNode(node, 'node', true);
            error = error || ensureType(relativeId, 'relativeId', 'string', true);

            if (error) {
                callback(error);
            } else {
                core.loadChild(node, relativeId, callback);
            }
        };

        /**
         * From the given starting node, it loads the path given as a series of relative ids (separated by '/')
         * and returns the node it finds at the ends of the path. If there is no node, the function will return null.
         * @param {module:Core~Node} node - the starting node of our search.
         * @param {string} relativePath - the relative path - built by relative ids - of the node in question.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreInternalError|null} callback.error - the result of the execution
         * @param {module:Core~Node} callback.node - the resulting node
         *
         * @return {external:Promise} If no callback is given, the result will be provided in a promise.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.loadByPath = function (node, relativePath, callback) {
            var error = null;

            ensureType(callback, 'callback', 'function');
            error = ensureNode(node, 'node', true);
            error = error || ensurePath(relativePath, 'relativePath', true);

            if (error) {
                callback(error);
            } else {
                core.loadByPath(node, relativePath, callback);
            }
        };

        /**
         * Loads all the children of the given parent. As it first checks the already reserved relative ids of
         * the parent, it only loads the already existing children (so no on-demand empty node creation).
         * @param {module:Core~Node} node - the container node in question.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreInternalError|null} callback.error - the result of the execution
         * @param {module:Core~Node[]} callback.children - the resulting children
         *
         * @return {external:Promise} If no callback is given, the result will be provided in a promise.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.loadChildren = function (node, callback) {
            var error = null;

            ensureType(callback, 'callback', 'function');
            error = ensureNode(node, 'node', true);

            if (error) {
                callback(error);
            } else {
                core.loadChildren(node, callback);
            }
        };

        /**
         * Loads all the children of the given parent that has some data and not just inherited. As it first checks
         * the already reserved relative ids of the parent, it only loads the already existing children
         * (so no on-demand empty node creation).
         * @param {module:Core~Node} node - the container node in question.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreInternalError|null} callback.error - the result of the execution
         * @param {module:Core~Node[]} callback.node - the resulting children
         *
         * @return {external:Promise} If no callback is given, the result will be provided in a promise.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.loadOwnChildren = function (node, callback) {
            var error = null;

            ensureType(callback, 'callback', 'function');
            error = ensureNode(node, 'node', true);

            if (error) {
                callback(error);
            } else {
                core.loadOwnChildren(node, callback);
            }
        };

        /**
         * Loads the target of the given pointer of the given node. In the callback the node can have three values:
         * if the node is valid, then it is the defined target of a valid pointer,
         * if the returned value is null, then it means that the pointer is defined, but has no real target,
         * finally if the returned value is undefined than there is no such pointer defined for the given node.
         * @param {module:Core~Node} node - the source node in question.
         * @param {string} pointerName - the name of the pointer.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreInternalError|null} callback.error - the result of the execution
         * @param {module:Core~Node} callback.node - the resulting target
         *
         * @return {external:Promise} If no callback is given, the result will be provided in a promise.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.loadPointer = function (node, pointerName, callback) {
            var error = null;

            ensureType(callback, 'callback', 'function');
            error = ensureNode(node, 'node', true);
            error = error || ensureType(pointerName, 'pointerName', 'string', true);

            if (error) {
                callback(error);
            } else {
                core.loadPointer(node, pointerName, callback);
            }

        };

        /**
         * Loads all the source nodes that has such a pointer and its target is the given node.
         * @param {module:Core~Node} node - the target node in question.
         * @param {string} pointerName - the name of the pointer of the sources.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreInternalError|null} callback.error - the result of the execution
         * @param {module:Core~Node[]} callback.node - the resulting sources
         *
         * @return {external:Promise} If no callback is given, the result will be provided in a promise.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.loadCollection = function (node, pointerName, callback) {
            var error = null;

            ensureType(callback, 'callback', 'function');
            error = ensureNode(node, 'node', true);
            error = error || ensureType(pointerName, 'pointerName', 'string', true);

            if (error) {
                callback(error);
            } else {
                core.loadCollection(node, pointerName, callback);
            }
        };

        /**
         * Loads a complete sub-tree of the containment hierarchy starting from the given node.
         * @param {module:Core~Node} node - the node that is the root of the sub-tree in question.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreInternalError|null} callback.error - the result of the execution
         * @param {module:Core~Node[]} callback.nodes - the resulting sources
         *
         * @return {external:Promise} If no callback is given, the result will be provided in a promise.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.loadSubTree = function (node, callback) {
            var error = null;

            ensureType(callback, 'callback', 'function');
            error = ensureNode(node, 'node', true);

            if (error) {
                callback(error);
            } else {
                core.loadSubTree(node, callback);
            }
        };

        /**
         * Loads a complete sub-tree of the containment hierarchy starting from the given node, but load only those
         * children that has some additional data and not purely inherited.
         * @param {module:Core~Node} node - the container node in question.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreInternalError|null} callback.error - the result of the execution
         * @param {module:Core~Node[]} callback.nodes - the resulting sources
         *
         * @return {external:Promise} If no callback is given, the result will be provided in a promise.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.loadOwnSubTree = function (node, callback) {
            var error = null;

            ensureType(callback, 'callback', 'function');
            error = ensureNode(node, 'node', true);

            if (error) {
                callback(error);
            } else {
                core.loadOwnSubTree(node, callback);
            }
        };

        /**
         * Loads a complete containment hierarchy using the data object - pointed by the given hash -
         * as the root.
         * @param {module:Core~ObjectHash} hash - hash of the root node.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreInternalError|null} callback.error - the result of the execution.
         * @param {module:Core~Node[]} callback.nodes - the resulting nodes.
         *
         * @return {external:Promise} If no callback is given, the result will be provided in a promise.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.loadTree = function (hash, callback) {
            var error = null;

            ensureType(callback, 'callback', 'function');
            error = ensureHash(hash, 'hash', true);

            if (error) {
                callback(error);
            } else {
                core.loadTree(hash, callback);
            }
        };

        /**
         * Collects the relative ids of all the children of the given node.
         * @param {module:Core~Node} node - the container node in question.
         *
         * @return {string[]} The function returns an array of the relative ids.
         */
        this.getChildrenRelids = function (node) {
            ensureNode(node, 'node');

            return core.getChildrenRelids(node);
        };

        /**
         * Collects the relative ids of all the children of the given node that has some data and not just inherited.
         * N.B. Do not mutate the returned array!
         * @param {module:Core~Node} node - the container node in question.
         *
         * @return {string[]} The function returns an array of the relative ids.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnChildrenRelids = function (node) {
            ensureNode(node, 'node');

            return core.getOwnChildrenRelids(node);
        };

        /**
         * Collects the paths of all the children of the given node.
         * @param {module:Core~Node} node - the container node in question.
         *
         *@return {string[]} The function returns an array of the absolute paths of the children.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getChildrenPaths = function (node) {
            ensureNode(node, 'node');

            return core.getChildrenPaths(node);
        };

        /**
         * Collects the paths of all the children of the given node that has some data as well and not just inherited.
         * @param {module:Core~Node} parent - the container node in question.
         *
         *@return {string[]} The function returns an array of the absolute paths of the children.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnChildrenPaths = function (node) {
            ensureNode(node, 'node');

            return core.getOwnChildrenPaths(node);
        };

        /**
         * Creates a node according to the given parameters.
         * @param {object} [parameters] - the details of the creation.
         * @param {module:Core~Node|null} [parameters.parent] - the parent of the node to be created.
         * @param {module:Core~Node|null} [parameters.base] - the base of the node to be created.
         * @param {string} [parameters.relid] - the relative id of the node to be created (if reserved, the function
         * returns the node behind the relative id)
         * @param {module:Core~GUID} [parameters.guid] - the GUID of the node to be created
         *
         *
         * @return {module:Core~Node} The function returns the created node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.createNode = function (parameters) {
            if (parameters) {
                ensureType(parameters, 'parameters', 'object');
                if (parameters.hasOwnProperty('parent') &&
                    parameters.parent !== null && parameters.parent !== undefined) {
                    ensureNode(parameters.parent, 'parameters.parent');
                }
                if (parameters.hasOwnProperty('base') &&
                    parameters.base !== null && parameters.base !== undefined) {
                    ensureNode(parameters.base, 'parameters.base');
                }
                if (parameters.hasOwnProperty('guid') && parameters.guid !== undefined) {
                    ensureGuid(parameters.guid, 'parameters.guid');
                }
            }
            return core.createNode(parameters);
        };


        /**
         * Creates a child, with base as provided, inside the provided node.
         * @param {module:Core~Node} node - the parent of the node to be created.
         * @param {module:Core~Node} base - the base of the node to be created.
         *
         * @return {module:Core~Node} The function returns the created child node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.createChild = function (node, base) {
            ensureNode(node, 'node');
            ensureNode(base, 'base');

            return core.createNode({parent: node, base: base});
        };

        /**
         * Removes a node from the containment hierarchy.
         * @param {module:Core~Node} node - the node to be removed.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.deleteNode = function (node) {
            ensureNode(node, 'node');
            if (core.getParent(node) === null) {
                throw new CoreIllegalOperationError('Not allowed to delete node without a parent.');
            }

            return core.deleteNode(node, false);
        };

        /**
         * Copies the given node into parent.
         * @param {module:Core~Node} node - the node to be copied.
         * @param {module:Core~Node} parent - the parent node of the copy.
         *
         * @return {module:Core~Node} The function returns the copied node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.copyNode = function (node, parent) {
            ensureNode(node, 'node');
            ensureNode(parent, 'parent');

            return core.copyNode(node, parent);
        };

        /**
         * Copies the given nodes into parent.
         * @param {module:Core~Node[]} nodes - the nodes to be copied.
         * @param {module:Core~Node} parent - the parent node of the copy.
         *
         * @return {module:Core~Node[]} The function returns an array of the copied nodes. The order follows
         * the order of originals.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.copyNodes = function (nodes, parent) {
            var i;
            ensureInstanceOf(nodes, 'nodes', Array);
            for (i = 0; i < nodes.length; i += 1) {
                ensureNode(nodes[i], 'nodes[' + i + ']');
            }
            ensureNode(parent, 'parent');

            return core.copyNodes(nodes, parent);
        };

        /**
         * Checks if parent can be the new parent of node.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node} parent - the new parent.
         *
         * @return {boolean} True if the supplied parent is a valid parent for the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isValidNewParent = function (node, parent) {
            ensureNode(node, 'node');
            ensureNode(parent, 'parent');

            return core.isValidNewParent(node, parent);
        };

        /**
         * Moves the given node under the given parent.
         * @param {module:Core~Node} node - the node to be moved.
         * @param {module:Core~Node} parent - the parent node of the copy.
         *
         * @return {module:Core~Node} The function returns the node after the move.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.moveNode = function (node, parent) {
            ensureNode(node, 'node');
            ensureNode(parent, 'parent');

            return core.moveNode(node, parent);
        };

        /**
         * Returns the names of the defined attributes of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns an array of the names of the attributes of the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getAttributeNames = function (node) {
            ensureNode(node, 'node');

            return core.getAttributeNames(node);
        };

        /**
         * Retrieves the value of the given attribute of the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the attribute.
         *
         * @return {string|number|bool|object|undefined} The function returns the value of the attribute of the node.
         * If the value is undefined that means the node do not have
         * such attribute defined.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getAttribute = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            return core.copyIfObject(core.getAttribute(node, name));
        };

        /**
         * Sets the value of the given attribute of the given node. It defines the attribute on demand, means that it
         * will set the given attribute even if was ot defined for the node beforehand.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the attribute.
         * @param {string|number|bool|object} value - the new of the attribute, undefined is not allowed.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.setAttribute = function (node, name, value) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensureMongoCompatibleKey(name, 'name', true);
            ensureValue(value, 'value');

            return core.setAttribute(node, name, value);
        };

        /**
         * Removes the given attributes from the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the attribute.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.delAttribute = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            return core.delAttribute(node, name);
        };

        /**
         * Returns the names of the defined registry entries of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns an array of the names of the registry entries of the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getRegistryNames = function (node) {
            ensureNode(node, 'node');

            return core.getRegistryNames(node);
        };

        /**
         * Retrieves the value of the given registry entry of the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the registry entry.
         *
         * @return {string|number|bool|object|undefined} The function returns the value of the registry entry
         * of the node. The value can be an object or any primitive type. If the value is undefined that means
         * the node do not have such attribute defined.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getRegistry = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            return core.copyIfObject(core.getRegistry(node, name));
        };

        /**
         * Sets the value of the given registry entry of the given node. It defines the registry entry on demand,
         * means that it will set the given registry entry even if was ot defined for the node beforehand.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the registry entry.
         * @param {string|number|bool|object} value - the new of the registry entry. Can be any primitive
         * type or object. Undefined is not allowed.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.setRegistry = function (node, name, value) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensureMongoCompatibleKey(name, 'name', true);
            ensureValue(value, 'value');

            return core.setRegistry(node, name, value);
        };

        /**
         * Removes the given registry entry from the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the registry entry.
         *
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.delRegistry = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            return core.delRegistry(node, name);
        };

        /**
         * Retrieves a list of the defined pointer names of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns an array of the names of the pointers of the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getPointerNames = function (node) {
            ensureNode(node, 'node');

            return core.getPointerNames(node);
        };

        /**
         * Retrieves the path of the target of the given pointer of the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer in question.
         *
         * @return {string|null|undefined} The function returns the absolute path of the target node
         * if there is a valid target. It returns null if though the pointer is defined it does not have any
         * valid target. Finally, it return undefined if there is no pointer defined for the node under the given name.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getPointerPath = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            return core.getPointerPath(node, name);
        };

        /**
         * Removes the pointer from the node. (Aliased deletePointer.)
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer in question.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.delPointer = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            return core.deletePointer(node, name);
        };

        /**
         * Removes the pointer from the node. (Aliased delPointer.)
         * @function
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer in question.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.deletePointer = this.delPointer;

        /**
         * Sets the target of the pointer of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer in question.
         * @param {module:Core~Node|null} target - the new target of the pointer.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.setPointer = function (node, name, target) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensureMongoCompatibleKey(name, 'name', true);
            if (target !== null) {
                ensureNode(target, 'target');
            }

            return core.setPointer(node, name, target);
        };

        /**
         * Retrieves a list of the defined pointer names that has the node as target.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns an array of the names of the pointers pointing to the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getCollectionNames = function (node) {
            ensureNode(node, 'node');

            return core.getCollectionNames(node);
        };

        /**
         * Retrieves a list of absolute paths of nodes that has a given pointer which points to the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer.
         *
         * @return {string[]} The function returns an array of absolute paths of nodes that
         * has the pointer pointing to the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getCollectionPaths = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            return core.getCollectionPaths(node, name);
        };

        /**
         * Collects the data hash values of the children of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {Object<string, module:Core~ObjectHash>} The function returns a dictionary of
         * {@link module:Core~ObjectHash} that stored in pair with the relative id of the corresponding
         * child of the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getChildrenHashes = function (node) {
            ensureNode(node, 'node');

            return core.getChildrenHashes(node);
        };

        /**
         * Returns the base node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {module:Core~Node|null} Returns the base of the given node or null if there is no such node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getBase = function (node) {
            ensureNode(node, 'node');

            return core.getBase(node);
        };

        /**
         * Returns the common base node of all supplied nodes. Note that if a node and its base are passed,
         * the method will return the base of the base.
         * @param {...module:Core~Node} nodes - a variable number of nodes to compare
         *
         * @return {module:Core~Node|null} The common base or null if e.g. the root node was passed or the fco.
         * @example
         * core.getCommonBase(node1, node2, node3);
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getCommonBase = function () {
            var nodesArr = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)),
                result,
                i;

            nodesArr.forEach(function (node, idx) {
                ensureNode(node, 'arguments[' + idx + ']');
            });

            result = nodesArr[0];

            for (i = 1; i < nodesArr.length; i += 1) {
                result = getCommonAncestor(result, nodesArr[i], core.getBase);
            }

            if (result && nodesArr.indexOf(result) > -1) {
                result = core.getBase(result);
            }

            return result || null;
        };

        /**
         * Returns the root of the inheritance chain of the given node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {module:Core~Node} Returns the root of the inheritance chain (usually the FCO).
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getBaseRoot = function (node) {
            ensureNode(node, 'node');

            return core.getBaseRoot(node);
        };

        /**
         * Returns the names of the attributes of the node that have been first defined for the node and not for its
         * bases.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns an array of the names of the own attributes of the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnAttributeNames = function (node) {
            ensureNode(node, 'node');

            return core.getOwnAttributeNames(node);
        };

        /**
         * Returns the names of the registry enrties of the node that have been first defined for the node
         * and not for its bases.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns an array of the names of the own registry entries of the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnRegistryNames = function (node) {
            ensureNode(node, 'node');

            return core.getOwnRegistryNames(node);
        };

        /**
         * Returns the value of the attribute defined for the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the attribute.
         *
         * @return {string|number|bool|object|undefined} Returns the value of the attribute defined specifically for
         * the node. If undefined then it means that there is no such attribute defined directly for the node, meaning
         * that it either inherits some value or there is no such attribute at all.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnAttribute = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            return core.copyIfObject(core.getOwnAttribute(node, name));
        };

        /**
         * Returns the value of the registry entry defined for the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the registry entry.
         *
         * @return {string|number|bool|object|undefined} Returns the value of the registry entry defined specifically
         * for the node. If undefined then it means that there is no such registry entry defined directly for the node,
         * meaning that it either inherits some value or there is no such registry entry at all.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnRegistry = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            return core.copyIfObject(core.getOwnRegistry(node, name));
        };

        /**
         * Returns the list of the names of the pointers that were defined specifically for the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} Returns an array of names of pointers defined specifically for the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnPointerNames = function (node) {
            ensureNode(node, 'node');

            return core.getOwnPointerNames(node);
        };

        /**
         * Returns the absolute path of the target of the pointer specifically defined for the node.
         * @param {module:Core~Node} node - the node in question
         * @param {string} name - the name of the pointer
         *
         * @return {string|null|undefined} Returns the absolute path. If the path is null, then it means that
         * 'no-target' was defined specifically for this node for the pointer. If undefined it means that the node
         * either inherits the target of the pointer or there is no pointer defined at all.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnPointerPath = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            return core.getOwnPointerPath(node, name);
        };

        /**
         * Checks if base can be the new base of node.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node|null|undefined} base - the new base.
         *
         * @return {boolean} True if the supplied base is a valid base for the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isValidNewBase = function (node, base) {
            ensureNode(node, 'node');
            if (base !== null) {
                ensureNode(base, 'base');
            }

            return core.isValidNewBase(node, base);
        };

        /**
         * Sets the base node of the given node. The function doesn't touch the properties or the children of the node
         * so it can cause META rule violations that needs to be corrected manually.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node|null} base - the new base.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.setBase = function (node, base) {
            ensureNode(node, 'node');
            if (base !== null) {
                ensureNode(base, 'base');
            }

            core.setBase(node, base);
        };

        /**
         * Returns the root of the inheritance chain (cannot be the node itself).
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {module:Core~Node|null} Returns the root of the inheritance chain of the node. If returns null,
         * that means the node in question is the root of the chain.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getTypeRoot = function (node) {
            ensureNode(node, 'node');

            return core.getTypeRoot(node);
        };

        /**
         * Returns the names of the sets of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} Returns an array of set names that the node has.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getSetNames = function (node) {
            ensureNode(node, 'node');

            return core.getSetNames(node);
        };

        /**
         * Returns the names of the sets created specifically at the node.
         * N.B. When adding a member to a set of a node, the set is automatically created at the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} Returns an array of set names that were specifically created at the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnSetNames = function (node) {
            ensureNode(node, 'node');

            return core.getOwnSetNames(node);
        };

        /**
         * Creates a set for the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.createSet = function (node, name) {
            ensureNode(node, 'node');
            ensureRelationName(name, 'name');
            ensureMongoCompatibleKey(name, 'name', false);
            core.createSet(node, name);
        };

        /**
         * Removes a set from the node. (Aliased deleteSet.)
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.delSet = function (node, name) {
            ensureNode(node, 'node');
            ensureRelationName(name, 'name');

            core.deleteSet(node, name);
        };

        /**
         * Removes a set from the node. (Aliased delSet.)
         * @function
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.deleteSet = this.delSet;

        /**
         * Return the names of the attribute entries for the set.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         *
         * @return {string[]} Returns the array of names of attribute entries in the set.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getSetAttributeNames = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            var names = core.getSetNames(node);
            if (names.indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of unknown set.');
            }

            return core.getSetAttributeNames(node, name);
        };

        /**
         * Return the names of the attribute entries specifically set for the set at the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         *
         * @return {string[]} Returns the array of names of attribute entries defined in the set at the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnSetAttributeNames = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            var names = core.getSetNames(node);
            if (names.indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of unknown set.');
            }

            return core.getOwnSetAttributeNames(node, name);
        };

        /**
         * Get the value of the attribute entry in the set.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} attrName - the name of the attribute entry.
         *
         * @return {string|number|bool|object|undefined} Return the value of the attribute. If it is undefined,
         * then there is no such attribute at the set.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getSetAttribute = function (node, setName, attrName) {
            ensureNode(node, 'node');
            ensureType(setName, 'setName', 'string');
            ensureType(attrName, 'attrName', 'string');
            var names = core.getSetNames(node);
            if (names.indexOf(setName) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of unknown set.');
            }

            return core.copyIfObject(core.getSetAttribute(node, setName, attrName));
        };

        /**
         * Get the value of the attribute entry specifically set for the set at the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} attrName - the name of the attribute entry.
         *
         * @return {string|number|bool|object|undefined} Return the value of the attribute. If it is undefined,
         * then there is no such attribute at the set.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnSetAttribute = function (node, setName, attrName) {
            ensureNode(node, 'node');
            ensureType(setName, 'setName', 'string');
            ensureType(attrName, 'attrName', 'string');
            var names = core.getSetNames(node);
            if (names.indexOf(setName) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of unknown set.');
            }

            return core.copyIfObject(core.getOwnSetAttribute(node, setName, attrName));
        };

        /**
         * Sets the attribute entry value for the set at the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} attrName - the name of the attribute entry.
         * @param {string|number|bool|object} value - the new value of the attribute.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.setSetAttribute = function (node, setName, attrName, value) {
            ensureNode(node, 'node');
            ensureType(setName, 'setName', 'string');
            ensureType(attrName, 'attrName', 'string');
            ensureMongoCompatibleKey(attrName, 'attrName', true);
            ensureValue(value, 'value');
            var names = core.getSetNames(node);
            if (names.indexOf(setName) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of unknown set.');
            }

            core.setSetAttribute(node, setName, attrName, value);
        };

        /**
         * Removes the attribute entry for the set at the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} attrName - the name of the attribute entry.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.delSetAttribute = function (node, setName, attrName) {
            ensureNode(node, 'node');
            ensureType(setName, 'setName', 'string');
            ensureType(attrName, 'attrName', 'string');
            var names = core.getSetNames(node);
            if (names.indexOf(setName) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of unknown set.');
            }

            core.delSetAttribute(node, setName, attrName);
        };

        //Regs

        /**
         * Return the names of the registry entries for the set.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         *
         * @return {string[]} Returns the array of names of registry entries in the set.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getSetRegistryNames = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            var names = core.getSetNames(node);
            if (names.indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of unknown set.');
            }

            return core.getSetRegistryNames(node, name);
        };

        /**
         * Return the names of the registry entries specifically set for the set at the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         *
         * @return {string[]} Returns the array of names of registry entries defined in the set at the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnSetRegistryNames = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            var names = core.getSetNames(node);
            if (names.indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of unknown set.');
            }

            return core.getOwnSetRegistryNames(node, name);
        };

        /**
         * Get the value of the registry entry in the set.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} regName - the name of the registry entry.
         *
         * @return {string|number|bool|object|undefined} Return the value of the registry. If it is undefined,
         * then there is no such registry at the set.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getSetRegistry = function (node, setName, regName) {
            ensureNode(node, 'node');
            ensureType(setName, 'setName', 'string');
            ensureType(regName, 'regName', 'string');
            var names = core.getSetNames(node);
            if (names.indexOf(setName) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of unknown set.');
            }

            return core.copyIfObject(core.getSetRegistry(node, setName, regName));
        };

        /**
         * Get the value of the registry entry specifically set for the set at the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} regName - the name of the registry entry.
         *
         * @return {string|number|bool|object|undefined} Return the value of the registry. If it is undefined,
         * then there is no such registry at the set.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnSetRegistry = function (node, setName, regName) {
            ensureNode(node, 'node');
            ensureType(setName, 'setName', 'string');
            ensureType(regName, 'regName', 'string');
            var names = core.getSetNames(node);
            if (names.indexOf(setName) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of unknown set.');
            }

            return core.copyIfObject(core.getOwnSetRegistry(node, setName, regName));
        };

        /**
         * Sets the registry entry value for the set at the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} regName - the name of the registry entry.
         * @param {string|number|bool|object} value - the new value of the registry.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.setSetRegistry = function (node, setName, regName, value) {
            ensureNode(node, 'node');
            ensureType(setName, 'setName', 'string');
            ensureType(regName, 'regName', 'string');
            ensureMongoCompatibleKey(regName, 'regName', true);
            ensureValue(value, 'value');
            var names = core.getSetNames(node);
            if (names.indexOf(setName) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of unknown set.');
            }

            core.setSetRegistry(node, setName, regName, value);
        };

        /**
         * Removes the registry entry for the set at the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} regName - the name of the registry entry.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.delSetRegistry = function (node, setName, regName) {
            ensureNode(node, 'node');
            ensureType(setName, 'setName', 'string');
            ensureType(regName, 'regName', 'string');
            var names = core.getSetNames(node);
            if (names.indexOf(setName) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of unknown set.');
            }

            core.delSetRegistry(node, setName, regName);
        };

        /**
         * Returns the list of absolute paths of the members of the given set of the given node.
         * @param {module:Core~Node} node - the set owner.
         * @param {string} name - the name of the set.
         *
         * @return {string[]} Returns an array of absolute path strings of the member nodes of the set.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getMemberPaths = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            var names = core.getSetNames(node).concat(core.getValidSetNames(node));
            if (names.indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Cannot access member information of unknown set.');
            }

            return core.getMemberPaths(node, name);
        };

        /**
         * Returns the list of absolute paths of the members of the given set of the given node that not simply
         * inherited.
         * @param {module:Core~Node} node - the set owner.
         * @param {string} name - the name of the set.
         *
         * @return {string[]} Returns an array of absolute path strings of the member nodes of the set that has
         * information on the node's inheritance level.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnMemberPaths = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            var names = core.getSetNames(node).concat(core.getValidSetNames(node));

            if (names.indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Cannot access member information of unknown set.');
            }

            return core.getOwnMemberPaths(node, name);
        };

        /**
         * Removes a member from the set. The functions doesn't remove the node itself.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         * @param {string} path - the absolute path of the member to be removed.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.delMember = function (node, name, path) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensurePath(path, 'path');
            var names = core.getSetNames(node);
            if (names.indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Cannot access member information of unknown set.');
            }

            core.delMember(node, name, path);
        };

        /**
         * Adds a member to the given set.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         * @param {module:Core~Node} member - the new member of the set.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.addMember = function (node, name, member) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensureRelationName(name, 'name');
            ensureMongoCompatibleKey(name, 'name', false);
            ensureNode(member, 'member');

            core.addMember(node, name, member);
        };

        /**
         * Return the names of the attributes defined for the set membership to the member node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         * @param {string} path - the absolute path of the member.
         *
         * @return {string[]} Returns the array of names of attributes that represents some property of the membership.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getMemberAttributeNames = function (node, name, path) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensurePath(path, 'path');
            var names = core.getSetNames(node);
            if (names.indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Cannot access member information of unknown set.');
            }
            var paths = core.getMemberPaths(node, name);
            if (paths.indexOf(path) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of an unknown member.');
            }

            return core.getMemberAttributeNames(node, name, path);
        };

        /**
         * Return the names of the attributes defined for the set membership specifically defined to the member node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         * @param {string} path - the absolute path of the member.
         *
         * @return {string[]} Returns the array of names of attributes that represents some property of the membership.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getMemberOwnAttributeNames = function (node, name, path) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensurePath(path, 'path');
            var names = core.getSetNames(node);
            if (names.indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Cannot access member information of unknown set.');
            }
            var paths = core.getMemberPaths(node, name);
            if (paths.indexOf(path) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of an unknown member.');
            }

            return core.getMemberOwnAttributeNames(node, name, path);
        };

        /**
         * Get the value of the attribute in relation with the set membership.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} path - the absolute path of the member node.
         * @param {string} attrName - the name of the attribute.
         *
         * @return {string|number|bool|object|undefined} Return the value of the attribute. If it is undefined,
         * then there is no such attributed connected to the given set membership.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getMemberAttribute = function (node, setName, path, attrName) {
            ensureNode(node, 'node');
            ensureType(setName, 'setName', 'string');
            ensurePath(path, 'path');
            ensureType(attrName, 'attrName', 'string');
            var names = core.getSetNames(node);
            if (names.indexOf(setName) === -1) {
                throw new CoreIllegalOperationError('Cannot access member information of unknown set.');
            }
            var paths = core.getMemberPaths(node, setName);
            if (paths.indexOf(path) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of an unknown member.');
            }

            return core.copyIfObject(core.getMemberAttribute(node, setName, path, attrName));
        };

        /**
         * Get the value of the attribute for the set membership specifically defined to the member node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} path - the absolute path of the member node.
         * @param {string} attrName - the name of the attribute.
         *
         * @return {string|number|bool|object|undefined} Return the value of the attribute. If it is undefined,
         * then there is no such attributed connected to the given set membership.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getMemberOwnAttribute = function (node, setName, path, attrName) {
            ensureNode(node, 'node');
            ensureType(setName, 'setName', 'string');
            ensurePath(path, 'path');
            ensureType(attrName, 'attrName', 'string');
            var names = core.getSetNames(node);
            if (names.indexOf(setName) === -1) {
                throw new CoreIllegalOperationError('Cannot access member information of unknown set.');
            }
            var paths = core.getMemberPaths(node, setName);
            if (paths.indexOf(path) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of an unknown member.');
            }

            return core.copyIfObject(core.getMemberOwnAttribute(node, setName, path, attrName));
        };

        /**
         * Sets the attribute value which represents a property of the membership.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} path - the absolute path of the member node.
         * @param {string} attrName - the name of the attribute.
         * @param {string|number|bool|object} value - the new value of the attribute.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.setMemberAttribute = function (node, setName, path, attrName, value) {
            ensureNode(node, 'node');
            ensureType(setName, 'setName', 'string');
            ensurePath(path, 'path');
            ensureType(attrName, 'attrName', 'string');
            ensureMongoCompatibleKey(attrName, 'attrName', true);
            ensureValue(value, 'value');
            var names = core.getSetNames(node);
            if (names.indexOf(setName) === -1) {
                throw new CoreIllegalOperationError('Cannot access member information of unknown set.');
            }
            var paths = core.getMemberPaths(node, setName);
            if (paths.indexOf(path) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of an unknown member.');
            }

            core.setMemberAttribute(node, setName, path, attrName, value);
        };

        /**
         * Removes an attribute which represented a property of the given set membership.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} memberPath - the absolute path of the member node.
         * @param {string} attrName - the name of the attribute.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.delMemberAttribute = function (node, setName, memberPath, attrName) {
            ensureNode(node, 'node');
            ensureType(setName, 'setName', 'string');
            ensurePath(memberPath, 'memberPath');
            ensureType(attrName, 'attrName', 'string');
            var names = core.getSetNames(node);
            if (names.indexOf(setName) === -1) {
                throw new CoreIllegalOperationError('Cannot access member information of unknown set.');
            }
            var paths = core.getMemberPaths(node, setName);
            if (paths.indexOf(memberPath) === -1) {
                throw new CoreIllegalOperationError('Cannot access attributes of an unknown member.');
            }

            core.delMemberAttribute(node, setName, memberPath, attrName);
        };

        /**
         * Return the names of the registry entries defined for the set membership to the member node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         * @param {string} path - the absolute path of the member.
         *
         * @return {string[]} Returns the array of names of registry entries that represents some property of the
         * membership.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getMemberRegistryNames = function (node, name, path) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensurePath(path, 'path');
            var names = core.getSetNames(node);
            if (names.indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Cannot access member information of unknown set.');
            }
            var paths = core.getMemberPaths(node, name);
            if (paths.indexOf(path) === -1) {
                throw new CoreIllegalOperationError('Cannot access registry of an unknown member.');
            }

            return core.getMemberRegistryNames(node, name, path);
        };

        /**
         * Return the names of the registry entries defined for the set membership specifically defined to
         * the member node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         * @param {string} path - the absolute path of the member.
         *
         * @return {string[]} Returns the array of names of registry entries that represents some property of the
         * membership.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getMemberOwnRegistryNames = function (node, name, path) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensurePath(path, 'path');
            var names = core.getSetNames(node);
            if (names.indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Cannot access member information of unknown set.');
            }
            var paths = core.getMemberPaths(node, name);
            if (paths.indexOf(path) === -1) {
                throw new CoreIllegalOperationError('Cannot access registry of an unknown member.');
            }

            return core.getMemberOwnRegistryNames(node, name, path);
        };

        /**
         * Get the value of the registry entry in relation with the set membership.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} path - the absolute path of the member node.
         * @param {string} regName - the name of the registry entry.
         *
         * @return {string|number|bool|object|undefined} Return the value of the registry. If it is undefined,
         * then there is no such registry connected to the given set membership.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getMemberRegistry = function (node, setName, path, regName) {
            ensureNode(node, 'node');
            ensureType(setName, 'setName', 'string');
            ensurePath(path, 'path');
            ensureType(regName, 'regName', 'string');
            var names = core.getSetNames(node);
            if (names.indexOf(setName) === -1) {
                throw new CoreIllegalOperationError('Cannot access member information of unknown set.');
            }
            var paths = core.getMemberPaths(node, setName);
            if (paths.indexOf(path) === -1) {
                throw new CoreIllegalOperationError('Cannot access registry of an unknown member.');
            }

            return core.copyIfObject(core.getMemberRegistry(node, setName, path, regName));
        };

        /**
         * Get the value of the registry entry for the set membership specifically defined to the member node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} path - the absolute path of the member node.
         * @param {string} regName - the name of the registry entry.
         *
         * @return {string|number|bool|object|undefined} Return the value of the registry. If it is undefined,
         * then there is no such registry connected to the given set membership.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getMemberOwnRegistry = function (node, setName, path, regName) {
            ensureNode(node, 'node');
            ensureType(setName, 'setName', 'string');
            ensurePath(path, 'path');
            ensureType(regName, 'regName', 'string');
            var names = core.getSetNames(node);
            if (names.indexOf(setName) === -1) {
                throw new CoreIllegalOperationError('Cannot access member information of unknown set.');
            }
            var paths = core.getMemberPaths(node, setName);
            if (paths.indexOf(path) === -1) {
                throw new CoreIllegalOperationError('Cannot access registry of an unknown member.');
            }

            return core.copyIfObject(core.getMemberOwnRegistry(node, setName, path, regName));
        };

        /**
         * Sets the registry entry value which represents a property of the membership.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} path - the absolute path of the member node.
         * @param {string} regName - the name of the registry entry.
         * @param {string|number|bool|object} value - the new value of the registry.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.setMemberRegistry = function (node, setName, path, regName, value) {
            ensureNode(node, 'node');
            ensureType(setName, 'setName', 'string');
            ensurePath(path, 'path');
            ensureType(regName, 'regName', 'string');
            ensureMongoCompatibleKey(regName, 'regName', true);
            ensureValue(value, 'value');
            var names = core.getSetNames(node);
            if (names.indexOf(setName) === -1) {
                throw new CoreIllegalOperationError('Cannot access member information of unknown set.');
            }
            var paths = core.getMemberPaths(node, setName);
            if (paths.indexOf(path) === -1) {
                throw new CoreIllegalOperationError('Cannot access registry of an unknown member.');
            }

            core.setMemberRegistry(node, setName, path, regName, value);
        };

        /**
         * Removes a registry entry which represented a property of the given set membership.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} path - the absolute path of the member node.
         * @param {string} regName - the name of the registry entry.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.delMemberRegistry = function (node, setName, path, regName) {
            ensureNode(node, 'node');
            ensureType(setName, 'setName', 'string');
            ensurePath(path, 'path');
            ensureType(regName, 'regName', 'string');
            var names = core.getSetNames(node);
            if (names.indexOf(setName) === -1) {
                throw new CoreIllegalOperationError('Cannot access member information of unknown set.');
            }
            var paths = core.getMemberPaths(node, setName);
            if (paths.indexOf(path) === -1) {
                throw new CoreIllegalOperationError('Cannot access registry of an unknown member.');
            }

            core.delMemberRegistry(node, setName, path, regName);
        };

        /**
         * Returns all membership information of the given node.
         * @param {module:Core~Node} node - the node in question
         *
         * @return {object} Returns a dictionary where every the key of every entry is an absolute path of a set owner
         * node. The value of each entry is an array with the set names in which the node can be found as a member.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isMemberOf = function (node) {
            ensureNode(node, 'node');

            return core.isMemberOf(node);
        };

        /**
         * Get the GUID of a node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {module:Core~GUID} Returns the globally unique identifier.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getGuid = function (node) {
            ensureNode(node, 'node');

            return core.getGuid(node);
        };

        //TODO this is only used in import - export use-cases, probably could be removed...
        /**
         * Set the GUID of a node. As the Core itself do not checks whether the GUID already exists. The use of
         * this function is only advised during the creation of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~GUID} guid - the new globally unique identifier.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreIllegalOperationError|CoreInternalError|null} callback.error - the
         * result of the execution.
         *
         * @return {external:Promise} If no callback is given, the result will be provided in a promise.
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.setGuid = function (node, guid, callback) {
            var error = null;
            ensureType(callback, 'callback', 'function');
            error = ensureNode(node, 'node', true);
            error = error || ensureGuid(guid, 'guid', true);

            if (error) {
                callback(error);
            } else {
                core.setGuid(node, guid, callback);
            }

        };

        /**
         * Gets a constraint object of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the constraint.
         *
         * @return {module:Core~Constraint|null} Returns the defined constraint or null if it was not
         * defined for the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         *
         * @example
         * {
         *   script: "function (core, node, callback) {callback(null, {hasViolation: false, message: ''});}",
         *   priority: 1,
         *   info: "Should check unique name"
         * }
         */
        this.getConstraint = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            return core.getConstraint(node, name);
        };

        /**
         * Sets a constraint object of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the constraint.
         * @param {module:Core~Constraint} constraint  - the constraint to be set.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.setConstraint = function (node, name, constraint) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensureMongoCompatibleKey(name, 'name', false);
            ensureType(constraint, 'constraint', 'object');

            core.setConstraint(node, name, constraint);
        };

        /**
         * Removes a constraint from the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the constraint.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.delConstraint = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            core.delConstraint(node, name);
        };

        /**
         * Retrieves the list of constraint names defined for the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} Returns the array of names of constraints available for the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getConstraintNames = function (node) {
            ensureNode(node, 'node');

            return core.getConstraintNames(node);
        };

        /**
         * Retrieves the list of constraint names defined specifically for the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} Returns the array of names of constraints for the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnConstraintNames = function (node) {
            ensureNode(node, 'node');

            return core.getOwnConstraintNames(node);
        };

        /**
         * Checks if the given node in any way inherits from the typeNode. In addition to checking if the node
         * "isInstanceOf" of typeNode, this methods also takes mixins into account.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node|string} typeNodeOrPath - the type node we want to check or its path.
         *
         * @return {bool} The function returns true if the typeNodeOrPath represents a base node,
         * or a mixin of any of the base nodes, of the node.
         * Every node is considered to be a type of itself.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isTypeOf = function (node, typeNodeOrPath) {
            ensureNode(node, 'node');
            if (typeof typeNodeOrPath === 'string') {
                ensurePath(typeNodeOrPath, 'typeNodeOrPath');
            } else {
                ensureNode(typeNodeOrPath, 'typeNodeOrPath');
            }

            return core.isTypeOf(node, typeNodeOrPath);
        };

        /**
         * Checks if according to the META rules the given node can be a child of the parent.
         * @param {module:Core~Node} node - the node in question
         * @param {module:Core~Node} parent - the parent we like to test.
         *
         * @return {bool} The function returns true if according to the META rules the node can be a child of the
         * parent. The check does not cover multiplicity (so if the parent can only have twi children and it already
         * has them, this function will still returns true).
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isValidChildOf = function (node, parent) {
            ensureNode(node, 'node');
            ensureNode(parent, 'parent');

            return core.isValidChildOf(node, parent);
        };

        /**
         * Returns the list of the META defined pointer names of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns all the pointer names that are defined among the META rules
         * of the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getValidPointerNames = function (node) {
            ensureNode(node, 'node');

            return core.getValidPointerNames(node);
        };

        /**
         * Returns the list of the META defined pointer names of the node that were specifically defined for the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns all the pointer names that are defined among the META
         * rules of the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnValidPointerNames = function (node) {
            ensureNode(node, 'node');

            return core.getOwnValidPointerNames(node);
        };

        /**
         * Returns the list of the META defined set names of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns all the set names that are defined among the META rules of the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getValidSetNames = function (node) {
            ensureNode(node, 'node');

            return core.getValidSetNames(node);
        };

        /**
         * Returns the list of the META defined set names of the node that were specifically defined for the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns all the set names that are defined among the META rules of the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnValidSetNames = function (node) {
            ensureNode(node, 'node');

            return core.getOwnValidSetNames(node);
        };

        /**
         * Checks if the node can be a target of a pointer of the source node in accordance with the META rules.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node} source - the source to test.
         * @param {string} name - the name of the pointer.
         *
         * @return {bool} The function returns true if according to the META rules, the given node is a valid
         * target of the given pointer of the source.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isValidTargetOf = function (node, source, name) {
            ensureNode(node, 'node');
            ensureNode(source, 'source');
            ensureType(name, 'name', 'string');

            return core.isValidTargetOf(node, source, name);
        };

        /**
         * Checks if the node can be a member of the given set at the provided set-owner node. This does not take
         * cardinality rules into account.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node} setOwner - the owner of the set.
         * @param {string} name - the name of the set.
         *
         * @return {bool} The function returns true if according to the META rules, the given node is a valid
         * member of set of the given set-owner.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isValidSetMemberOf = function (node, setOwner, name) {
            ensureNode(node, 'node');
            ensureNode(setOwner, 'setOwner');
            ensureType(name, 'name', 'string');

            // This is not a typo - the isValidTargetOf method can be reused.
            return core.isValidTargetOf(node, setOwner, name);
        };

        /**
         * Returns the list of the META defined attribute names of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns all the attribute names that are defined among the META rules of the
         * node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getValidAttributeNames = function (node) {
            ensureNode(node, 'node');

            return core.getValidAttributeNames(node);
        };

        /**
         * Returns the list of the META defined attribute names of the node that were specifically defined for the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns the attribute names that are defined specifically for the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnValidAttributeNames = function (node) {
            ensureNode(node, 'node');

            return core.getOwnValidAttributeNames(node);
        };

        /**
         * Checks if the given value is of the necessary type, according to the META rules.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the attribute.
         * @param {string|number|bool|object} value - the value to test.
         *
         * @return {bool} Returns true if the value matches the META definitions.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isValidAttributeValueOf = function (node, name, value) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensureValue(value, 'value');

            if (core.getValidAttributeNames(node).indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Not a valid attribute name [' + name + '] of the node.');
            }

            return core.isValidAttributeValueOf(node, name, value);
        };

        /**
         * Returns the list of the META defined aspect names of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns all the aspect names that are defined among the META rules of the
         * node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getValidAspectNames = function (node) {
            ensureNode(node, 'node');

            return core.getValidAspectNames(node);
        };

        /**
         * Returns the list of the META defined aspect names of the node that were specifically defined for the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns the aspect names that are specifically defined for the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnValidAspectNames = function (node) {
            ensureNode(node, 'node');

            return core.getOwnValidAspectNames(node);
        };

        /**
         * Returns the list of valid children types of the given aspect.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the aspect.
         *
         * @return {string[]} The function returns a list of absolute paths of nodes that are valid children of the node
         * and fits to the META rules defined for the aspect. Any children, visible under the given aspect of the node
         * must be an instance of at least one node represented by the absolute paths.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getAspectMeta = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            return core.getAspectMeta(node, name);
        };

        /**
         * Gives a JSON representation of the META rules of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {object} Returns an object that represents all the META rules of the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         *
         * @example
         * {
         *   children: {
         *     items: [ "/1", "/c" ],
         *     minItems: [ -1, -1 ],
         *     maxItems: [ -1, -1 ]
         *   },
         *   attributes: {
         *     name: { type: "string" },
         *     level: { type: "integer"}
         *   },
         *   pointers: {
         *     ptr: {
         *       min: 1,
         *       max: 1,
         *       items: [ "/1" ],
         *       minItems: [ -1 ],
         *       maxItems: [ 1 ]
         *     },
         *     set: {
         *       min: -1,
         *       max: -1,
         *       items: [ "/c" ],
         *       minItems: [ -1 ],
         *       maxItems: [ -1 ]
         *     }
         *   },
         *   aspects: {
         *     filter: [ "/8", "/c" ]
         *   },
         *   constraints: {
         *     myConstraint: {
         *       script: "function (core, node, callback) {callback(null, {hasViolation: false, message: ''});}",
         *       priority: 1,
         *       info: "Should check unique name"
         *     }
         *   }
         * }
         * @example
         * {
         *   children: {},
         *   attributes: {
         *      name: { type: "string" },
         *   },
         *   pointers: {},
         *   aspects: {},
         *   constraints: {}
         */
        this.getJsonMeta = function (node) {
            ensureNode(node, 'node');

            return core.getJsonMeta(node);
        };

        /**
         * Returns the META rules specifically defined for the given node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {object} The function returns an object that represent the META rules that were defined
         * specifically for the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnJsonMeta = function (node) {
            ensureNode(node, 'node');

            return core.getOwnJsonMeta(node);
        };

        /**
         * Removes all META rules defined at the node. Note that it does not clear any rules from other meta-nodes
         * where the node if referenced.
         * @param {module:Core~Node} node - the node in question.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.clearMetaRules = function (node) {
            ensureNode(node, 'node');

            core.clearMetaRules(node);
        };

        /**
         * Sets the META rules of the attribute of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the attribute.
         * @param {object} rule - the rules that defines the attribute
         * @param {'string'|'integer'|'float'|'boolean'|'asset'} rule.type - the type of the attribute (valid types see
         * CONSTANTS.ATTRIBUTE_TYPES).
         * @param {string[]} [rule.enum] - if the attribute is an enumeration, this array contains the possible values
         * @param {string|number|boolean} [rule.default] - The value the attribute should have at the node. If not given
         * it should be set at some point.
         * @param {boolean} [rule.multiline] - if true, than the attribute represents a multiline string, 
         * for example code snipet.
         * @param {string} [rule.multilineType] - describing the type of the multiline (like java or c++) 
         * suggesting syntax highlighting.
         * @param {boolean} [rule.isPassword] - shows if the string attribute should be handled 
         * sensitively on the user interface.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.setAttributeMeta = function (node, name, rule) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensureMongoCompatibleKey(name, 'name', false);
            ensureType(rule, 'rule', 'object');
            ensureType(rule.type, 'rule.type', 'string');

            core.setAttributeMeta(node, name, rule);
        };

        /**
         * Removes an attribute definition from the META rules of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the attribute.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.delAttributeMeta = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            core.delAttributeMeta(node, name);
        };

        /**
         * Returns the definition object of an attribute from the META rules of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the attribute.
         *
         * @return {object} The function returns the definition object, where type is always defined.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         *
         * @example
         * {
         *    type: "string"
         * }
         * @example
         * {
         *    type: "string",
         *    regexp: "^win"
         * }
         * @example
         * {
         *    type: "string",
         *    enum: [ "value1", "value2" ]
         * }
         * @example
         * {
         *    type: "boolean"
         * }
         * @example
         * {
         *    type: "integer"
         * }
         * @example
         * {
         *    type: "integer",
         *    min: 0,
         *    max: 10
         * }
         * @example
         * {
         *    type: "integer",
         *    enum: [ 3, 8 ]
         * }
         * @example
         * {
         *    type: "float",
         *    min: 0,
         *    max: 9.9
         * }
         * @example
         * {
         *    type: "asset"
         * }
         */
        this.getAttributeMeta = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            return core.copyIfObject(core.getAttributeMeta(node, name));
        };

        /**
         * Returns the list of absolute path of the valid children types of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns an array of absolute paths of the nodes that was defined as valid
         * children for the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getValidChildrenPaths = function (node) {
            ensureNode(node, 'node');

            return core.getValidChildrenPaths(node);
        };

        /**
         * Return a JSON representation of the META rules regarding the valid children of the given node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {module:Core~RelationRule} The function returns a detailed JSON structure that represents the META
         * rules regarding the possible children of the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         *
         * @example
         * {
         *   '/5': { max: 1, min: -1 },
         *   '/c': { max: -1, min: 2 },
         *   max: 10,
         *   min: undefined
         * }
         * @func
         */
        this.getChildrenMeta = function (node) {
            ensureNode(node, 'node');

            return core.getChildrenMeta(node);
        };

        /**
         * Sets the given child as a valid children type for the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node} child - the valid child node.
         * @param {integer} [min] - the allowed minimum number of children from this given node type (if not given or
         * -1 is set, then there will be no minimum rule according this child type)
         * @param {integer} [max] - the allowed maximum number of children from this given node type (if not given or
         * -1 is set, then there will be no minimum rule according this child type)
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.setChildMeta = function (node, child, min, max) {
            ensureNode(node, 'node');
            ensureNode(child, 'child');
            ensureMinMax(min, 'min');
            ensureMinMax(max, 'max');

            core.setChildMeta(node, child, min, max);
        };

        /**
         * Removes the given child rule from the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} path - the absolute path of the child which rule is to be removed from the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.delChildMeta = function (node, path) {
            ensureNode(node, 'node');
            ensurePath(path, 'path');

            core.delChildMeta(node, path);
        };

        /**
         * Sets the global containment limits for the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {integer} [min] - the allowed minimum number of children (if not given or
         * -1 is set, then there will be no minimum rule according children)
         * @param {integer} [max] - the allowed maximum number of children (if not given or
         * -1 is set, then there will be no maximum rule according children)
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.setChildrenMetaLimits = function (node, min, max) {
            ensureNode(node, 'node');
            ensureMinMax(min, 'min');
            ensureMinMax(max, 'max');

            core.setChildrenMetaLimits(node, min, max);
        };

        /**
         * Sets the given target as a valid target type for the pointer/set of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer/set.
         * @param {module:Core~Node} target - the valid target/member node.
         * @param {integer} [min] - the allowed minimum number of target/member from this given node type (if not
         * given or -1 is set, then there will be no minimum rule according this target type)
         * @param {integer} [max] - the allowed maximum number of target/member from this given node type (if not
         * given or -1 is set, then there will be no minimum rule according this target type)
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.setPointerMetaTarget = function (node, name, target, min, max) {
            ensureNode(node, 'node');
            ensureRelationName(name, 'name');
            ensureMongoCompatibleKey(name, 'name', false);
            ensureNode(target, 'target');
            ensureMinMax(min, 'min');
            ensureMinMax(max, 'max');

            core.setPointerMetaTarget(node, name, target, min, max);
        };

        /**
         * Removes a possible target type from the pointer/set of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer/set
         * @param {string} path - the absolute path of the possible target type.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If node is read-only, or definition does not exist.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.delPointerMetaTarget = function (node, name, path) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensurePath(path, 'path');
            var names = core.getValidPointerNames(node).concat(core.getValidSetNames(node));
            if (names.indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Cannot access definition of unknown pointer.');
            }

            core.delPointerMetaTarget(node, name, path);
        };

        /**
         * Sets the global target limits for pointer/set of the node. On META level the only distinction between
         * pointer and sets is the global multiplicity which has to maximize the number of possible targets to 1 in
         * case of 'pure' pointer definitions.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer/set.
         * @param {integer} [min] - the allowed minimum number of children (if not given or
         * -1 is set, then there will be no minimum rule according targets)
         * @param {integer} [max] - the allowed maximum number of children (if not given or
         * -1 is set, then there will be no maximum rule according targets)
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.setPointerMetaLimits = function (node, name, min, max) {
            ensureNode(node, 'node');
            ensureRelationName(name, 'name');
            ensureMinMax(min, 'min');
            ensureMinMax(max, 'max');

            core.setPointerMetaLimits(node, name, min, max);
        };

        /**
         * Removes the complete META rule regarding the given pointer/set of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer/set.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.delPointerMeta = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            core.delPointerMeta(node, name);
        };

        /**
         * Return a JSON representation of the META rules regarding the given pointer/set of the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer/set.
         *
         * @return {module:Core~RelationRule|undefined} The function returns a detailed JSON structure that
         * represents the META rules regarding the given pointer/set of the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         *
         * @example
         * pointer
         * {
         *   '/a': { max: 1, min: -1 },
         *   max: 1,
         *   min: 1
         * }
         * @example
         * set
         * {
         *   '/G': { max: -1, min: -1},
         *   '/i': { max: -1, min: -1},
         *   max: -1
         *   min: -1
         * }
         */
        this.getPointerMeta = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            return core.getPointerMeta(node, name);
        };

        /**
         * Sets a valid type for the given aspect of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the aspect.
         * @param {module:Core~Node} target - the valid type for the aspect.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.setAspectMetaTarget = function (node, name, target) {
            ensureNode(node, 'node');
            ensureRelationName(name, 'name');
            ensureMongoCompatibleKey(name, 'name', false);
            ensureNode(target, 'target');

            core.setAspectMetaTarget(node, name, target);
        };

        /**
         * Removes a valid type from the given aspect of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the aspect.
         * @param {string} path - the absolute path of the valid type of the aspect.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.delAspectMetaTarget = function (node, name, path) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensurePath(path, 'path');
            var names = core.getValidAspectNames(node);
            if (names.indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Cannot change definition of unknown aspect.');
            }

            core.delAspectMetaTarget(node, name, path);
        };

        /**
         * Removes the given aspect rule of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the aspect.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.delAspectMeta = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            core.delAspectMeta(node, name);
        };

        /**
         * Returns the meta-node of the node in question, that is the first base node that is part of the meta.
         * (Aliased getBaseType).
         * @param {module:Core~Node} node - the node in question
         *
         * @return {module:Core~Node|null} Returns the first node (including itself) among the inheritance chain
         * that is a META node. It returns null if it does not find such node (ideally the only node with this result
         * is the ROOT).
         *
         * @throws {CoreIllegalArgumentError} If node is not a Node
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getMetaType = function (node) {
            ensureNode(node, 'node');

            return core.getBaseType(node);
        };

        /**
         * Returns the meta-node of the node in question, that is the first base node that is part of the meta.
         * (Aliased getMetaType).
         * @function
         * @param {module:Core~Node} node - the node in question
         *
         * @return {module:Core~Node|null} Returns the first node (including itself) among the inheritance chain
         * that is a META node. It returns null if it does not find such node (ideally the only node with this result
         * is the ROOT).
         *
         * @throws {CoreIllegalArgumentError} If node is not a Node
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getBaseType = this.getMetaType;

        /**
         * Checks if the node is an instance of base.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node|string} baseNodeOrPath - a potential base node (or its path) of the node
         *
         * @return {bool} Returns true if the base is on the inheritance chain of node.
         * A node is considered to be an instance of itself here.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isInstanceOf = function (node, baseNodeOrPath) {
            var noPath;
            ensureNode(node, 'node');
            if (typeof baseNodeOrPath === 'string') {
                noPath = ensurePath(baseNodeOrPath, 'baseNodeOrPath', true);
                if (noPath) {
                    return core.isInstanceOfDeprecated(node, baseNodeOrPath);
                }
            } else {
                ensureNode(baseNodeOrPath, 'baseNodeOrPath');
            }

            return core.isInstanceOf(node, baseNodeOrPath);
        };

        /**
         * Generates a differential tree among the two states of the project that contains the necessary changes
         * that can modify the source to be identical to the target. The result is in form of a json object.
         * @param {module:Core~Node} sourceRoot - the root node of the source state.
         * @param {module:Core~Node} targetRoot - the root node of the target state.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreInternalError|null} callback.error - the status of the exectuion.
         * @param {object} callback.treeDiff - the difference between the two containment hierarchies in
         * a special JSON object
         *
         * @return {external:Promise} if the callback is not defined, the result is provided in a promise
         * like manner.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.generateTreeDiff = function (sourceRoot, targetRoot, callback) {
            var error;

            ensureType(callback, 'callback', 'function');
            error = ensureNode(sourceRoot, 'sourceRoot', true);
            error = error || ensureNode(targetRoot, 'targetRoot', true);
            if (error) {
                callback(error);
            } else {
                core.generateTreeDiff(sourceRoot, targetRoot, callback);
            }
        };

        /**
         * Apply changes to the current project.
         * @param {module:Core~Node} node - the root of the containment hierarchy where we wish to apply the changes
         * @param {object} patch - the tree structured collection of changes represented with a special JSON object
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreInternalError|null} callback.error - the result of the execution.
         *
         * @return {external:Promise} If no callback is given, the result will be provided in a promise.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.applyTreeDiff = function (node, patch, callback) {
            var error;

            ensureType(callback, 'callback', 'function');
            error = ensureNode(node, 'node', true);
            error = error || ensureType(patch, 'patch', 'object', true);
            if (error) {
                callback(error);
            } else {
                core.applyTreeDiff(node, patch, callback);
            }
        };

        /**
         * Tries to merge two patch object. The patches ideally represents changes made by two parties. They represents
         * changes from the same source ending in different states. Our aim is to generate a single patch that could
         * cover the changes of both party.
         * @param {object} mine - the tree structured JSON patch that represents my changes.
         * @param {object} theirs - the tree structured JSON patch that represents the changes of the other party.
         *
         * @return {object} The function returns with an object that contains the conflicts (if any) and the merged
         * patch.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.tryToConcatChanges = function (mine, theirs) {
            ensureType(mine, 'mine', 'object');
            ensureType(theirs, 'theirs', 'object');

            return core.tryToConcatChanges(mine, theirs);
        };

        /**
         * When our attempt to merge two patches ended in some conflict, then we can modify that result highlighting
         * that in case of every conflict, which side we prefer (mine vs. theirs). If we give that object as an input
         * to this function, it will finish the merge resolving the conflict according our settings and present a final
         * patch.
         * @param {object} conflict - the object that represents our settings for every conflict and the so-far-merged
         * patch.
         *
         * @return {object} The function results in a tree structured patch object that contains the changesthat cover
         * both parties modifications (and the conflicts are resolved according the input settings).
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.applyResolution = function (conflict) {
            ensureType(conflict, 'conflict', 'object');

            return core.applyResolution(conflict);
        };

        /**
         * Checks if the node is abstract.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {bool} The function returns true if the registry entry 'isAbstract' of the node if true hence
         * the node is abstract.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isAbstract = function (node) {
            ensureNode(node, 'node');

            return core.isAbstract(node);
        };

        /**
         * Check is the node is a connection-like node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {bool} Returns true if both the 'src' and 'dst' pointer are defined as valid for the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isConnection = function (node) {
            ensureNode(node, 'node');

            return core.isConnection(node);
        };

        /**
         * Retrieves the valid META nodes that can be base of a child of the node.
         * @param {object} parameters - the input parameters of the query.
         * @param {module:Core~Node} parameters.node - the node in question.
         * @param {bool} [parameters.sensitive=false] - if true, the query filters out the abstract and connection-like
         * nodes.
         * @param {bool} [parameters.multiplicity=false] - if true, the query tries to filter out even more
         * nodes according to the multiplicity rules.
         * @param {module:Core~Node[]} [parameters.children=[]] - the current children of the node in question
         * (must be passed if multiplicity=true)
         * @param {string|null} [parameters.aspect=undefined] - if given, the query filters to contain only types that
         * are visible in the given aspect.
         * @return {module:Core~Node[]} The function returns a list of valid nodes that can be instantiated as a
         * child of the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getValidChildrenMetaNodes = function (parameters) {
            ensureType(parameters, 'parameters', 'object');
            ensureNode(parameters.node, 'parameters.node');
            if (parameters.hasOwnProperty('children') && parameters.children !== undefined) {
                ensureInstanceOf(parameters.children, 'parameters.children', Array);
                for (var i = 0; i < parameters.children.length; i += 1) {
                    ensureNode(parameters.children[i], 'parameters.children[i]');
                }
            }
            if (parameters.hasOwnProperty('sensitive') && parameters.sensitive !== undefined) {
                ensureType(parameters.sensitive, 'parameters.sensitive', 'boolean');
            }
            if (parameters.hasOwnProperty('multiplicity')) {
                ensureType(parameters.multiplicity, 'parameters.multiplicity', 'boolean');
            }
            if (parameters.hasOwnProperty('aspect') && parameters.aspect !== undefined && parameters.aspect !== null) {
                ensureType(parameters.aspect, 'parameters.aspect', 'string');
            }

            return core.getValidChildrenMetaNodes(parameters);
        };

        /**
         * Retrieves the valid META nodes that can be base of a member of the set of the node.
         * @param {object} parameters - the input parameters of the query.
         * @param {module:Core~Node} parameters.node - the node in question.
         * @param {string} parameters.name - the name of the set.
         * @param {bool} [parameters.sensitive=false] - if true, the query filters out the abstract and connection-like
         * nodes.
         * @param {bool} [parameters.multiplicity=false] - if true, the query tries to filter out even more nodes
         * according to the multiplicity rules (the check is only meaningful if all the members were passed)
         * @param {module:Core~Node[]} [parameters.members=[]] - the current members of the set of the node in question.
         *
         * @return {module:Core~Node[]} The function returns a list of valid nodes that can be instantiated as a
         * member of the set of the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getValidSetElementsMetaNodes = function (parameters) {
            ensureType(parameters, 'parameters', 'object');
            ensureNode(parameters.node, 'parameters.node');
            ensureType(parameters.name, 'parameters.name', 'string');
            if (parameters.hasOwnProperty('members')) {
                ensureInstanceOf(parameters.members, 'parameters.members', Array);
                for (var i = 0; i < parameters.members.length; i += 1) {
                    ensureNode(parameters.members[i], 'parameters.members[i]');
                }
            }
            if (parameters.hasOwnProperty('sensitive')) {
                ensureType(parameters.sensitive, 'parameters.sensitive', 'boolean');
            }
            if (parameters.hasOwnProperty('multiplicity')) {
                ensureType(parameters.multiplicity, 'parameters.multiplicity', 'boolean');
            }

            return core.getValidSetElementsMetaNodes(parameters);
        };

        /**
         * Returns all META nodes.
         * @param {module:Core~Node} node - any node of the containment hierarchy.
         *
         * @return {Object<string, module:Core~Node>} The function returns a dictionary. The keys of the dictionary
         * are the absolute paths of the META nodes of the project. Every value of the dictionary
         * is a {@link module:Core~Node}.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getAllMetaNodes = function (node) {
            ensureNode(node, 'node');

            return core.getAllMetaNodes(node);
        };

        /**
         * Checks if the node is a META node.
         * @param {module:Core~Node} node - the node to test.
         *
         * @return {bool} Returns true if the node is a member of the METAAspectSet of the ROOT node hence can be
         * seen as a META node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isMetaNode = function (node) {
            ensureNode(node, 'node');

            return core.isMetaNode(node);
        };

        /**
         * Checks if the member is completely overridden in the set of the node.
         * @param {module:Core~Node} node - the node to test.
         * @param {string} name - the name of the set of the node.
         * @param {string} path - the path of the member in question.
         *
         * @return {bool} Returns true if the member exists in the base of the set, but was
         * added to the given set as well, which means a complete override. If the set does not exist
         * or the member do not have a 'base' member or just some property was overridden, the function returns
         * false.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isFullyOverriddenMember = function (node, name, path) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensurePath(path, 'path');
            var names = core.getSetNames(node);
            if (names.indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Cannot access member information of unknown set.');
            }

            return core.isFullyOverriddenMember(node, name, path);
        };

        /**
         * Checks if the mixins allocated with the node can be used.
         * Every mixin node should be on the Meta.
         * Every rule (attribute/pointer/set/aspect/containment/constraint) should be defined only in one mixin.
         *
         * @param {module:Core~Node} node - the node to test.
         *
         * @return {module:Core~MixinViolation[]} Returns the array of violations. If the array is empty,
         * there is no violation.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getMixinErrors = function (node) {
            ensureNode(node, 'node');

            return core.getMixinErrors(node);
        };

        /**
         * Gathers the paths of the mixin nodes defined directly at the node.
         *
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The paths of the mixins in an array ordered by their order of use (which is important
         * in case of some collision among definitions would arise).
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getMixinPaths = function (node) {
            ensureNode(node, 'node');

            return core.getMixinPaths(node);
        };

        /**
         * Gathers the mixin nodes defined directly at the node.
         *
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {Object<string, module:Core~Node>} The dictionary of the mixin nodes keyed by their paths.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getMixinNodes = function (node) {
            ensureNode(node, 'node');

            return core.getMixinNodes(node);
        };

        /**
         * Removes a mixin from the mixin set of the node.
         *
         * @param {module:Core~Node} node - the node in question.
         * @param {string} path - the path of the mixin node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.delMixin = function (node, path) {
            ensureNode(node, 'node');
            ensurePath(path, 'path');

            return core.delMixin(node, path);
        };

        /**
         * Adds a mixin to the mixin set of the node.
         *
         * @param {module:Core~Node} node - the node in question.
         * @param {string} path - the path of the mixin node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.addMixin = function (node, path) {
            ensureNode(node, 'node');
            ensurePath(path, 'path');

            return core.addMixin(node, path);
        };

        /**
         * Removes all mixins for a given node.
         *
         * @param {module:Core~Node} node - the node in question.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.clearMixins = function (node) {
            ensureNode(node, 'node');

            return core.clearMixins(node);
        };

        /**
         * Searches for the closest META node of the node in question and the direct mixins of that node.
         * @param {module:Core~Node} node - the node in question
         *
         * @return {module:Core~Node[]} Returns the closest Meta node that is a base of the given node
         * plus it returns all the mixin nodes associated with the base.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getBaseTypes = function (node) {
            ensureNode(node, 'node');

            return core.getBaseTypes(node);
        };

        /**
         * Checks if the given path can be added as a mixin to the given node.
         *
         * @param {module:Core~Node} node - the node in question.
         * @param {string} path - the path of the mixin node.
         * @return {object} Returns an object with isOk set to true if the given path can be added as a
         * mixin to the given node. If it cannot, the reason will be reported under reason.
         *
         * @example
         * result = core.canSetAsMixin(node, core.getPath(aValidMixinNode));
         * // result = { isOk: true, reason: '' }
         * result = core.canSetAsMixin(node, core.getPath(node));
         * // result = { isOk: false, reason: 'Node cannot be mixin of itself!' }
         * result = core.canSetAsMixin(node, core.getPath(nonMetaNode));
         * // result = { isOk: false, reason: 'Mixin must be on the Meta!!' }
         * result = core.canSetAsMixin(node, core.getPath(FCO));
         * // result = { isOk: false, reason: 'Base of node cannot be its mixin as well!' }
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.canSetAsMixin = function (node, path) {
            ensureNode(node, 'node');
            ensurePath(path, 'path');

            return core.canSetAsMixin(node, path);
        };

        //library function TODO checking everything and adding all new functions

        /**
         * It adds a project as library to your project by copying it over. The library will be a node
         * with the given name directly under your project's ROOT. It becomes a read-only portion of your project.
         * You will only be able to manipulate it with library functions, but cannot edit the individual nodes inside.
         * However you will be able to instantiate or copy the nodes into other places of your project. Every node
         * that was part of the META in the originating project becomes part of your project's meta.
         * @param {module:Core~Node} node - any regular node in your project.
         * @param {string} name - the name of the library you wish to use as a namespace in your project.
         * @param {string} libraryRootHash - the hash of your library's root
         * (must exist in the project's collection at the time of call).
         * @param {object} [libraryInfo] - information about your project.
         * @param {string} [libraryInfo.projectId] - the projectId of your library.
         * @param {string} [libraryInfo.branchName] - the branch that your library follows in the origin project.
         * @param {string} [libraryInfo.commitHash] - the version of your library.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreIllegalOperationError|CoreInternalError|null} callback.error - the
         * result of the execution.
         *
         * @return {external:Promise} If no callback is given, the result is provided in a promise like manner.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.addLibrary = function (node, name, libraryRootHash, libraryInfo, callback) {
            ensureType(callback, 'callback', 'function');
            var error = ensureNode(node, 'node', true);
            error = error || ensureType(name, 'name', 'string', true);
            error = error || ensureHash(libraryRootHash, 'libraryRootHash', true);
            if (libraryInfo) {
                error = error || ensureType(libraryInfo, 'libraryInfo', 'object', true);
                if (libraryInfo.hasOwnProperty('projectId') && libraryInfo.projectId !== undefined) {
                    error = error || ensureType(libraryInfo.projectId, 'libraryInfo.projectId', 'string', true);
                }
                if (libraryInfo.hasOwnProperty('branchName') && libraryInfo.branchName !== undefined) {
                    error = error || ensureType(libraryInfo.branchName, 'libraryInfo.branchName', 'string', true);
                }
                if (libraryInfo.hasOwnProperty('commitHash') && libraryInfo.commitHash !== undefined) {
                    error = error || ensureHash(libraryInfo.commitHash, 'libraryInfo.commitHash', true);
                }
            }
            if (error) {
                callback(error);
            } else {
                core.addLibrary(node, name, libraryRootHash, libraryInfo, callback);
            }
        };

        /**
         * It updates a library in your project based on the input information. It will 'replace' the old
         * version, keeping as much information as possible regarding the instances.
         * @param {module:Core~Node} node - any regular node in your project.
         * @param {string} name - the name of the library you want to update.
         * @param {string} libraryRootHash - the hash of your library's new root
         * (must exist in the project's collection at the time of call).
         * @param {object} [libraryInfo] - information about your project.
         * @param {string} [libraryInfo.projectId] - the projectId of your library.
         * @param {string} [libraryInfo.branchName] - the branch that your library follows in the origin project.
         * @param {string} [libraryInfo.commitHash] - the version of your library.
         * @param updateInstructions - not yet used parameter.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreIllegalOperationError|CoreInternalError|null} callback.error - the
         * status of the execution.
         *
         * @return {external:Promise} If no callback is given, the result is presented in a promise like manner.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.updateLibrary = function (node, name, libraryRootHash, libraryInfo, updateInstructions, callback) {
            ensureType(callback, 'callback', 'function');
            var error = ensureNode(node, 'node', true);
            error = error || ensureType(name, 'name', 'string', true);
            error = error || ensureHash(libraryRootHash, 'libraryRootHash', true);
            if (libraryInfo) {
                error = error || ensureType(libraryInfo, 'libraryInfo', 'object', true);
                if (libraryInfo.hasOwnProperty('projectId') && libraryInfo.projectId !== undefined) {
                    error = error || ensureType(libraryInfo.projectId, 'libraryInfo.projectId', 'string', true);
                }
                if (libraryInfo.hasOwnProperty('branchName') && libraryInfo.branchName !== undefined) {
                    error = error || ensureType(libraryInfo.branchName, 'libraryInfo.branchName', 'string', true);
                }
                if (libraryInfo.hasOwnProperty('commitHash') && libraryInfo.commitHash !== undefined) {
                    error = error || ensureHash(libraryInfo.commitHash, 'libraryInfo.commitHash', true);
                }
            }
            if (error) {
                callback(error);
            } else {
                core.updateLibrary(node, name, libraryRootHash, libraryInfo, callback);
            }

        };

        /**
         * Gives back the list of libraries in your project.
         *
         * @param {module:Core~Node} node - any node in your project.
         *
         * @return {string[]} Returns the fully qualified names of all the libraries in your project
         * (even embedded ones).
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getLibraryNames = function (node) {
            ensureNode(node, 'node');

            return core.getLibraryNames(node);
        };

        /**
         * Return the root of the inheritance chain of your Meta nodes.
         *
         * @param {module:Core~Node} node - any node in your project.
         *
         * @return {module:Core~Node} Returns the acting FCO of your project.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getFCO = function (node) {
            ensureNode(node, 'node');

            return core.getFCO(node);
        };

        /**
         * Returns true if the node in question is a library root..
         *
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {bool} Returns true if your node is a library root (even if it is embedded in other library),
         * false otherwise.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isLibraryRoot = function (node) {
            ensureNode(node, 'node');

            return core.isLibraryRoot(node);
        };

        /**
         * Returns true if the node in question is a library element..
         *
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {bool} Returns true if your node is a library element, false otherwise.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isLibraryElement = function (node) {
            ensureNode(node, 'node');

            return core.isLibraryElement(node);
        };

        /**
         * Returns the resolved namespace for the node. If node is not in a library it returns the
         * empty string. If the node is in a library of a library -
         * the full name space is the library names joined together by dots.
         *
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string} Returns the name space of the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         *
         * @example NS1.NS2
         */
        this.getNamespace = function (node) {
            ensureNode(node, 'node');

            return core.getNamespace(node);
        };

        /**
         * Returns the fully qualified name of the node, which is the list of its namespaces separated
         * by dot and followed by the name of the node.
         *
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string} Returns the fully qualified name of the node,
         * i.e. its namespaces and name join together by dots.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         *
         * @example NS1.NS2.name
         */
        this.getFullyQualifiedName = function (node) {
            ensureNode(node, 'node');

            return core.getFullyQualifiedName(node);
        };

        /**
         * Removes a library from your project. It will also remove any remaining instances of the specific library.
         *
         * @param {module:Core~Node} node - any node in your project.
         * @param {string} name - the name of your library.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.removeLibrary = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            var names = core.getLibraryNames(node);
            if (names.indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Cannot remove unknown library');
            }

            return core.removeLibrary(node, name);
        };

        /**
         * Returns the origin GUID of any library node. (If name is not provided the returned GUID will be the same
         * across all projects where the library node is contained - regardless of library hierarchy.)
         * @param {module:Core~Node} node - the node in question.
         * @param {undefined|string} [name] - name of the library where we want to compute the GUID from.
         * If not given, then the GUID is computed from the direct library root of the node.
         *
         * @return {module:Core~GUID} Returns the origin GUID of the node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getLibraryGuid = function (node, name) {
            ensureNode(node, 'node');
            if (name !== undefined && name !== null) {
                ensureType(name, 'name', 'string');
            }

            return core.getLibraryGuid(node, name);
        };

        /**
         * Rename a library in your project.
         *
         * @param {module:Core~Node} node - any node in your project.
         * @param {string} oldName - the current name of the library.
         * @param {string} newName - the new name of the project.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.renameLibrary = function (node, oldName, newName) {
            ensureNode(node, 'node');
            ensureType(oldName, 'oldName', 'string');
            ensureType(newName, 'newName', 'string');

            core.renameLibrary(node, oldName, newName);
        };

        /**
         * Returns the info associated with the library.
         *
         * @param {module:Core~Node} node - any node in the project.
         * @param {string} name - the name of the library.
         *
         * @return {object} Returns the information object, stored alongside the library (that basically
         * carries metaData about the library).
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getLibraryInfo = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            return core.copyIfObject(core.getLibraryInfo(node, name));
        };

        /**
         * Returns the root node of the given library.
         *
         * @param {module:Core~Node} node - any node in the project.
         * @param {string} name - the name of the library.
         *
         * @return {module:Core~Node|null} Returns the library root node or null, if the library is unknown.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getLibraryRoot = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            return core.getLibraryRoot(node, name);
        };

        /**
         * Returns all the Meta nodes within the given library.
         * By default it will include nodes defined in any library within the given library.
         *
         * @param {module:Core~Node} node - any node of your project.
         * @param {string} name - name of your library.
         * @param {bool} [onlyOwn=false] - if true only returns with Meta nodes defined in the library itself.
         *
         * @return {module:Core~Node[]} Returns an array of core nodes that are part of your meta from
         * the given library.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getLibraryMetaNodes = function (node, name, onlyOwn) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            if (onlyOwn !== null && onlyOwn !== undefined) {
                ensureType(onlyOwn, 'onlyOwn', 'boolean');
            }

            return core.getLibraryMetaNodes(node, name, onlyOwn);
        };

        /**
         * The function traverses the sub-tree of the project starting with the given root and calls the
         * visit function for every node.
         *
         * @param {module:Core~Node} root - the root node of the sub-tree that needs to be traversed.
         * @param {object} options - parameters to control the traversing.
         * @param {bool} [options.excludeRoot=false] - controls whether the root should be excluded from visit.
         * @param {'BFS'|'DFS'} [options.order='BFS'] - controls if the traversal order should be breadth first
         * or depth first.
         * @param {integer} [options.maxParallelLoad=100]- the maximum number of parallel loads allowed.
         * @param {bool} [options.stopOnError=true]- controls if the traverse should stop in case of error.
         * @param {function} visitFn - the visitation function that will be called for
         * every node in the sub-tree, the second parameter of the function is a callback that should be called to
         * note to the traversal function that the visitation for a given node finished.
         * @param {module:Core~Node} visitFn.node - the node that is being visited.
         * @param {function} visitFn.next - the callback function of the visit function that marks the end
         * of visitation.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreInternalError|null} callback.error - the status of the execution.
         *
         * @return {external:Promise} If no callback is given, the end of traverse is marked in a promise like
         * manner.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.traverse = function (root, options, visitFn, callback) {
            ensureType(callback, 'callback', 'function');
            var error = ensureNode(root, 'root', true);
            if (options) {
                error = error || ensureType(options, 'options', 'object');
                if (options.hasOwnProperty('excludeRoot')) {
                    error = error || ensureType(options.excludeRoot, 'options.excludeRoot', 'boolean', true);
                }
                if (options.hasOwnProperty('order')) {
                    error = error || ensureType(options.order, 'options.order', 'string', true);
                    if (options.order !== 'BFS' && options.order !== 'DFS') {
                        error = error ||
                            new CoreIllegalArgumentError('Parameter options.order must be either \'BFS\' or \'DFS\'.');
                    }
                }
                if (options.hasOwnProperty('stopOnError')) {
                    error = error || ensureType(options.stopOnError, 'options.stopOnError', 'boolean', true);
                }
            }
            error = error || ensureType(visitFn, 'visitFn', 'function');

            if (error) {
                callback(error);
            } else {
                core.traverse(root, options, visitFn, callback);
            }
        };

        /**
         * Collects the necessary information to export the set of input nodes and use it in other
         * - compatible - projects.
         * @private
         *
         * @param {module:Core~Node[]} nodes - the set of nodes that we want to export
         *
         * @return {object} If the closure is available for export, the returned special JSON object
         * will contain information about the necessary data that needs to be exported as well as relations
         * that will need to be recreated in the destination project to preserve the structure of nodes.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getClosureInformation = function (nodes) {
            ensureInstanceOf(nodes, 'nodes', Array);
            for (var i = 0; i < nodes.length; i += 1) {
                ensureNode(nodes[i], 'nodes[i]');
            }

            return core.getClosureInformation(nodes);
        };

        /**
         * Imports the set of nodes in the closureInformation - that has the format created by
         * [getClosureInformation]{@link Core#getClosureInformation} - as direct children of the parent node.
         * All data necessary for importing the closure has to be imported beforehand!
         * @private
         *
         * @param {module:Core~Node} node - the parent node where the closure will be imported.
         * @param {object} closureInformation - the information about the closure.
         *
         * @return {object} If the closure cannot be imported the resulting error highlights the causes,
         * otherwise a specific object will be returned that holds information about the closure.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.importClosure = function (node, closureInformation) {
            ensureNode(node, 'node');
            ensureType(closureInformation, 'closureInformation', 'object');

            return core.importClosure(node, closureInformation);
        };

        /**
         * Collects the paths of all the instances of the given node.
         * @param {module:Core~Node} node - the node in question.
         *
         *@return {string[]} The function returns an array of the absolute paths of the instances.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getInstancePaths = function (node) {
            ensureNode(node, 'node');

            return core.getInstancePaths(node);
        };

        /**
         * Loads all the instances of the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreInternalError|null} callback.error - the status of the execution.
         * @param {module:Core~Node[]} callback.nodes - the found instances of the node.
         *
         * @return {external:Promise} If no callback is given, the result will be provided in a promise
         * like manner.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.loadInstances = function (node, callback) {
            ensureType(callback, 'callback', 'function');
            var error = ensureNode(node, 'node', true);
            if (error) {
                callback(error);
            } else {
                core.loadInstances(node, callback);
            }
        };

        /**
         * Loads all the members of the given set of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} setName - the name of the set in question.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreInternalError|null} callback.error - the status of the execution.
         * @param {module:Core~Node[]} callback.nodes - the found members of the set of the node.
         *
         * @return {external:Promise} If no callback is given, the result will be provided in a promise
         * like manner.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.loadMembers = function (node, setName, callback) {
            ensureType(setName, 'setName', 'string');
            ensureType(callback, 'callback', 'function');
            var error = ensureNode(node, 'node', true);
            if (error) {
                callback(error);
            } else {
                core.loadMembers(node, setName, callback);
            }
        };

        /**
         * Loads all the own members of the given set of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} setName - the name of the set in question.
         * @param {function} [callback]
         * @param {Error|CoreIllegalArgumentError|CoreInternalError|null} callback.error - the status of the execution.
         * @param {module:Core~Node[]} callback.nodes - the found own members of the set of the node.
         *
         * @return {external:Promise} If no callback is given, the result will be provided in a promise
         * like manner.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         */
        this.loadOwnMembers = function (node, setName, callback) {
            ensureType(setName, 'setName', 'string');
            ensureType(callback, 'callback', 'function');
            var error = ensureNode(node, 'node', true);
            if (error) {
                callback(error);
            } else {
                core.loadOwnMembers(node, setName, callback);
            }
        };

        /**
         * Renames the given pointer of the node if its target is not inherited.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} oldName - the current name of the pointer in question.
         * @param {string} newName - the new name of the pointer.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.renamePointer = function (node, oldName, newName) {
            ensureNode(node, 'node');
            ensureType(oldName, 'oldName', 'string');
            ensureType(newName, 'newName', 'string');
            ensureMongoCompatibleKey(newName, 'newName', true);

            if (core.getOwnPointerPath(node, oldName) === undefined) {
                throw new CoreIllegalOperationError('Only pointers with values can be renamed.');
            }

            core.renamePointer(node, oldName, newName);
        };

        /**
         * Renames the given attribute of the node if its value is not inherited.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} oldName - the current name of the attribute in question.
         * @param {string} newName - the new name of the attribute.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.renameAttribute = function (node, oldName, newName) {
            ensureNode(node, 'node');
            ensureType(oldName, 'oldName', 'string');
            ensureType(newName, 'newName', 'string');
            ensureMongoCompatibleKey(newName, 'newName', true);

            if (core.getOwnAttribute(node, oldName) === undefined) {
                throw new CoreIllegalOperationError('Only attributes with own values can be renamed.');
            }

            core.renameAttribute(node, oldName, newName);
        };

        /**
         * Renames the given registry of the node if its value is not inherited.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} oldName - the current name of the registry in question.
         * @param {string} newName - the new name of the registry.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.renameRegistry = function (node, oldName, newName) {
            ensureNode(node, 'node');
            ensureType(oldName, 'oldName', 'string');
            ensureType(newName, 'newName', 'string');
            ensureMongoCompatibleKey(newName, 'newName', true);

            if (core.getOwnRegistry(node, oldName) === undefined) {
                throw new CoreIllegalOperationError('Only registry entries with own values can be renamed.');
            }

            core.renameRegistry(node, oldName, newName);
        };

        /**
         * Renames the given set of the node if its is not inherited.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} oldName - the current name of the set in question.
         * @param {string} newName - the new name of the set.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.renameSet = function (node, oldName, newName) {
            ensureNode(node, 'node');
            ensureType(oldName, 'oldName', 'string');
            ensureType(newName, 'newName', 'string');
            ensureMongoCompatibleKey(newName, 'newName', true);

            if (core.getOwnSetNames(node).indexOf(oldName) === -1) {
                throw new CoreIllegalOperationError('Cannot rename nonexistent/inherited set [' + oldName + ']');
            }

            core.renameSet(node, oldName, newName);
        };

        /**
         * Returns the meta node that introduces the given attribute.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the attribute in question.
         *
         * @return {module:Core~Node} The meta-node that defines the attribute and makes it valid attribute for the
         * given node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getAttributeDefinitionOwner = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            if (core.getValidAttributeNames(node).indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Not a valid attribute name [' + name + '] of the node.');
            }

            return core.getAttributeDefinitionOwner(node, name);
        };

        /**
         * Returns the meta nodes that introduce the given pointer relationship.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer in question.
         * @param {module:Core~Node} target - the target node.
         *
         * @return {module:Core~DefinitionInfo} The owner and the target of the pointer meta-rule that makes target a
         * valid target of the named pointer of node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getPointerDefinitionInfo = function (node, name, target) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensureNode(target, 'target');

            if (core.getValidPointerNames(node).indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Not valid pointer name [' + name + '] of the node.');
            }

            if (core.isValidTargetOf(target, node, name) !== true) {
                throw new CoreIllegalOperationError('Not a valid target node of [' + name + '] pointer.');
            }

            return core.getPointerDefinitionInfo(node, name, target);
        };

        /**
         * Returns the meta nodes that introduce the given set relationship.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the set in question.
         * @param {module:Core~Node} member - the member.
         *
         * @return {module:Core~DefinitionInfo} The owner and the target of the set meta-rule that makes member a
         * valid member of the named set of node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getSetDefinitionInfo = function (node, name, member) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensureNode(member, 'member');

            if (core.getValidSetNames(node).indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Not valid set name [' + name + '] of the node.');
            }

            if (core.isValidTargetOf(member, node, name) !== true) {
                throw new CoreIllegalOperationError('Not a valid member of [' + name + '] set.');
            }

            return core.getSetDefinitionInfo(node, name, member);
        };

        /**
         * Returns the meta nodes that introduce the given containment relationship.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node} child - the child.
         *
         * @return {module:Core~DefinitionInfo} The owner and the target of the containment meta-rule that makes child a
         * valid child of node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getChildDefinitionInfo = function (node, child) {
            ensureNode(node, 'node');
            ensureNode(child, 'child');

            if (core.isValidChildOf(child, node) !== true) {
                throw new CoreIllegalOperationError('Not a valid child.');
            }

            return core.getChildDefinitionInfo(node, child);
        };

        /**
         * Returns the meta nodes that introduce the given aspect relationship.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the set in question.
         * @param {module:Core~Node} member - the child.
         *
         * @return {module:Core~DefinitionInfo} The owner and the target of the aspect meta-rule that makes member a
         * valid member of the named aspect of node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getAspectDefinitionInfo = function (node, name, member) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');
            ensureNode(member, 'member');

            if (core.getValidAspectNames(node).indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Not valid aspect name [' + name + '] of the node.');
            }

            if (core.isValidAspectMemberOf(member, node, name) !== true) {
                throw new CoreIllegalOperationError('Not a valid member of [' + name + '] aspect.');
            }

            return core.getAspectDefinitionInfo(node, name, member);
        };

        /**
         * Returns the paths of the meta nodes that are valid target members of the given aspect.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the aspec in question.
         *
         * @return {string[]} The paths of the meta nodes whose instances could be members of the aspect.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getValidAspectTargetPaths = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            if (core.getValidAspectNames(node).indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Not a valid aspect [' + name + '] of the node.');
            }

            return core.getValidAspectTargetPaths(node, name);
        };

        /**
         * Returns the paths of the meta nodes that are valid target members of the given aspect
         * specifically defined for the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the aspec in question.
         *
         * @return {string[]} The paths of the meta nodes whose instances could be members of the aspect.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnValidAspectTargetPaths = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            if (core.getValidAspectNames(node).indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Not a valid aspect [' + name + '] of the node.');
            }

            return core.getOwnValidAspectTargetPaths(node, name);
        };

        /**
         * Returns the meta node that introduces the given aspect.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the set in question.
         *
         * @return {module:Core~Node} The meta-node that defines the aspect and makes a valid aspect for the given node.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getAspectDefinitionOwner = function (node, name) {
            ensureNode(node, 'node');
            ensureType(name, 'name', 'string');

            if (core.getValidAspectNames(node).indexOf(name) === -1) {
                throw new CoreIllegalOperationError('Not valid aspect name [' + name + '] of the node.');
            }

            return core.getAspectDefinitionOwner(node, name);
        };

        /**
         * Moves an own member of the set over to another set of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} memberPath - the path of the memberNode that should be moved.
         * @param {string} oldSetName - the name of the set where the member is currently reside.
         * @param {string} newSetName - the name of the target set where the member should be moved to.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.moveMember = function (node, memberPath, oldSetName, newSetName) {
            ensureNode(node, 'node');
            ensureType(memberPath, 'memberPath', 'string');
            ensurePath(memberPath, 'memberPath');
            ensureType(oldSetName, 'oldSetName', 'string');
            ensureType(newSetName, 'newSetName', 'string');
            ensureMongoCompatibleKey(newSetName, 'newSetName', true);

            if (core.getSetNames(node).indexOf(oldSetName) === -1) {
                throw new CoreIllegalOperationError('Source set [' + oldSetName + '] does not exists.');
            }

            if (core.getOwnMemberPaths(node, oldSetName).indexOf(memberPath) === -1) {
                throw new CoreIllegalOperationError('Not own member of the set therefore cannot be moved.');
            }

            core.moveMember(node, memberPath, oldSetName, newSetName);
        };

        /**
         * Renames the given attribute definition of the node. It also renames the default value of the definition!
         * As a result of this operation, all instances of node will have the new attribute, but if they have
         * overriden the old attribute it will remain under that name (and become meta invalid).
         * @param {module:Core~Node} node - the node in question.
         * @param {string} oldName - the current name of the attribute definition in question.
         * @param {string} newName - the new name of the attribute.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.renameAttributeMeta = function (node, oldName, newName) {
            ensureNode(node, 'node');
            ensureType(oldName, 'oldName', 'string');
            ensureType(newName, 'newName', 'string');
            ensureMongoCompatibleKey(newName, 'newName', true);

            if (core.getValidAttributeNames(node).indexOf(oldName) === -1) {
                throw new CoreIllegalOperationError('Unknown definition [' + oldName + '] cannot be renamed.');
            }

            core.renameAttributeMeta(node, oldName, newName);
        };

        /**
         * Moves the given target definition over to a new pointer or set.
         * Note this does not alter the actual pointer target or set members.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node} target - the target that should be moved among definitions.
         * @param {string} oldName - the current name of the pointer/set definition in question.
         * @param {string} newName - the new name of the relation towards the target.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.movePointerMetaTarget = function (node, target, oldName, newName) {
            ensureNode(node, 'node');
            ensureNode(target, 'target');
            ensureType(oldName, 'oldName', 'string');
            ensureType(newName, 'newName', 'string');
            ensureMongoCompatibleKey(newName, 'newName', true);

            if (core.getOwnValidPointerNames(node).indexOf(oldName) === -1 &&
                core.getOwnValidSetNames(node).indexOf(oldName) === -1) {
                throw new CoreIllegalOperationError('Definition [' + oldName + '] does not exists for the node.');
            }

            if (core.getOwnValidTargetPaths(node, oldName).indexOf(core.getPath(target)) === -1) {
                throw new CoreIllegalOperationError('Not a valid target of [' + oldName + '] defined for the node.');
            }

            core.movePointerMetaTarget(node, target, oldName, newName);
        };

        /**
         * Moves the given target definition over to a new aspect. As actual values in case of
         * relation definitions vary quite a bit from the meta-targets, this function does not deals with
         * the actual pointer/set target/members.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node} target - the target that should be moved among definitions.
         * @param {string} oldName - the current name of the aspect that has the target.
         * @param {string} newName - the new aspect name where the target should be moved over.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreIllegalOperationError} If the context of the operation is not allowed.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.moveAspectMetaTarget = function (node, target, oldName, newName) {
            ensureNode(node, 'node');
            ensureNode(target, 'target');
            ensureType(oldName, 'oldName', 'string');
            ensureType(newName, 'newName', 'string');
            ensureMongoCompatibleKey(newName, 'newName', true);

            if (core.getOwnValidAspectNames(node).indexOf(oldName) === -1) {
                throw new CoreIllegalOperationError('Aspect [' + oldName + '] doesn\'t exists for the node.');
            }

            if (core.getOwnValidAspectTargetPaths(node, oldName).indexOf(core.getPath(target)) === -1) {
                throw new CoreIllegalOperationError('Not a valid target of [' + oldName + '] defined for the node.');
            }

            core.moveAspectMetaTarget(node, target, oldName, newName);
        };

        /**
         * Returns if a node could be contained in the given container's aspect.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node} parent - the container node in question.
         * @param {string} name - the name of aspect.
         *
         * @return {bool} The function returns true if the given container could contain the node in the asked aspect.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isValidAspectMemberOf = function (node, parent, name) {
            ensureNode(node, 'node');
            ensureNode(parent, 'parent');
            ensureType(name, 'name', 'string');

            return core.isValidAspectMemberOf(node, parent, name);
        };

        /**
         * Returns the paths of Meta nodes that are possible targets of the given pointer/set introduced by the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of pointer/set.
         *
         * @return {string[]} The function returns the paths of valid nodes.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getOwnValidTargetPaths = function (node, name) {
            ensureNode(node, 'node');
            ensureRelationName(name, 'name');

            return core.getOwnValidTargetPaths(node, name);
        };

        /**
         * Returns the paths of Meta nodes that are possible targets of the given pointer/set.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of pointer/set.
         *
         * @return {string[]} The function returns the paths of valid nodes.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.getValidTargetPaths = function (node, name) {
            ensureNode(node, 'node');
            ensureRelationName(name, 'name');

            return core.getValidTargetPaths(node, name);
        };

        /**
         * Checks if an instance of the given base can be created under the parent. It does not check for
         * meta consistency. It only validates if the proposed creation would cause any loops in the
         * combined containment inheritance trees.
         * @param {module:Core~Node|null} parentNode - the parent in question.
         * @param {module:Core~Node|null} baseNode - the intended type of the node.
         *
         * @return {boolean} True if a child of the type can be created.
         *
         * @throws {CoreIllegalArgumentError} If some of the parameters don't match the input criteria.
         * @throws {CoreInternalError} If some internal error took place inside the core layers.
         */
        this.isValidNewChild = function (parentNode, baseNode) {
            if (parentNode !== null) {
                ensureNode(parentNode, 'parentNode');
            }

            if (baseNode !== null) {
                ensureNode(baseNode, 'baseNode');
            }

            return core.isValidNewChild(parentNode, baseNode);
        };

        this.CONSTANTS = CONSTANTS;
    }

    return Core;
});

/*globals define*/
/*eslint-env node, browser*/

/**
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/core/coreQ',['common/core/core', 'q'], function (Core, Q) {

    'use strict';
    /**
     * @param {object} storage
     * @param {object} options - contains logging information
     * @extends Core
     * @constructor
     */
    function CoreQ(storage, options) {
        var self = this;
        Core.call(self, storage, options);

        var loadChildOrg = this.loadChild;
        this.loadChild = function (parent, relativeId, callback) {
            var deferred = Q.defer();
            loadChildOrg(parent, relativeId, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadRootOrg = this.loadRoot;
        this.loadRoot = function (hash, callback) {
            var deferred = Q.defer();
            loadRootOrg(hash, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadByPathOrg = this.loadByPath;
        this.loadByPath = function (startNode, relativeId, callback) {
            var deferred = Q.defer();
            loadByPathOrg(startNode, relativeId, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadChildrenOrg = this.loadChildren;
        this.loadChildren = function (parent, callback) {
            var deferred = Q.defer();
            loadChildrenOrg(parent, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadOwnChildrenOrg = this.loadOwnChildren;
        this.loadOwnChildren = function (parent, callback) {
            var deferred = Q.defer();
            loadOwnChildrenOrg(parent, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadPointerOrg = this.loadPointer;
        this.loadPointer = function (source, pointerName, callback) {
            var deferred = Q.defer();
            loadPointerOrg(source, pointerName, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadCollectionOrg = this.loadCollection;
        this.loadCollection = function (target, pointerName, callback) {
            var deferred = Q.defer();
            loadCollectionOrg(target, pointerName, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadSubTreeOrg = this.loadSubTree;
        this.loadSubTree = function (node, callback) {
            var deferred = Q.defer();
            loadSubTreeOrg(node, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadOwnSubTreeOrg = this.loadOwnSubTree;
        this.loadOwnSubTree = function (node, callback) {
            var deferred = Q.defer();
            loadOwnSubTreeOrg(node, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadTreeOrg = this.loadTree;
        this.loadTree = function (rootHash, callback) {
            var deferred = Q.defer();
            loadTreeOrg(rootHash, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var applyTreeDiffOrg = this.applyTreeDiff;
        this.applyTreeDiff = function (root, patch, callback) {
            var deferred = Q.defer();
            applyTreeDiffOrg(root, patch, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var generateTreeDiffOrg = this.generateTreeDiff;
        this.generateTreeDiff = function (sourceRoot, targetRoot, callback) {
            var deferred = Q.defer();
            generateTreeDiffOrg(sourceRoot, targetRoot, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var setGuidOrg = this.setGuid;
        this.setGuid = function (node, guid, callback) {
            var deferred = Q.defer();
            setGuidOrg(node, guid, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var addLibraryOrg = this.addLibrary;
        this.addLibrary = function (node, name, libraryRootHash, libraryInfo, callback) {
            var deferred = Q.defer();
            addLibraryOrg(node, name, libraryRootHash, libraryInfo, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var updateLibraryOrg = this.updateLibrary;
        this.updateLibrary = function (node, name, updatedLibraryRootHash, libraryInfo, updateInstructions, callback) {
            var deferred = Q.defer();
            updateLibraryOrg(node, name, updatedLibraryRootHash, libraryInfo, updateInstructions,
                function (err, result) {
                    if (err) {
                        deferred.reject(err);
                    } else {
                        deferred.resolve(result);
                    }
                }
            );

            return deferred.promise.nodeify(callback);
        };

        var traverseOrg = this.traverse;
        this.traverse = function (node, options, visitFn, callback) {
            var deferred = Q.defer();
            traverseOrg(node, options, visitFn, function (err, result) {
                if (err) {
                    deferred.reject(err);
                } else {
                    deferred.resolve(result);
                }
            });
            return deferred.promise.nodeify(callback);
        };

        var loadInstancesOrg = this.loadInstances;
        this.loadInstances = function (node, callback) {
            var deferred = Q.defer();
            loadInstancesOrg(node, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadMembersOrg = this.loadMembers;
        this.loadMembers = function (target, setName, callback) {
            var deferred = Q.defer();
            loadMembersOrg(target, setName, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadOwnMembersOrg = this.loadOwnMembers;
        this.loadOwnMembers = function (target, setName, callback) {
            var deferred = Q.defer();
            loadOwnMembersOrg(target, setName, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };
    }

    CoreQ.prototype = Object.create(Core.prototype);
    CoreQ.prototype.constructor = CoreQ;

    return CoreQ;
});
/*globals define*/
/*eslint-env browser*/

/**
 * @author pmeijer / https://github.com/pmeijer
 */

define('client/constants',[
    'common/Constants'
], function (CONSTANTS) {
    'use strict';

    return {

        STORAGE: CONSTANTS.STORAGE,
        CORE: CONSTANTS.CORE,

        BRANCH_STATUS: CONSTANTS.STORAGE.BRANCH_STATUS,

        UNCAUGHT_EXCEPTION: 'UNCAUGHT_EXCEPTION',

        // Events
        NETWORK_STATUS_CHANGED: CONSTANTS.STORAGE.NETWORK_STATUS_CHANGED,
        BRANCH_STATUS_CHANGED: 'BRANCH_STATUS_CHANGED',

        BRANCH_CLOSED: 'BRANCH_CLOSED',
        BRANCH_OPENED: 'BRANCH_OPENED',
        PROJECT_CLOSED: 'PROJECT_CLOSED',
        PROJECT_OPENED: 'PROJECT_OPENED',

        BRANCH_CHANGED: 'BRANCH_CHANGED',

        NEW_COMMIT_STATE: 'NEW_COMMIT_STATE',

        UNDO_AVAILABLE: 'UNDO_AVAILABLE',
        REDO_AVAILABLE: 'REDO_AVAILABLE',

        // general notification event
        NOTIFICATION: 'NOTIFICATION',
        PLUGIN_NOTIFICATION: 'PLUGIN_NOTIFICATION',
        CONNECTED_USERS_CHANGED: 'CONNECTED_USERS_CHANGED',
        PLUGIN_INITIATED: 'PLUGIN_INITIATED',
        PLUGIN_FINISHED: 'PLUGIN_FINISHED',

        // Constraint Checking
        META_RULES_RESULT: 'META_RULES_RESULT',
        CONSTRAINT_RESULT: 'CONSTRAINT_RESULT'
    };
});

/*globals define*/
/*eslint-env node, browser*/

/**
 * @author kecso / https://github.com/kecso
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/core/users/metarules',['q', 'common/core/constants'], function (Q, CONSTANTS) {
    'use strict';

    // Helper functions.
    function loadNode(core, rootNode, nodePath) {
        return core.loadByPath(rootNode, nodePath)
            .then(function (node) {
                if (node === null) {
                    throw new Error('Given nodePath does not exist "' + nodePath + '"!');
                } else {
                    return node;
                }
            });
    }

    function loadNodes(core, node, nodePaths) {
        var i,
            loadPromises = [],
            rootNode = core.getRoot(node);

        for (i = 0; i < nodePaths.length; i += 1) {
            loadPromises.push(loadNode(core, rootNode, nodePaths[i]));
        }

        return Q.all(loadPromises);
    }

    function filterPointerRules(meta) {
        var result = {
                pointers: {},
                sets: {}
            },
            pointerNames = Object.keys(meta.pointers),
            i;

        for (i = 0; i < pointerNames.length; i += 1) {
            if (meta.pointers[pointerNames[i]].max === 1) {
                // These are single target pointers (e.g. connections).
                result.pointers[pointerNames[i]] = meta.pointers[pointerNames[i]];
            } else {
                // These are multi target pointer, i.e. sets.
                result.sets[pointerNames[i]] = meta.pointers[pointerNames[i]];
            }
        }

        return result;
    }

    function getMatchedItemIndices(core, node, items) {
        var i,
            metaNodes = core.getAllMetaNodes(node),
            indices = [];

        for (i = 0; i < items.length; i += 1) {
            if (core.isTypeOf(node, metaNodes[items[i]])) {
                indices.push(i);
            }
        }

        return indices;
    }

    function metaNodePathToName(core, metaNodes, path) {
        var name = 'Unknown';
        if (metaNodes[path]) {
            name = core.getAttribute(metaNodes[path], 'name');
        }

        return name;
    }

    function checkNodeTypesAndCardinality(core, node, nodes, subMetaRules, checkTypeText, singular) {
        var matches = [],
            metaNodes = core.getAllMetaNodes(node),
            result = {
                hasViolation: false,
                messages: []
            },
            i,
            j,
            matchedIndices;
        /*
         * example subMetaRules
         *   {
         *       items: [ '/1', '/822429792/942380411' ],
         *       min: undefined,
         *       max: undefined,
         *       minItems: [ -1, -1 ],
         *       maxItems: [ -1, 4 ]
         *   }
         */

        // Initialize the number of matches for each valid type.
        matches = subMetaRules.items.map(function () {
            return 0;
        });

        // For each node
        for (i = 0; i < nodes.length; i += 1) {

            // check which types it matches and
            matchedIndices = getMatchedItemIndices(core, nodes[i], subMetaRules.items);

            if (matchedIndices.length === 0) {
                result.hasViolation = true;
                result.messages.push('Illegal node "' + core.getAttribute(nodes[i], 'name') + '" [' +
                    core.getPath(nodes[i]) + '] ' + (singular ? 'as ' : 'among ') + checkTypeText + '.');
            } else {
                // increase the counter for each type it matches.
                for (j = 0; j < matchedIndices.length; j += 1) {
                    matches[matchedIndices[j]] += 1;
                }
            }
        }

        for (i = 0; i < subMetaRules.items.length; i += 1) {
            if (subMetaRules.minItems[i] > -1 && subMetaRules.minItems[i] > matches[i]) {
                result.hasViolation = true;
                result.messages.push('Fewer ' + checkTypeText + ' (' +
                    metaNodePathToName(core, metaNodes, subMetaRules.items[i]) + ') than needed - there should be ' +
                    subMetaRules.minItems[i] + ' but only ' + matches[i] + ' found.');
            } else if (subMetaRules.maxItems[i] > -1 && subMetaRules.maxItems[i] < matches[i]) {
                result.hasViolation = true;
                result.messages.push('More ' + checkTypeText + '(' +
                    metaNodePathToName(core, metaNodes, subMetaRules.items[i]) + ') than allowed - there can only be ' +
                    subMetaRules.maxItems[i] + ' but ' + matches[i] + ' found.');
            }
        }

        return result;
    }

    // Checker functions for pointers, sets, containment and attributes.
    function checkPointerRules(meta, core, node, callback) {
        var result = {
                hasViolation: false,
                messages: []
            },
            metaPointers = filterPointerRules(meta).pointers,
            checkPromises = [],
            pointerNames = core.getPointerNames(node);

        checkPromises = pointerNames.map(function (pointerName) {
            var metaPointer = metaPointers[pointerName],
                pointerPath,
                pointerPaths = [];

            if (!metaPointer) {
                if (pointerName === 'base') {
                    return {hasViolation: false};
                } else {
                    return Q({
                        hasViolation: true,
                        messages: ['Illegal pointer "' + pointerName + '".']
                    });
                }
            } else {
                pointerPath = core.getPointerPath(node, pointerName);
                if (pointerPath !== null) {
                    pointerPaths.push(pointerPath);
                }
                return loadNodes(core, node, pointerPaths)
                    .then(function (nodes) {
                        return checkNodeTypesAndCardinality(core, node, nodes, metaPointer,
                            '"' + pointerName + '" target', true);
                    });
            }
        });

        return Q.all(checkPromises)
            .then(function (results) {
                results.forEach(function (res) {
                    if (res.hasViolation) {
                        result.hasViolation = true;
                        result.messages = result.messages.concat(res.messages);
                    }
                });

                return result;
            }).nodeify(callback);
    }

    function checkSetRules(meta, core, node, callback) {
        var result = {
                hasViolation: false,
                messages: []
            },
            metaSets = filterPointerRules(meta).sets,
            checkPromises = [],
            setNames = core.getSetNames(node);

        checkPromises = setNames.map(function (setName) {
            var metaSet = metaSets[setName],
                memberPaths;
            if (!metaSet) {
                if (core.getValidAspectNames(node).indexOf(setName) > -1) {

                    // TODO: Should the Aspects be checked too?
                    return Q({
                        hasViolation: false
                    });
                } else {
                    var crossCuts = core.getRegistry(node, 'CrossCuts') || [],
                        i;

                    // The 'CrossCuts' is a constant from client/js/RegistryKeys.js

                    for (i = 0; i < crossCuts.length; i += 1) {
                        if (crossCuts[i].SetID === setName) {
                            i = -1;
                            break;
                        }
                    }

                    if (i === -1) {
                        // TODO: Should the CrossCuts be checked too?
                        return Q({
                            hasViolation: false
                        });
                    } else {
                        return Q({
                            hasViolation: true,
                            messages: ['Illegal set "' + setName + '".']
                        });
                    }
                }
            } else {
                memberPaths = core.getMemberPaths(node, setName);
                return loadNodes(core, node, memberPaths)
                    .then(function (nodes) {
                        return checkNodeTypesAndCardinality(core, node, nodes, metaSet, '"' + setName + '"-members');
                    });
            }
        });

        return Q.all(checkPromises)
            .then(function (results) {
                results.forEach(function (res) {
                    if (res.hasViolation) {
                        result.hasViolation = true;
                        result.messages = result.messages.concat(res.messages);
                    }
                });

                return result;
            }).nodeify(callback);
    }

    function checkChildrenRules(meta, core, node, callback) {
        return core.loadChildren(node)
            .then(function (nodes) {
                return checkNodeTypesAndCardinality(core, node, nodes, meta.children, 'children');
            })
            .nodeify(callback);
    }

    function checkAttributeRules(meta, core, node) {
        var result = {
                hasViolation: false,
                messages: []
            },
            names = core.getAttributeNames(node),
            validNames = core.getValidAttributeNames(node),
            ownVal,
            i;

        function checkValidValue(attrName) {
            try {
                if (!core.isValidAttributeValueOf(node, attrName, core.getAttribute(node, attrName))) {
                    result.hasViolation = true;
                    result.messages.push('Attribute "' + attrName + '" has invalid value "' +
                        core.getAttribute(node, attrName) + '".');
                }
            } catch (e) {
                if (e.message.indexOf('Invalid regular expression') > -1) {
                    result.messages.push('Invalid regular expression defined for attribute "' + attrName + '"!');
                    result.hasViolation = true;
                } else {
                    throw e;
                }
            }
        }

        for (i = 0; i < names.length; i++) {
            if (validNames.indexOf(names[i]) !== -1) {
                if (meta.attributes[names[i]].readonly === true) {
                    ownVal = core.getOwnAttribute(node, names[i]);
                    if (ownVal !== undefined && core.isMetaNode(node) === false) {
                        result.messages.push('Read-only attribute "' + names[i] +
                            '" value has been set for a non-meta node!');
                        result.hasViolation = true;
                    } else if (core.isMetaNode(node)) {
                        checkValidValue(names[i]);
                    }
                } else {
                    checkValidValue(names[i]);
                }
            } else {
                result.hasViolation = true;
                result.messages.push('Illegal attribute "' + names[i] + '".');
            }
        }

        return Q(result);
    }

    /**
     *
     * @param core
     * @param node
     * @param [callback]
     * @returns {Q.Promise}
     */
    function checkNode(core, node, callback) {
        var result = {
                hasViolation: false,
                messages: [],
                message: ''
            },
            meta;

        if (core.getPath(node) === '' || core.isLibraryRoot(node)) {
            // Do not check the meta-rules for the root-node or library-roots.
            return Q(result);
        }

        meta = core.getJsonMeta(node);

        return Q.all([
            checkPointerRules(meta, core, node),
            checkSetRules(meta, core, node),
            checkChildrenRules(meta, core, node),
            checkAttributeRules(meta, core, node)
        ])
            .then(function (results) {
                var i;
                for (i = 0; i < results.length; i += 1) {
                    if (results[i].hasViolation === true) {
                        result.hasViolation = true;
                        result.messages = result.messages.concat(results[i].messages);
                    }
                }

                result.message = result.messages.join(' ');
                return result;
            })
            .nodeify(callback);
    }

    /**
     * Checks that the meta-nodes and their definitions are consistent w.r.t.
     * - Meta name collisions.
     * - Referencing nodes outside of the meta.
     * - Duplicate definitions from mixins.
     * - Collisions between set names and pointers/aspects
     * - Invalid regular expression for attributes
     * - Invalid min/max for attributes
     * - Invalid set/pointer/attribute/aspect/constraint names
     * @param core
     * @param node - any node in tree to be checked
     */
    function checkMetaConsistency(core, node) {
        var metaNodes = core.getAllMetaNodes(node),
            names = {},
            result = [],
            isPointer,
            i,
            key,
            path,
            metaNode,
            metaName,
            setNames,
            pointerNames,
            aspectNames,
            childPaths,
            ownMetaJson;

        function isTypeOfAny(node, paths) {
            var i,
                metaNode;

            for (i = 0; i < paths.length; i += 1) {
                metaNode = metaNodes[paths[i]];
                if (metaNode && core.isTypeOf(node, metaNode)) {
                    return true;
                }
            }

            return false;
        }

        function getUnderScoreError(metaName, path, key, type) {
            return {
                severity: 'error',
                message: metaName + ' defines ' + type + ' [' + key + '] starting with an underscore ("_").',
                description: 'Such relations/properties in the models are considered private and can ' +
                'collied with reserved properties.',
                hint: 'Remove/rename it.',
                path: path,
                relatedPaths: []
            };
        }

        function getReservedNameError(metaName, path, key, type) {
            return {
                severity: 'error',
                message: metaName + ' defines ' + type + ' [' + key + '] which is a reserved name.',
                description: 'Such relations/properties in the models can lead to collisions resulting in unexpected' +
                ' behavior.',
                hint: 'Remove/rename it.',
                path: path,
                relatedPaths: []
            };
        }

        function getMixinError(mixinError) {
            return {
                severity: mixinError.severity,
                message: mixinError.message,
                description: 'Mixin violations makes it hard to see which definition is used.',
                hint: mixinError.hint,
                path: path,
                relatedPaths: mixinError.collisionPaths || []
            };
        }

        for (path in metaNodes) {
            metaNode = metaNodes[path];
            metaName = core.getFullyQualifiedName(metaNode);
            ownMetaJson = core.getOwnJsonMeta(metaNode);
            setNames = core.getValidSetNames(metaNode);
            pointerNames = core.getValidPointerNames(metaNode);
            aspectNames = core.getValidAspectNames(metaNode);
            childPaths = core.getValidChildrenPaths(metaNode);

            //Patch the ownMetaJson
            ownMetaJson.attributes = ownMetaJson.attributes || {};
            ownMetaJson.children = ownMetaJson.children || {};
            ownMetaJson.pointers = ownMetaJson.pointers || {};
            ownMetaJson.aspects = ownMetaJson.aspects || {};
            ownMetaJson.constraints = ownMetaJson.constraints || {};

            // Check for name duplication.
            if (typeof names[metaName] === 'string') {
                result.push({
                    severity: 'error',
                    message: 'Duplicate name among meta-nodes [' + metaName + ']',
                    description: 'Non-unique meta names makes it hard to reason about the meta-model',
                    hint: 'Rename one of the objects',
                    path: path,
                    relatedPaths: [names[metaName]]
                });
            } else {
                names[metaName] = path;
            }

            // Get the mixin errors.
            result = result.concat(core.getMixinErrors(metaNode).map(getMixinError));

            if (ownMetaJson.children.items) {
                for (i = 0; i < ownMetaJson.children.items.length; i += 1) {
                    if (!metaNodes[ownMetaJson.children.items[i]]) {
                        result.push({
                            severity: 'error',
                            message: metaName + ' defines containment of a node that is not part of the meta.',
                            description: 'All defined meta-relations should be between meta-nodes.',
                            hint: 'Locate the related node, add it to the meta and remove the containment definition.',
                            path: path,
                            relatedPaths: [ownMetaJson.children.items[i]]
                        });
                    }
                }
            }

            for (key in ownMetaJson.pointers) {
                isPointer = ownMetaJson.pointers[key].max === 1;

                for (i = 0; i < ownMetaJson.pointers[key].items.length; i += 1) {
                    if (!metaNodes[ownMetaJson.pointers[key].items[i]]) {
                        result.push({
                            severity: 'error',
                            message: metaName + ' defines a ' + (isPointer ? 'pointer' : 'set') + ' [' + key + '] ' +
                            'where the ' + (isPointer ? 'target' : 'member') + ' is not part of the meta.',
                            description: 'All defined meta-relations should be between meta-nodes.',
                            hint: 'Locate the related node, add it to the meta and remove the ' +
                            (isPointer ? 'pointer' : 'set') + ' definition.',
                            path: path,
                            relatedPaths: [ownMetaJson.pointers[key].items[i]]
                        });
                    }
                }

                if (isPointer) {
                    if (setNames.indexOf(key) > -1) {
                        result.push({
                            severity: 'error',
                            message: metaName + ' defines a pointer [' + key + '] colliding with a set definition.',
                            description: 'Pointer and set definitions share the same namespace.',
                            hint: 'Remove/rename one of them.',
                            path: path,
                            relatedPaths: ownMetaJson.pointers[key].items
                        });
                    }

                    if (key === CONSTANTS.BASE_POINTER || key === CONSTANTS.MEMBER_RELATION) {
                        result.push(getReservedNameError(metaName, path, key, 'a pointer'));
                    }
                } else {
                    if (pointerNames.indexOf(key) > -1) {
                        result.push({
                            severity: 'error',
                            message: metaName + ' defines a set [' + key + '] colliding with a pointer definition.',
                            description: 'Pointer and set definitions share the same namespace.',
                            hint: 'Remove/rename one of them.',
                            path: path,
                            relatedPaths: ownMetaJson.pointers[key].items
                        });
                    }

                    if (aspectNames.indexOf(key) > -1) {
                        result.push({
                            severity: 'error',
                            message: metaName + ' defines a set [' + key + '] colliding with an aspect definition.',
                            description: 'Sets and aspects share the same name-space.',
                            hint: 'Remove/rename one of them.',
                            path: path,
                            relatedPaths: ownMetaJson.pointers[key].items
                        });
                    }

                    if (key === CONSTANTS.OVERLAYS_PROPERTY) {
                        result.push(getReservedNameError(metaName, path, key, 'a set'));
                    }
                }

                if (key[0] === '_') {
                    result.push(getUnderScoreError(metaName, path, key, isPointer ? 'a pointer' : 'a set'));
                }
            }

            for (key in ownMetaJson.aspects) {
                for (i = 0; i < ownMetaJson.aspects[key].length; i += 1) {
                    if (!metaNodes[ownMetaJson.aspects[key][i]]) {
                        result.push({
                            severity: 'error',
                            message: metaName + ' defines an aspect [' + key + '] where a member is not part of' +
                            ' the meta.',
                            description: 'All defined meta-relations should be between meta-nodes.',
                            hint: 'Remove the item from the aspect.',
                            path: path,
                            relatedPaths: [ownMetaJson.aspects[key][i]]
                        });
                    } else if (isTypeOfAny(metaNodes[ownMetaJson.aspects[key][i]], childPaths) === false) {
                        result.push({
                            severity: 'error',
                            message: metaName + ' defines an aspect [' + key + '] where a member does not have a ' +
                            'containment definition.',
                            description: 'All defined meta-relations should be between meta-nodes.',
                            hint: 'Remove the item from the aspect or add a containment definition.',
                            path: path,
                            relatedPaths: [ownMetaJson.aspects[key][i]]
                        });
                    }
                }

                if (setNames.indexOf(key) > -1) {
                    result.push({
                        severity: 'error',
                        message: metaName + ' defines an aspect [' + key + '] colliding with a set definition.',
                        description: 'Sets and aspects share the same name-space.',
                        hint: 'Remove the aspect and create a new one.',
                        path: path,
                        relatedPaths: []
                    });
                }

                if (key === CONSTANTS.OVERLAYS_PROPERTY) {
                    result.push(getReservedNameError(metaName, path, key, 'an aspect'));
                }

                if (key[0] === '_') {
                    result.push(getUnderScoreError(metaName, path, key, 'an aspect'));
                }
            }

            for (key in ownMetaJson.attributes) {
                if (ownMetaJson.attributes[key].hasOwnProperty('regexp')) {
                    try {
                        new RegExp(ownMetaJson.attributes[key].regexp);
                    } catch (err) {
                        result.push({
                            severity: 'error',
                            message: metaName + ' defines an invalid regular expression for the attribute [' + key +
                            '], "' + ownMetaJson.attributes[key].regexp + '".',
                            description: 'Invalid properties can lead to unexpected results in the models.',
                            hint: 'Edit the regular expression for the attribute.',
                            path: path,
                            relatedPaths: []
                        });
                    }
                }

                if (ownMetaJson.attributes[key].type === CONSTANTS.ATTRIBUTE_TYPES.INTEGER ||
                    ownMetaJson.attributes[key].type === CONSTANTS.ATTRIBUTE_TYPES.FLOAT) {

                    if (ownMetaJson.attributes[key].hasOwnProperty('min') &&
                        typeof ownMetaJson.attributes[key].min !== 'number') {
                        result.push({
                            severity: 'error',
                            message: metaName + ' defines an invalid min value for the attribute [' + key +
                            ']. The type is not a number but "' + typeof ownMetaJson.attributes[key].min + '".',
                            description: 'Invalid properties can lead to unexpected results in the models.',
                            hint: 'Edit the min value for the attribute.',
                            path: path,
                            relatedPaths: []
                        });
                    }

                    if (ownMetaJson.attributes[key].hasOwnProperty('max') &&
                        typeof ownMetaJson.attributes[key].max !== 'number') {
                        result.push({
                            severity: 'error',
                            message: metaName + ' defines an invalid max value for the attribute [' + key +
                            ']. The type is not a number but "' + typeof ownMetaJson.attributes[key].max + '".',
                            description: 'Invalid properties can lead to unexpected results in the models.',
                            hint: 'Edit the max value for the attribute.',
                            path: path,
                            relatedPaths: []
                        });
                    }
                }

                // This cannot happen since _s are filtered out.
                if (key[0] === '_') {
                    result.push(getUnderScoreError(metaName, path, key, 'an attribute'));
                }
            }

            // for (key in ownMetaJson.constraints) {
            //     // Any checking on constraints?
            // }
        }

        return result;
    }

    return {
        checkNode: checkNode,
        checkMetaConsistency: checkMetaConsistency
    };
});
/*globals define, console*/
/*eslint-env browser*/

/**
 * @author kecso / https://github.com/kecso
 * @author pmeijer / https://github.com/pmeijer
 */

define('client/gmeNodeGetter',[], function () {
    'use strict';

    function _logDeprecated(oldFn, newFn, comment) {
        var commentStr = comment ? comment : '';
        //eslint-disable-next-line no-console
        console.warn('"gmeNode.' + oldFn + '" is deprecated and will eventually be removed, use "gmeNode.' + newFn +
            '" instead.' + commentStr);
    }

    function _getNode(nodes, path) {
        return nodes[path] && nodes[path].node;
    }

    /**
     * @param {string} _id - Path of node.
     * @param {GmeLogger} logger - logger.
     * @param {object} state - state of the client.
     * @param {function} storeNode - invoked when storing new nodes.
     * @constructor
     */
    function GMENode(_id, logger, state, storeNode) {
        this._id = _id;
        this._logger = logger;
        this._state = state;
        this._storeNode = storeNode;
    }

    GMENode.prototype.getId = function () {
        return this._id;
    };

    GMENode.prototype.getRelid = function () {
        return this._state.core.getRelid(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getGuid = function () {
        return this._state.core.getGuid(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getParentId = function () {
        //just for sure, as it may missing from the cache
        return this._storeNode(this._state.core.getParent(this._state.nodes[this._id].node));
    };

    GMENode.prototype.getCommonParentId = function (/*otherNodeIds*/) {
        var nodesArr = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)),
            self = this;

        nodesArr.push(this._id);

        return this._storeNode(this._state.core.getCommonParent.apply(this._state.core, nodesArr.map(function (id) {
            return _getNode(self._state.nodes, id);
        })));
    };

    GMENode.prototype.getChildrenIds = function () {
        return this._state.core.getChildrenPaths(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getChildrenRelids = function () {
        return this._state.core.getChildrenRelids(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getBaseId = function () {
        return this._storeNode(this._state.core.getBase(this._state.nodes[this._id].node));
    };

    GMENode.prototype.getCommonBaseId = function (/*otherNodeIds*/) {
        var nodesArr = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)),
            self = this;

        nodesArr.push(this._id);

        return this._storeNode(this._state.core.getCommonBase.apply(this._state.core, nodesArr.map(function (id) {
            return _getNode(self._state.nodes, id);
        })));
    };

    GMENode.prototype.isValidNewBase = function (basePath) {
        var base;
        if (typeof basePath === 'string') {
            base = _getNode(this._state.nodes, basePath);
            if (base) {
                return this._state.core.isValidNewBase(this._state.nodes[this._id].node, base);
            } else {
                return false;
            }
        } else if (basePath === undefined || basePath === null) {
            return true;
        }

        return false;
    };

    GMENode.prototype.isValidNewParent = function (parentPath) {
        var parent;
        if (typeof parentPath === 'string') {
            parent = _getNode(this._state.nodes, parentPath);
            if (parent) {
                return this._state.core.isValidNewParent(this._state.nodes[this._id].node, parent);
            } else {
                return false;
            }
        } else {
            return false;
        }
    };

    GMENode.prototype.isValidNewChild = function (basePath) {
        var base;
        if (typeof basePath === 'string') {
            base = _getNode(this._state.nodes, basePath);
            if (base) {
                return this._state.core.isValidNewChild(this._state.nodes[this._id].node, base);
            } else {
                return false;
            }
        } else if (basePath === undefined || basePath === null) {
            return true;
        }

        return false;
    };

    GMENode.prototype.getInheritorIds = function () {
        return this._state.core.getInstancePaths(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getAttribute = function (name) {
        return this._state.core.getAttribute(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getOwnAttribute = function (name) {
        return this._state.core.getOwnAttribute(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getEditableAttribute = function (name) {
        _logDeprecated('getEditableAttribute', 'getAttribute',
            ' All returned values from the core can now be mutated without any issues.');
        return this._state.core.getAttribute(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getOwnEditableAttribute = function (name) {
        _logDeprecated('getOwnEditableAttribute', 'getOwnAttribute',
            ' All returned values from the core can now be mutated without any issues.');
        return this._state.core.getOwnAttribute(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getRegistry = function (name) {
        return this._state.core.getRegistry(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getOwnRegistry = function (name) {
        return this._state.core.getOwnRegistry(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getEditableRegistry = function (name) {
        _logDeprecated('getEditableRegistry', 'getRegistry',
            ' All returned values from the core can now be mutated without any issues.');

        return this._state.core.getRegistry(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getOwnEditableRegistry = function (name) {
        _logDeprecated('getOwnEditableRegistry', 'getOwnRegistry',
            ' All returned values from the core can now be mutated without any issues.');

        return this._state.core.getOwnRegistry(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getPointer = function (name) {
        return {to: this._state.core.getPointerPath(this._state.nodes[this._id].node, name), from: []};
    };

    GMENode.prototype.getPointerId = function (name) {
        return this.getPointer(name).to;
    };

    GMENode.prototype.getOwnPointer = function (name) {
        return {to: this._state.core.getOwnPointerPath(this._state.nodes[this._id].node, name), from: []};
    };

    GMENode.prototype.getOwnPointerId = function (name) {
        return this.getOwnPointer(name).to;
    };

    GMENode.prototype.getPointerNames = function () {
        return this._state.core.getPointerNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getOwnPointerNames = function () {
        return this._state.core.getOwnPointerNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getAttributeNames = function () {
        return this._state.core.getAttributeNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getOwnAttributeNames = function () {
        return this._state.core.getOwnAttributeNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getAttributeMeta = function (name) {
        return this._state.core.getAttributeMeta(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getRegistryNames = function () {
        return this._state.core.getRegistryNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getOwnRegistryNames = function () {
        return this._state.core.getOwnRegistryNames(this._state.nodes[this._id].node);
    };

    //SET
    GMENode.prototype.getMemberIds = function (setName) {
        return this._state.core.getMemberPaths(this._state.nodes[this._id].node, setName);
    };

    GMENode.prototype.getSetNames = function () {
        return this._state.core.getSetNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.isMemberOf = function () {
        return this._state.core.isMemberOf(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getMemberAttributeNames = function (setName, memberId) {
        return this._state.core.getMemberAttributeNames(this._state.nodes[this._id].node, setName, memberId);
    };

    GMENode.prototype.getMemberAttribute = function (setName, memberId, attrName) {
        return this._state.core.getMemberAttribute(this._state.nodes[this._id].node, setName, memberId, attrName);
    };

    GMENode.prototype.getEditableMemberAttribute = function (setName, memberId, attrName) {
        _logDeprecated('getEditableMemberAttribute', 'getMemberAttribute',
            ' All returned values from the core can now be mutated without any issues.');
        return this._state.core.getMemberAttribute(this._state.nodes[this._id].node, setName, memberId, attrName);
    };

    GMENode.prototype.getMemberRegistryNames = function (setName, memberId) {
        return this._state.core.getMemberRegistryNames(this._state.nodes[this._id].node, setName, memberId);
    };

    GMENode.prototype.getMemberRegistry = function (setName, memberId, regName) {
        return this._state.core.getMemberRegistry(this._state.nodes[this._id].node, setName, memberId, regName);
    };

    GMENode.prototype.getEditableMemberRegistry = function (setName, memberId, regName) {
        _logDeprecated('getEditableMemberRegistry', 'getMemberRegistry',
            ' All returned values from the core can now be mutated without any issues.');
        return this._state.core.getMemberRegistry(this._state.nodes[this._id].node, setName, memberId, regName);
    };

    GMENode.prototype.getSetRegistry = function (setName, regName) {
        return this._state.core.getSetRegistry(this._state.nodes[this._id].node, setName, regName);
    };

    GMENode.prototype.getSetRegistryNames = function (setName) {
        return this._state.core.getSetRegistryNames(this._state.nodes[this._id].node, setName);
    };

    GMENode.prototype.getSetAttribute = function (setName, attrName) {
        return this._state.core.getSetAttribute(this._state.nodes[this._id].node, setName, attrName);
    };

    GMENode.prototype.getSetAttributeNames = function (setName) {
        return this._state.core.getSetAttributeNames(this._state.nodes[this._id].node, setName);
    };

    //META
    GMENode.prototype.getValidChildrenTypes = function () {
        _logDeprecated('getValidChildrenTypes()', 'getValidChildrenIds()');
        return this.getValidChildrenIds();
    };

    GMENode.prototype.getValidAttributeNames = function () {
        return this._state.core.getValidAttributeNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getOwnValidAttributeNames = function () {
        return this._state.core.getOwnValidAttributeNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.isValidAttributeValueOf = function (name, value) {
        return this._state.core.isValidAttributeValueOf(this._state.nodes[this._id].node, name, value);
    };

    GMENode.prototype.getValidPointerNames = function () {
        return this._state.core.getValidPointerNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getValidSetNames = function () {
        return this._state.core.getValidSetNames(this._state.nodes[this._id].node);
    };

    //constraint functions
    GMENode.prototype.getConstraintNames = function () {
        return this._state.core.getConstraintNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getOwnConstraintNames = function () {
        return this._state.core.getOwnConstraintNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getConstraint = function (name) {
        return this._state.core.getConstraint(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.toString = function () {
        return this._state.core.getAttribute(this._state.nodes[this._id].node, 'name') + ' (' + this._id + ')';
    };

    GMENode.prototype.getCollectionPaths = function (name) {
        return this._state.core.getCollectionPaths(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getInstancePaths = function () {
        return this._state.core.getInstancePaths(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getJsonMeta = function () {
        return this._state.core.getJsonMeta(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getOwnJsonMeta = function () {
        return this._state.core.getOwnJsonMeta(this._state.nodes[this._id].node);
    };

    GMENode.prototype.isConnection = function () {
        return this._state.core.isConnection(this._state.nodes[this._id].node);
    };

    GMENode.prototype.isAbstract = function () {
        return this._state.core.isAbstract(this._state.nodes[this._id].node);
    };

    GMENode.prototype.isLibraryRoot = function () {
        return this._state.core.isLibraryRoot(this._state.nodes[this._id].node);
    };

    GMENode.prototype.isLibraryElement = function () {
        return this._state.core.isLibraryElement(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getFullyQualifiedName = function () {
        return this._state.core.getFullyQualifiedName(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getNamespace = function () {
        return this._state.core.getNamespace(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getLibraryGuid = function () {
        return this._state.core.getLibraryGuid(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getCrosscutsInfo = function () {
        return this._state.core.getRegistry(this._state.nodes[this._id].node, 'CrossCuts') || [];
    };

    GMENode.prototype.getValidChildrenTypesDetailed = function (aspect, noFilter) {
        var parameters = {
                childrenIds: this.getChildrenIds(),
                sensitive: !noFilter,
                multiplicity: false,
                aspect: aspect,
                cache: {}
            },
            result = {},
            fullList,
            filteredList,
            i;

        fullList = this.getValidChildrenMetaIds(parameters);
        parameters.multiplicity = true;
        filteredList = this.getValidChildrenMetaIds(parameters);

        for (i = 0; i < fullList.length; i += 1) {
            result[fullList[i]] = false;
        }

        for (i = 0; i < filteredList.length; i += 1) {
            result[filteredList[i]] = true;
        }

        return result;
    };

    GMENode.prototype.getValidChildrenMetaIds = function (parameters) {
        var coreParams = {
                node: this._state.nodes[this._id].node,
                cache: parameters.cache || {}
            },
            self = this,
            i;

        if (parameters.sensitive) {
            coreParams.sensitive = parameters.sensitive;
        }

        if (parameters.aspect) {
            coreParams.aspect = parameters.aspect;
        }

        if (parameters.childrenIds && parameters.multiplicity) {
            coreParams.multiplicity = true;
            coreParams.children = [];
            for (i = 0; i < parameters.childrenIds.length; i++) {
                if (this._state.nodes[parameters.childrenIds[i]]) {
                    coreParams.children.push(this._state.nodes[parameters.childrenIds[i]].node);
                } else {
                    this._logger.warn('Child node [' + parameters.childrenIds[i] + '] not loaded at ' +
                        'getValidChildrenMetaIds - cardinality constraints will not be enforced properly.');
                }
            }
        }

        return this._state.core.getValidChildrenMetaNodes(coreParams)
            .map(function (coreNode) {
                return self._state.core.getPath(coreNode);
            });
    };

    GMENode.prototype.getValidSetMemberTypesDetailed = function (setName) {
        var parameters = {
                node: this._state.nodes[this._id].node,
                memberIds: this.getMemberIds(setName),
                sensitive: true,
                multiplicity: false,
                name: setName
            },
            result = {},
            fullList,
            filteredList,
            i;

        fullList = this.getValidSetElementsMetaIds(parameters);
        parameters.multiplicity = true;
        filteredList = this.getValidSetElementsMetaIds(parameters);

        for (i = 0; i < fullList.length; i += 1) {
            result[fullList[i]] = false;
        }

        for (i = 0; i < filteredList.length; i += 1) {
            result[filteredList[i]] = true;
        }

        return result;
    };

    GMENode.prototype.getValidSetElementsMetaIds = function (parameters) {
        var coreParams = {
                node: this._state.nodes[this._id].node,
                name: parameters.name,
                cache: parameters.cache || {}
            },
            self = this,
            i;

        if (parameters.sensitive) {
            coreParams.sensitive = parameters.sensitive;
        }

        if (parameters.memberIds && parameters.multiplicity) {
            coreParams.multiplicity = true;
            coreParams.members = [];
            for (i = 0; i < parameters.memberIds.length; i++) {
                if (this._state.nodes[parameters.memberIds[i]]) {
                    coreParams.members.push(this._state.nodes[parameters.memberIds[i]].node);
                } else {
                    this._logger.warn('Member node [' + parameters.memberIds[i] + '] not loaded at ' +
                        'getValidSetElementsMetaIds - cardinality constraints will not be enforced properly.');
                }
            }
        }

        return this._state.core.getValidSetElementsMetaNodes(coreParams)
            .map(function (coreNode) {
                return self._state.core.getPath(coreNode);
            });
    };

    GMENode.prototype.getMetaTypeId = GMENode.prototype.getBaseTypeId = function () {
        var metaType = this._state.core.getMetaType(this._state.nodes[this._id].node);

        if (metaType) {
            return this._storeNode(metaType);
        } else {
            return null;
        }
    };

    GMENode.prototype.isMetaNode = function () {
        return this._state.core.isMetaNode(this._state.nodes[this._id].node);
    };

    GMENode.prototype.isTypeOf = function (typeId) {
        return this._state.core.isTypeOf(this._state.nodes[this._id].node, typeId);
    };

    GMENode.prototype.isInstanceOf = function (baseId) {
        return this._state.core.isInstanceOf(this._state.nodes[this._id].node, baseId);
    };

    GMENode.prototype.isValidChildOf = function (parentPath) {
        var parentNode = _getNode(this._state.nodes, parentPath);

        if (parentNode) {
            return this._state.core.isValidChildOf(this._state.nodes[this._id].node, parentNode);
        } else {
            return false;
        }
    };

    GMENode.prototype.getValidChildrenIds = function () {
        return this._state.core.getValidChildrenPaths(this._state.nodes[this._id].node);
    };

    GMENode.prototype.isValidTargetOf = function (sourcePath, name) {
        var sourceNode = _getNode(this._state.nodes, sourcePath);

        if (sourceNode) {
            return this._state.core.isValidTargetOf(this._state.nodes[this._id].node, sourceNode, name);
        } else {
            return false;
        }
    };

    GMENode.prototype.isValidSetMemberOf = function (setOwnerPath, name) {
        var setOwner = _getNode(this._state.nodes, setOwnerPath);

        if (setOwner) {
            return this._state.core.isValidSetMemberOf(this._state.nodes[this._id].node, setOwner, name);
        } else {
            return false;
        }
    };

    GMENode.prototype.getValidAspectNames = function () {
        return this._state.core.getValidAspectNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getOwnValidAspectNames = function () {
        return this._state.core.getOwnValidAspectNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getAspectMeta = function (name) {
        return this._state.core.getAspectMeta(this._state.nodes[this._id].node, name);
    };

    //MIXINS
    GMENode.prototype.getMixinPaths = function () {
        return this._state.core.getMixinPaths(this._state.nodes[this._id].node);
    };

    GMENode.prototype.canSetAsMixin = function (mixinPath) {
        return this._state.core.canSetAsMixin(this._state.nodes[this._id].node, mixinPath);
    };

    GMENode.prototype.isReadOnly = function () {
        return this._state.readOnlyProject || this._state.viewer || this.isLibraryRoot() || this.isLibraryElement();
    };

    GMENode.prototype.getAttributeDefinitionOwnerId = function (name) {
        return this._storeNode(this._state.core.getAttributeDefinitionOwner(this._state.nodes[this._id].node, name));
    };

    GMENode.prototype.getAspectDefinitionOwner = function (name) {
        return this._storeNode(this._state.core.getAttributeDefinitionOwner(this._state.nodes[this._id].node, name));
    };

    GMENode.prototype.isValidAspectMemberOf = function (parentId, name) {
        return this._state.core.isValidAspectMemberOf(this._state.nodes[this._id].node,
            this._state.nodes[parentId].node, name);
    };

    GMENode.prototype.getOwnValidPointerNames = function () {
        return this._state.core.getOwnValidPointerNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getOwnValidSetNames = function () {
        return this._state.core.getOwnValidSetNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getValidTargetIds = function (name) {
        return this._state.core.getValidTargetPaths(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getOwnValidTargetIds = function (name) {
        return this._state.core.getOwnValidTargetPaths(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getValidAspectTargetIds = function (name) {
        return this._state.core.getValidAspectTargetPaths(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getOwnValidAspectTargetIds = function (name) {
        return this._state.core.getOwnValidAspectTargetPaths(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getPointerDefinitionInfo = function (name, targetId) {
        var coreInfo = this._state.core.getPointerDefinitionInfo(this._state.nodes[this._id].node, name,
            this._state.nodes[targetId]);

        return {
            ownerId: this._storeNode(coreInfo.ownerNode),
            targetId: this._storeNode(coreInfo.targetNode)
        };
    };

    GMENode.prototype.getAspectDefinitionInfo = function (name, targetId) {
        var coreInfo = this._state.core.getAspectDefinitionInfo(this._state.nodes[this._id].node,
            name, this._state.nodes[targetId]);

        return {
            ownerId: this._storeNode(coreInfo.ownerNode),
            targetId: this._storeNode(coreInfo.targetNode)
        };
    };

    GMENode.prototype.getSetDefinitionInfo = function (name, targetId) {
        var coreInfo = this._state.core.getSetDefinitionInfo(this._state.nodes[this._id].node,
            name, this._state.nodes[targetId]);

        return {
            ownerId: this._storeNode(coreInfo.ownerNode),
            targetId: this._storeNode(coreInfo.targetNode)
        };
    };

    GMENode.prototype.getChildDefinitionInfo = function (name, targetId) {
        var coreInfo = this._state.core.getChildDefinitionInfo(this._state.nodes[this._id].node,
            name, this._state.nodes[targetId]);

        return {
            ownerId: this._storeNode(coreInfo.ownerNode),
            targetId: this._storeNode(coreInfo.targetNode)
        };
    };

    GMENode.prototype.getLibraryRootId = function (name) {
        return this._storeNode(this._state.core.getLibraryRoot(this._state.nodes[this._id].node, name));
    };


    // GetNode from another node...
    GMENode.prototype.getNode = function (id) {
        if (this._state.nodes[id]) {
            return new GMENode(id, this._logger, this._state, this._storeNode);
        }
        return null;
    };

    //getNode
    function getNode(_id, logger, state, storeNode) {
        if (state.nodes[_id]) {
            return new GMENode(_id, logger, state, storeNode);

        } else {
            //logger.warn('Tried to get node with path "' + _id + '" but was not in state.nodes');
        }

        return null;
    }

    return getNode;
});

/*globals define, console*/
/*eslint-env browser*/

/**
 * @author kecso / https://github.com/kecso
 * @author pmeijer / https://github.com/pmeijer
 */
define('client/gmeNodeSetter',[], function () {
    'use strict';

    function gmeNodeSetter(logger, state, saveRoot, storeNode, printCoreError) {

        function _logDeprecated(oldFn, newFn, isGetter, comment) {
            var typeToUse = isGetter ? 'gmeNode.' : 'gmeClient.',
                commentStr = comment ? comment : '';

            //eslint-disable-next-line no-console
            console.warn('"gmeClient.' + oldFn + '" is deprecated and will eventually be removed, use "' +
                typeToUse + newFn + '" instead.' + commentStr);
        }

        function _getNode(path) {
            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {
                return state.nodes[path].node;
            }
        }

        function _setAttrAndRegistry(node, desc) {
            var name;
            desc = desc || {};

            if (desc.attributes) {
                for (name in desc.attributes) {
                    if (desc.attributes.hasOwnProperty(name)) {
                        state.core.setAttribute(node, name, desc.attributes[name]);
                    }
                }
            }

            if (desc.registry) {
                for (name in desc.registry) {
                    if (desc.registry.hasOwnProperty(name)) {
                        state.core.setRegistry(node, name, desc.registry[name]);
                    }
                }
            }
        }

        function _copyMultipleNodes(paths, parentNode, resultAsArray) {
            var copiedNodes, result = {},
                resultArray = [],
                i, originalNodes = [],
                checkPaths = function () {
                    var i,
                        result = true;

                    for (i = 0; i < paths.length; i += 1) {
                        result = result && (state.nodes[paths[i]] &&
                            typeof state.nodes[paths[i]].node === 'object');
                    }

                    return result;
                };

            if (parentNode && checkPaths()) {
                for (i = 0; i < paths.length; i += 1) {
                    originalNodes.push(state.nodes[paths[i]].node);
                }

                copiedNodes = state.core.copyNodes(originalNodes, parentNode);

                if (copiedNodes instanceof Error) {
                    return copiedNodes;
                }

                for (i = 0; i < paths.length; i += 1) {
                    result[paths[i]] = copiedNodes[i];
                    resultArray.push(storeNode(copiedNodes[i]));
                }
            }

            return resultAsArray ? resultArray : result;
        }

        /**
         * @description Method to set an attribute of a given node.
         * @memberOf Client
         * @instance
         * @param {string} path - The path of the node in question.
         * @param {string} name - The name of the attribute.
         * @param {any} value - The value of the attribute to be set.
         * @param {string} msg - The message that should be attached to the commit that covers this update.
         */
        function setAttribute(path, name, value, msg) {
            var error,
                node = _getNode(path);

            if (node) {
                error = state.core.setAttribute(node, name, value);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ?
                    msg : 'setAttribute(' + path + ',' + name + ',' + JSON.stringify(value) + ')');
            }
        }

        /**
         * @description Method to remove an attribute from a given node.
         * @memberOf Client
         * @instance
         * @param {string} path - The path of the node in question.
         * @param {string} name - The name of the attribute.
         * @param {string} msg - The message that should be attached to the commit that covers this update.
         */
        function delAttribute(path, name, msg) {
            var error,
                node = _getNode(path);

            if (node) {
                error = state.core.delAttribute(node, name);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'delAttribute(' + path + ',' + name + ')');
            }
        }

        /**
         * @description Method to set a registry entry of a given node.
         * @memberOf Client
         * @instance
         * @param {string} path - The path of the node in question.
         * @param {string} name - The name of the registry.
         * @param {any} value - The value of the registry to be set.
         * @param {string} msg - The message that should be attached to the commit that covers this update.
         */
        function setRegistry(path, name, value, msg) {
            var error,
                node = _getNode(path);

            if (node) {
                error = state.core.setRegistry(node, name, value);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ?
                    msg : 'setRegistry(' + path + ',' + name + ',' + JSON.stringify(value) + ')');
            }
        }

        /**
         * @description Method to remove a registry entry of a given node.
         * @memberOf Client
         * @instance
         * @param {string} path - The path of the node in question.
         * @param {string} name - The name of the registry.
         * @param {string} msg - The message that should be attached to the commit that covers this update.
         */
        function delRegistry(path, name, msg) {
            var error,
                node = _getNode(path);

            if (node) {
                error = state.core.delRegistry(node, name);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'delRegistry(' + path + ',' + name + ')');
            }
        }

        /**
         * @example
         *
         * var nodeCopy1 = client.copyNode('/4', '');
         * var nodeCopy2 = client.copyNode('/4', '', {
         *   attributes: {
         *     name: 'CopiedNode'
         *   },
         *   registry: {
         *     position: {x: 100, y: 100}
         *   }
         * }, 'Created node with specific name and position.');
         *
         * @description Copies the given node into parent 
         * (does not enforce meta-rules and requires all participating nodes to be loaded in the client)
         * @function copyNode
         * @memberOf Client
         * @param {string} path - the id/path of the node to copy
         * @param {string} parentId - the id/path of the parent where the new copy should be created
         * @param {object} [desc={}] - named attributes and/or registries to set for the new node (see example)
         * @param {object} [desc.attributes={}] - named attributes to set for the new node
         * @param {object} [desc.registry={}] - named registries to set for the new node
         * @param {string} [msg] - optional commit message, if not supplied a default one 
         * with the function name and input parameters will be used
         * @returns {GMENode|undefined} - the newly created node if it could be copied
         * @instance
         */
        function copyNode(path, parentPath, desc, msg) {
            var node = _getNode(path),
                parentNode = _getNode(parentPath),
                newNode, newPath;

            if (node && parentNode) {
                newNode = state.core.copyNode(node, parentNode);

                if (newNode instanceof Error) {
                    printCoreError(newNode);
                    return;
                }

                _setAttrAndRegistry(newNode, desc);
                newPath = storeNode(newNode);

                saveRoot(typeof msg === 'string' ?
                    msg : 'copyNode(' + path + ', ' + parentPath + ', ' + JSON.stringify(desc) + ')');
                return newPath;
            }
        }

        /**
         * @example
         *
         * client.copyMoreNodes({
         *    parentId: '',
         *    '/4': {},
         *    '/5': {
         *      attributes: {
         *        name: 'MyNamedCopy'
         *      },
         *      registry: {
         *        position: {x: 100, y:100}
         *      }
         *    }
         * }, 'Copied two nodes with some additional init data.');
         *
         * @description Copies the given nodes into the parent (does not enforce meta-rules 
         * and requires all participating nodes to be loaded in the client)
         * @function copyMoreNodes
         * @memberOf Client
         * @param {object} parameters - the parameters holding parentId and nodes to be copied
         * indexed by their ids/paths (see example)
         * @param {string} parameters.parentId - the id/path of the parent where the new copies should be created
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function copyMoreNodes(parameters, msg) {
            var pathsToCopy = [],
                parentNode = _getNode(parameters.parentId),
                nodePath,
                newNodes;

            if (parentNode) {
                for (nodePath in parameters) {
                    if (parameters.hasOwnProperty(nodePath) && nodePath !== 'parentId') {
                        pathsToCopy.push(nodePath);
                    }
                }

                msg = typeof msg === 'string' ?
                    msg : 'copyMoreNodes(' + JSON.stringify(pathsToCopy) + ',' + parameters.parentId + ')';

                if (pathsToCopy.length < 1) {
                    // empty on purpose
                } else if (pathsToCopy.length === 1) {
                    copyNode(pathsToCopy[0], parameters.parentId, parameters[pathsToCopy[0]], msg);
                } else {
                    newNodes = _copyMultipleNodes(pathsToCopy, parentNode);

                    if (newNodes instanceof Error) {
                        printCoreError(newNodes);
                        return;
                    }

                    for (nodePath in newNodes) {
                        if (newNodes.hasOwnProperty(nodePath) && parameters[nodePath]) {
                            _setAttrAndRegistry(newNodes[nodePath], parameters[nodePath]);
                        }
                    }

                    saveRoot(msg);
                }
            } else {
                state.logger.error('wrong parameters for copy operation - denied -');
            }
        }

        /**
         * @example
         *
         * client.moveMoreNodes({
         *    parentId: '',
         *    '/4': {},
         *    '/5': {
         *      attributes: {
         *        name: 'MyNamedCopy'
         *      },
         *      registry: {
         *        position: {x: 100, y:100}
         *      }
         *    }
         * }, 'Copied two nodes with some additional init data.');
         *
         * @description Moves the given nodes into the parent (does not enforce meta-rules 
         * and requires all participating nodes to be loaded in the client)
         * @function moveMoreNodes
         * @memberOf Client
         * @param {object} parameters - the parameters holding parentId and nodes to be copied
         * indexed by their ids/paths (see example)
         * @param {string} parameters.parentId - the id/path of the parent where the new copies should be created
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function moveMoreNodes(parameters, msg) {
            var pathsToMove = [],
                returnParams = {},
                i,
                newNode;

            for (i in parameters) {
                if (parameters.hasOwnProperty(i)) {
                    if (i !== 'parentId') {
                        pathsToMove.push(i);
                    }
                }
            }

            if (pathsToMove.length > 0 &&
                typeof parameters.parentId === 'string' &&
                state.nodes[parameters.parentId] &&
                typeof state.nodes[parameters.parentId].node === 'object') {
                for (i = 0; i < pathsToMove.length; i += 1) {
                    if (state.nodes[pathsToMove[i]] &&
                        typeof state.nodes[pathsToMove[i]].node === 'object') {

                        newNode = state.core.moveNode(state.nodes[pathsToMove[i]].node,
                            state.nodes[parameters.parentId].node);
                        returnParams[pathsToMove[i]] = state.core.getPath(newNode);
                        _setAttrAndRegistry(newNode, parameters[pathsToMove[i]]);
                        delete state.nodes[pathsToMove[i]];
                        storeNode(newNode, true);
                    }
                }
            }

            saveRoot(typeof msg === 'string' ? msg : 'moveMoreNodes(' + JSON.stringify(returnParams) + ')');
            return returnParams;
        }

        /**
         * @example
         *
         * client.createChildren({
         *    parentId: '',
         *    '/4': {},
         *    '/5': {
         *      attributes: {
         *        name: 'MyVeryOwnName'
         *      },
         *      registry: {
         *        position: {x: 100, y:100}
         *      }
         *    }
         * }, 'Created new children of the root based on the list of existing nodes.');
         *
         * @description Creates instances as children of the parent node based on the list 
         * of nodes among the parameters (does not enforce meta-rules 
         * and requires all participating nodes to be loaded in the client).
         * @function createChildren
         * @memberOf Client
         * @param {object} parameters - the parameters holding parentId and nodes to be instantiated
         * indexed by their ids/paths (see example)
         * @param {string} parameters.parentId - the id/path of the parent where the new nodes should be created
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function createChildren(parameters, msg) {
            //TODO we also have to check out what is happening with the sets!!!
            var result = {},
                paths = [],
                nodes = [],
                node,
                parent = state.nodes[parameters.parentId].node,
                names, i, j, index, pointer,
                newChildren = [],
                relations = [];

            //to allow 'meaningfull' instantiation of multiple objects
            // we have to recreate the internal relations - except the base
            paths = Object.keys(parameters);
            paths.splice(paths.indexOf('parentId'), 1);
            for (i = 0; i < paths.length; i++) {
                node = state.nodes[paths[i]].node;
                nodes.push(node);
                pointer = {};
                names = state.core.getPointerNames(node);
                index = names.indexOf('base');
                if (index !== -1) {
                    names.splice(index, 1);
                }

                for (j = 0; j < names.length; j++) {
                    index = paths.indexOf(state.core.getPointerPath(node, names[j]));
                    if (index !== -1) {
                        pointer[names[j]] = index;
                    }
                }
                relations.push(pointer);
            }

            //now the instantiation
            for (i = 0; i < nodes.length; i++) {
                newChildren.push(state.core.createNode({parent: parent, base: nodes[i]}));
            }

            //now for the storage and relation setting
            for (i = 0; i < paths.length; i++) {
                _setAttrAndRegistry(newChildren[i], parameters[paths[i]]);

                //relations
                names = Object.keys(relations[i]);
                for (j = 0; j < names.length; j++) {
                    state.core.setPointer(newChildren[i], names[j], newChildren[relations[i][names[j]]]);
                }

                //store
                result[paths[i]] = storeNode(newChildren[i]);

            }

            msg = typeof msg === 'string' ? msg : 'createChildren(' + JSON.stringify(result) + ')';
            saveRoot(msg);
            return result;
        }

        /**
         * @description Delete the given node.
         * @function deleteNode
         * @memberOf Client
         * @param {string} path - the path/id of the node to be deleted from the model.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function deleteNode(path, msg) {
            var node = _getNode(path);

            if (node) {
                state.core.deleteNode(node);
                saveRoot(typeof msg === 'string' ? msg : 'deleteNode(' + path + ')');
            }
        }

        /**
         * @description Delete the given node.
         * @function deleteNodes
         * @memberOf Client
         * @param {string[]} paths - the path/id list of the nodes to be deleted from the model.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function deleteNodes(paths, msg) {
            var didDelete = false,
                i,
                node;

            for (i = 0; i < paths.length; i++) {
                node = _getNode(paths[i]);
                if (node) {
                    state.core.deleteNode(node);
                    didDelete = true;
                }
            }

            if (didDelete) {
                saveRoot(typeof msg === 'string' ? msg : 'deleteNodes(' + paths + ')');
            }
        }

        /**
         * @example
         *
         * client.createNode({
         *    parentId: '',
         *    baseId:'/1',
         *    guid:,
         *    relid:'/aaa'
         *   },
         *   {
         *     attributes: {
         *        name: 'MyVeryOwnName'
         *      },
         *      registry: {
         *        position: {x: 100, y:100}
         *      }
         *   },
         *   'Created new node as the child of the root and instance of the FCO.');
         *
         * @description Creates a new node based on the given parameters.
         * @function createNode
         * @memberOf Client
         * @param {object} parameters - the parameters holding necessary information for the creation.
         * @param {string} parameters.parentId - the path/id of the container of the new node.
         * @param {string} parameters.baseId - the path/id of the prototype of the new node.
         * @param {string} parameters.parentId - the id/path of the parent where the new nodes should be created
         * @param {string} [parameters.guid] - the unique identifier of the node we will create.
         * @param {string} [parameters.relid] - the relative id of the node we will create.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function createNode(parameters, desc, msg) {
            var parentNode = _getNode(parameters.parentId),
                baseNode = _getNode(parameters.baseId),
                newNode,
                newID;

            if (parentNode) {
                newNode = state.core.createNode({
                    parent: parentNode,
                    base: baseNode,
                    guid: parameters.guid,
                    relid: parameters.relid
                });

                if (newNode instanceof Error) {
                    printCoreError(newNode);
                    return;
                }

                // By default the position will be {100, 100}

                desc = desc || {};
                desc.registry = desc.registry || {};
                desc.registry.position = desc.registry.position || {};
                desc.registry.position.x = (typeof desc.registry.position.x === 'number' ||
                    Number(desc.registry.position.x) + '' === desc.registry.position.x) ?
                    Number(desc.registry.position.x) : 100;
                desc.registry.position.y = (typeof desc.registry.position.y === 'number' ||
                    Number(desc.registry.position.y) + '' === desc.registry.position.y) ?
                    Number(desc.registry.position.y) : 100;

                _setAttrAndRegistry(newNode, desc);

                storeNode(newNode);
                newID = state.core.getPath(newNode);
                saveRoot(typeof msg === 'string' ? msg :
                    'createNode(' + parameters.parentId + ',' + parameters.baseId + ',' + newID + ')');
            }

            return newID;
        }

        /**
         * @description Sets the value of the pointer of the given node.
         * @function setPointer
         * @memberOf Client
         * @param {string} path - the path/id of the node that we will modify.
         * @param {string} name - the name of the pointer to set.
         * @param {string|null} target - the id/path of the target node of the pointer. If
         * the value is null, there will be no target for the pointer.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function setPointer(path, name, target, msg) {
            var node = _getNode(path),
                targetNode;

            if (node) {
                if (target === null) {
                    state.core.setPointer(node, name, target);
                } else {
                    targetNode = _getNode(target);
                    state.core.setPointer(node, name, targetNode);
                }

                saveRoot(typeof msg === 'string' ? msg : 'setPointer(' + path + ',' + name + ',' + target + ')');
            }
        }

        /**
         * @description Removes the pointer of the given node.
         * Setting a pointer to null and deleting it is different! 
         * (one is a value, the other means the absence of value)
         * @function delPointer
         * @memberOf Client
         * @param {string} path - the path/id of the node that we will modify.
         * @param {string} name - the name of the pointer to set.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function delPointer(path, name, msg) {
            var node = _getNode(path);

            if (node) {
                state.core.delPointer(node, name);
                saveRoot(typeof msg === 'string' ? msg : 'delPointer(' + path + ',' + name + ')');
            }
        }

        // Mixed argument methods - START
        /**
         * @description Add a new member node to the given set of the
         * specified node.
         * @function addMember
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} memberPath - the path/id of the member node.
         * @param {string} setId - the name of the set to expand.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function addMember(path, memberPath, setId, msg) {
            // FIXME: This will have to break due to switched arguments
            var node = _getNode(path),
                memberNode = _getNode(memberPath);

            if (node && memberNode) {
                state.core.addMember(node, setId, memberNode);
                saveRoot(typeof msg === 'string' ? msg : 'addMember(' + path + ',' + memberPath + ',' + setId + ')');
            }
        }

        /**
         * @description Removes a member node from the given set of the
         * specified node.
         * @function removeMember
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} memberPath - the path/id of the member node.
         * @param {string} setId - the name of the set to expand.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function removeMember(path, memberPath, setId, msg) {
            // FIXME: This will have to break due to switched arguments (sort of)
            var node = _getNode(path);

            if (node) {
                state.core.delMember(node, setId, memberPath);
                saveRoot(typeof msg === 'string' ? msg : 'removeMember(' + path + ',' + memberPath + ',' + setId + ')');
            }
        }

        /**
         * @description Set the given attribute value that is connected to the membership 
         * (not the member node, so it only has a meaning in the context of the membership).
         * @function setMemberAttribute
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} memberPath - the path/id of the member node.
         * @param {string} setId - the name of the set where the member exists.
         * @param {string} name - the name of the attribute.
         * @param {object|string|null} value - the value of the attribute.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function setMemberAttribute(path, memberPath, setId, name, value, msg) {
            // FIXME: This will have to break due to switched arguments
            var node = _getNode(path);

            if (node) {
                state.core.setMemberAttribute(node, setId, memberPath, name, value);
                saveRoot(typeof msg === 'string' ?
                    msg : 'setMemberAttribute(' + [path, memberPath, setId, name, value].join(',') + ')');
            }
        }

        /**
         * @description Removes the given attribute that is connected to the membership 
         * from the node.
         * @function delMemberAttribute
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} memberPath - the path/id of the member node.
         * @param {string} setId - the name of the set to expand.
         * @param {string} name - the name of the attribute.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function delMemberAttribute(path, memberPath, setId, name, msg) {
            // FIXME: This will have to break due to switched arguments
            var node = _getNode(path);

            if (node) {
                state.core.delMemberAttribute(node, setId, memberPath, name);
                saveRoot(typeof msg === 'string' ?
                    msg : 'delMemberAttribute(' + [path, memberPath, setId, name].join(',') + ')');
            }
        }

        /**
         * @description Set the given registry value that is connected to the membership 
         * (not the member node, so it only has a meaning in the context of the membership).
         * @function setMemberRegistry
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} memberPath - the path/id of the member node.
         * @param {string} setId - the name of the set to expand.
         * @param {string} name - the name of the registry.
         * @param {object|string|null} value - the value of the registry.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function setMemberRegistry(path, memberPath, setId, name, value, msg) {
            // FIXME: This will have to break due to switched arguments
            var node = _getNode(path);

            if (node) {
                state.core.setMemberRegistry(node, setId, memberPath, name, value);
                saveRoot(typeof msg === 'string' ?
                    msg : 'setMemberRegistry(' + path + ',' + memberPath + ',' + setId + ',' + name + ',' +
                    JSON.stringify(value) + ')');
            }
        }

        /**
         * @description Removes the given registry that is connected to the membership 
         * from the node.
         * @function delMemberRegistry
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} memberPath - the path/id of the member node.
         * @param {string} setId - the name of the set to expand.
         * @param {string} name - the name of the registry.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function delMemberRegistry(path, memberPath, setId, name, msg) {
            // FIXME: This will have to break due to switched arguments
            var node = _getNode(path);

            if (node) {
                state.core.delMemberRegistry(node, setId, memberPath, name);
                saveRoot(typeof msg === 'string' ?
                    msg : 'delMemberRegistry(' + path + ',' + memberPath + ',' + setId + ',' + name + ')');
            }
        }

        // Mixed argument methods - END
        /**
         * @description Set the given attribute value of the set of the node 
         * (the value is connected to the node, but only in the context of the set).
         * @function setSetAttribute
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} setName - the name of the set where the member exists.
         * @param {string} attrName - the name of the attribute.
         * @param {object|string|null} attrValue - the value of the attribute.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function setSetAttribute(path, setName, attrName, attrValue, msg) {
            var node = _getNode(path);

            if (node) {
                state.core.setSetAttribute(node, setName, attrName, attrValue);
                saveRoot(typeof msg === 'string' ?
                    msg : 'setSetAttribute(' + path + ',' + setName + ',' + attrName + ',' +
                    JSON.stringify(attrValue) + ')');
            }
        }

        /**
         * @description Removes the given attribute that is connected to set of the node.
         * @function delSetAttribute
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} setName - the name of the set to change.
         * @param {string} attrName - the name of the attribute.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function delSetAttribute(path, setName, attrName, msg) {
            var node = _getNode(path);

            if (node) {
                state.core.delSetAttribute(node, setName, attrName);
                saveRoot(typeof msg === 'string' ?
                    msg : 'delSetAttribute(' + path + ',' + setName + ',' + attrName + ')');
            }
        }

        /**
         * @description Set the given registry value of the set of the node 
         * (the value is connected to the node, but only in the context of the set).
         * @function setSetRegistry
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} setName - the name of the set where the member exists.
         * @param {string} regName - the name of the registry.
         * @param {object|string|null} regValue - the value of the registry.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function setSetRegistry(path, setName, regName, regValue, msg) {
            var node = _getNode(path);

            if (node) {
                state.core.setSetRegistry(node, setName, regName, regValue);
                saveRoot(typeof msg === 'string' ?
                    msg : 'setSetRegistry(' + [path, setName, regName, JSON.stringify(regValue)].join(',') + ')');
            }
        }

        /**
         * @description Removes the given registry that is connected to set of the node.
         * @function delSetRegistry
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} setName - the name of the set to change.
         * @param {string} attrName - the name of the registry.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function delSetRegistry(path, setName, regName, msg) {
            var node = _getNode(path);

            if (node) {
                state.core.delSetRegistry(node, setName, regName);
                saveRoot(typeof msg === 'string' ?
                    msg : 'delSetRegistry(' + path + ',' + setName + ',' + regName + ')');
            }
        }

        /**
         * @description Creates a set that belongs to the node.
         * @function createSet
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} setId - the name of the set.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function createSet(path, setId, msg) {
            var node = _getNode(path);

            if (node) {
                state.core.createSet(node, setId);
                saveRoot(typeof msg === 'string' ? msg : 'createSet(' + path + ',' + setId + ')');
            }
        }

        /**
         * @description Removes a set that belongs to the node.
         * @function delSet
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} setId - the name of the set.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function delSet(path, setId, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.delSet(node, setId);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'delSet(' + path + ',' + setId + ')');
            }
        }

        /**
         * @description Changes the prototype node of the node.
         * This function should only be used with care!
         * @function setBase
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} basePath - the path/id of the new prototype node.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function setBase(path, basePath, msg) {
            var node = _getNode(path),
                baseNode = _getNode(basePath),
                error;

            if (node && baseNode) {
                error = state.core.setBase(node, baseNode);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'setBase(' + path + ',' + basePath + ')');
            }
        }

        /**
         * @description Moves a node into a new container.
         * @function moveNode
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} parentPath - the path/id of the new container node.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function moveNode(path, parentPath, msg) {
            var node = _getNode(path),
                parentNode = _getNode(parentPath),
                movedPath;

            if (node && parentNode) {
                movedPath = storeNode(state.core.moveNode(node, parentNode));
                saveRoot(typeof msg === 'string' ? msg : 'moveNode(' + path + ',' + parentPath + ')');
            }

            return movedPath;
        }

        /**
         * @description Removes teh prototype ofd the node. Do not use this function
         * as it is very dangerous!
         * @function delBase
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function delBase(path, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.setBase(node, null);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'delBase(' + path + ')');
            }
        }

        // META functions
        /**
         * @description Returns the JSON based meta description of the node.
         * @function getMeta
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function getMeta(path) {
            var node = _getNode(path),
                meta = {children: {}, attributes: {}, pointers: {}, aspects: {}};

            if (!node) {
                return null;
            }

            meta = state.core.getJsonMeta(node);

            return meta;
        }

        /**
         * @description Set all the meta rules of a node based on a JSON.
         * It has no effect on the inherited rules!
         * @function setMeta
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {object} meta - the directory of rules to be set.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function setMeta(path, meta, msg) {
            var node = _getNode(path),
                otherNode,
                name,
                i,
                error;

            if (node) {
                state.core.clearMetaRules(node);

                //children
                if (meta.children && meta.children.items && meta.children.items.length > 0) {
                    error = state.core.setChildrenMetaLimits(node, meta.children.min, meta.children.max);
                    if (error instanceof Error) {
                        printCoreError(error);
                        return;
                    }

                    for (i = 0; i < meta.children.items.length; i += 1) {
                        otherNode = _getNode(meta.children.items[i]);
                        if (otherNode) {
                            error = state.core.setChildMeta(node,
                                otherNode,
                                meta.children.minItems[i],
                                meta.children.maxItems[i]);

                            if (error instanceof Error) {
                                printCoreError(error);
                                return;
                            }
                        }
                    }
                }

                //attributes
                if (meta.attributes) {
                    for (i in meta.attributes) {
                        error = state.core.setAttributeMeta(node, i, meta.attributes[i]);
                        if (error instanceof Error) {
                            printCoreError(error);
                            return;
                        }
                    }
                }

                //pointers and sets
                if (meta.pointers) {
                    for (name in meta.pointers) {
                        if (meta.pointers[name].items && meta.pointers[name].items.length > 0) {
                            error = state.core.setPointerMetaLimits(node,
                                name,
                                meta.pointers[name].min,
                                meta.pointers[name].max);

                            if (error instanceof Error) {
                                printCoreError(error);
                                return;
                            }

                            for (i = 0; i < meta.pointers[name].items.length; i += 1) {
                                otherNode = _getNode(meta.pointers[name].items[i]);
                                if (otherNode) {
                                    error = state.core.setPointerMetaTarget(node,
                                        name,
                                        otherNode,
                                        meta.pointers[name].minItems[i],
                                        meta.pointers[name].maxItems[i]);
                                    if (error instanceof Error) {
                                        printCoreError(error);
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }

                //aspects
                if (meta.aspects) {
                    for (name in meta.aspects) {
                        for (i = 0; i < meta.aspects[name].length; i += 1) {
                            otherNode = _getNode(meta.aspects[name][i]);
                            if (otherNode) {
                                error = state.core.setAspectMetaTarget(node, name, otherNode);
                                if (error instanceof Error) {
                                    printCoreError(error);
                                    return;
                                }
                            }
                        }
                    }
                }

                //constraints
                if (meta.constraints) {
                    for (name in meta.constraints) {
                        if (typeof meta.constraints[name] === 'object') {
                            error = state.core.setConstraint(node, name, meta.constraints[name]);
                            if (error instanceof Error) {
                                printCoreError(error);
                                return;
                            }
                        }
                    }
                }

                saveRoot(typeof msg === 'string' ? msg : 'setMeta(' + path + ')');
            }
        }

        /**
         * @description Removes all Meta rules from the node (does not have effect on the inherited rules).
         * @function clearMetaRules
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function clearMetaRules(path, msg) {
            var node = _getNode(path);

            if (node) {
                state.core.clearMetaRules(node);

                saveRoot(typeof msg === 'string' ? msg : 'clearMetaRules(' + path + ')');
            }
        }

        /**
         * @description Creates a mixin connection to the node.
         * @function addMixin
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} addMixin - the path/id of the mixin node.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function addMixin(path, mixinPath, msg) {
            var error,
                node = _getNode(path);

            if (node) {
                error = state.core.addMixin(node, mixinPath);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'addMixin(' + path + ',' + mixinPath + ')');
            }
        }

        /**
         * @description Removes a mixin connection from the node.
         * @function delMixin
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} addMixin - the path/id of the mixin node.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function delMixin(path, mixinPath, msg) {
            var error,
                node = _getNode(path);

            if (node) {
                error = state.core.delMixin(node, mixinPath);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'delMixin(' + path + ',' + mixinPath + ')');
            }
        }

        //TODO add function description
        function setChildrenMetaAttribute(path, attrName, value, msg) {
            if (attrName !== 'items') {
                var rawMeta = getMeta(path);
                rawMeta.children[attrName] = value;
                setMeta(path, rawMeta, msg);
            }
        }

        /**
         * @description Creates a containment rule for the node.
         * @function setChildMeta
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} childPath - the path/id of the child node.
         * @param {number} min - the minimum allowed number of children of this type.
         * -1 means that there is no lower limit.
         * @param {number} max - the maximum allowed number of children of this type.
         * -1 ,eams there is no upper limit.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function setChildMeta(path, childPath, min, max, msg) {
            var node = _getNode(path),
                childNode = _getNode(childPath),
                error;

            if (childNode && node) {
                error = state.core.setChildMeta(node, childNode, min, max);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'setChildMeta(' + path + ',' + childPath + ',' +
                    (min || -1) + ',' + (max || -1) + ')');
            }
        }

        /**
         * @example
         *
         * client.setChildMeta(
         *   '/a/b/c',
         *   {
         *     min: 0,
         *     max: 10,
         *     items:[
         *       { id: 'a/b/dd',
         *       min: 0,
         *       max: 1 },
         *       { id: 'a/b/ee',
         *       min: 4,
         *       max: 10 },
         *     ]
         *   },
         *   'Adding containment rules to the node and setting global cardinality.');
         *
         * @description Creates multiple containment rules for the node.
         * @function setChildMeta
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {object} meta - the collection of containment rules.
         * @param {object[]} meta.items - array of containment rules with child 
         * type identification and cardinality rules.
         * @param {string} meta.items[i].id - the path/id of the child.
         * @param {string} meta.items[i].min - the lower bound of the cardinality for the given child type.
         * @param {string} meta.items[i].max - the upper bound of the cardinality for the given child type.
         * @param {number} [meta.min] - global lower limit on the number of children of the node.
         * @param {number} [meta.min] - global lower limit on the number of children of the node.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function setChildrenMeta(path, meta, msg) {
            var node = _getNode(path),
                target,
                error,
                i;

            if (meta && meta.items && node) {
                for (i = 0; i < meta.items.length; i += 1) {
                    target = _getNode(meta.items[i].id);
                    if (target) {
                        error = state.core.setChildMeta(node, target, meta.items[i].min, meta.items[i].max);
                        if (error instanceof Error) {
                            printCoreError(error);
                            return;
                        }
                    }
                }

                error = state.core.setChildrenMetaLimits(node, meta.min, meta.max);

                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'Meta.setChildrenMeta(' + path + ')');
            }
        }

        /**
         * @description Removes a containment rule from the node.
         * @function delChildMeta
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} typeId - the path/id of the child node.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function delChildMeta(path, typeId, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.delChildMeta(node, typeId);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'delChildMeta(' + path + ', ' + typeId + ')');
            }
        }

        /**
         * @description Creates an attribute meta rule for the node.
         * @function setAttributeMeta
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} name - the name of the attribute.
         * @param {object} schema - the description of the attribute rule.
         * @param {'string'|'integer'|'float'|'boolean'|'asset'} schema.type - 
         * the type of the attribute.
         * @param {string[]} [enum] - valid choices if the attrubite is an enumeration.
         * @param {string|number|boolean} [default] - the default value of the attribute.
         * @param {boolean} multiline - shows if the string attribute is a multiline one
         * and should be edited in a code-editor style.
         * @param {string} multilineType - show the style of the multiline 
         * (c, js, java, ...). helps in functions like syntax highlighting.
         * @param {boolean} isPassword - shows if the attribute should be handled
         * sensitively on the UI.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function setAttributeMeta(path, name, schema, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.setAttributeMeta(node, name, schema);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'setAttributeMeta(' + path + ', ' + name + ')');
            }
        }

        /**
         * @description Removes an attribute rule from the node.
         * @function delAttributeMeta
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} name - the name of the attribute.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function delAttributeMeta(path, name, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.delAttributeMeta(node, name);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'delAttributeMeta(' + path + ', ' + name + ')');
            }
        }

        /**
         * @description Add a potential target/member to a pointer/set rule.
         * @function setPointerMetaTarget
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} name - the name of the pointer/set.
         * @param {string} targetPath - the path/id of the new pointer target/member.
         * @param {integer} min - the lower bound of the cardinality of the rule 
         * (for pointer it should be always 0).
         * @param {integer} max - the upper bound of the cardinality of the rule 
         * (for pointer it should be always 1).
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function setPointerMetaTarget(path, name, targetPath, min, max, msg) {
            var node = _getNode(path),
                targetNode = _getNode(targetPath),
                error;

            if (node && targetNode) {
                error = state.core.setPointerMetaTarget(node, name, targetNode, min, max);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'setPointerMetaTarget(' +
                    [path, name, targetPath, min || -1, max || -1].join(',') + ')');
            }
        }

        /**
         * @description Moves a potential target/member to a pointer/set rule from another.
         * @function movePointerMetaTarget
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} name - the name of the pointer/set.
         * @param {string} targetPath - the path/id of the pointer target/member.
         * @param {string} oldName - the name of the current pointer rule.
         * @param {integer} newName - the name of the new pointer/set rule.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function movePointerMetaTarget(path, targetPath, oldName, newName, msg) {
            var node = _getNode(path),
                targetNode = _getNode(targetPath);

            if (node && targetNode) {
                try {
                    state.core.movePointerMetaTarget(node, targetNode, oldName, newName);
                } catch (err) {
                    printCoreError(err);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'movePointerMetaTarget(' + path + ', ' + targetPath + ',' +
                    oldName + ',' + newName);
            }
        }

        /**
         * @description Removes a target/member from a pointer/set rule.
         * @function delPointerMetaTarget
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} name - the name of the pointer/set.
         * @param {string} targetPath - the path/id of the pointer target/member.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function delPointerMetaTarget(path, name, targetPath, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.delPointerMetaTarget(node, name, targetPath);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg :
                    'delPointerMetaTarget(' + path + ', ' + name + ', ' + targetPath + ')');
            }
        }

        /**
         * @description Removes a complete pointer/set rule including all target/member rules.
         * @function delPointerMeta
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} name - the name of the pointer/set.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function delPointerMeta(path, name, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.delPointerMeta(node, name);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'delPointerMeta(' + path + ', ' + name + ')');
            }
        }

        /**
         * @example
         *
         * client.setPointerMeta(
         *   '/a/b/c',
         *   'myPointer',
         *   {
         *     min: 0,
         *     max: 1,
         *     items:[
         *       { id: 'a/b/dd',
         *       min: 0,
         *       max: 1 },
         *       { id: 'a/b/ee',
         *       min: 0,
         *       max: 1 },
         *     ]
         *   },
         *   'Adding pointer rules to the node.');
         * @example
         * * client.setPointerMeta(
         *   '/a/b/c',
         *   'mySet',
         *   {
         *     items:[
         *       { id: 'a/b/dd'},
         *       { id: 'a/b/ee'},
         *     ]
         *   },
         *   'Adding set rules to the node.');
         *
         * @description Creates a pointer/set meta rule with multiple potential target/member.
         * @function setPointerMeta
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {object} meta - the collection of pointer/set rules.
         * @param {object[]} meta.items - array of target/member rules.
         * @param {string} meta.items[i].id - the path/id of the target/member.
         * @param {string} meta.items[i].min - the lower bound of the cardinality for the given target/member.
         * @param {string} meta.items[i].max - the upper bound of the cardinality for the given target/member.
         * @param {number} [meta.min] - global lower limit on the number of target/member of the node.
         * should be 0 for pointer!
         * @param {number} [meta.max] - global upper limit on the number of target/member of the node.
         * should be 1 for pointer!
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function setPointerMeta(path, name, meta, msg) {
            var node = _getNode(path),
                target,
                error,
                i;

            if (meta && meta.items && node) {
                for (i = 0; i < meta.items.length; i += 1) {
                    target = _getNode(meta.items[i].id);
                    if (target) {
                        error = state.core.setPointerMetaTarget(node,
                            name,
                            target,
                            meta.items[i].min,
                            meta.items[i].max);

                        if (error instanceof Error) {
                            printCoreError(error);
                            return;
                        }
                    }
                }

                error = state.core.setPointerMetaLimits(node, name, meta.min, meta.max);

                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'setPointerMeta(' + path + ', ' + name + ')');
            }
        }

        /**
         * @description Creates/extends an aspect rule set (filtered contaiment).
         * @function setAspectMetaTarget
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} name - the name of the aspect.
         * @param {string} targetPath - the path/id of the new member.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function setAspectMetaTarget(path, name, targetPath, msg) {
            var node = _getNode(path),
                targetNode = _getNode(targetPath),
                error;

            if (node && targetNode) {
                error = state.core.setAspectMetaTarget(node, name, targetNode);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ?
                    msg : 'setAspectMetaTarget(' + path + ', ' + name + ',' + targetPath + ')');
            }
        }

        /**
         * @description Removes an element from an aspect rule set (filtered contaiment).
         * @function delAspectMetaTarget
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} name - the name of the aspect.
         * @param {string} targetPath - the path/id of the member.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function delAspectMetaTarget(path, name, targetPath, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.delAspectMetaTarget(node, name, targetPath);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'delAspectMeta(' + path + ', ' + name + ')');
            }
        }

        /**
         * @description Creates/extends an aspect rule set (filtered contaiment) 
         * with multiple new targets.
         * @function setAspectMetaTargets
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} name - the name of the aspect.
         * @param {string[]} targetPaths - array of path/id of the new members.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function setAspectMetaTargets(path, name, targetPaths, msg) {
            var node = _getNode(path),
                i,
                target,
                error;

            if (node) {
                error = state.core.delAspectMeta(node, name);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                for (i = 0; i < targetPaths.length; i += 1) {
                    target = _getNode(targetPaths[i]);
                    if (target) {
                        error = state.core.setAspectMetaTarget(node, name, target);
                        if (error instanceof Error) {
                            printCoreError(error);
                            return;
                        }
                    }
                }

                saveRoot(typeof msg === 'string' ? msg :
                    'setAspectMetaTargets(' + path + ', ' + name + ',' + JSON.stringify(targetPaths) + ')');
            }
        }

        /**
         * @description Removes a complete aspect rule set (filtered contaiment).
         * @function delAspectMeta
         * @memberOf Client
         * @param {string} path - the path/id of the node that will be modified.
         * @param {string} name - the name of the aspect.
         * @param {string} [msg] - optional commit message, if not supplied a default one with the 
         * function name and input parameters will be used
         * @instance
         */
        function delAspectMeta(path, name, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.delAspectMeta(node, name);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'delAspectMeta(' + path + ', ' + name + ')');
            }
        }

        /**
         * @description Check if the given node is an instance of the type node.
         * All participant nodes have to be loaded to the client
         * @function isTypeOf
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} path - the path/id of the node.
         * @param {string} typePath - the path/id of the type node.
         * @returns {boolean} - true if the node inherits from the type node, false otherwise 
         * (or if one of the nodes is not accessible).
         * @instance
         */
        function isTypeOf(path, typePath) {
            var node = _getNode(path);

            if (node) {
                return state.core.isTypeOf(node, typePath);
            }

            return false;
        }

        /**
         * @description Check if the given node is valid target for the pointer of the other node.
         * All participant nodes have to be loaded to the client
         * @function isValidTarget
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} path - the path/id of the node that hold the pointer rule 
         * (the source of the pointer).
         * @param {string} name - the name of the pointer to check.
         * @param {string} targetPath - the path/id of the target node.
         * @returns {boolean} - true if the target node is a valid target for 
         * the pointer of the node, false otherwise 
         * (or if one of the nodes is not accessible).
         * @instance
         */
        function isValidTarget(path, name, targetPath) {
            var node = _getNode(path),
                target = _getNode(targetPath);

            if (node && target) {
                return state.core.isValidTargetOf(target, node, name);
            }

            return false;
        }

        /**
         * @description Filters out potential pointer targets based on wether they 
         * would be valid targets.
         * All participant nodes have to be loaded to the client
         * @function filterValidTarget
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} path - the path/id of the node that hold the pointer rule 
         * (the source of the pointer).
         * @param {string} name - the name of the pointer to check.
         * @param {string[]} paths - the path/id of the target nodes.
         * @returns {string[]} - list of path/id of valid target nodes.
         * @instance
         */
        function filterValidTarget(path, name, paths) {
            var targets = [];

            for (var i = 0; i < paths.length; i++) {
                if (isValidTarget(path, name, paths[i])) {
                    targets.push(paths[i]);
                }
            }

            return targets;
        }

        /**
         * @description Collects the meta node ids, that can be instantiated for a 
         * valid target of the given pointer of the node.
         * All participant nodes have to be loaded to the client
         * @function getValidTargetTypes
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} path - the path/id of the node that hold the pointer rule 
         * (the source of the pointer).
         * @param {string} name - the name of the pointer to check.
         * @returns {string[]} - list of path/id of valid target meta-nodes.
         * @instance
         */
        function getValidTargetTypes(path, name) {
            var node = _getNode(path),
                meta, i,
                targets = [];

            if (node) {
                meta = state.core.getPointerMeta(node, name);

                for (i in meta) {
                    if (i !== 'min' && i !== 'max') {
                        targets.push(i);
                    }
                }
            }

            return targets;
        }

        /**
         * @description Collects the meta node ids, that can be instantiated for a 
         * valid target of the given pointer of the node. Additionaly it filters out those
         * that only valid due to inherioted rules.
         * All participant nodes have to be loaded to the client
         * @function getOwnValidTargetTypes
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} path - the path/id of the node that hold the pointer rule 
         * (the source of the pointer).
         * @param {string} name - the name of the pointer to check.
         * @returns {string[]} - list of path/id of valid target meta-nodes.
         * @instance
         */
        function getOwnValidTargetTypes(path, name) {
            var node = _getNode(path),
                ownMeta;

            if (node) {
                ownMeta = state.core.getOwnJsonMeta(node);
                ownMeta.pointers = ownMeta.pointers || {};
                ownMeta.pointers[name] = ownMeta.pointers[name] || {};

                return ownMeta.pointers[name].items || [];
            }

            return [];
        }

        function _getValidTargetItems(path, name, ownOnly) {
            var node = _getNode(path),
                meta,
                paths,
                items = [],
                i;

            if (node) {
                meta = state.core.getPointerMeta(node, name);
                paths = ownOnly ? state.core.getOwnJsonMeta(node) : state.core.getJsonMeta(node);
                if (paths && paths.pointers && paths.pointers[name]) {
                    paths = paths.pointers[name].items || [];
                } else {
                    paths = [];
                }

                if (meta && paths.length > 0) {
                    delete meta.min;
                    delete meta.max;
                    for (i in meta) {
                        if (paths.indexOf(i) !== -1) {
                            items.push({
                                id: i,
                                min: meta[i].min === -1 ? undefined : meta[i].min,
                                max: meta[i].max === -1 ? undefined : meta[i].max
                            });
                        }
                    }

                    return items;
                }
            }

            return null;
        }

        /**
         * @description Identical to [getValidTargetTypes]{@link Client#getValidTargetTypes}.
         * @function getValidTargetItems
         * @memberOf Client
         * @instance
         */
        function getValidTargetItems(path, name) {
            return _getValidTargetItems(path, name, false);
        }

        /**
         * @description Identical to [getOwnValidTargetTypes]{@link Client#getOwnValidTargetTypes}.
         * @function getOwnValidTargetItems
         * @memberOf Client
         * @instance
         */
        function getOwnValidTargetItems(path, name) {
            return _getValidTargetItems(path, name, true);
        }

        /**
         * @description Checks if the node would be a valid child of the given parent.
         * All participant nodes have to be loaded to the client
         * @function getValidChildrenTypes
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} parentPath - the path/id of the parent node.
         * @param {string} path - the path/id of the node.
         * @returns {boolean} - true if the node would be a valid child of the parent, 
         * false otherwise (or if any of the nodes is missing).
         * @instance
         */
        function isValidChild(parentPath, path) {
            var node = _getNode(path),
                parentNode = _getNode(parentPath);

            if (node && parentNode) {
                return state.core.isValidChildOf(node, parentNode);
            }

            return false;
        }

        /**
         * @description Collects the meta node ids, that can be instantiated for a 
         * valid child of the given node.
         * All participant nodes have to be loaded to the client
         * @function getValidChildrenTypes
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} path - the path/id of the node.
         * @returns {string[]} - list of path/id of valid target meta-nodes.
         * @instance
         */
        function getValidChildrenTypes(path) {
            var node = _getNode(path);

            if (node) {
                return state.core.getValidChildrenPaths(node);
            }

            return [];
        }

        /**
         * @description Collects the names of the valid attributes of the node.
         * All participant nodes have to be loaded to the client
         * @function getValidAttributeNames
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} path - the path/id of the node.
         * @returns {string[]} - list of valid attribute names.
         * @instance
         */
        function getValidAttributeNames(path) {
            var node = _getNode(path);

            if (node) {
                return state.core.getValidAttributeNames(node);
            }

            return [];
        }

        /**
         * @description Collects the names of the valid attributes of the node.
         * Additionally, it filters out those names that are inherited for the node.
         * All participant nodes have to be loaded to the client
         * @function getOwnValidAttributeNames
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} path - the path/id of the node.
         * @returns {string[]} - list of valid attribute names.
         * @instance
         */
        function getOwnValidAttributeNames(path) {
            var node = _getNode(path);

            if (node) {
                return state.core.getOwnValidAttributeNames(node);
            }

            return [];
        }

        /**
         * @description Collects and returns the meta rules related to a pointer/set of the node.
         * All participant nodes have to be loaded to the client
         * @function getPointerMeta
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} path - the path/id of the node that hold the pointer rule 
         * (the source of the pointer).
         * @param {string} name - the name of the pointer/set.
         * @returns {object} - structured object of the rules related to the pointer/set.
         * @instance
         */
        function getPointerMeta(path, name) {
            var node = _getNode(path),
                meta,
                i,
                pointerMeta;

            if (node) {
                meta = state.core.getPointerMeta(node, name);

                if (meta) {
                    pointerMeta = {min: meta.min, max: meta.max, items: []};

                    for (i in meta) {
                        if (i !== 'min' && i !== 'max') {
                            pointerMeta.items.push({
                                id: i,
                                min: meta[i].min === -1 ? undefined : meta[i].min,
                                max: meta[i].max === -1 ? undefined : meta[i].max
                            });
                        }
                    }

                    return pointerMeta;
                }
            }

            return null;
        }

        /**
         * @description Collects and returns the meta rules related to an attribute of the node.
         * All participant nodes have to be loaded to the client
         * @function getAttributeSchema
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} path - the path/id of the node.
         * @param {string} name - the name of the attribute.
         * @returns {object} - structured collection of the rules of the attribute.
         * @instance
         */
        function getAttributeSchema(path, name) {
            var node = _getNode(path);

            if (node) {
                return state.core.getAttributeMeta(node, name);
            }

            return;
        }

        /**
         * @description Collect and returns a list of aspects defined for the node.
         * All participant nodes have to be loaded to the client
         * @function getMetaAspectNames
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} path - the path/id of the node.
         * @returns {string[]} - list of valid aspect names.
         * @instance
         */
        function getMetaAspectNames(path) {
            var node = _getNode(path);

            if (node) {
                return state.core.getValidAspectNames(node);
            }

            return [];
        }

        /**
         * @description Collect and returns a list of aspects defined for the node.
         * Additionally, it filters out those aspects that are inherited for the node.
         * All participant nodes have to be loaded to the client
         * @function getOwnMetaAspectNames
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} path - the path/id of the node.
         * @returns {string[]} - list of valid aspect names.
         * @instance
         */
        function getOwnMetaAspectNames(path) {
            var node = _getNode(path);

            if (node) {
                return state.core.getOwnValidAspectNames(node);
            }

            return [];
        }

        /**
         * @description Collects and returns the meta rules related to an aspect of the node.
         * All participant nodes have to be loaded to the client
         * @function getMetaAspect
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} path - the path/id of the node.
         * @param {string} name - the name of the aspect.
         * @returns {object} - structured collection of the rules of the aspect.
         * @instance
         */
        function getMetaAspect(path, name) {
            var node = _getNode(path),
                meta;

            if (node) {
                meta = state.core.getAspectMeta(node, name);

                if (meta) {
                    return {items: meta};
                }
            }

            return null;
        }

        /**
         * @description Checks if the node has meta rules of its own (not inherited).
         * All participant nodes have to be loaded to the client
         * @function hasOwnMetaRules
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} path - the path/id of the node.
         * @param {string} name - the name of the aspect.
         * @returns {boolean} - true if the node has some rule of its own, 
         * false if it only has inherited rules.
         * @instance
         */
        function hasOwnMetaRules(path) {
            var node = _getNode(path),
                ownMeta, key;

            if (node) {
                ownMeta = state.core.getOwnJsonMeta(node);

                //children
                if (ownMeta.children && ownMeta.children.items && ownMeta.children.items.length > 0) {
                    return true;
                }

                //pointers
                for (key in ownMeta.pointers || {}) {
                    return true;
                }

                //attributes
                for (key in ownMeta.attributes || {}) {
                    return true;
                }
                //aspects
                for (key in ownMeta.aspects || {}) {
                    return true;
                }

                //mixins
                if (ownMeta.mixins && ownMeta.mixins.length > 0) {
                    return true;
                }
            }

            return false;
        }

        /**
         * @description Collects and returns the meta rules related to containment of the node.
         * All participant nodes have to be loaded to the client
         * @see For reference check the correspondent 
         * Core function [getChildrenMeta]{@link Core#getChildrenMeta}
         * @function getChildrenMeta
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} path - the path/id of the node.
         * @returns {object} - structured collection of the rules of the containment.
         * @instance
         */
        function getChildrenMeta(path) {
            //the returned object structure is : {'min':0,'max':0,'items':[{'id':path,'min':0,'max':0},...]}
            var node = _getNode(path),
                meta, i,
                childrenMeta = {items: []};

            if (node) {
                meta = state.core.getChildrenMeta(node);
                if (meta) {
                    childrenMeta = {min: meta.min, max: meta.max, items: []};
                    for (i in meta) {
                        if (i !== 'min' && i !== 'max') {
                            childrenMeta.items.push({
                                id: i,
                                min: meta[i].min === -1 ? undefined : meta[i].min,
                                max: meta[i].max === -1 ? undefined : meta[i].max
                            });
                        }
                    }
                }

                return childrenMeta;
            }

            return null;
        }

        //FIXME: what is this?
        function getChildrenMetaAttribute(path/*, attrName*/) {
            var childrenMeta = getChildrenMeta(path);
            if (childrenMeta) {
                return childrenMeta.attrName;
            }
            return null;
        }

        /**
         * @description Collects and returns the list of containment rules of the node.
         * All participant nodes have to be loaded to the client
         * @function getValidChildrenItems
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} path - the path/id of the node.
         * @returns {object} - structured collection of children types of the 
         * containment with cardinality information.
         * @instance
         */
        function getValidChildrenItems(path) {
            var childrenMeta = getChildrenMeta(path);
            if (childrenMeta) {
                return childrenMeta.items;
            }
            return null;
        }

        /**
         * @description Collects and returns the list of containment rules of the node.
         * Additionally the list filters out elements that are inherited.
         * All participant nodes have to be loaded to the client
         * @function getOwnValidChildrenTypes
         * @memberOf Client
         * @deprecated The function provided in GMENode class should be used! 
         * (this one will be removed at the next major release)
         * @param {string} path - the path/id of the node.
         * @returns {object} - structured collection of children types of the 
         * containment with cardinality information.
         * @instance
         */
        function getOwnValidChildrenTypes(path) {
            var node = _getNode(path),
                ownMeta;

            if (node) {
                ownMeta = state.core.getOwnJsonMeta(node);

                if (ownMeta && ownMeta.children && ownMeta.children.items) {
                    return ownMeta.children.items;
                }
            }

            return [];
        }

        /**
         * @description Returns a client pattern that covers the given aspect of the node.
         * All participant nodes have to be loaded to the client
         * @function getAspectTerritoryPattern
         * @memberOf Client
         * @param {string} path - the path/id of the node.
         * @param {string} name - the name of the aspect.
         * @returns {object} - object representing the client territory
         * @instance
         */
        function getAspectTerritoryPattern(path, name) {
            var aspect = getMetaAspect(path, name);

            if (aspect !== null) {
                aspect.children = 1; //TODO now it is fixed, maybe we can change that in the future
                return aspect;
            }
            return null;
        }

        /**
         * @example
         *
         * var nodeCopies1 = client.copyNodes(['/4', '/3'], '');
         * var nodeCopies2 = client.copyNodes('/4', '/3'], '', 'Copied two nodes');
         *
         * @description Copies the given nodes into the parent 
         * (does not enforce meta-rules and requires all participating nodes
         * to be loaded in the client)
         * @see For reference check the correspondent 
         * Core function [copyNodes]{@link Core#copyNodes}
         * @function copyNodes
         * @memberOf Client
         * @param {string[]} paths - array of the ids/paths of the nodes to copy
         * @param {string} parentId - the id/path of the parent where the new copies should be created
         * @param {string} [msg] - optional commit message, if not supplied a default one with 
         * the function name and input
         * parameters will be used
         * @returns {GMENode[]|undefined} - the newly created nodes if all could be copied
         * @instance
         */
        function copyNodes(pathsToCopy, parentPath, msg) {
            var parentNode = _getNode(parentPath),
                copyResult;

            if (parentNode) {
                copyResult = _copyMultipleNodes(pathsToCopy, parentNode, true);

                if (copyResult instanceof Error) {
                    printCoreError(copyResult);
                    return;
                }

                if ((copyResult || []).length !== pathsToCopy.length) {
                    state.logger.error('not all nodes were available - denied -');
                    return;
                }

                saveRoot(msg);
                return copyResult;
            } else {
                state.logger.error('parent cannot be found - denied -');
            }
        }

        /**
         * @description Renames a pointer of the node.
         * Effectively, it moves the target of one pointer to another.
         * All participant nodes have to be loaded to the client
         * @see For reference check the correspondent 
         * Core function [renamePointer]{@link Core#renamePointer}
         * @function renamePointer
         * @memberOf Client
         * @param {string} path - the path/id of the node.
         * @param {string} oldName - the name of the current pointer.
         * @param {string} newName - the name of the new pointer.
         * @param {string} [msg] - optional commit message, if not supplied a default one with 
         * the function name and input
         * parameters will be used
         * @instance
         */
        function renamePointer(path, oldName, newName, msg) {
            var node = _getNode(path);

            if (node) {
                try {
                    state.core.renamePointer(node, oldName, newName);
                } catch (e) {
                    printCoreError(e);
                    return;
                }
                saveRoot(typeof msg === 'string' ? msg : 'renamePointer(' + path + ',' +
                    oldName + ',' + newName);
            }
        }

        /**
         * @description Renames an attribute of the node.
         * Effectively, it moves the value of one attribute to another.
         * All participant nodes have to be loaded to the client
         * @see For reference check the correspondent 
         * Core function [renameAttribute]{@link Core#renameAttribute}
         * @function renameAttribute
         * @memberOf Client
         * @param {string} path - the path/id of the node.
         * @param {string} oldName - the name of the current attribute.
         * @param {string} newName - the name of the new attribute.
         * @param {string} [msg] - optional commit message, if not supplied a default one with 
         * the function name and input
         * parameters will be used
         * @instance
         */
        function renameAttribute(path, oldName, newName, msg) {
            var node = _getNode(path);

            if (node) {
                try {
                    state.core.renameAttribute(node, oldName, newName);
                } catch (e) {
                    printCoreError(e);
                    return;
                }
                saveRoot(typeof msg === 'string' ? msg : 'renameAttribute(' + path + ',' +
                    oldName + ',' + newName);
            }
        }

        /**
         * @description Renames an registry of the node.
         * Effectively, it moves the value of one registry to another.
         * All participant nodes have to be loaded to the client
         * @see For reference check the correspondent 
         * Core function [renameRegistry]{@link Core#renameRegistry}
         * @function renameRegistry
         * @memberOf Client
         * @param {string} path - the path/id of the node.
         * @param {string} oldName - the name of the current registry.
         * @param {string} newName - the name of the new registry.
         * @param {string} [msg] - optional commit message, if not supplied a default one with 
         * the function name and input
         * parameters will be used
         * @instance
         */
        function renameRegistry(path, oldName, newName, msg) {
            var node = _getNode(path);

            if (node) {
                try {
                    state.core.renameRegistry(node, oldName, newName);
                } catch (e) {
                    printCoreError(e);
                    return;
                }
                saveRoot(typeof msg === 'string' ? msg : 'renameRegistry(' + path + ',' +
                    oldName + ',' + newName);
            }
        }

        /**
         * @description Renames a set of the node.
         * Effectively, it moves the members of one set to another.
         * All participant nodes have to be loaded to the client
         * @see For reference check the correspondent 
         * Core function [renameSet]{@link Core#renameSet}
         * @function renameSet
         * @memberOf Client
         * @param {string} path - the path/id of the node.
         * @param {string} oldName - the name of the current set.
         * @param {string} newName - the name of the new set.
         * @param {string} [msg] - optional commit message, if not supplied a default one with 
         * the function name and input
         * parameters will be used
         * @instance
         */
        function renameSet(path, oldName, newName, msg) {
            var node = _getNode(path);

            if (node) {
                try {
                    state.core.renameSet(node, oldName, newName);
                } catch (e) {
                    printCoreError(e);
                    return;
                }
                saveRoot(typeof msg === 'string' ? msg : 'renameSet(' + path + ',' +
                    oldName + ',' + newName);
            }
        }

        /**
         * @description Moves an aspect target rule to a new aspect.
         * All participant nodes have to be loaded to the client
         * @see For reference check the correspondent 
         * Core function [moveAspectMetaTarget]{@link Core#moveAspectMetaTarget}
         * @function moveAspectMetaTarget
         * @memberOf Client
         * @param {string} path - the path/id of the node.
         * @param {string} targetPath - the path/id of the target to be moved.
         * @param {string} oldName - the name of the current aspect.
         * @param {string} newName - the name of the new aspect.
         * @param {string} [msg] - optional commit message, if not supplied a default one with 
         * the function name and input
         * parameters will be used
         * @instance
         */
        function moveAspectMetaTarget(path, targetPath, oldName, newName, msg) {
            var node = _getNode(path),
                targetNode = _getNode(targetPath);

            if (node && targetNode) {
                try {
                    state.core.moveAspectMetaTarget(node, targetNode, oldName, newName);
                } catch (err) {
                    printCoreError(err);
                    return;
                }

                saveRoot(typeof msg === 'string' ? msg : 'moveAspectMetaTarget(' + path + ', ' + targetPath + ',' +
                    oldName + ',' + newName);
            }
        }

        /**
         * @description Moves a set member to a new set.
         * All participant nodes have to be loaded to the client
         * @see For reference check the correspondent 
         * Core function [moveMember]{@link Core#moveMember}
         * @function moveMember
         * @memberOf Client
         * @param {string} path - the path/id of the node.
         * @param {string} memberPath - the path/id of the member to be moved.
         * @param {string} oldSetName - the name of the current set.
         * @param {string} newSetName - the name of the new set.
         * @param {string} [msg] - optional commit message, if not supplied a default one with 
         * the function name and input
         * parameters will be used
         * @instance
         */
        function moveMember(path, memberPath, oldSetName, newSetName, msg) {
            var node = _getNode(path);

            if (node) {
                try {
                    state.core.moveMember(node, memberPath, oldSetName, newSetName);
                } catch (e) {
                    printCoreError(e);
                    return;
                }
                saveRoot(typeof msg === 'string' ? msg : 'moveMember(' + path + ', ' + memberPath + ',' +
                    oldSetName + ',' + newSetName);
            }
        }

        /**
         * @description Renames an attribute meta rule.
         * All participant nodes have to be loaded to the client
         * @see For reference check the correspondent 
         * Core function [renameAttributeMeta]{@link Core#renameAttributeMeta}
         * @function renameAttributeMeta
         * @memberOf Client
         * @param {string} path - the path/id of the node.
         * @param {string} oldName - the name of the current attribute.
         * @param {string} newName - the name of the new attribute.
         * @param {string} [msg] - optional commit message, if not supplied a default one with 
         * the function name and input
         * parameters will be used
         * @instance
         */
        function renameAttributeMeta(path, oldName, newName, msg) {
            var node = _getNode(path);

            if (node) {
                try {
                    state.core.renameAttributeMeta(node, oldName, newName);
                } catch (e) {
                    printCoreError(e);
                    return;
                }
                saveRoot(typeof msg === 'string' ? msg : 'renameAttributeMeta(' + path + ', ' + oldName + ',' +
                    newName + ')');
            }
        }

        return {
            setAttribute: setAttribute,
            setAttributes: function () {
                _logDeprecated('setAttributes', 'setAttribute');
                setAttribute.apply(null, arguments);
            },

            delAttribute: delAttribute,
            delAttributes: function () {
                _logDeprecated('delAttributes', 'delAttribute');
                delAttribute.apply(null, arguments);
            },
            setRegistry: setRegistry,
            delRegistry: delRegistry,

            copyNode: copyNode,
            copyNodes: copyNodes,
            copyMoreNodes: copyMoreNodes,
            moveNode: moveNode,
            moveMoreNodes: moveMoreNodes,
            deleteNode: deleteNode,
            deleteNodes: deleteNodes,
            delMoreNodes: function () {
                _logDeprecated('delMoreNodes', 'deleteNodes');
                deleteNodes.apply(null, arguments);
            },
            createNode: createNode,
            createChild: function (parameters, msg) {
                return createNode(parameters, {
                    registry: {
                        position: parameters.position
                    }
                }, msg);
            },
            createChildren: createChildren,

            setPointer: setPointer,
            makePointer: function () {
                _logDeprecated('makePointer', 'setPointer');
                setPointer.apply(null, arguments);
            },
            delPointer: delPointer,
            deletePointer: delPointer,

            addMember: addMember,
            removeMember: removeMember,
            moveMember: moveMember,
            setMemberAttribute: setMemberAttribute,
            delMemberAttribute: delMemberAttribute,
            setMemberRegistry: setMemberRegistry,
            delMemberRegistry: delMemberRegistry,
            setSetAttribute: setSetAttribute,
            delSetAttribute: delSetAttribute,
            setSetRegistry: setSetRegistry,
            delSetRegistry: delSetRegistry,
            createSet: createSet,
            delSet: delSet,
            deleteSet: delSet,

            setBase: setBase,
            delBase: delBase,

            // --- Meta ---
            setMeta: setMeta,
            clearMetaRules: clearMetaRules,

            // containment
            setChildrenMeta: setChildrenMeta,
            setChildrenMetaAttribute: setChildrenMetaAttribute,
            setChildMeta: setChildMeta,
            updateValidChildrenItem: function (path, newTypeObj, msg) {
                _logDeprecated('updateValidChildrenItem(path, newTypeObj, msg)',
                    'setChildMeta(path, childPath, min, max, msg)');
                newTypeObj = newTypeObj || {};
                setChildMeta(path, newTypeObj.id, newTypeObj.min, newTypeObj.max, msg);
            },

            delChildMeta: delChildMeta,
            removeValidChildrenItem: function () {
                _logDeprecated('removeValidChildrenItem', 'delChildMeta');
                delChildMeta.apply(null, arguments);
            },

            // attribute
            setAttributeMeta: setAttributeMeta,
            setAttributeSchema: function () {
                _logDeprecated('setAttributeSchema', 'setAttributeMeta');
                setAttributeMeta.apply(null, arguments);
            },
            delAttributeMeta: delAttributeMeta,
            removeAttributeSchema: function () {
                _logDeprecated('removeAttributeSchema', 'delAttributeMeta');
                delAttributeMeta.apply(null, arguments);
            },
            renameAttributeMeta: renameAttributeMeta,

            // pointer
            setPointerMeta: setPointerMeta,
            setPointerMetaTarget: setPointerMetaTarget,
            movePointerMetaTarget: movePointerMetaTarget,
            updateValidTargetItem: function (path, name, targetObj, msg) {
                _logDeprecated('updateValidTargetItem(path, name, targetObj, msg)',
                    'setPointerMetaTarget(path, name, targetPath, childPath, min, max, msg)');
                targetObj = targetObj || {};
                setPointerMetaTarget(path, name, targetObj.id, targetObj.min, targetObj.max, msg);
            },

            delPointerMetaTarget: delPointerMetaTarget,
            removeValidTargetItem: function () {
                _logDeprecated('removeValidTargetItem', 'delPointerMetaTarget');
                delPointerMetaTarget.apply(null, arguments);
            },
            delPointerMeta: delPointerMeta,
            deleteMetaPointer: function () {
                _logDeprecated('deleteMetaPointer', 'delPointerMeta');
                delPointerMeta.apply(null, arguments);
            },

            // aspect
            setAspectMetaTarget: setAspectMetaTarget,
            setAspectMetaTargets: setAspectMetaTargets,
            moveAspectMetaTarget: moveAspectMetaTarget,
            setMetaAspect: function () {
                _logDeprecated('setMetaAspect', 'setAspectMetaTargets');
                setAspectMetaTargets.apply(null, arguments);
            },
            delAspectMetaTarget: delAspectMetaTarget,
            delAspectMeta: delAspectMeta,
            deleteMetaAspect: function () {
                _logDeprecated('deleteMetaAspect', 'delAspectMeta');
                delAspectMeta.apply(null, arguments);
            },

            // mixin
            addMixin: addMixin,
            delMixin: delMixin,

            // renames
            renamePointer: renamePointer,
            renameAttribute: renameAttribute,
            renameRegistry: renameRegistry,
            renameSet: renameSet,

            // Deprecated meta-getters
            // TODO: These should be moved to Util/GMEConcepts or removed.
            getMeta: function () {
                _logDeprecated('getMeta(path)', 'getJsonMeta()', true);
                return getMeta.apply(null, arguments);
            },
            isTypeOf: function () {
                //_logDeprecated('isTypeOf(path, typePath)', 'isTypeOf(typePath)', true);
                return isTypeOf.apply(null, arguments);
            },
            isValidTarget: function () {
                _logDeprecated('isValidTarget(path, name, targetPath)', 'isValidTargetOf(sourcePath, name)', true);
                return isValidTarget.apply(null, arguments);
            },
            filterValidTarget: function () {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return filterValidTarget.apply(null, arguments);
            },
            getValidTargetTypes: function () {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getValidTargetTypes.apply(null, arguments);
            },
            getOwnValidTargetTypes: function () {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getOwnValidTargetTypes.apply(null, arguments);
            },
            getValidTargetItems: function () {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getValidTargetItems.apply(null, arguments);
            },
            getOwnValidTargetItems: function () {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getOwnValidTargetItems.apply(null, arguments);
            },
            getPointerMeta: function () {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getPointerMeta.apply(null, arguments);
            },
            isValidChild: function () {
                _logDeprecated('isValidChild(path, childPath)', 'isValidChildOf(parentPath)', true);
                return isValidChild.apply(null, arguments);
            },
            getValidChildrenTypes: function () {
                _logDeprecated('getValidChildrenTypes(path)', 'getValidChildrenIds()', true);
                return getValidChildrenTypes.apply(null, arguments);
            },
            getValidAttributeNames: function () {
                _logDeprecated('getValidAttributeNames(path)', 'getValidAttributeNames()', true);
                return getValidAttributeNames.apply(null, arguments);
            },
            getOwnValidAttributeNames: function () {
                _logDeprecated('getOwnValidAttributeNames(path)', 'getOwnValidAttributeNames()', true);
                return getOwnValidAttributeNames.apply(null, arguments);
            },
            getAttributeSchema: function () {
                _logDeprecated('getAttributeSchema(path, name)', 'getAttributeMeta(name)', true);
                return getAttributeSchema.apply(null, arguments);
            },
            getMetaAspectNames: function () {
                _logDeprecated('getMetaAspectNames(path)', 'getValidAspectNames()', true);
                return getMetaAspectNames.apply(null, arguments);
            },
            getOwnMetaAspectNames: function () {
                _logDeprecated('getOwnMetaAspectNames(path)', 'getOwnValidAspectNames()', true);
                return getOwnMetaAspectNames.apply(null, arguments);
            },
            getMetaAspect: function () {
                _logDeprecated('getMetaAspect(path, name)', 'getAspectMeta(name)', true,
                    ' Returned value is of different structure! {items: meta} vs meta');
                return getMetaAspect.apply(null, arguments);
            },
            hasOwnMetaRules: function () {
                // TODO: Should we add a method on the core??
                return hasOwnMetaRules.apply(null, arguments);
            },
            getChildrenMeta: function () {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getChildrenMeta.apply(null, arguments);
            },
            getChildrenMetaAttribute: function () {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getChildrenMetaAttribute.apply(null, arguments);
            },
            getValidChildrenItems: function () {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getValidChildrenItems.apply(null, arguments);
            },
            getOwnValidChildrenTypes: function () {
                // TODO: Should we add a method on the core similar to getValidChildrenTypes?
                return getOwnValidChildrenTypes.apply(null, arguments);
            },
            getAspectTerritoryPattern: function () {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getAspectTerritoryPattern.apply(null, arguments);
            }
        };
    }

    return gmeNodeSetter;
});

/*globals define, console*/
/*eslint-env browser*/

/**
 * @author kecso / https://github.com/kecso
 */
define('client/libraries',['common/Constants'], function (CONSTANTS) {
    'use strict';
    function gmeLibraries(logger, state, storage, saveRoot) {

        function getLibraryNames() {
            if (state.core && state.nodes[CONSTANTS.PROJECT_ROOT_ID] &&
                typeof state.nodes[CONSTANTS.PROJECT_ROOT_ID].node === 'object') {
                return state.core.getLibraryNames(state.nodes[CONSTANTS.PROJECT_ROOT_ID].node);
            }

            return [];
        }

        function getLibraryInfo(libraryName) {
            if (state.core && state.nodes[CONSTANTS.PROJECT_ROOT_ID] &&
                typeof state.nodes[CONSTANTS.PROJECT_ROOT_ID].node === 'object') {
                return state.core.getLibraryInfo(state.nodes[CONSTANTS.PROJECT_ROOT_ID].node, libraryName) || null;
            }

            return null;
        }

        function removeLibrary(libraryName) {
            state.core.removeLibrary(state.nodes[CONSTANTS.PROJECT_ROOT_ID].node, libraryName);
            saveRoot('removeLibrary(' + libraryName + ')');
        }

        function renameLibrary(oldName, newName) {
            state.core.renameLibrary(state.nodes[CONSTANTS.PROJECT_ROOT_ID].node, oldName, newName);
            saveRoot('renameLibrary(' + oldName + ',' + newName + ')');
        }

        function openLibraryOriginInNewWindow(libraryRootId, followBranch) {
            // FIXME: This does not belong here (the client knows nothing about the URL serialization..
            //eslint-disable-next-line no-console
            console.warn('client.openLibraryOriginInNewWindow is deprecated use ' +
                'src/client/Utils/LibraryManager.js instead.');
            var address,
                info;
            if (!state.nodes[libraryRootId]) {
                logger.warn('only cached libraries can be followed!');
                return;
            }
            info = getLibraryInfo(state.core.getFullyQualifiedName(state.nodes[libraryRootId].node));

            if (!info) {
                logger.warn('the library has no valid info');
                return;
            }

            if (!info.projectId) {
                logger.warn('the library has only partial info');
                return;
            }

            address = window.location.origin + '/?project=' + encodeURIComponent(info.projectId);

            if (info.branchName && followBranch) {
                address += '&branch=' + encodeURIComponent(info.branchName);
            } else if (info.commitHash) {
                address += '&commit=' + encodeURIComponent(info.commitHash);
            }

            window.open(address, '_blank');
            window.focus();

        }

        return {
            getLibraryNames: getLibraryNames,
            removeLibrary: removeLibrary,
            renameLibrary: renameLibrary,
            getLibraryInfo: getLibraryInfo,
            openLibraryOriginInNewWindow: openLibraryOriginInNewWindow
        };
    }

    return gmeLibraries;
});
/*global define*/
/*eslint-env browser*/
/**
 * @author kecso / https://github.com/kecso
 * @author pmeijer / https://github.com/pmeijer
 */

define('client/gmeServerRequests',['common/Constants', 'common/regexp'], function (CONSTANTS, REGEXP) {
    'use strict';

    function gmeServerRequest(client, logger, state, storage) {

        function importProjectFromFile(projectName, branchName, blobHash, ownerId, url, callback) {
            var parameters = {
                command: CONSTANTS.SERVER_WORKER_REQUESTS.IMPORT_PROJECT_FROM_FILE,
                projectName: projectName,
                blobHash: blobHash,
                branchName: branchName,
                ownerId: ownerId,
                url: url
            };

            logger.debug('creating project from package', parameters);

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }
                callback(err, result);
            });
        }

        function updateProjectFromFile(projectId, branchName, blobHashOrSeedName, callback) {
            var parameters = {
                command: CONSTANTS.SERVER_WORKER_REQUESTS.UPDATE_PROJECT_FROM_FILE,
                projectId: projectId,
                branchName: branchName
            };

            logger.debug('updating project from package', parameters);

            if (REGEXP.BLOB_HASH.test(blobHashOrSeedName)) {
                parameters.blobHash = blobHashOrSeedName;
            } else {
                parameters.seedName = blobHashOrSeedName;
            }

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }
                callback(err, result);
            });
        }

        function addLibrary(name, blobHashLibraryInfoOrSeedName, callback) {
            var parameters = {
                command: CONSTANTS.SERVER_WORKER_REQUESTS.ADD_LIBRARY,
                projectId: state.project.projectId,
                libraryName: name,
                branchName: state.branchName
            };

            if (typeof blobHashLibraryInfoOrSeedName === 'string') {
                if (REGEXP.BLOB_HASH.test(blobHashLibraryInfoOrSeedName)) {
                    parameters.blobHash = blobHashLibraryInfoOrSeedName;
                } else {
                    parameters.seed = blobHashLibraryInfoOrSeedName;
                }
            } else {
                parameters.libraryInfo = blobHashLibraryInfoOrSeedName;
            }

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }
                callback(err, result);
            });
        }

        function updateLibrary(name, blobHashLibraryInfoOrSeedName, callback) {
            var parameters = {
                command: CONSTANTS.SERVER_WORKER_REQUESTS.UPDATE_LIBRARY,
                projectId: state.project.projectId,
                libraryName: name,
                branchName: state.branchName
            };

            if (typeof blobHashLibraryInfoOrSeedName === 'string') {
                if (REGEXP.BLOB_HASH.test(blobHashLibraryInfoOrSeedName)) {
                    parameters.blobHash = blobHashLibraryInfoOrSeedName;
                } else {
                    parameters.seed = blobHashLibraryInfoOrSeedName;
                }
            } else {
                parameters.libraryInfo = blobHashLibraryInfoOrSeedName;
            }

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }
                callback(err, result);
            });
        }

        function renameConcept(nodePath, type, oldName, newName, callback) {
            var parameters = {
                command: CONSTANTS.SERVER_WORKER_REQUESTS.RENAME_CONCEPT,
                projectId: state.project.projectId,
                nodePath: nodePath,
                type: type,
                oldName: oldName,
                newName: newName,
                branchName: state.branchName
            };

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }
                callback(err, result);
            });
        }

        function renameAttributeDefinition(nodePath, meta, oldName, newName, callback) {
            var parameters = {
                command: CONSTANTS.SERVER_WORKER_REQUESTS.CHANGE_ATTRIBUTE_META,
                projectId: state.project.projectId,
                nodePath: nodePath,
                meta: meta,
                oldName: oldName,
                newName: newName,
                branchName: state.branchName
            };

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }
                callback(err, result);
            });
        }

        function renamePointerTargetDefinition(nodePath, targetPath, oldName, newName, isSet, callback) {
            var parameters = {
                command: CONSTANTS.SERVER_WORKER_REQUESTS.RENAME_META_POINTER_TARGET,
                projectId: state.project.projectId,
                nodePath: nodePath,
                targetPath: targetPath,
                type: isSet ? 'set' : 'pointer',
                oldName: oldName,
                newName: newName,
                branchName: state.branchName
            };

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }
                callback(err, result);
            });
        }

        function renameAspectDefinition(nodePath, meta, oldName, newName, callback) {
            var parameters = {
                command: CONSTANTS.SERVER_WORKER_REQUESTS.CHANGE_ASPECT_META,
                projectId: state.project.projectId,
                nodePath: nodePath,
                meta: meta,
                type: 'aspect',
                oldName: oldName,
                newName: newName,
                branchName: state.branchName
            };

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }
                callback(err, result);
            });
        }

        function removeMetaRule(nodePath, name, type, targetPath, callback) {
            var parameters = {
                command: CONSTANTS.SERVER_WORKER_REQUESTS.REMOVE_META_RULE,
                projectId: state.project.projectId,
                nodePath: nodePath,
                type: type,
                name: name,
                targetPath: targetPath,
                branchName: state.branchName
            };

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }
                callback(err, result);
            });
        }

        //meta rules checking
        /**
         *
         * @param {string[]} nodePaths - Paths to nodes of which to check.
         * @param includeChildren
         * @param callback
         */
        function checkMetaRules(nodePaths, includeChildren, callback) {
            var parameters = {
                command: CONSTANTS.SERVER_WORKER_REQUESTS.CHECK_CONSTRAINTS,
                checkType: 'META', //TODO this should come from a constant
                includeChildren: includeChildren,
                nodePaths: nodePaths,
                commitHash: state.commitHash,
                projectId: state.project.projectId
            };

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }

                if (result) {
                    client.dispatchEvent(client.CONSTANTS.META_RULES_RESULT, result);
                } else {
                    client.notifyUser({
                        severity: 'error',
                        message: 'Evaluating Meta rules failed with error.'
                    });
                }

                if (callback) {
                    callback(err, result);
                }
            });
        }

        /**
         *
         * @param {string[]} nodePaths - Paths to nodes of which to check.
         * @param {boolean} includeChildren - If true will recursively check the children of the nodes to check.
         * @param {function(Error, Object)} callback
         */
        function checkCustomConstraints(nodePaths, includeChildren, callback) {
            var parameters = {
                command: CONSTANTS.SERVER_WORKER_REQUESTS.CHECK_CONSTRAINTS,
                checkType: 'CUSTOM', //TODO this should come from a constant
                includeChildren: includeChildren,
                nodePaths: nodePaths,
                commitHash: state.commitHash,
                projectId: state.project.projectId
            };

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }

                if (result) {
                    client.dispatchEvent(client.CONSTANTS.CONSTRAINT_RESULT, result);
                } else {
                    client.notifyUser({
                        severity: 'error',
                        message: 'Evaluating custom constraints failed with error.'
                    });
                }

                if (callback) {
                    callback(err, result);
                }
            });
        }

        //seed
        function seedProject(parameters, callback) {
            logger.debug('seeding project', parameters);
            parameters.command = CONSTANTS.SERVER_WORKER_REQUESTS.SEED_PROJECT;
            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }
                callback(err, result);
            });
        }

        //automerge
        function autoMerge(projectId, mine, theirs, callback) {
            var parameters = {
                command: CONSTANTS.SERVER_WORKER_REQUESTS.AUTO_MERGE,
                projectId: projectId,
                mine: mine,
                theirs: theirs
            };

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error('autoMerge failed with error', err);
                    callback(err);
                } else {
                    callback(null, result);
                }
            });
        }

        function resolve(mergeResult, callback) {
            var command = {
                command: CONSTANTS.SERVER_WORKER_REQUESTS.RESOLVE,
                partial: mergeResult
            };

            storage.simpleRequest(command, function (err, result) {
                if (err) {
                    logger.error('resolve failed with error', err);
                    callback(err);
                } else {
                    callback(null, result);
                }
            });
        }

        //package save
        function exportProjectToFile(projectId, branchName, commitHash, withAssets, callback) {
            var parameters = {
                command: CONSTANTS.SERVER_WORKER_REQUESTS.EXPORT_PROJECT_TO_FILE,
                projectId: projectId,
                branchName: branchName,
                commitHash: commitHash,
                withAssets: withAssets
            };

            logger.debug('exportProjectToFile, parameters', parameters);
            if (parameters.projectId && (parameters.branchName || commitHash)) {
                storage.simpleRequest(parameters, function (err, result) {
                    if (err && !result) {
                        logger.error('exportProjectToFile failed with error', err);
                        callback(err);
                    } else {
                        callback(err, result);
                    }
                });
            } else {
                callback(new Error('invalid parameters!'));
            }
        }

        function exportSelectionToFile(projectId, commitHash, selectedIds, withAssets, callback) {
            var parameters = {
                command: CONSTANTS.SERVER_WORKER_REQUESTS.EXPORT_SELECTION_TO_FILE,
                projectId: projectId,
                commitHash: commitHash,
                withAssets: withAssets,
                paths: selectedIds
            };

            logger.debug('exportSelectionToFile, parameters', parameters);
            if (parameters.projectId && commitHash && selectedIds && selectedIds.length > 0) {
                storage.simpleRequest(parameters, function (err, result) {
                    if (err && !result) {
                        logger.error('exportSelectionToFile failed with error', err);
                        callback(err);
                    } else {
                        callback(err, result);
                    }
                });
            } else {
                callback(new Error('invalid parameters!'));
            }
        }

        function importSelectionFromFile(projectId, branchName, parentId, blobHash, callback) {
            var parameters = {
                command: CONSTANTS.SERVER_WORKER_REQUESTS.IMPORT_SELECTION_FROM_FILE,
                projectId: projectId,
                blobHash: blobHash,
                parentPath: parentId,
                branchName: branchName
            };

            logger.debug('import selection from package', parameters);

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }
                callback(err, result);
            });
        }

        return {
            workerRequests: {
                importProjectFromFile: importProjectFromFile,
                updateProjectFromFile: updateProjectFromFile,
                addLibrary: addLibrary,
                updateLibrary: updateLibrary,
                renameConcept: renameConcept,
                renameAttributeDefinition: renameAttributeDefinition,
                renamePointerTargetDefinition: renamePointerTargetDefinition,
                renameAspectDefinition: renameAspectDefinition,
                removeMetaRule: removeMetaRule,
                checkMetaRules: checkMetaRules,
                checkCustomConstraints: checkCustomConstraints,
                seedProject: seedProject,
                autoMerge: autoMerge,
                resolve: resolve,
                exportProjectToFile: exportProjectToFile,
                exportSelectionToFile: exportSelectionToFile,
                importSelectionFromFile: importSelectionFromFile
            },

            // To keep the client API intact we still provide the old functions directly as well
            importProjectFromFile: importProjectFromFile,
            updateProjectFromFile: updateProjectFromFile,
            addLibrary: addLibrary,
            updateLibrary: updateLibrary,
            checkMetaRules: checkMetaRules,
            checkCustomConstraints: checkCustomConstraints,
            seedProject: seedProject,
            autoMerge: autoMerge,
            resolve: resolve,
            exportProjectToFile: exportProjectToFile,
            exportSelectionToFile: exportSelectionToFile,
            importSelectionFromFile: importSelectionFromFile
        };
    }

    return gmeServerRequest;
});
/*globals define*/
/*eslint-env node, browser*/

/**
 * Client module for accessing the blob.
 *
 * @author lattmann / https://github.com/lattmann
 */

define('blob/BlobConfig',[], function () {
    'use strict';
    var BlobConfig = {
        hashMethod: 'sha1', // TODO: in the future we may switch to sha512
        hashRegex: new RegExp('^[0-9a-f]{40}$')
    };

    return BlobConfig;
});
/*globals define*/
/*eslint-env node, browser*/

/**
 * Client module for accessing the blob.
 *
 * @author lattmann / https://github.com/lattmann
 */

define('blob/BlobMetadata',['blob/BlobConfig'], function (BlobConfig) {
    'use strict';

    /**
     * Initializes a new instance of BlobMetadata
     * @param {object} metadata - A serialized metadata object.
     * @param {string} metadata.name
     * @param {string|Object} metadata.content
     * @param {number} [metadata.size=0]
     * @param {BlobMetadata.CONTENT_TYPES} [metadata.contentType=BlobMetadata.CONTENT_TYPES.OBJECT]
     * @param {string} [metadata.mime='']
     * @param {boolean} [metadata.isPublic=false]
     * @param {string[]} [metadata.tags=[]]
     * @constructor
     * @alias BlobMetadata
     */
    var BlobMetadata = function (metadata) {
        var key;
        if (metadata) {
            this.name = metadata.name;
            this.size = metadata.size || 0;
            this.mime = metadata.mime || '';
            this.isPublic = metadata.isPublic || false;
            this.tags = metadata.tags || [];
            this.content = metadata.content;
            this.contentType = metadata.contentType || BlobMetadata.CONTENT_TYPES.OBJECT;
            if (this.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {
                for (key in this.content) {
                    if (this.content.hasOwnProperty(key)) {
                        if (BlobConfig.hashRegex.test(this.content[key].content) === false) {
                            throw new Error('BlobMetadata is malformed: hash \'' + this.content[key].content +
                                '\'is invalid');
                        }
                    }
                }
            }
        } else {
            throw new Error('metadata parameter is not defined');
        }
    };

    /**
     * Type of the metadata
     * @type {{OBJECT: string, COMPLEX: string, SOFT_LINK: string}}
     */
    BlobMetadata.CONTENT_TYPES = {
        OBJECT: 'object',
        COMPLEX: 'complex',
        SOFT_LINK: 'softLink'
    };

    /**
     * Serializes the metadata to a JSON object.
     * @returns {{
     *  name: string,
     *  size: number,
     *  mime: string,
     *  tags: Array.<string>,
     *  content: (string|Object),
     *  contentType: string}}
     */
    BlobMetadata.prototype.serialize = function () {
        var metadata = {
            name: this.name,
            size: this.size,
            mime: this.mime,
            isPublic: this.isPublic,
            tags: this.tags,
            content: this.content,
            contentType: this.contentType
        };

        metadata.tags.sort();

        if (this.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {
            // override on  purpose to normalize content
            metadata.content = {};
            var fnames = Object.keys(this.content);
            fnames.sort();

            for (var j = 0; j < fnames.length; j += 1) {
                metadata.content[fnames[j]] = this.content[fnames[j]];
            }
        }

        return metadata;
    };

    return BlobMetadata;
});

/*globals define*/
/*eslint-env node, browser*/

/**
 * @author lattmann / https://github.com/lattmann
 */

define('blob/Artifact',[
    'blob/BlobMetadata',
    'blob/BlobConfig',
    'common/core/tasync',
    'q'
], function (BlobMetadata, BlobConfig, tasync, Q) {
    'use strict';

    /**
     * Creates a new instance of artifact, i.e. complex object, in memory. This object can be saved in the blob-storage
     * on the server and later retrieved with its metadata hash.
     * @param {string} name Artifact's name without extension
     * @param {BlobClient} blobClient
     * @param {BlobMetadata} descriptor
     * @constructor
     * @alias Artifact
     */
    var Artifact = function (name, blobClient, descriptor) {
        this.name = name;
        this.blobClient = blobClient;
        this.blobClientPutFile = tasync.unwrap(tasync.throttle(tasync.wrap(blobClient.putFile), 5));
        this.blobClientGetMetadata = tasync.unwrap(tasync.throttle(tasync.wrap(blobClient.getMetadata), 5));
        // TODO: use BlobMetadata class here
        this.descriptor = descriptor || {
            name: name + '.zip',
            size: 0,
            mime: 'application/zip',
            content: {},
            contentType: 'complex'
        }; // name and hash pairs
    };

    /**
     * Adds content to the artifact as a file.
     * @param {string} name - filename
     * @param {Blob} content - File object or Blob.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string} <b>metadataHash</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    Artifact.prototype.addFile = function (name, content, callback) {
        var self = this,
            filename = name.substring(name.lastIndexOf('/') + 1),
            deferred = Q.defer();

        self.blobClientPutFile.call(self.blobClient, filename, content, function (err, metadataHash) {
            if (err) {
                deferred.reject(err);
                return;
            }

            self.addObjectHash(name, metadataHash, function (err, metadataHash) {
                if (err) {
                    deferred.reject(err);
                    return;
                }

                deferred.resolve(metadataHash);
            });
        });

        return deferred.promise.nodeify(callback);
    };

    /**
     * Adds files as soft-link.
     * @param {string} name - filename.
     * @param {Blob} content - File object or Blob.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string} <b>metadataHash</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    Artifact.prototype.addFileAsSoftLink = function (name, content, callback) {
        var deferred = Q.defer(),
            self = this,
            filename = name.substring(name.lastIndexOf('/') + 1);

        self.blobClientPutFile.call(self.blobClient, filename, content,
            function (err, metadataHash) {
                if (err) {
                    deferred.reject(err);
                    return;
                }
                var size;
                if (content.size !== undefined) {
                    size = content.size;
                }
                if (content.length !== undefined) {
                    size = content.length;
                }

                self.addMetadataHash(name, metadataHash, size)
                    .then(deferred.resolve)
                    .catch(deferred.reject);
            });

        return deferred.promise.nodeify(callback);
    };

    /**
     * Adds a hash to the artifact using the given file path.
     * @param {string} name - Path to the file in the artifact. Note: 'a/b/c.txt'
     * @param {string} metadataHash - Metadata hash that has to be added.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string} <b>hash</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    Artifact.prototype.addObjectHash = function (name, metadataHash, callback) {
        var self = this,
            deferred = Q.defer();

        if (BlobConfig.hashRegex.test(metadataHash) === false) {
            deferred.reject('Blob hash is invalid');
        } else {
            self.blobClientGetMetadata.call(self.blobClient, metadataHash, function (err, metadata) {
                if (err) {
                    deferred.reject(err);
                    return;
                }

                if (self.descriptor.content.hasOwnProperty(name)) {
                    deferred.reject(new Error('Another content with the same name was already added. ' +
                        JSON.stringify(self.descriptor.content[name])));

                } else {
                    self.descriptor.size += metadata.size;

                    self.descriptor.content[name] = {
                        content: metadata.content,
                        contentType: BlobMetadata.CONTENT_TYPES.OBJECT
                    };
                    deferred.resolve(metadataHash);
                }
            });
        }

        return deferred.promise.nodeify(callback);
    };

    /**
     * Adds a hash to the artifact using the given file path.
     * @param {string} name - Path to the file in the artifact. Note: 'a/b/c.txt'
     * @param {string} metadataHash - Metadata hash that has to be added.
     * @param {number} [size] - Size of the referenced blob.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string} <b>hash</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    Artifact.prototype.addMetadataHash = function (name, metadataHash, size, callback) {
        var self = this,
            deferred = Q.defer(),
            addMetadata = function (size) {
                if (self.descriptor.content.hasOwnProperty(name)) {
                    deferred.reject(new Error('Another content with the same name was already added. ' +
                        JSON.stringify(self.descriptor.content[name])));

                } else {
                    self.descriptor.size += size;

                    self.descriptor.content[name] = {
                        content: metadataHash,
                        contentType: BlobMetadata.CONTENT_TYPES.SOFT_LINK
                    };
                    deferred.resolve(metadataHash);
                }
            };

        if (typeof size === 'function') {
            callback = size;
            size = undefined;
        }

        if (BlobConfig.hashRegex.test(metadataHash) === false) {
            deferred.reject(new Error('Blob hash is invalid'));
        } else if (size === undefined) {
            self.blobClientGetMetadata.call(self.blobClient, metadataHash, function (err, metadata) {
                if (err) {
                    deferred.reject(err);
                    return;
                }
                addMetadata(metadata.size);
            });
        } else {
            addMetadata(size);
        }

        return deferred.promise.nodeify(callback);
    };

    /**
     * Adds multiple files.
     * @param {Object.<string, Blob>} files files to add
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string[]} <b>metadataHashes</b>.<br>
     * On error the promise will be rejected with {@link Error|string} <b>error</b>.
     */
    Artifact.prototype.addFiles = function (files, callback) {
        var self = this,
            fileNames = Object.keys(files);

        return Q.all(fileNames.map(function (fileName) {
            return self.addFile(fileName, files[fileName]);
        })).nodeify(callback);
    };

    /**
     * Adds multiple files as soft-links.
     * @param {Object.<string, Blob>} files files to add
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string[]} <b>metadataHashes</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    Artifact.prototype.addFilesAsSoftLinks = function (files, callback) {
        var self = this,
            fileNames = Object.keys(files);

        return Q.all(fileNames.map(function (fileName) {
            return self.addFileAsSoftLink(fileName, files[fileName]);
        })).nodeify(callback);
    };

    /**
     * Adds hashes to the artifact using the given file paths.
     * @param {object.<string, string>} metadataHashes - Keys are file paths and values metadata hashes.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string[]} <b>hashes</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    Artifact.prototype.addObjectHashes = function (metadataHashes, callback) {
        var self = this,
            fileNames = Object.keys(metadataHashes);

        return Q.all(fileNames.map(function (fileName) {
            return self.addObjectHash(fileName, metadataHashes[fileName]);
        })).nodeify(callback);
    };

    /**
     * Adds hashes to the artifact using the given file paths.
     * @param {object.<string, string>} metadataHashes - Keys are file paths and values metadata hashes.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string[]} <b>hashes</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    Artifact.prototype.addMetadataHashes = function (metadataHashes, callback) {
        var self = this,
            fileNames = Object.keys(metadataHashes);

        return Q.all(fileNames.map(function (fileName) {
            return self.addMetadataHash(fileName, metadataHashes[fileName]);
        })).nodeify(callback);
    };

    /**
     * Saves this artifact and uploads the metadata to the server's storage.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string} <b>metadataHash</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    Artifact.prototype.save = function (callback) {
        var deferred = Q.defer();

        this.blobClient.putMetadata(this.descriptor, function (err, hash) {
            if (err) {
                deferred.reject(err);
            } else {
                deferred.resolve(hash);
            }
        });

        return deferred.promise.nodeify(callback);
    };

    return Artifact;
});

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('superagent',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.superagent = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],2:[function(require,module,exports){
function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects",
 "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(function(fn) {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function(/*varargs*/) {
    this._defaults.push({fn:fn, arguments:arguments});
    return this;
  }
});

Agent.prototype._setDefaults = function(req) {
    this._defaults.forEach(function(def) {
      req[def.fn].apply(req, def.arguments);
    });
};

module.exports = Agent;

},{}],3:[function(require,module,exports){
'use strict';

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;

},{}],4:[function(require,module,exports){
'use strict';

/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = require('./is-object');

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }
  return obj;
}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function _clearTimeout(){
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function timeout(options){
  if (!options || 'object' !== typeof options) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for(var option in options) {
    switch(option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;
      case 'response':
        this._responseTimeout = options.response;
        break;
      default:
        console.warn("Unknown timeout option", option);
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function retry(count, fn){
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

var ERROR_CODES = [
  'ECONNRESET',
  'ETIMEDOUT',
  'EADDRINFO',
  'ESOCKETTIMEDOUT'
];

/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */
RequestBase.prototype._shouldRetry = function(err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);
      if (override === true) return true;
      if (override === false) return false;
      // undefined falls back to defaults
    } catch(e) {
      console.error(e);
    }
  }
  if (res && res.status && res.status >= 500 && res.status != 501) return true;
  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;
    // Superagent timeout
    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }
  return false;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function() {

  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;

  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise(function(innerResolve, innerReject) {
      self.end(function(err, res) {
        if (err) innerReject(err);
        else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype['catch'] = function(cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function(cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function(res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};

/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
RequestBase.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function(name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  if (Array.isArray(val)) {
    for (var i in val) {
      this.field(name, val[i]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if ('boolean' === typeof val) {
    val = '' + val;
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
RequestBase.prototype.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', 'Basic ' + base64Encoder(user + ':' + pass));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', 'Bearer ' + user);
      break;
  }
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function(on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */
RequestBase.prototype.maxResponseSize = function(n){
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }
  this._maxResponseSize = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function() {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header,
  };
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.send = function(data){
  var isObj = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  }

  // merge
  if (isObj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};

/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function(sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */
RequestBase.prototype._finalizeQueryString = function(){
  var query = this._query.join('&');
  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }
  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');
    if (index >= 0) {
      var queryArr = this.url.substring(index + 1).split('&');
      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }
      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
};

// For backwards compat only
RequestBase.prototype._appendQueryString = function() {console.trace("Unsupported");}

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function(reason, timeout, errno){
  if (this._aborted) {
    return;
  }
  var err = new Error(reason + timeout + 'ms exceeded');
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function() {
  var self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }
  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function(){
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

},{"./is-object":3}],5:[function(require,module,exports){
'use strict';

/**
 * Module dependencies.
 */

var utils = require('./utils');

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }
  return obj;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function(field) {
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function(header){
    // TODO: moar!
    // TODO: make this a util

    // content-type
    var ct = header['content-type'] || '';
    this.type = utils.type(ct);

    // params
    var params = utils.params(ct);
    for (var key in params) this[key] = params[key];

    this.links = {};

    // links
    try {
        if (header.link) {
            this.links = utils.parseLinks(header.link);
        }
    } catch (err) {
        // ignore
    }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function(status){
    var type = status / 100 | 0;

    // status / class
    this.status = this.statusCode = status;
    this.statusType = type;

    // basics
    this.info = 1 == type;
    this.ok = 2 == type;
    this.redirect = 3 == type;
    this.clientError = 4 == type;
    this.serverError = 5 == type;
    this.error = (4 == type || 5 == type)
        ? this.toError()
        : false;

    // sugar
    this.created = 201 == status;
    this.accepted = 202 == status;
    this.noContent = 204 == status;
    this.badRequest = 400 == status;
    this.unauthorized = 401 == status;
    this.notAcceptable = 406 == status;
    this.forbidden = 403 == status;
    this.notFound = 404 == status;
    this.unprocessableEntity = 422 == status;
};

},{"./utils":6}],6:[function(require,module,exports){
'use strict';

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = function(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = function(str){
  return str.split(/ *; */).reduce(function(obj, str){
    var parts = str.split(/ *= */);
    var key = parts.shift();
    var val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = function(str){
  return str.split(/ *, */).reduce(function(obj, str){
    var parts = str.split(/ *; */);
    var url = parts[0].slice(1, -1);
    var rel = parts[1].split(/ *= */)[1].slice(1, -1);
    obj[rel] = url;
    return obj;
  }, {});
};

/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = function(header, changesOrigin){
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host'];
  // secuirty
  if (changesOrigin) {
    delete header['authorization'];
    delete header['cookie'];
  }
  return header;
};

},{}],"superagent":[function(require,module,exports){
/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

var Emitter = require('component-emitter');
var RequestBase = require('./request-base');
var isObject = require('./is-object');
var ResponseBase = require('./response-base');
var Agent = require('./agent-base');

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

var request = exports = module.exports = function(method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
}

exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only version of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function(v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(var subkey in val) {
        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

request.serializeObject = serialize;

/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};

/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    if (index === -1) { // could be empty line, just skip it
      continue;
    }
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[\/+]json($|[^-\w])/.test(mime);
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }
  this._setStatusProperties(status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD'
      ? this._parseBody(this.text ? this.text : this.xhr.response)
      : null;
  }
}

ResponseBase(Response.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str) {
  var parse = request.parse[this.type];
  if (this.req._parser) {
    return this.req._parser(this, str);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);

    var new_err;
    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch(custom_err) {
      new_err = custom_err; // ok() callback can throw
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

Emitter(Request.prototype);
RequestBase(Request.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (1 === arguments.length) pass = '';
  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }
  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto',
    };
  }

  var encoder = function(string) {
    if ('function' === typeof btoa) {
      return btoa(string);
    }
    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, options){
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

// This only warns, because the request is still likely to work
Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){
  console.warn("This is not supported in browser version of superagent");
  return this;
};

// This throws, because it can't send/receive data as expected
Request.prototype.pipe = Request.prototype.write = function(){
  throw Error("Streaming is not supported in browser version of superagent");
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
}

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._finalizeQueryString();

  return this._end();
};

Request.prototype._end = function() {
  var self = this;
  var xhr = (this.xhr = request.getXHR());
  var data = this._formData || this._data;

  this._setTimeouts();

  // state change
  xhr.onreadystatechange = function(){
    var readyState = xhr.readyState;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (4 != readyState) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch(e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;

    if (this.header.hasOwnProperty(field))
      xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};

request.agent = function() {
  return new Agent();
};

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function(method) {
  Agent.prototype[method.toLowerCase()] = function(url, fn) {
    var req = new request.Request(method, url);
    this._setDefaults(req);
    if (fn) {
      req.end(fn);
    }
    return req;
  };
});

Agent.prototype.del = Agent.prototype['delete'];

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn) {
  var req = request('GET', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn) {
  var req = request('HEAD', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function(url, data, fn) {
  var req = request('OPTIONS', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  var req = request('DELETE', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn) {
  var req = request('PATCH', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn) {
  var req = request('POST', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn) {
  var req = request('PUT', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./agent-base":2,"./is-object":3,"./request-base":4,"./response-base":5,"component-emitter":1}]},{},[])("superagent")
});

/*globals define*/
/*eslint-env node, browser*/
/**
 * @author kecso / https://github.com/kecso
 */
define('common/util/uint',[], function () {
    'use strict';

    // As the earlier used escape function is outdated and crashed in some scenarios, we replaced with this approach
    var decoder = null;
    if (typeof window === 'undefined') {
        var util = require('util');
        decoder = new util.TextDecoder();
    } else {
        decoder = new TextDecoder();
    }
    //this helper function is necessary as in case of large json objects,
    // the library standard function causes stack overflow
    function uint8ArrayToString(uintArray) {
        return decoder.decode(uintArray);
    }

    return {
        uint8ArrayToString: uint8ArrayToString
    };
});
/*globals define, Uint8Array, ArrayBuffer, WebGMEGlobal*/
/*eslint-env node, browser*/
/**
 * Client module for accessing the blob.
 *
 * @author lattmann / https://github.com/lattmann
 * @author ksmyth / https://github.com/ksmyth
 */

define('blob/BlobClient',[
    'blob/Artifact',
    'blob/BlobMetadata',
    'superagent',
    'q',
    'common/util/uint'
], function (Artifact, BlobMetadata, superagent, Q, UINT) {
    'use strict';

    /**
     * Client to interact with the blob-storage. <br>
     *
     * @param {object} parameters
     * @param {object} parameters.logger
     * @constructor
     * @alias BlobClient
     */
    var BlobClient = function (parameters) {
        var self = this;

        // Store these to be able to create a new instance from an instance.
        this.parameters = parameters;

        this.artifacts = [];
        if (parameters && parameters.logger) {
            this.logger = parameters.logger;
        } else {
            /*eslint-disable no-console*/
            var doLog = function () {
                console.log.apply(console, arguments);
            };
            this.logger = {
                debug: doLog,
                log: doLog,
                info: doLog,
                warn: doLog,
                error: doLog
            };
            console.warn('Since v1.3.0 BlobClient requires a logger, falling back on console.log.');
            /*eslint-enable no-console*/
        }

        if (parameters && parameters.uploadProgressHandler) {
            this.uploadProgressHandler = parameters.uploadProgressHandler;
        } else {
            this.uploadProgressHandler = function (fName, e) {
                self.logger.debug('File upload of', fName, e.percent, '%');
            };
        }

        this.logger.debug('ctor', {metadata: parameters});

        if (parameters) {
            this.server = parameters.server || this.server;
            this.serverPort = parameters.serverPort || this.serverPort;
            this.httpsecure = (parameters.httpsecure !== undefined) ? parameters.httpsecure : this.httpsecure;
            this.apiToken = parameters.apiToken;
            this.webgmeToken = parameters.webgmeToken;
            this.keepaliveAgentOptions = parameters.keepaliveAgentOptions || {/* use defaults */};
        } else {
            this.keepaliveAgentOptions = {/* use defaults */};
        }
        this.origin = '';
        if (this.httpsecure !== undefined && this.server && this.serverPort) {
            this.origin = (this.httpsecure ? 'https://' : 'http://') + this.server + ':' + this.serverPort;
        }
        if (parameters && typeof parameters.relativeUrl === 'string') {
            this.relativeUrl = parameters.relativeUrl;
        } else if (typeof WebGMEGlobal !== 'undefined' && WebGMEGlobal.gmeConfig &&
            typeof WebGMEGlobal.gmeConfig.client.mountedPath === 'string') {
            this.relativeUrl = WebGMEGlobal.gmeConfig.client.mountedPath + '/rest/blob/';
        } else {
            this.relativeUrl = '/rest/blob/';
        }
        this.blobUrl = this.origin + this.relativeUrl;

        this.isNodeOrNodeWebKit = typeof process !== 'undefined';
        if (this.isNodeOrNodeWebKit) {
            // node or node-webkit
            this.logger.debug('Running under node or node-web-kit');
            if (this.httpsecure) {
                this.Agent = require('agentkeepalive').HttpsAgent;
            } else {
                this.Agent = require('agentkeepalive');
            }
            if (this.keepaliveAgentOptions.hasOwnProperty('ca') === false) {
                this.keepaliveAgentOptions.ca = require('https').globalAgent.options.ca;
            }
            this.keepaliveAgent = new this.Agent(this.keepaliveAgentOptions);
        }

        this.logger.debug('origin', this.origin);
        this.logger.debug('blobUrl', this.blobUrl);
    };

    /**
     * Creates and returns a new instance of a BlobClient with the same settings as the current one.
     * This can be used to avoid issues with the artifacts being book-kept at the instance.
     * @returns {BlobClient} A new instance of a BlobClient
     */
    BlobClient.prototype.getNewInstance = function () {
        return new BlobClient(this.parameters);
    };

    BlobClient.prototype.getMetadataURL = function (hash) {
        return this.origin + this.getRelativeMetadataURL(hash);
    };

    BlobClient.prototype.getRelativeMetadataURL = function (hash) {
        var metadataBase = this.relativeUrl + 'metadata';
        if (hash) {
            return metadataBase + '/' + hash;
        } else {
            return metadataBase;
        }
    };

    BlobClient.prototype._getURL = function (base, hash, subpath) {
        var subpathURL = '';
        if (subpath) {
            subpathURL = subpath;
        }
        return this.relativeUrl + base + '/' + hash + '/' + encodeURIComponent(subpathURL);
    };

    BlobClient.prototype.getViewURL = function (hash, subpath) {
        return this.origin + this.getRelativeViewURL(hash, subpath);
    };

    BlobClient.prototype.getRelativeViewURL = function (hash, subpath) {
        return this._getURL('view', hash, subpath);
    };

    /**
     * Returns the get-url for downloading a blob.
     * @param {string} metadataHash
     * @param {string} [subpath] - optional file-like path to sub-object if complex blob
     * @return {string} get-url for blob
     */
    BlobClient.prototype.getDownloadURL = function (metadataHash, subpath) {
        return this.origin + this.getRelativeDownloadURL(metadataHash, subpath);
    };

    BlobClient.prototype.getRelativeDownloadURL = function (hash, subpath) {
        return this._getURL('download', hash, subpath);
    };

    BlobClient.prototype.getCreateURL = function (filename, isMetadata) {
        return this.origin + this.getRelativeCreateURL(filename, isMetadata);
    };

    BlobClient.prototype.getRelativeCreateURL = function (filename, isMetadata) {
        if (isMetadata) {
            return this.relativeUrl + 'createMetadata/';
        } else {
            return this.relativeUrl + 'createFile/' + encodeURIComponent(filename);
        }
    };

    /**
     * Adds a file to the blob storage.
     * @param {string} name - file name.
     * @param {string|Buffer|ArrayBuffer|stream.Readable} data - file content. 
     * !ReadStream currently only available from a nodejs setting
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise} On success the promise will be resolved with {string} <b>metadataHash</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    BlobClient.prototype.putFile = function (name, data, callback) {
        var deferred = Q.defer(),
            self = this,
            contentLength,
            req,
            stream = null;

        this.logger.debug('putFile', name);

        function toArrayBuffer(buffer) {
            var ab = new ArrayBuffer(buffer.length),
                view = new Uint8Array(ab);

            for (var i = 0; i < buffer.length; ++i) {
                view[i] = buffer[i];
            }

            return ab;
        }

        if (typeof window === 'undefined') {
            stream = require('stream');
        }
        // On node-webkit, we use XMLHttpRequest, but xhr.send thinks a Buffer is a string and encodes it in utf-8 -
        // send an ArrayBuffer instead.
        if (typeof window !== 'undefined' && typeof Buffer !== 'undefined' && data instanceof Buffer) {
            data = toArrayBuffer(data); // FIXME will this have performance problems
        }
        // on node, empty Buffers will cause a crash in superagent
        if (typeof window === 'undefined' && typeof Buffer !== 'undefined' && data instanceof Buffer) {
            if (data.length === 0) {
                data = '';
            }
        }
        contentLength = data.hasOwnProperty('length') ? data.length : data.byteLength;
        req = superagent.post(this.getCreateURL(name));

        if (typeof window === 'undefined') {
            req.agent(this.keepaliveAgent);
        }

        this._setAuthHeaders(req);

        if (typeof data !== 'string' &&
        !(data instanceof String) &&
        typeof window === 'undefined' &&
        !(data instanceof stream.Readable)) {
            req.set('Content-Length', contentLength);
        }

        req.set('Content-Type', 'application/octet-stream');

        if (typeof window === 'undefined' && data instanceof stream.Readable) {
            const DEFAULT_ERROR = new Error('Failed to send stream data completely');
            const errorHandler = err => deferred.reject(err || DEFAULT_ERROR);
            data.on('error', errorHandler);
            req.on('error', errorHandler);
            req.on('response', function (res) {
                var response = res.body;
                // Get the first one
                var hash = Object.keys(response)[0];
                self.logger.debug('putFile - result', hash);
                deferred.resolve(hash);
            });
            data.pipe(req);
        } else {
            req.send(data)
                .on('progress', function (event) {
                    self.uploadProgressHandler(name, event);
                })
                .end(function (err, res) {
                    if (err || res.status > 399) {
                        deferred.reject(err || new Error(res.status));
                        return;
                    }
                    var response = res.body;
                    // Get the first one
                    var hash = Object.keys(response)[0];
                    self.logger.debug('putFile - result', hash);
                    deferred.resolve(hash);
                });
        }

        return deferred.promise.nodeify(callback);
    };

    BlobClient.prototype._setAuthHeaders = function (req) {
        if (this.apiToken) {
            req.set('x-api-token', this.apiToken);
        } else if (this.webgmeToken) {
            req.set('Authorization', 'Bearer ' + this.webgmeToken);
        }
    };

    BlobClient.prototype.putMetadata = function (metadataDescriptor, callback) {
        var metadata = new BlobMetadata(metadataDescriptor),
            deferred = Q.defer(),
            self = this,
            blob,
            contentLength,
            req;
        // FIXME: in production mode do not indent the json file.
        this.logger.debug('putMetadata', {metadata: metadataDescriptor});
        if (typeof Blob !== 'undefined' && typeof window !== 'undefined') {
            // This does not work using the "new" Blob class in nodejs - so make sure (for now at least) that
            // we running under a brower even though Blob is defined.
            // https://nodejs.org/api/buffer.html#class-blob
            blob = new Blob([JSON.stringify(metadata.serialize(), null, 4)], {type: 'text/plain'});
            contentLength = blob.size;
        } else {
            blob = Buffer.from(JSON.stringify(metadata.serialize(), null, 4), 'utf8');
            contentLength = blob.length;
        }

        req = superagent.post(this.getCreateURL(metadataDescriptor.name, true));
        this._setAuthHeaders(req);

        if (typeof window === 'undefined') {
            req.agent(this.keepaliveAgent);
            req.set('Content-Length', contentLength);
        }

        req.set('Content-Type', 'application/octet-stream')
            .send(blob)
            .end(function (err, res) {
                if (err || res.status > 399) {
                    deferred.reject(err || new Error(res.status));
                    return;
                }
                // Uploaded.
                var response = JSON.parse(res.text);
                // Get the first one
                var hash = Object.keys(response)[0];
                self.logger.debug('putMetadata - result', hash);
                deferred.resolve(hash);
            });

        return deferred.promise.nodeify(callback);
    };

    /**
     * Adds multiple files to the blob storage.
     * @param {object.<string, string|Buffer|ArrayBuffer>} o - Keys are file names and values the content.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise} On success the promise will be resolved with {object}
     * <b>fileNamesToMetadataHashes</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    BlobClient.prototype.putFiles = function (o, callback) {
        var self = this,
            deferred = Q.defer(),
            error,
            filenames = Object.keys(o),
            remaining = filenames.length,
            hashes = {},
            putFile;

        if (remaining === 0) {
            deferred.resolve(hashes);
        }
        putFile = function (filename, data) {
            self.putFile(filename, data, function (err, hash) {
                remaining -= 1;

                hashes[filename] = hash;

                if (err) {
                    error = err;
                    self.logger.error('putFile failed with error', {metadata: err});
                }

                if (remaining === 0) {
                    if (error) {
                        deferred.reject(error);
                    } else {
                        deferred.resolve(hashes);
                    }
                }
            });
        };

        for (var j = 0; j < filenames.length; j += 1) {
            putFile(filenames[j], o[filenames[j]]);
        }

        return deferred.promise.nodeify(callback);
    };

    BlobClient.prototype.getSubObject = function (hash, subpath, callback) {
        return this.getObject(hash, callback, subpath);
    };

    /**
     * Retrieves object from blob storage as a Buffer under node and as an ArrayBuffer in the client.
     * N.B. if the retrieved file is a json-file and running in a browser, the content will be decoded and
     * the string parsed as a JSON.
     * @param {string} metadataHash - hash of metadata for object.
     * @param {function} [callback] - if provided no promise will be returned.
     * @param {string} [subpath] - optional file-like path to sub-object if complex blob
     *
     * @return {external:Promise} On success the promise will be resolved with {Buffer|ArrayBuffer|object}
     * <b>content</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    BlobClient.prototype.getObject = function (metadataHash, callback, subpath) {
        var deferred = Q.defer(),
            self = this;

        this.logger.debug('getObject', metadataHash, subpath);

        superagent.parse['application/zip'] = function (obj, parseCallback) {
            if (parseCallback) {
                // Running on node; this should be unreachable due to req.pipe() below
            } else {
                return obj;
            }
        };
        //superagent.parse['application/json'] = superagent.parse['application/zip'];

        var req = superagent.get(this.getViewURL(metadataHash, subpath));
        this._setAuthHeaders(req);

        if (typeof window === 'undefined') {
            // running on node
            req.agent(this.keepaliveAgent);
            var Writable = require('stream').Writable;
            var BuffersWritable = function (options) {
                Writable.call(this, options);

                var self = this;
                self.buffers = [];
            };
            require('util').inherits(BuffersWritable, Writable);

            BuffersWritable.prototype._write = function (chunk, encoding, cb) {
                this.buffers.push(chunk);
                cb();
            };

            var buffers = new BuffersWritable();
            buffers.on('finish', function () {
                if (req.req.res.statusCode > 399) {
                    deferred.reject(new Error(req.req.res.statusCode));
                } else {
                    deferred.resolve(Buffer.concat(buffers.buffers));
                }
            });
            buffers.on('error', function (err) {
                deferred.reject(err);
            });
            req.pipe(buffers);
        } else {
            req.removeAllListeners('end');
            req.on('request', function () {
                if (typeof this.xhr !== 'undefined') {
                    this.xhr.responseType = 'arraybuffer';
                }
            });
            // req.on('error', callback);
            req.on('end', function () {
                if (req.xhr.status > 399) {
                    deferred.reject(new Error(req.xhr.status));
                } else {
                    var contentType = req.xhr.getResponseHeader('content-type');
                    var response = req.xhr.response; // response is an arraybuffer
                    if (contentType === 'application/json') {
                        response = JSON.parse(UINT.uint8ArrayToString(new Uint8Array(response)));
                    }
                    self.logger.debug('getObject - result', {metadata: response});
                    deferred.resolve(response);
                }
            });
            // TODO: Why is there an end here too? Isn't req.on('end',..) enough?
            req.end(function (err, result) {
                if (err) {
                    deferred.reject(err);
                } else {
                    self.logger.debug('getObject - result', {metadata: result});
                    deferred.resolve(result);
                }
            });
        }

        return deferred.promise.nodeify(callback);
    };

    /**
     * If running under nodejs and getting large objects use this method to pipe the downloaded
     * object to your provided writeStream.
     * @example
     * // Piping object to the filesystem..
     * var writeStream = fs.createWriteStream('my.zip');
     *
     * writeStream.on('error', function (err) {
     *   // handle error
     * });
     *
     * writeStream.on('finish', function () {
     *   // my.zip exists at this point
     * });
     *
     * blobClient.getStreamObject(metadataHash, writeStream);
     *
     * @param {string} metadataHash - hash of metadata for object.
     * @param {stream.Writable} writeStream - stream the requested data will be piped to.
     * @param {string} [subpath] - optional file-like path to sub-object if complex blob
     */
    BlobClient.prototype.getStreamObject = function (metadataHash, writeStream, subpath) {
        this.logger.debug('getStreamObject', metadataHash, subpath);

        var req = superagent.get(this.getViewURL(metadataHash, subpath));

        this._setAuthHeaders(req);

        if (typeof Buffer !== 'undefined') {
            // running on node
            req.agent(this.keepaliveAgent);
            req.pipe(writeStream);
        } else {
            throw new Error('streamObject only supported under nodejs, use getObject instead.');
        }
    };

    /**
     * Retrieves object from blob storage and parses the content as a string.
     * @param {string} metadataHash - hash of metadata for object.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise} On success the promise will be resolved with {string} <b>contentString</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    BlobClient.prototype.getObjectAsString = function (metadataHash, callback) {
        var self = this;
        return self.getObject(metadataHash)
            .then(function (content) {
                if (typeof content === 'string') {
                    // This does currently not happen..
                    return content;
                } else if (typeof Buffer !== 'undefined' && content instanceof Buffer) {
                    return UINT.uint8ArrayToString(new Uint8Array(content));
                } else if (content instanceof ArrayBuffer) {
                    return UINT.uint8ArrayToString(new Uint8Array(content));
                } else if (content !== null && typeof content === 'object') {
                    return JSON.stringify(content);
                } else {
                    throw new Error('Unknown content encountered: ' + content);
                }
            })
            .nodeify(callback);
    };

    /**
     * Retrieves object from blob storage and parses the content as a JSON. (Will resolve with error if not valid JSON.)
     * @param {string} metadataHash - hash of metadata for object.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise} On success the promise will be resolved with {object} <b>contentJSON</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    BlobClient.prototype.getObjectAsJSON = function (metadataHash, callback) {
        var self = this;
        return self.getObject(metadataHash)
            .then(function (content) {
                if (typeof content === 'string') {
                    // This does currently not happen..
                    return JSON.parse(content);
                } else if (typeof Buffer !== 'undefined' && content instanceof Buffer) {
                    return JSON.parse(UINT.uint8ArrayToString(new Uint8Array(content)));
                } else if (content instanceof ArrayBuffer) {
                    return JSON.parse(UINT.uint8ArrayToString(new Uint8Array(content)));
                } else if (content !== null && typeof content === 'object') {
                    return content;
                } else {
                    throw new Error('Unknown content encountered: ' + content);
                }
            })
            .nodeify(callback);
    };

    /**
     * Retrieves metadata from blob storage.
     * @param {string} metadataHash - hash of metadata.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise} On success the promise will be resolved with {object} <b>metadata</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    BlobClient.prototype.getMetadata = function (metadataHash, callback) {
        var req = superagent.get(this.getMetadataURL(metadataHash)),
            deferred = Q.defer(),
            self = this;

        this.logger.debug('getMetadata', metadataHash);

        this._setAuthHeaders(req);

        if (typeof window === 'undefined') {
            req.agent(this.keepaliveAgent);
        }

        req.end(function (err, res) {
            if (err || res.status > 399) {
                deferred.reject(err || new Error(res.status));
            } else {
                self.logger.debug('getMetadata', res.text);
                deferred.resolve(JSON.parse(res.text));
            }
        });

        return deferred.promise.nodeify(callback);
    };

    /**
     * Creates a new artifact and adds it to array of artifacts of the instance.
     * @param {string} name - Name of artifact
     * @return {Artifact}
     */
    BlobClient.prototype.createArtifact = function (name) {
        var artifact = new Artifact(name, this);
        this.artifacts.push(artifact);
        return artifact;
    };

    /**
     * Retrieves the {@link Artifact} from the blob storage.
     * @param {hash} metadataHash - hash associated with the artifact.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with
     * {@link Artifact} <b>artifact</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    BlobClient.prototype.getArtifact = function (metadataHash, callback) {
        // TODO: get info check if complex flag is set to true.
        // TODO: get info get name.
        var self = this,
            deferred = Q.defer();
        this.logger.debug('getArtifact', metadataHash);
        this.getMetadata(metadataHash, function (err, info) {
            if (err) {
                deferred.reject(err);
                return;
            }

            self.logger.debug('getArtifact - return', {metadata: info});
            if (info.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {
                var artifact = new Artifact(info.name, self, info);
                self.artifacts.push(artifact);
                deferred.resolve(artifact);
            } else {
                deferred.reject(new Error('not supported contentType ' + JSON.stringify(info, null, 4)));
            }

        });

        return deferred.promise.nodeify(callback);
    };

    /**
     * Saves all the artifacts associated with the current instance.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with
     * {string[]} <b>artifactHashes</b> (metadataHashes).<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    BlobClient.prototype.saveAllArtifacts = function (callback) {
        var promises = [];

        for (var i = 0; i < this.artifacts.length; i += 1) {
            promises.push(this.artifacts[i].save());
        }

        return Q.all(promises).nodeify(callback);
    };

    /**
     * Converts bytes to a human readable string.
     * @param {number} - File size in bytes.
     * @param {boolean} [si] - If true decimal conversion will be used (by default binary is used).
     * @returns {string}
     */
    BlobClient.prototype.getHumanSize = function (bytes, si) {
        var thresh = si ? 1000 : 1024,
            units = si ?
                ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'] :
                ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'],
            u = -1;

        if (bytes < thresh) {
            return bytes + ' B';
        }

        do {
            bytes = bytes / thresh;
            u += 1;
        } while (bytes >= thresh);

        return bytes.toFixed(1) + ' ' + units[u];
    };

    BlobClient.prototype.setToken = function (token) {
        this.webgmeToken = token;
    };

    return BlobClient;
});

/*globals define*/
/*eslint-env browser*/

/**
 * @author kecso / https://github.com/kecso
 */
define('client/SaveToDisk',['blob/BlobClient'], function (BlobClient) {
    'use strict';

    function saveUrlToDisk(fileURL, fileName) {
        // for non-IE
        if (!window.ActiveXObject) {
            var save = document.createElement('a');
            //event = document.createEvent('Event');

            save.href = fileURL;
            save.target = '_self';

            if (fileName) {
                save.download = fileName;
            }

            // event.initEvent('click', true, true);
            // save.dispatchEvent(event);
            // (window.URL || window.webkitURL).revokeObjectURL(save.href);
            save.click();
        } else if (!!window.ActiveXObject && document.execCommand) {
            // for IE
            var _window = window.open(fileURL, '_self');
            _window.document.close();
            _window.document.execCommand('SaveAs', true, fileName || fileURL);
            _window.close();
        }
    }

    function downloadTextAsFile(filename, text) {
        var element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', filename);

        element.style.display = 'none';
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
    }

    function saveJsonToBlobStorage(fileName, data, logger, callback) {
        var bc = new BlobClient({logger: logger}),
            artifact = bc.createArtifact('uploaded');

        artifact.addFile(fileName, JSON.stringify(data, null, 4), function (err, fileHash) {
            callback(err, bc.getDownloadURL(fileHash));
        });
    }

    function saveJsonToDisk(fileName, data, logger, callback) {
        saveJsonToBlobStorage(fileName, data, logger, function (err, downloadUrl) {
            if (err) {
                return callback(err);
            }

            saveUrlToDisk(downloadUrl, fileName);
            callback(null, downloadUrl);
        });
    }

    return {
        saveToBlobStorage: saveJsonToBlobStorage,
        saveUrlToDisk: saveUrlToDisk,
        saveJsonToDisk: saveJsonToDisk,
        downloadTextAsFile: downloadTextAsFile
    };
});
/*globals define*/
/*eslint-env browser*/
/**
 * Contains helper functions for logging/downloading the state of the client.
 *
 * @author pmeijer / https://github.com/pmeijer
 */

define('client/stateloghelpers',[
    './SaveToDisk'
], function (saveToDisk) {
    'use strict';

    function _stateLogReplacer(key, value) {
        var chainItem,
            prevChain,
            nextChain,
            chain;
        if (key === 'project') {
            if (value) {
                return value.name;
            } else {
                return null;
            }

        } else if (key === 'core') {
            if (value) {
                return 'instantiated';
            } else {
                return 'notInstantiated';
            }
        } else if (key === 'metaNodes') {
            return Object.keys(value);
        } else if (key === 'nodes') {
            return Object.keys(value);
        } else if (key === 'loadNodes') {
            return Object.keys(value);
        } else if (key === 'users') {
            return Object.keys(value);
        } else if (key === 'rootObject') {
            return;
        } else if (key === 'undoRedoChain') {
            if (value) {
                chain = {
                    previous: null,
                    next: null
                };
                if (value.previous) {
                    prevChain = {};
                    chain.previous = prevChain;
                }
                chainItem = value;
                while (chainItem.previous) {
                    prevChain.previous = {
                        commitHash: chainItem.commitHash,
                        previous: null
                    };
                    prevChain = prevChain.previous;
                    chainItem = chainItem.previous;
                }
                if (value.next) {
                    nextChain = {};
                    chain.next = nextChain;
                }
                chainItem = value;
                while (chainItem.next) {
                    nextChain.next = {
                        commitHash: chainItem.commitHash,
                        next: null
                    };
                    nextChain = nextChain.next;
                    chainItem = chainItem.next;
                }
                return chain;
            }
        }

        return value;
    }

    function getStateLogString(client, state, doFullState, indent) {
        indent = indent || 0;
        if (doFullState === true) {
            return JSON.stringify(state, _stateLogReplacer, indent);
        } else {
            return JSON.stringify({
                connection: client.getNetworkStatus(),
                projectId: client.getActiveProjectId(),
                branchName: client.getActiveBranchName(),
                branchStatus: client.getBranchStatus(),
                commitHash: client.getActiveCommitHash(),
                rootHash: client.getActiveRootHash(),
                projectReadOnly: client.isProjectReadOnly(),
                commitReadOnly: client.isCommitReadOnly()
            }, null, indent);
        }
    }

    function downloadStateDump(client, state) {
        var errData = {
            timestamp: (new Date()).toISOString(),
            webgme: {
                NpmVersion: 'n/a',
                version: 'n/a',
                GitHubVersion: 'n/a'
            },
            gmeConfig: client.gmeConfig,
            uiState: null,
            branchErrors: [],
            browserInfo: {
                appCodeName: window.navigator.appCodeName,
                appName: window.navigator.appName,
                appVersion: window.navigator.appVersion,
                onLine: window.navigator.onLine,
                cookieEnabled: window.navigator.cookieEnabled,
                platform: window.navigator.platform,
                product: window.navigator.product,
                userAgent: window.navigator.userAgent
            },
            clientState: JSON.parse(getStateLogString(client, state, true))
        };

        if (typeof WebGMEGlobal !== 'undefined') {
            /* eslint-disable no-undef*/
            errData.webgme.NpmVersion = WebGMEGlobal.NpmVersion;
            errData.webgme.GitHubVersion = WebGMEGlobal.GitHubVersion;
            errData.webgme.version = WebGMEGlobal.version;
            /* eslint-enable no-undef*/
        }

        if (typeof client.uiStateGetter === 'function') {
            errData.uiState = client.uiStateGetter();
        } else {
            errData.uiState = 'Client did not have an attached uiStateGetter.';
        }

        if (state.project && state.branchName && state.project.branches[state.branchName]) {
            state.project.branches[state.branchName].errorList.forEach(function (err) {
                errData.branchErrors.push({
                    message: err.message,
                    stack: err.stack});
            });
        }

        saveToDisk.downloadTextAsFile('webgme-client-dump.json', JSON.stringify(errData, null, 2));
    }

    function downloadCommitQueue(client, commitQueue) {
        var backupData = {
            webgmeVersion: client.getConnectedStorageVersion(),
            projectId: client.getActiveProjectId(),
            branchName: client.getActiveBranchName(),
            branchStatus: client.getBranchStatus(),
            commitQueue: commitQueue
        };

        saveToDisk.downloadTextAsFile('commit-queue-dump.json', JSON.stringify(backupData, null, 2));
    }

    return {
        downloadStateDump: downloadStateDump,
        getStateLogString: getStateLogString,
        downloadCommitQueue: downloadCommitQueue
    };
});
/*globals define*/
/*eslint-env node, browser*/

/**
 * A module representing a PluginNodeDescription.
 *
 * @author lattmann / https://github.com/lattmann
 */


(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('plugin/PluginNodeDescription',[], factory);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = factory();
    }
}(function () {
    'use strict';
    /**
     * Initializes a new instance of plugin node description object.
     *
     * Note: this object is JSON serializable see serialize method.
     *
     * @param config - deserializes an existing configuration to this object.
     * @constructor
     * @alias PluginNodeDescription
     */
    var PluginNodeDescription = function (config) {
        var keys,
            i;

        this.name = '';
        this.id = '';

        if (config) {
            keys = Object.keys(config);
            for (i = 0; i < keys.length; i += 1) {
                this[keys[i]] = config[keys[i]];
            }
        }
    };

    /**
     * Serializes this object to a JSON representation.
     *
     * @returns {{}}
     */
    PluginNodeDescription.prototype.serialize = function () {
        var keys = Object.keys(this),
            result = {},
            i;

        for (i = 0; i < keys.length; i += 1) {
            result[keys[i]] = this[keys[i]];
        }

        return result;
    };

    return PluginNodeDescription;
}));
/*globals define*/
/*eslint-env node, browser*/

/**
 * A module representing a PluginMessage.
 *
 * @author lattmann / https://github.com/lattmann
 */


(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('plugin/PluginMessage',['plugin/PluginNodeDescription'], factory);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = factory(require('./PluginNodeDescription'));
    }
}(function (PluginNodeDescription) {
    'use strict';

    /**
     * Initializes a new instance of plugin message.
     *
     * Note: this object is JSON serializable see serialize method.
     *
     * @param {object} config - deserializes an existing configuration to this object.
     * @constructor
     * @alias PluginMessage
     */
    var PluginMessage = function (config) {
        if (config) {
            this.commitHash = config.commitHash;
            if (config.activeNode instanceof PluginNodeDescription) {
                this.activeNode = config.activeNode;
            } else {
                this.activeNode = new PluginNodeDescription(config.activeNode);
            }

            this.message = config.message;
            if (config.severity) {
                this.severity = config.severity;
            } else {
                this.severity = 'info';
            }
        } else {
            this.commitHash = '';
            this.activeNode = new PluginNodeDescription();
            this.message = '';
            this.severity = 'info';
        }
    };

    /**
     * Serializes this object to a JSON representation.
     *
     * @returns {object}
     */
    PluginMessage.prototype.serialize = function () {
        var result = {
            commitHash: this.commitHash,
            activeNode: this.activeNode.serialize(),
            message: this.message,
            severity: this.severity
        };

        return result;
    };

    return PluginMessage;
}));
/*globals define*/
/*eslint-env node, browser*/

/**
 * A module representing the base class for PluginResult and InterPluginResult.
 * @author pmeijer / https://github.com/meijer
 */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('plugin/PluginResultBase',[], factory);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = factory();
    }
}(function () {
    'use strict';

    /**
     * Initializes a new instance of a plugin result object.
     * @constructor
     * @alias PluginResultBase
     * @param {string} pluginName - name of plugin.
     */
    var PluginResultBase = function (pluginName) {
        this.success = false;
        this.artifacts = [];
        this.messages = [];
        this.pluginName = pluginName;
    };

    /**
     * Gets the success flag of this result object
     *
     * @returns {boolean}
     */
    PluginResultBase.prototype.getSuccess = function () {
        return this.success;
    };

    /**
     * Sets the success flag of this result.
     *
     * @param {boolean} value
     */
    PluginResultBase.prototype.setSuccess = function (value) {
        this.success = value;
    };

    /**
     * Returns with the plugin messages.
     *
     * @returns {PluginMessage[]}
     */
    PluginResultBase.prototype.getMessages = function () {
        return this.messages;
    };

    /**
     * Adds a new plugin message to the messages list.
     *
     * @param {PluginMessage} pluginMessage
     */
    PluginResultBase.prototype.addMessage = function (pluginMessage) {
        this.messages.push(pluginMessage);
    };

    /**
     * Returns all artifacts stored.
     *
     * @returns {string[]} hashes - Hashes of the stored artifacts.
     */
    PluginResultBase.prototype.getArtifacts = function () {
        return this.artifacts;
    };

    /**
     * Adds a saved artifact to the result - linked via its hash.
     *
     * @param {string} hash - Hash of saved artifact.
     */
    PluginResultBase.prototype.addArtifact = function (hash) {
        this.artifacts.push(hash);
    };

    /**
     * Gets the name of the plugin to which the result object belongs to.
     *
     * @returns {string}
     */
    PluginResultBase.prototype.getPluginName = function () {
        return this.pluginName;
    };

    return PluginResultBase;
}));
/*globals define*/
/*eslint-env node, browser*/

/**
 * A module representing a PluginResult.
 *
 * @author lattmann / https://github.com/lattmann
 */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('plugin/PluginResult',['plugin/PluginMessage', 'plugin/PluginResultBase'], factory);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = factory(require('./PluginMessage'), require('./PluginResultBase'));
    }
}(function (PluginMessage, PluginResultBase) {
    'use strict';

    /**
     * Initializes a new instance of a plugin result object.
     *
     * Note: this object is JSON serializable see serialize method.
     *
     * @param config - deserializes an existing configuration to this object.
     * @constructor
     * @augments PluginResultBase
     * @alias PluginResult
     */
    var PluginResult = function (config) {
        var pluginMessage,
            i;
        if (config) {
            this.success = config.success;
            this.pluginName = config.pluginName;
            this.pluginId = config.pluginId;
            this.startTime = config.startTime;
            this.finishTime = config.finishTime;
            this.messages = [];
            this.artifacts = config.artifacts;
            this.error = config.error;
            this.commits = config.commits;
            this.projectId = config.projectId;

            for (i = 0; i < config.messages.length; i += 1) {
                if (config.messages[i] instanceof PluginMessage) {
                    pluginMessage = config.messages[i];
                } else {
                    pluginMessage = new PluginMessage(config.messages[i]);
                }
                this.messages.push(pluginMessage);
            }
        } else {
            this.success = false;
            this.messages = []; // array of PluginMessages
            this.artifacts = []; // array of hashes
            this.pluginName = 'PluginName N/A';
            this.startTime = null;
            this.finishTime = null;
            this.error = null;
            this.projectId = null;
            this.pluginId = null;
            this.commits = [];
        }
    };

    // Prototypical inheritance from PluginResultBase.
    PluginResult.prototype = Object.create(PluginResultBase.prototype);
    PluginResult.prototype.constructor = PluginResult;

    /**
     *
     * @param {object} commitData
     * @param {string} commitData.commitHash - hash of the commit.
     * @param {string} commitData.status - storage.constants./SYNCED/FORKED/MERGED
     * @param {string} commitData.branchName - name of branch that got updated with the commitHash.
     */
    PluginResult.prototype.addCommit = function (commitData) {
        this.commits.push(commitData);
    };

    //------------------------------------------------------------------------------------------------------------------
    //--------------- Methods used by the plugin manager

    /**
     * Sets the name of the plugin to which the result object belongs to.
     *
     * @param {string} pluginName - name of the plugin
     */
    PluginResult.prototype.setPluginName = function (pluginName) {
        this.pluginName = pluginName;
    };

    /**
     * Sets the name of the plugin to which the result object belongs to.
     *
     * @param {string} pluginName - name of the plugin
     */
    PluginResult.prototype.setPluginId = function (pluginId) {
        this.pluginId = pluginId;
    };

    /**
     * Sets the name of the projectId the result was generated from.
     *
     * @param {string} projectId - id of the project
     */
    PluginResult.prototype.setProjectId = function (projectId) {
        this.projectId = projectId;
    };

    /**
     * Gets the ISO 8601 representation of the time when the plugin started its execution.
     *
     * @returns {string}
     */
    PluginResult.prototype.getStartTime = function () {
        return this.startTime;
    };

    /**
     * Sets the ISO 8601 representation of the time when the plugin started its execution.
     *
     * @param {string} time
     */
    PluginResult.prototype.setStartTime = function (time) {
        this.startTime = time;
    };

    /**
     * Gets the ISO 8601 representation of the time when the plugin finished its execution.
     *
     * @returns {string}
     */
    PluginResult.prototype.getFinishTime = function () {
        return this.finishTime;
    };

    /**
     * Sets the ISO 8601 representation of the time when the plugin finished its execution.
     *
     * @param {string} time
     */
    PluginResult.prototype.setFinishTime = function (time) {
        this.finishTime = time;
    };

    /**
     * Gets error if any error occured during execution.
     * FIXME: should this be an Error object?
     * @returns {string}
     */
    PluginResult.prototype.getError = function () {
        return this.error;
    };

    /**
     * Sets the error string if any error occured during execution.
     * FIXME: should this be an Error object?
     * @param {string} time
     */
    PluginResult.prototype.setError = function (error) {
        if (this.error) {
            // Do not overwrite user defined error.
            return;
        }

        if (error instanceof Error) {
            this.error = error.message;
        } else {
            this.error = error;
        }
    };

    /**
     * Serializes this object to a JSON representation.
     *
     * @returns {{success: boolean, messages: plugin.PluginMessage[], pluginName: string, finishTime: stirng}}
     */
    PluginResult.prototype.serialize = function () {
        var result = {
                success: this.success,
                projectId: this.projectId,
                messages: [],
                commits: this.commits,
                artifacts: this.artifacts,
                pluginName: this.pluginName,
                pluginId: this.pluginId,
                startTime: this.startTime,
                finishTime: this.finishTime,
                error: this.error
            },
            i;

        for (i = 0; i < this.messages.length; i += 1) {
            result.messages.push(this.messages[i].serialize());
        }

        return result;
    };

    return PluginResult;
}));

/*globals define*/
/*eslint-env node, browser*/
/**
 * Helper functions used by plugins and plugin-managers.
 * @author pmeijer / https://github.com/pmeijer
 */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('plugin/util',['q'], factory);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = factory(require('q'));
    }
}(function (Q) {
    'use strict';

    /**
     *
     * @param {object} core
     * @param {GmeNode} rootNode
     * @param {GmeLogger} logger
     * @param {string} [namespace='']
     * @param namespace
     */
    function getMetaNodesMap(core, rootNode, logger, namespace) {
        var paths2MetaNodes = core.getAllMetaNodes(rootNode),
            libraryNames = core.getLibraryNames(rootNode),
            result = {},
            metaNodeName,
            nodeNamespace,
            fullName,
            path;

        // Gather the META nodes and "sort" based on given namespace.
        function startsWith(str, pattern) {
            return str.indexOf(pattern) === 0;
        }

        if (namespace) {
            if (libraryNames.indexOf(namespace) === -1) {
                throw new Error('Given namespace "' + namespace + '" does not exist among the available: [' +
                    libraryNames + '].');
            }

            for (path in paths2MetaNodes) {
                nodeNamespace = core.getNamespace(paths2MetaNodes[path]);
                metaNodeName = core.getAttribute(paths2MetaNodes[path], 'name');

                if (startsWith(nodeNamespace, namespace)) {
                    // Trim the based on the chosen namespace (+1 is to remove any dot).
                    nodeNamespace = nodeNamespace.substring(namespace.length + 1);
                    if (nodeNamespace) {
                        result[nodeNamespace + '.' + metaNodeName] = paths2MetaNodes[path];
                    } else {
                        result[metaNodeName] = paths2MetaNodes[path];
                    }
                } else {
                    // Meta node is not within the given namespace and will not be added to META.
                }
            }
        } else {
            for (path in paths2MetaNodes) {
                fullName = core.getFullyQualifiedName(paths2MetaNodes[path]);
                if (result[fullName]) {
                    logger.error('Meta-nodes share the same full name. Will still proceed..', fullName);
                }

                result[fullName] = paths2MetaNodes[path];
            }
        }

        return result;
    }

    /**
     *
     * @param {object} project
     * @param {object} core
     * @param {string} commitHash
     * @param {GmeLogger} logger
     * @param {object} options
     * @param {string} [options.activeNode=''] - path to active node
     * @param {string[]} [options.activeSelection=[]] - paths to selected nodes.
     * @param {string} [options.namespace=''] - used namespace during execution ('' represents all namespaces).
     * @param callback
     * @returns {*}
     */
    function loadNodesAtCommitHash(project, core, commitHash, logger, options, callback) {
        var result = {
            commitHash: commitHash,
            rootHash: null,
            rootNode: null,
            activeNode: null,
            activeSelection: null,
            META: {}
        };

        return Q.ninvoke(project, 'loadObject', commitHash)
            .then(function (commitObject) {
                result.rootHash = commitObject.root;
                logger.debug('commitObject loaded');

                // Load root node.
                return core.loadRoot(result.rootHash);
            })
            .then(function (rootNode) {
                result.rootNode = rootNode;
                logger.debug('rootNode loaded');

                // Load active node.
                return core.loadByPath(result.rootNode, options.activeNode || '');
            })
            .then(function (activeNode) {
                result.activeNode = activeNode;
                logger.debug('activeNode loaded');

                // Load active selection.
                options.activeSelection = options.activeSelection || [];

                return Q.all(options.activeSelection.map(function (nodePath) {
                    return core.loadByPath(result.rootNode, nodePath);
                }));
            })
            .then(function (activeSelection) {
                result.activeSelection = activeSelection;
                logger.debug('activeSelection loaded');
                result.META = getMetaNodesMap(core, result.rootNode, logger, options.namespace);

                return result;
            })
            .nodeify(callback);
    }

    return {
        loadNodesAtCommitHash: loadNodesAtCommitHash,
        getMetaNodesMap: getMetaNodesMap,
    };
}));
/*globals define*/
/*eslint-env node, browser*/

/**
 * Module for finding strongly connected components in a directed graph, that is circular references.
 *
 * Based on https://gist.github.com/chadhutchins/1440602 but with constant time stack lookup.
 * https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
 *
 * The example below returns the SCC v2,v3,v4
 *     v1 -*  v2
 *            / *
 *           *   \
 *          v3 -* v4
 * @example
 *
 * var t = new Tarjan();
 *
 * t.addVertex(1);
 * t.addVertex(2);
 * t.addVertex(3);
 * t.addVertex(4);
 *
 * t.connectVertices(1, 2); // Order matters
 * t.connectVertices(2, 3);
 * t.connectVertices(3, 4);
 * t.connectVertices(4, 2);
 *
 * t.calculateSCCs();   -> [[1], [2, 3, 4]]
 * t.hasLoops(); -> true
 *
 *
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/util/tarjan',[], function () {
    'use strict';
    function Vertex(id) {
        this.id = id;
        this.connectedVertices = [];
        this.index = -1;
        this.lowlink = -1;
    }

    Vertex.prototype.connectTo = function (vertex) {
        this.connectedVertices.push(vertex);
    };

    function Graph() {
        // Assumption: ids are unique.
        this.vertices = {};
    }

    Graph.prototype.addVertex = function (id) {
        if (this.vertices.hasOwnProperty(id)) {
            return false;
        } else {
            this.vertices[id] = new Vertex(id);
            return true;
        }
    };

    Graph.prototype.connectVertices = function (id1, id2) {
        if (this.vertices.hasOwnProperty(id1) === false) {
            throw new Error('Vertex [' + id1 + '] was never added to graph!');
        }

        if (this.vertices.hasOwnProperty(id2) === false) {
            throw new Error('Vertex [' + id2 + '] was never added to graph!');
        }

        this.vertices[id1].connectTo(this.vertices[id2]);
    };

    function Tarjan() {
        this.index = 0;
        this.stackLookup = {};
        this.stack = [];
        this.graph = new Graph();
        this.SCCs = [];
        this.didRun = false;
    }

    /**
     * Adds a vertex with given id.
     * @param {string|number} id
     * @returns {boolean} false if it was already added.
     */
    Tarjan.prototype.addVertex = function (id) {
        if (this.didRun) {
            throw new Error('Cannot modify graph after algorithm ran!');
        }

        return this.graph.addVertex(id);
    };

    /**
     * Creates a connection from vertex at id1 to vertex at id2
     * @param {string|number} id1
     * @param {string|number} id2
     */
    Tarjan.prototype.connectVertices = function (id1, id2) {
        if (this.didRun) {
            throw new Error('Cannot modify graph after algorithm ran!');
        }

        this.graph.connectVertices(id1, id2);
    };

    /**
     * Checks if there are any loops in the graph.
     * @returns {boolean}
     */
    Tarjan.prototype.hasLoops = function () {
        var i;

        this.calculateSCCs();

        for (i = 0; i < this.SCCs.length; i += 1) {
            if (this.SCCs[i].length > 1) {
                return true;
            }
        }

        return false;
    };

    /**
     * Returns the strongly connected components (by ids)
     * @returns {Array<Array<String|Number>>} An array with all SCCs.
     */
    Tarjan.prototype.calculateSCCs = function () {
        var id;

        if (this.didRun === false) {
            for (id in this.graph.vertices) {
                if (this.graph.vertices[id].index < 0) {
                    this._strongConnect(this.graph.vertices[id]);
                }
            }

            this.didRun = true;
        }

        return this.SCCs;
    };

    Tarjan.prototype._strongConnect = function (vertex) {
        var i,
            connectedVertex,
            sccVertices = [],
            topVertex;
        // Set the depth index for v to the smallest unused index
        vertex.index = this.index;
        vertex.lowlink = this.index;
        this.index = this.index + 1;

        this.stack.push(vertex);
        this.stackLookup[vertex.id] = true;
        // Consider successors of vertex
        // aka... consider each vertex in vertex.connections
        for (i = 0; i < vertex.connectedVertices.length; i += 1) {
            connectedVertex = vertex.connectedVertices[i];
            if (connectedVertex.index < 0) {
                // Successor connectedVertex has not yet been visited; recurse on it
                this._strongConnect(connectedVertex);
                vertex.lowlink = Math.min(vertex.lowlink, connectedVertex.lowlink);
            } else if (this.stackLookup[connectedVertex.id]) {
                // Successor connectedVertex is in stack S and hence in the current SCC
                vertex.lowlink = Math.min(vertex.lowlink, connectedVertex.index);
            }
        }

        // If vertex is a root node, pop the stack and generate an SCC.
        if (vertex.lowlink === vertex.index) {
            // start a new strongly connected component
            if (this.stack.length > 0) {
                do {
                    topVertex = this.stack.pop();
                    this.stackLookup[topVertex.id] = false;
                    // add topVertex to current strongly connected component
                    sccVertices.push(topVertex.id);
                } while (vertex.id !== topVertex.id);
            }
            // output the current strongly connected component
            // ... i'm going to push the results to a member scc array variable
            if (sccVertices.length > 0) {
                this.SCCs.push(sccVertices);
            }
        }
    };

    return Tarjan;
});
/*globals requirejs, define*/
/*eslint-env node, browser*/
/**
 * @author pmeijer / https://github.com/pmeijer
 */

define('plugin/managerbase',[
    'common/core/coreQ',
    'plugin/PluginResult',
    'plugin/PluginMessage',
    'plugin/util',
    'common/storage/project/interface',
    'common/storage/util',
    'common/util/tarjan',
    'q',
], function (Core,
             PluginResult,
             PluginMessage,
             pluginUtil,
             ProjectInterface,
             storageUtil,
             Tarjan,
             Q) {

    'use strict';

    /**
     *
     * @param blobClient
     * @param [project]
     * @param mainLogger
     * @param gmeConfig
     * @constructor
     */
    function PluginManagerBase(blobClient, project, mainLogger, gmeConfig) {
        var self = this;

        this.logger = mainLogger.fork('PluginManagerBase');
        this.notificationHandlers = [];

        function getPluginInstance(pluginIdOrClass, callback) {
            var deferred = Q.defer(),
                pluginPath;

            function instantiatePlugin(PluginClass) {
                var plugin;

                if (!PluginClass) {
                    // This should not happen, but just in case..
                    deferred.reject(new Error('Loading plugin "' + pluginIdOrClass +
                        '" with requirejs return undefined.'));
                    return;
                }

                plugin = new PluginClass();
                if (self.serverSide && plugin.pluginMetadata.disableServerSideExecution) {
                    deferred.reject(new Error(pluginIdOrClass + ' cannot be invoked on server.'));
                } else if (self.browserSide && plugin.pluginMetadata.disableBrowserSideExecution) {
                    deferred.reject(new Error(pluginIdOrClass + ' cannot be invoked in browser.'));
                } else {
                    deferred.resolve(plugin);
                }
            }

            if (typeof pluginIdOrClass === 'function') {
                self.logger.debug('plugin class was passed wont load it with requirejs');
                instantiatePlugin(pluginIdOrClass);
            } else {
                pluginPath = 'plugin/' + pluginIdOrClass + '/' + pluginIdOrClass + '/' + pluginIdOrClass;
                self.logger.debug('requirejs plugin from path: ' + pluginPath);
                requirejs([pluginPath], instantiatePlugin,
                    function (err) {
                        deferred.reject(err);
                    }
                );
            }

            return deferred.promise.nodeify(callback);
        }

        function checkDependencies(plugin, tarjan, callback) {
            return Q.all(plugin.getPluginDependencies()
                .map(function (pluginId) {
                    if (tarjan.addVertex(pluginId) === false) {
                        // Dependency already added, just account for the connection
                        tarjan.connectVertices(plugin.getId(), pluginId);
                        return Q.resolve();
                    } else {
                        tarjan.connectVertices(plugin.getId(), pluginId);
                        return getPluginInstance(pluginId)
                            .then(function (depPluginInstance) {
                                return checkDependencies(depPluginInstance, tarjan);
                            });
                    }
                }))
                .nodeify(callback);
        }

        /**
         * These are used to determine if the user is allowed to execute a plugin based on
         * the project access level. It also determines if the user is allowed to modify certain config
         * parameters of the plugin.
         * N.B. When reading or writing to the project from the plugin the access level is always checked
         * by the storage.
         * @type {{read: boolean, write: boolean, delete: boolean}}
         */
        this.projectAccess = {
            read: true,
            write: true,
            delete: true
        };

        /**
         *
         */
        this.blobClient = blobClient;

        /**
         *
         * @param {string} pluginIdOrClass
         * @param {object} pluginConfig - configuration for the plugin.
         * @param {object} context
         * @param {string} [context.branchName] - name of branch that should be updated
         * @param {string} [context.commitHash=<%brashHash%>] - commit from which to start the plugin.
         * @param {ProjectInterface} [context.project=project] - project instance if different from the one passed in.
         * @param {string} [context.activeNode=''] - path to active node
         * @param {string[]} [context.activeSelection=[]] - paths to selected nodes.
         * @param {string} [context.namespace=''] - used namespace during execution ('' represents all namespaces).
         * @param {function} callback
         */
        this.executePlugin = function (pluginIdOrClass, pluginConfig, context, callback) {
            var pluginId = typeof pluginIdOrClass === 'string' ? pluginIdOrClass : pluginIdOrClass.metadata.id,
                plugin;

            self.initializePlugin(pluginIdOrClass)
                .then(function (plugin_) {
                    plugin = plugin_;
                    return self.configurePlugin(plugin, pluginConfig, context);
                })
                .then(function () {
                    self.runPluginMain(plugin, callback);
                })
                .catch(function (err) {
                    var pluginResult = self.getPluginErrorResult(pluginId,
                        pluginId,
                        'Exception was raised, err: ' + err.stack,
                        plugin && plugin.projectId);

                    self.logger.error(err.stack);
                    callback(err.message, pluginResult);
                });
        };

        /**
         * Retrieves plugin script files and creates instance.
         * @param {string} - pluginId
         * @param {function} callback
         * @returns {promise}
         */
        this.initializePlugin = function (pluginId, callback) {
            var plugin,
                tarjan;

            if (!self.serverSide && !self.browserSide) {
                self.logger.debug('Running as CLI - does not respect gmeConfig.plugin.allowServerExecution..');
            } else {
                if (self.serverSide && !gmeConfig.plugin.allowServerExecution) {
                    throw new Error('Plugin execution on server side is disabled from gmeConfig.');
                } else if (self.browserSide && !gmeConfig.plugin.allowBrowserExecution) {
                    throw new Error('Plugin execution on server side is disabled from gmeConfig.');
                }
            }

            return getPluginInstance(pluginId)
                .then(function (plugin_) {
                    tarjan = new Tarjan();
                    plugin = plugin_;

                    tarjan.addVertex(pluginId);
                    return checkDependencies(plugin, tarjan);
                })
                .then(function () {
                    if (tarjan.hasLoops()) {
                        throw new Error('The dependencies of ' + pluginId + ' forms a circular loop..');
                    }

                    var pluginLogger = self.logger.fork('plugin:' + pluginId);

                    plugin.initialize(pluginLogger, self.blobClient, gmeConfig);

                    plugin.notificationHandlers = self.notificationHandlers;
                    return plugin;
                })
                .nodeify(callback);
        };

        /**
         *
         * @param {object} plugin
         * @param {object} pluginConfig - configuration for the plugin.
         * @param {object} context
         * @param {string} context.branchName - name of branch that should be updated
         * @param {string} [context.commitHash=<%brashHash%>] - commit from which to start the plugin.
         * @param {ProjectInterface} [context.project=project] - project instance if different from the one passed in.
         * @param {string} [context.activeNode=''] - path to active node
         * @param {string[]} [context.activeSelection=[]] - paths to selected nodes.
         * @param {string} [context.namespace=''] - used namespace during execution ('' represents all namespaces).
         * @param {function} callback
         * @returns {promise}
         */
        this.configurePlugin = function (plugin, pluginConfig, context, callback) {
            var deferred = Q.defer(),
                self = this,
                defaultConfig = plugin.getDefaultConfig(),
                writeAccessKeys = {},
                readOnlyKeys = {},
                faultyKeys = [],
                key;

            context.project = context.project || project;

            if (context.project instanceof ProjectInterface === false) {
                deferred.reject(new Error('project is not an instance of ProjectInterface, ' +
                    'pass it via context or set it in the constructor of PluginManagerBase.'));
            } else if (plugin.pluginMetadata.writeAccessRequired === true && self.projectAccess.write === false) {
                deferred.reject(new Error('Plugin requires write access to the project for execution!'));
            } else {
                plugin.pluginMetadata.configStructure.forEach(function (configStructure) {
                    if (configStructure.writeAccessRequired === true && self.projectAccess.write === false) {
                        writeAccessKeys[configStructure.name] = true;
                    }
                    if (configStructure.readOnly === true) {
                        readOnlyKeys[configStructure.name] = true;
                    }
                });

                pluginConfig = pluginConfig || {};

                for (key in pluginConfig) {

                    if (readOnlyKeys[key] || writeAccessKeys[key]) {
                        // Parameter is not allowed to be modified, check if it was.
                        if (pluginConfig.hasOwnProperty(key) &&
                            pluginConfig[key] !== defaultConfig[key]) {
                            faultyKeys.push(key);
                        }
                    }

                    // We do allow extra config-parameters that aren't specified in the default config.
                    defaultConfig[key] = pluginConfig[key];
                }

                if (faultyKeys.length > 0) {
                    deferred.reject(new Error('User not allowed to modify configuration parameter(s): "' +
                        faultyKeys + '".'));
                } else {

                    plugin.setCurrentConfig(defaultConfig);

                    self.loadContext(context)
                        .then(function (pluginContext) {
                            plugin.configure(pluginContext);
                            deferred.resolve();
                        })
                        .catch(deferred.reject);
                }
            }

            return deferred.promise.nodeify(callback);
        };

        /**
         *
         * @param plugin
         * @param callback
         */
        this.runPluginMain = async function (plugin, callback) {
            var startTime = (new Date()).toISOString(),
                mainCallbackCalls = 0,
                multiCallbackHandled = false;

            self.logger.debug('plugin configured, invoking main');

            if (plugin.isConfigured === false) {
                callback('Plugin is not configured.', self.getPluginErrorResult(plugin.getId(), plugin.getName(),
                    'Plugin is not configured.', project && project.projectId));
                return;
            }

            let result,
                err = null;

            const expectsCallback = plugin.main.length > 0;
            const checkMultiCallbacks = () => {
                mainCallbackCalls += 1;
                if (mainCallbackCalls > 1) {
                    const stackTrace = new Error().stack;
                    self.logger.error('The main callback is being called more than once!', {metadata: stackTrace});
                    result.setError('The main callback is being called more than once!');
                    if (multiCallbackHandled === true) {
                        plugin.createMessage(null, stackTrace);
                        return;
                    }
                    multiCallbackHandled = true;
                    result.setSuccess(false);
                    plugin.createMessage(null, 'The main callback is being called more than once.');
                    plugin.createMessage(null, stackTrace);
                    callback('The main callback is being called more than once!', result);
                }
            };
            try {
                if (expectsCallback) {
                    result = await new Promise((resolve, reject) => 
                        plugin.main(function (err, res) {
                            result = res || result;
                            if (err) {
                                reject(err);
                            }
                            resolve();
                            setTimeout(checkMultiCallbacks);
                        })
                    );
                } else {
                    result = await plugin.main();
                }
            } catch (e) {
                err = e;
            }

            result = result || plugin.result;
            self.logger.debug('plugin main callback called', {result: result.serialize()});
            // set common information (meta info) about the plugin and measured execution times
            result.setFinishTime((new Date()).toISOString());
            result.setStartTime(startTime);

            result.setPluginName(plugin.getName());
            result.setPluginId(plugin.getId());

            result.setError(err);
            plugin.notificationHandlers = [];
            callback(typeof err === 'string' ? new Error(err) : err, result);
        };

        this.getPluginErrorResult = function (pluginId, pluginName, message, projectId) {
            var pluginResult = new PluginResult(),
                pluginMessage = new PluginMessage();
            pluginMessage.severity = 'error';
            pluginMessage.message = message;
            pluginResult.setSuccess(false);
            pluginResult.setPluginName(pluginName);
            pluginResult.setPluginId(pluginId);
            pluginResult.setProjectId(projectId || 'N/A');
            pluginResult.addMessage(pluginMessage);
            pluginResult.setStartTime((new Date()).toISOString());
            pluginResult.setFinishTime((new Date()).toISOString());
            pluginResult.setError(pluginMessage.message);

            return pluginResult;
        };

        function getBranchHash(project, branchName) {
            if (branchName) {
                return project.getBranchHash(branchName);
            } else {
                return Q(null);
            }
        }

        /**
         *
         * @param {object} context
         * @param {object} context.project - project form where to load the context.
         * @param {string} [context.branchName] - name of branch that should be updated
         * @param {string} [context.commitHash=<%branchHash%>] - commit from which to start the plugin.
         * @param {string} [context.activeNode=''] - path to active node
         * @param {string[]} [context.activeSelection=[]] - paths to selected nodes.
         * @param {string} [context.namespace=''] - used namespace during execution ('' represents all namespaces).
         * @param {object} pluginLogger - logger for the plugin.
         */
        this.loadContext = function (context) {
            var deferred = Q.defer(),
                pluginContext = {
                    branchName: context.branchName,
                    commitHash: context.commitHash || context.commit,

                    rootNode: null,
                    activeNode: null,
                    activeSelection: null,
                    META: {},
                    namespace: context.namespace || '',

                    project: context.project,
                    projectId: context.project.projectId,
                    projectName: storageUtil.getProjectNameFromProjectId(context.project.projectId),
                    core: new Core(context.project, {
                        globConf: gmeConfig,
                        logger: self.logger.fork('core')
                    })
                };

            self.logger.debug('loading context');
            getBranchHash(pluginContext.project, pluginContext.branchName)
                .then(function (branchHash) {
                    pluginContext.commitHash = context.commitHash || branchHash;
                    if (!pluginContext.commitHash) {
                        throw new Error('Neither commitHash nor branchHash from branch was obtained, branchName: [' +
                            context.branchName + ']');
                    }

                    return pluginUtil.loadNodesAtCommitHash(
                        pluginContext.project,
                        pluginContext.core,
                        pluginContext.commitHash,
                        self.logger,
                        context);
                })
                .then(function (result) {
                    pluginContext.rootNode = result.rootNode;
                    pluginContext.activeNode = result.activeNode;
                    pluginContext.activeSelection = result.activeSelection;
                    pluginContext.META = result.META;

                    deferred.resolve(pluginContext);
                })
                .catch(function (err) {
                    deferred.reject(err);
                });

            return deferred.promise;
        };
    }

    return PluginManagerBase;
});

/*globals define*/
/*eslint-env browser*/

/**
 * @author pmeijer / https://github.com/pmeijer
 */


define('client/pluginmanager',[
    'plugin/managerbase',
    'blob/BlobClient',
    'common/storage/project/project',
    'common/Constants',
    'common/util/key',
    'q',
    'superagent'
], function (PluginManagerBase, BlobClient, Project, CONSTANTS, generateKey, Q, superagent) {
    'use strict';

    var ROOT_PATH = '';

    /**
     *
     * @param client
     * @param storage
     * @param state
     * @param mainLogger
     * @param gmeConfig
     * @constructor
     */
    function PluginManager(client, storage, state, mainLogger, gmeConfig) {

        var self = this,
            logger = mainLogger.fork('PluginManager'),
            runningPlugins = {};

        this.getCurrentPluginContext = function (pluginId, activeNodeId, activeSelectionIds) {
            var activeNode,
                validPlugins,
                context = {
                    managerConfig: {
                        project: client.getProjectObject(),
                        branchName: client.getActiveBranchName(),
                        commitHash: client.getActiveCommitHash(),
                        activeNode: ROOT_PATH,
                        activeSelection: [],
                        namespace: ''
                    },
                    pluginConfig: null
                };

            // If executed from the Generic UI we can access the active- and selected-nodes.
            if (typeof WebGMEGlobal !== 'undefined') {
                /* eslint-disable no-undef*/
                context.managerConfig.activeSelection = WebGMEGlobal.State.getActiveSelection();
                context.managerConfig.activeNode = WebGMEGlobal.State.getActiveObject();
                /* eslint-enable no-undef*/
            }

            if (activeSelectionIds) {
                context.managerConfig.activeSelection = activeSelectionIds;
            }

            if (typeof activeNodeId === 'string') {
                context.managerConfig.activeNode = activeNodeId;
            }

            // Given the active-node we infer the namespace (user may still select another one).
            activeNodeId = context.managerConfig.activeNode;
            if (activeNodeId && pluginId) {
                activeNode = client.getNode(activeNodeId);
                if (activeNode === null) {
                    logger.warn('Getting context for non-available' + 
                        ' node is dangerous and could lead to failed plugin execution [' + 
                        pluginId + '][' + activeNodeId + '].');
                    return context;
                }
                do {
                    validPlugins = activeNode.getOwnRegistry('validPlugins');
                    if (validPlugins && validPlugins.indexOf(pluginId) > -1) {
                        // The plugin was defined at this particular node, we use the namespace of it.
                        context.managerConfig.namespace = activeNode.getNamespace();
                        break;
                    }

                    activeNode = activeNode.getBaseId() ? client.getNode(activeNode.getBaseId()) : null;
                } while (activeNode);
            }

            return context;
        };

        function getPluginMetadata(pluginId) {
            var deferred = Q.defer();

            superagent.get(gmeConfig.client.mountedPath + '/api/plugins/' + pluginId + '/metadata')
                .end(function (err, res) {
                    if (err) {
                        deferred.reject(err);
                    }
                    deferred.resolve(res.body);
                });

            return deferred.promise;
        }

        function getSanitizedManagerConfig(config) {
            var sanitized = {},
                keys = Object.keys(config);

            keys.forEach(function (key) {
                switch (key) {
                    case 'project':
                        if (typeof config.project === 'string') {
                            sanitized.project = config.project;
                        } else {
                            sanitized.project = config.project.projectId;
                        }
                        break;
                    default:
                        sanitized[key] = config[key];

                }
            });

            return sanitized;
        }

        function getSanitizedPluginContext(context) {
            var sanitized = {},
                keys = Object.keys(context);

            keys.forEach(function (key) {
                switch (key) {
                    case 'managerConfig':
                        sanitized.managerConfig = getSanitizedManagerConfig(context.managerConfig);
                        break;
                    default:
                        sanitized[key] = context[key];

                }
            });

            return sanitized;
        }

        function getSanitizedPluginEntry(pluginEntry) {
            var sanitized = {},
                keys = Object.keys(pluginEntry);

            keys.forEach(function (key) {
                switch (key) {
                    case 'plugin':
                        break;
                    case 'context':
                        sanitized.context = getSanitizedPluginContext(pluginEntry.context);
                        break;
                    default:
                        sanitized[key] = pluginEntry[key];
                }
            });

            return sanitized;
        }

        /**
         * Run the plugin in the browser.
         * @param {string|function} pluginIdOrClass - id or class for plugin.
         * @param {object} context
         * @param {object} context.managerConfig - where the plugin should execute.
         * @param {ProjectInterface} context.managerConfig.project - project (e.g. client.getProjectObject()).
         * @param {string} [context.managerConfig.activeNode=''] - path to activeNode.
         * @param {string} [context.managerConfig.activeSelection=[]] - paths to selected nodes.
         * @param {string} context.managerConfig.commitHash - commit hash to start the plugin from.
         * @param {string} [context.managerConfig.branchName] - branch which to save to.
         * @param {string} [context.managerConfig.namespace=''] - used namespace ('' represents root namespace).
         * @param {object} [context.pluginConfig=%defaultForPlugin%] - specific configuration for the plugin.
         * @param {function(err, PluginResult)} callback
         */
        this.runBrowserPlugin = function (pluginIdOrClass, context, callback) {
            var pluginEntry,
                blobClient = new BlobClient({
                    logger: logger.fork('BlobClient'),
                    relativeUrl: gmeConfig.client.mountedPath + '/rest/blob/'
                }),
                pluginManager = new PluginManagerBase(blobClient, null, mainLogger, gmeConfig),
                plugin,
                executionId;

            pluginManager.browserSide = true;

            pluginManager.projectAccess = client.getProjectAccess();

            pluginManager.notificationHandlers = [function (data, callback) {
                data.executionId = executionId;
                self.dispatchPluginNotification(data);
                callback(null);
            }];

            // pluginManager.executePlugin(pluginIdOrClass, context.pluginConfig, context.managerConfig, callback);
            pluginManager.initializePlugin(pluginIdOrClass)
                .then(function (plugin_) {
                    plugin = plugin_;

                    pluginEntry = {
                        id: plugin.getId(),
                        name: plugin.getName(),
                        plugin: plugin,
                        metadata: plugin.pluginMetadata,
                        context: context,
                        canBeAborted: plugin.pluginMetadata.canBeAborted,
                        start: Date.now(),
                        clientSide: true,
                        executionId: null,
                        result: null
                    };

                    executionId = generateKey({
                        id: pluginEntry.id,
                        name: pluginEntry.name,
                        start: pluginEntry.start
                    }, gmeConfig);
                    pluginEntry.executionId = executionId;
                    runningPlugins[executionId] = pluginEntry;

                    return pluginManager.configurePlugin(plugin, context.pluginConfig, context.managerConfig);
                })
                .then(function () {
                    return Q.ninvoke(pluginManager, 'runPluginMain', plugin);
                })
                .then(function (result) {
                    if (runningPlugins.hasOwnProperty(executionId)) {
                        delete runningPlugins[executionId];
                    } else {
                        logger.error('Running plugin registry misses entry [' + pluginEntry.id +
                            '][' + executionId + '].');
                    }
                    pluginEntry.result = result;
                    client.dispatchEvent(client.CONSTANTS.PLUGIN_FINISHED, getSanitizedPluginEntry(pluginEntry));
                    callback(null, result);
                })
                .catch(function (err) {
                    if (runningPlugins.hasOwnProperty(executionId)) {
                        delete runningPlugins[executionId];
                    } else {
                        logger.error('Running plugin registry misses entry [' + pluginEntry.id +
                            '][' + executionId + '].');
                    }
                    pluginEntry.result = null;
                    client.dispatchEvent(client.CONSTANTS.PLUGIN_FINISHED, getSanitizedPluginEntry(pluginEntry));
                    var pluginResult = pluginManager.getPluginErrorResult(
                        plugin.getId(),
                        plugin.getName(),
                        'Exception was raised, err: ' + err.stack, plugin && plugin.projectId
                    );
                    logger.error(err.stack);
                    callback(err.message, pluginResult);
                })
                .done();
        };

        /**
         * Run the plugin on the server inside a worker process.
         * @param {string|function} pluginIdOrClass - id or class for plugin.
         * @param {object} context
         * @param {object} context.managerConfig - where the plugin should execute.
         * @param {ProjectInterface|string} context.managerConfig.project - project or id of project.
         * @param {string} [context.managerConfig.activeNode=''] - path to activeNode.
         * @param {string} [context.managerConfig.activeSelection=[]] - paths to selected nodes.
         * @param {string} context.managerConfig.commitHash - commit hash to start the plugin from.
         * @param {string} [context.managerConfig.branchName] - branch which to save to.
         * @param {string} [context.managerConfig.namespace=''] - used namespace ('' represents root namespace).
         * @param {object} [context.pluginConfig=%defaultForPlugin%] - specific configuration for the plugin.
         * @param {function} callback
         */
        this.runServerPlugin = function (pluginIdOrClass, context, callback) {
            var pluginEntry,
                executionId,
                pluginId = typeof pluginIdOrClass === 'string' ? pluginIdOrClass : pluginIdOrClass.metadata.id;
            if (context.managerConfig.project instanceof Project) {
                context.managerConfig.project = context.managerConfig.project.projectId;
            }

            getPluginMetadata(pluginId)
                .then(function (metadata) {
                    pluginEntry = {
                        id: pluginId,
                        name: metadata.name,
                        plugin: null,
                        metadata: metadata,
                        context: context,
                        canBeAborted: metadata.canBeAborted,
                        start: Date.now(),
                        clientSide: false,
                        executionId: null,
                        result: null
                    };

                    executionId = generateKey({
                        id: pluginId,
                        name: pluginEntry.name,
                        start: pluginEntry.start
                    }, gmeConfig);
                    pluginEntry.executionId = executionId;
                    runningPlugins[executionId] = pluginEntry;

                    context.executionId = executionId;

                    storage.simpleRequest({
                        command: CONSTANTS.SERVER_WORKER_REQUESTS.EXECUTE_PLUGIN,
                        name: pluginId,
                        context: context
                    }, function (err, result) {
                        if (runningPlugins.hasOwnProperty(executionId)) {
                            delete runningPlugins[executionId];
                        } else {
                            logger.error('Running plugin registry misses entry [' + pluginEntry.id +
                                '][' + executionId + '].');
                        }

                        pluginEntry.result = result;
                        client.dispatchEvent(client.CONSTANTS.PLUGIN_FINISHED, getSanitizedPluginEntry(pluginEntry));
                        if (err) {
                            callback(err, err.result);
                        } else {
                            callback(null, result);
                        }
                    });
                })
                .catch(function (err) {
                    callback(err, null);
                });
        };

        /**
         * @param {string[]} pluginIds - All available plugins on the server.
         * @param {string} [nodePath=''] - Node to get the validPlugins from.
         * @returns {string[]} - Filtered plugin ids.
         */
        this.filterPlugins = function (pluginIds, nodePath) {
            var filteredIds = [],
                validPlugins,
                i,
                node;

            logger.debug('filterPluginsBasedOnNode allPlugins, given nodePath', pluginIds, nodePath);
            if (!nodePath) {
                logger.debug('filterPluginsBasedOnNode nodePath not given - will fall back on root-node.');
                nodePath = ROOT_PATH;
            }

            node = state.nodes[nodePath];

            if (!node) {
                logger.warn('filterPluginsBasedOnNode node not loaded - will fall back on root-node.', nodePath);
                nodePath = ROOT_PATH;
                node = state.nodes[nodePath];
            }

            if (!node) {
                logger.warn('filterPluginsBasedOnNode root node not loaded - will return full list.');
                return pluginIds;
            }

            validPlugins = (state.core.getRegistry(node.node, 'validPlugins') || '').split(' ');
            for (i = 0; i < validPlugins.length; i += 1) {
                if (pluginIds.indexOf(validPlugins[i]) > -1) {
                    filteredIds.push(validPlugins[i]);
                } else if (validPlugins[i] === '') {
                    // Skip empty strings..
                } else {
                    logger.warn('Registered plugin for node at path "' + nodePath +
                        '" is not amongst available plugins', pluginIds);
                }
            }

            return filteredIds;
        };

        this.dispatchPluginNotification = function (data) {
            var notification = {
                severity: data.notification.severity || 'info',
                message: '[Plugin] ' + data.pluginName + ' - ' + data.notification.message
            };

            if (typeof data.notification.progress === 'number') {
                notification.message += ' [' + data.notification.progress + '%]';
            }

            logger.debug('plugin notification', data);
            if (data.notification && data.notification.type === CONSTANTS.STORAGE.PLUGIN_NOTIFICATION_TYPE.INITIATED) {
                if (runningPlugins.hasOwnProperty(data.executionId)) {
                    runningPlugins[data.executionId].socketId = data.pluginSocketId;
                    client.dispatchEvent(client.CONSTANTS.PLUGIN_INITIATED,
                        getSanitizedPluginEntry(runningPlugins[data.executionId]));
                }
            } else {
                client.dispatchEvent(client.CONSTANTS.NOTIFICATION, notification);
                client.dispatchEvent(client.CONSTANTS.PLUGIN_NOTIFICATION, data);
            }

        };

        this.getRunningPlugins = function () {
            var sanitizedData = {},
                executionIds = Object.keys(runningPlugins);

            executionIds.forEach(function (executionId) {
                if (runningPlugins.hasOwnProperty(executionId)) {
                    sanitizedData[executionId] = getSanitizedPluginEntry(runningPlugins[executionId]);
                }
            });
            return sanitizedData;
        };

        this.abortPlugin = function (pluginExecutionId) {
            var pluginEntry = runningPlugins[pluginExecutionId];
            if (pluginEntry) {
                if (!pluginEntry.metadata.canBeAborted) {
                    throw new Error('Aborting plugin [' + pluginEntry.name + '] is not allowed.');
                }

                if (pluginEntry.clientSide) {
                    pluginEntry.plugin.onAbort();
                } else if (pluginEntry.socketId) {
                    storage.sendNotification({
                        type: CONSTANTS.STORAGE.PLUGIN_NOTIFICATION,
                        notification: {
                            toBranch: false,
                            type: CONSTANTS.STORAGE.PLUGIN_NOTIFICATION_TYPE.ABORT,
                            executionId: pluginExecutionId
                        },
                        originalSocketId: pluginEntry.socketId,
                    });
                }
            }
        };

        this.sendMessageToPlugin = function (pluginExecutionId, messageId, content) {
            var pluginEntry = runningPlugins[pluginExecutionId];
            if (pluginEntry) {
                if (pluginEntry.clientSide) {
                    pluginEntry.plugin.onMessage(messageId, content);
                } else if (pluginEntry.socketId) {
                    storage.sendNotification({
                        type: CONSTANTS.STORAGE.PLUGIN_NOTIFICATION,
                        notification: {
                            toBranch: false,
                            type: CONSTANTS.STORAGE.PLUGIN_NOTIFICATION_TYPE.MESSAGE,
                            executionId: pluginExecutionId,
                            messageId: messageId,
                            content: content
                        },
                        originalSocketId: pluginEntry.socketId,
                    });
                }
            }
        };
    }

    return PluginManager;

});

/*globals define, console*/
/*eslint-env browser*/

/**
 * @author kecso / https://github.com/kecso
 * @author pmeijer / https://github.com/pmeijer
 */

define('client/websocketRouterAccess',['common/storage/constants', 'q'], function (CONSTANTS, Q) {
    'use strict';
    class WebsocketRouterAccessClient {
        constructor(routerId, logger, send, connectReceiveFunctions) {
            this._id = routerId;
            this._logger = logger;
            this._send = send;
            this._isConnected = false;
            const handleObject = {};
            handleObject[CONSTANTS.WEBSOCKET_ROUTER_MESSAGE_TYPES.MESSAGE] = (payload) => {
                if (typeof this._onMessageHandle === 'function') {
                    this._onMessageHandle(payload);
                } else {
                    logger.warn('Receiving message without handle [' + routerId + ']');
                }
            };
            handleObject[CONSTANTS.WEBSOCKET_ROUTER_MESSAGE_TYPES.DISCONNECT] = (payload) => {
                if (typeof this._onDisconnectHandle === 'function') {
                    this._onDisconnectHandle(payload);
                } else {
                    logger.warn('Receiving disconnect without handle [' + routerId + ']');
                }
            }; 

            connectReceiveFunctions(this._id, handleObject);
        }

        connect(callback) {
            const deferred = Q.defer();

            this._send(this._id, CONSTANTS.WEBSOCKET_ROUTER_MESSAGE_TYPES.CONNECT, null, (err, data) => {
                if (!err) {
                    this._isConnected = true;
                    deferred.resolve(data);
                } else {
                    deferred.reject(err);
                }
            });

            return deferred.promise.nodeify(callback);
        }

        send(payload, callback) {
            return this._send(this._id, CONSTANTS.WEBSOCKET_ROUTER_MESSAGE_TYPES.MESSAGE, payload).nodeify(callback);
        }

        disconnect(reason, callback) {
            this._isConnected = false;
            return this._send(this._id, CONSTANTS.WEBSOCKET_ROUTER_MESSAGE_TYPES.DISCONNECT, reason).nodeify(callback);
        }

        onMessage(handleFn) {
            this._onMessageHandle = handleFn;
        }

        onDisconnect(handleFn) {
            this._onDisconnectHandle = handleFn;
        }

        isConnected() {
            return this._isConnected;
        }
    }

    /**
     * @param {string} _id - Path of node.
     * @param {GmeLogger} logger - logger.
     * @param {object} state - state of the client.
     * @param {function} storeNode - invoked when storing new nodes.
     * @constructor
     */
    function WebsocketRouterAccess(logger, client, storage) {
        const routers = {};
        const handles = {};

        function send(routerId, messageType, payload, callback) {
            const deferred = Q.defer();
            logger.debug('outgoing message to websocket router',
                {metadata: {routerId: routerId, messageType: messageType, payload: payload}});
            storage.sendWsRouterMessage(routerId, messageType, payload, (err, result) => {
                if (err) {
                    deferred.reject(err);
                } else {
                    deferred.resolve(result);
                }
            });

            return deferred.promise.nodeify(callback);
        }

        function connectHandles(routerId, clientHandles) {
            logger.debug('access binding [' +  routerId + ']');
            handles[routerId] = clientHandles;
        }

        function processMessage(routerId, messageType, payload) {
            if (handles[routerId] && routers[routerId]) {
                switch (messageType) {
                    case CONSTANTS.WEBSOCKET_ROUTER_MESSAGE_TYPES.MESSAGE:
                    case CONSTANTS.WEBSOCKET_ROUTER_MESSAGE_TYPES.DISCONNECT:
                        logger.debug('incoming message from websocket router',
                            {metadata: {routerId: routerId, messageType: messageType, payload: payload}});
                        handles[routerId][messageType](payload);
                        return;
                }
            }
            logger.debug('bad incoming message from websocket router',
                {metadata: {routerId: routerId, messageType: messageType, payload: payload}});
        }

        function getWebsocketRouterAccess(routerId) {
            logger.debug('getting websocket router access [' + routerId + ']');
            if (routers[routerId]) {
                return routers[routerId];
            } 
            
            routers[routerId] = new WebsocketRouterAccessClient(routerId, logger.fork(routerId), send, connectHandles);
            return routers[routerId];
        }


        storage.onWebsocketRouterMessage(processMessage);
        
        return {
            getWebsocketRouterAccess: getWebsocketRouterAccess
        };
    }

    return WebsocketRouterAccess;
});

/*globals define*/
/*eslint-env browser*/

/**
 * @author kecso / https://github.com/kecso
 * @author pmeijer / https://github.com/pmeijer
 */
define('client/client',[
    './logger',
    'common/storage/browserstorage',
    'common/EventDispatcher',
    'common/core/coreQ',
    './constants',
    'common/util/assert',
    'common/core/tasync',
    'common/util/guid',
    'common/core/users/metarules',
    './gmeNodeGetter',
    './gmeNodeSetter',
    './libraries',
    './gmeServerRequests',
    './stateloghelpers',
    './pluginmanager',
    './websocketRouterAccess',
    'superagent'
], function (Logger,
             Storage,
             EventDispatcher,
             Core,
             CONSTANTS,
             ASSERT,
             TASYNC,
             GUID,
             metaRules,
             getNode,
             getNodeSetters,
             getLibraryFunctions,
             getServerRequests,
             stateLogHelpers,
             PluginManager,
             WebsocketRouterAccess,
             superagent) {

    'use strict';

    function Client(gmeConfig) {
        var self = this,
            logger = Logger.create('gme:client', gmeConfig.client.log),
            storage = Storage.getStorage(logger, gmeConfig, true),
            state = {
                // CONSTANTS.STORAGE. CONNECTED/DISCONNECTED/RECONNECTED/INCOMPATIBLE_CONNECTION/CONNECTION_ERROR
                connection: null,
                renewingToken: false,
                exception: null,
                project: null,
                projectAccess: null,
                projectInfo: null,
                core: null,
                branchName: null,
                branchStatus: null, //CONSTANTS.BRANCH_STATUS. SYNC/AHEAD_SYNC/AHEAD_NOT_SYNC/PULLING/ERROR or null
                readOnlyProject: false,
                viewer: false, // This means that a specific commit is selected w/o regards to any branch.

                users: {},
                nodes: {},
                loadNodes: {},

                rootHash: null,
                rootObject: null,
                commitHash: null,

                undoRedoChain: null, //{commitHash: '#hash', rootHash: '#hash', previous: object, next: object}

                transactions: {
                    opened: 0,
                    callbacks: []
                },
                msg: '',
                gHash: 0,
                loadError: null,
                ongoingTerritoryUpdateCounter: 0,
                ongoingLoadPatternsCounter: 0,
                pendingTerritoryUpdatePatterns: {},
                loadingStatus: null,
                inLoading: false,
                loading: {
                    rootHash: null,
                    commitHash: null,
                    changedNodes: null,
                    next: null
                }

            },
            monkeyPatchKey,
            pluginManager,
            nodeSetterFunctions,
            coreLibraryFunctions,
            serverRequests,
            ROOT_PATH = '',
            //addOnFunctions = new AddOn(state, storage, logger, gmeConfig),
            loadPatternThrottled;

        EventDispatcher.call(this);

        this.CONSTANTS = CONSTANTS;

        // Internal functions
        function copy(object) {
            if (object) {
                return JSON.parse(JSON.stringify(object));
            }
            return null;
        }

        function addLoadUnloadPathToUpdates(paths) {
            var i,
                pathPieces;

            for (i = 0; i < paths.length; i += 1) {
                pathPieces = paths[i].split(CONSTANTS.CORE.PATH_SEP);
                while (pathPieces.length > 1) {
                    state.loading.changedNodes.update[pathPieces.join(CONSTANTS.CORE.PATH_SEP)] = true;
                    pathPieces.pop();
                }
            }
        }

        function wasNodeUpdated(changedNodes, node) {
            // Is changedNodes available at all?  If not (undo/redo) emit for all nodes...
            if (!changedNodes) {
                return true;
            }

            // Did the node have a collection update?
            if (changedNodes.partialUpdate[state.core.getPath(node)] === true) {
                return true;
            }

            // Did any of the base classes have a non-collection update?
            while (node) {
                if (changedNodes.update[state.core.getPath(node)] === true) {
                    return true;
                }

                node = state.core.getBase(node);
            }

            return false;
        }

        function getModifiedNodes(newerNodes) {
            var modifiedNodes = [],
                updatedMetaPaths = [],
                metaNodes,
                metaPath,
                updatePath,
                nodePath,
                i;

            // For the client these rules apply for finding the affected nodes.
            // 1. Updates should be triggered to any node that core.isTypeOf (i.e. mixins accounted for).
            // 2. Root node should always be triggered.
            // 3. loads/unloads should trigger updates for the parent chain.

            if (state.loading.changedNodes) {
                // 1. Account for mixins - i.e resolve isTypeOf.
                // Gather all meta-nodes that had an update.
                metaNodes = state.core.getAllMetaNodes(newerNodes[ROOT_PATH].node);
                for (updatePath in state.loading.changedNodes.update) {
                    if (metaNodes.hasOwnProperty(updatePath)) {
                        updatedMetaPaths.push(updatePath);
                    }
                }

                if (updatedMetaPaths.length > 0) {
                    // There are meta-nodes with updates.
                    for (metaPath in metaNodes) {
                        // For all meta nodes..
                        if (metaNodes.hasOwnProperty(metaPath)) {
                            for (i = 0; i < updatedMetaPaths.length; i += 1) {
                                // check if it is a typeOf (includes mixins) any of the updated meta-nodes
                                if (state.core.isTypeOf(metaNodes[metaPath], metaNodes[updatedMetaPaths[i]]) === true) {
                                    // if so add its path to the update nodes.
                                    state.loading.changedNodes.update[metaPath] = true;
                                }
                            }
                        }
                    }
                }
                //console.log('Update after meta considered', Object.keys(state.loading.changedNodes.update));

                // 2. Add Root node
                state.loading.changedNodes.update[ROOT_PATH] = true;

                // 3. Account for loads and unloads.
                addLoadUnloadPathToUpdates(Object.keys(state.loading.changedNodes.load));
                addLoadUnloadPathToUpdates(Object.keys(state.loading.changedNodes.unload));

                //console.log('Update after loads and unloads considered',
                //    Object.keys(state.loading.changedNodes.update));
            }

            for (nodePath in state.nodes) {
                if (state.nodes.hasOwnProperty(nodePath) && newerNodes.hasOwnProperty(nodePath) &&
                    wasNodeUpdated(state.loading.changedNodes, newerNodes[nodePath].node)) {

                    modifiedNodes.push(nodePath);
                }
            }
            //console.log('NewerNodes, modifiedNodes', Object.keys(newerNodes).length, modifiedNodes.length);
            return modifiedNodes;
        }

        //this is just a first brute implementation it needs serious optimization!!!
        function fitsInPatternTypes(path, pattern) {
            var i;

            if (pattern.items && pattern.items.length > 0) {
                for (i = 0; i < pattern.items.length; i += 1) {
                    if (self.isTypeOf(path, pattern.items[i])) {
                        return true;
                    }
                }
                return false;
            } else {
                return true;
            }
        }

        function patternToPaths(patternId, pattern, pathsSoFar) {
            var children,
                subPattern,
                i;

            if (state.nodes[patternId]) {
                pathsSoFar[patternId] = true;
                if (pattern.children && pattern.children > 0) {
                    children = state.core.getChildrenPaths(state.nodes[patternId].node);
                    subPattern = copy(pattern);
                    subPattern.children -= 1;
                    for (i = 0; i < children.length; i += 1) {
                        if (fitsInPatternTypes(children[i], pattern)) {
                            patternToPaths(children[i], subPattern, pathsSoFar);
                        }
                    }
                }
            } else {
                state.loadError++;
            }
        }

        function userEvents(userId, modifiedNodes) {
            var newPaths = {},
                startErrorLevel = state.loadError,
                loadedOrUnloaded = {},
                i,
                events = [];

            for (i in state.users[userId].PATTERNS) {
                if (state.users[userId].PATTERNS.hasOwnProperty(i)) {
                    if (state.nodes[i]) { //TODO we only check pattern if its root is there...
                        patternToPaths(i, state.users[userId].PATTERNS[i], newPaths);
                    }
                }
            }

            if (startErrorLevel !== state.loadError) {
                return; //we send events only when everything is there correctly
            }

            //deleted items
            for (i in state.users[userId].PATHS) {
                if (!newPaths[i]) {
                    events.push({etype: 'unload', eid: i});
                    loadedOrUnloaded[i] = true;
                }
            }

            //added items
            for (i in newPaths) {
                if (!state.users[userId].PATHS[i]) {
                    events.push({etype: 'load', eid: i});
                    loadedOrUnloaded[i] = true;
                }
            }

            //updated items
            for (i = 0; i < modifiedNodes.length; i++) {
                // Check that there wasn't a load or unload event for the node
                if (newPaths[modifiedNodes[i]] && !loadedOrUnloaded[modifiedNodes[i]]) {
                    events.push({etype: 'update', eid: modifiedNodes[i]});
                }
            }

            state.users[userId].PATHS = newPaths;

            //this is how the events should go
            if (events.length > 0) {
                if (state.loadError > startErrorLevel) {
                    events.unshift({etype: 'incomplete', eid: null});
                } else {
                    events.unshift({etype: 'complete', eid: null});
                }
            } else {
                events.unshift({etype: 'complete', eid: null});
            }

            state.users[userId].FN(events); //eslint-disable-line new-cap
        }

        function loadChildrenPattern(core, nodesSoFar, node, level, callback) {
            var path = core.getPath(node),
                childrenPaths = core.getChildrenPaths(node),
                childrenRelids = core.getChildrenRelids(node),
                missing = childrenPaths.length,
                error = null,
                i,
                childrenPatternLoaded = function (err) {
                    error = error || err;
                    missing -= 1;
                    if (missing === 0) {
                        callback(error);
                    }
                },
                childLoaded = function (err, child) {
                    if (err || child === null) {
                        error = error || err;
                        missing -= 1;
                        if (missing === 0) {
                            callback(error);
                        }
                    } else {
                        loadChildrenPattern(core, nodesSoFar, child, level - 1, childrenPatternLoaded);
                    }
                };

            if (!nodesSoFar[path]) {
                nodesSoFar[path] = {
                    node: node
                };
            }
            if (level > 0) {
                if (missing > 0) {
                    for (i = 0; i < childrenPaths.length; i++) {
                        if (nodesSoFar[childrenPaths[i]]) {
                            loadChildrenPattern(core,
                                nodesSoFar,
                                nodesSoFar[childrenPaths[i]].node,
                                level - 1, childrenPatternLoaded);
                        } else {
                            core.loadChild(node, childrenRelids[i], childLoaded);
                        }
                    }
                } else {
                    callback(error);
                }
            } else {
                callback(error);
            }
        }

        function loadPattern(core, id, pattern, nodesSoFar, callback) {
            //console.log('LP',id,pattern);
            //var _callback = callback;
            //callback = function(error){
            //    console.log('LPF',id,pattern);
            //    _callback(error);
            //};

            var base = null,
                baseLoaded = function () {
                    if (pattern.children && pattern.children > 0) {
                        var level = pattern.children;
                        loadChildrenPattern(core, nodesSoFar, base, level, callback);
                    } else {
                        callback(null);
                    }
                };

            if (nodesSoFar[id]) {
                base = nodesSoFar[id].node;
                baseLoaded();
            } else {
                if (!nodesSoFar[ROOT_PATH]) {
                    logger.error('pattern cannot be loaded if there is no root!!!');
                }
                base = nodesSoFar[ROOT_PATH].node;

                core.loadByPath(base, id, function (err, node) {
                    var path;
                    if (!err && node && !core.isEmpty(node)) {
                        path = core.getPath(node);
                        if (!nodesSoFar[path]) {
                            nodesSoFar[path] = {
                                node: node
                            };
                        }
                        base = node;
                        baseLoaded();
                    } else {
                        callback(err);
                    }
                });
            }
        }

        loadPatternThrottled = TASYNC.throttle(loadPattern, 1); //magic number could be fine-tuned

        function reLaunchUsers() {
            var i;
            for (i in state.users) {
                if (state.users.hasOwnProperty(i)) {
                    if (state.users[i].UI && typeof state.users[i].UI === 'object' &&
                        typeof state.users[i].UI.reLaunch === 'function') {
                        state.users[i].UI.reLaunch();
                    }
                }
            }
        }

        function _updateTerritoryAllDone(guid, patterns, error) {

            logger.debug('updateTerritory related loads finished', {
                metadata: {
                    userId: guid, patterns: patterns, error: error
                }
            });

            if (state.users[guid]) {
                state.users[guid].PATTERNS = copy(patterns);
                if (!error) {
                    userEvents(guid, []);
                }
            }
        }

        function canSwitchStates() {
            if (state.inLoading && state.ongoingTerritoryUpdateCounter === 0 &&
                state.ongoingLoadPatternsCounter === 0) {
                return true;
            }
            return false;
        }

        function switchStates() {
            //it is safe now to move the loadNodes into nodes,
            // refresh the metaNodes and generate events - all in a synchronous manner!!!
            var modifiedPaths,
                key;

            //console.time('switchStates');

            logger.debug('switching project state [C#' +
                state.commitHash + ']->[C#' + state.loading.commitHash + '] : [R#' +
                state.rootHash + ']->[R#' + state.loading.rootHash + ']');

            //console.time('getModifiedNodes');
            modifiedPaths = getModifiedNodes(state.loadNodes);
            //console.timeEnd('getModifiedNodes');
            state.nodes = state.loadNodes;
            state.loadNodes = {};
            self.getAllMetaNodes(); //This ensures that all language elements can be accessed with getNode

            state.inLoading = false;
            state.rootHash = state.loading.rootHash;
            state.loading.rootHash = null;
            state.commitHash = state.loading.commitHash;
            state.loading.commitHash = null;

            //checkMetaNameCollision(state.core, state.nodes[ROOT_PATH].node);
            //checkMixinErrors(state.core, state.nodes[ROOT_PATH].node);
            // These are checked by the meta-editor..

            for (key in state.users) {
                if (state.users.hasOwnProperty(key)) {
                    userEvents(key, modifiedPaths);
                }
            }

            if (state.loadingStatus) {
                state.loading.next(state.loadingStatus);
            } else {
                state.loading.next(null);
            }

            //console.timeEnd('switchStates');
        }

        function loadingPatternFinished(err) {
            state.loadingStatus = state.loadingStatus || err;
            state.ongoingLoadPatternsCounter -= 1;

            if (canSwitchStates()) {
                switchStates();
            }
        }

        function loading(newRootHash, newCommitHash, changedNodes, callback) {
            var i, j,
                userIds,
                patternPaths,
                patternsToLoad = [];

            if (state.ongoingLoadPatternsCounter !== 0) {
                callback(new Error('at the start of loading counter should bee zero!!! [' +
                    state.ongoingLoadPatternsCounter + ']'));
                return;
            }

            state.loadingStatus = null;
            state.loadNodes = {};
            state.loading.rootHash = newRootHash;
            state.loading.commitHash = newCommitHash;
            state.loading.next = callback;
            state.loading.changedNodes = changedNodes;

            state.core.loadRoot(state.loading.rootHash, function (err, root) {
                if (err) {
                    state.loading.next(err);
                    return;
                }

                state.inLoading = true;
                state.loadNodes[state.core.getPath(root)] = {
                    node: root
                };

                //we first only set the counter of patterns but we also generate a completely separate pattern queue
                //as we cannot be sure if all the users will remain at the point of giving the actual load command!
                userIds = Object.keys(state.users);
                for (i = 0; i < userIds.length; i += 1) {
                    state.ongoingLoadPatternsCounter += Object.keys(state.users[userIds[i]].PATTERNS || {}).length;
                    patternPaths = Object.keys(state.users[userIds[i]].PATTERNS || {});
                    for (j = 0; j < patternPaths.length; j += 1) {
                        patternsToLoad.push({
                            id: patternPaths[j],
                            pattern: copy(state.users[userIds[i]].PATTERNS[patternPaths[j]])
                        });
                    }
                }
                userIds = Object.keys(state.pendingTerritoryUpdatePatterns);
                for (i = 0; i < userIds.length; i += 1) {
                    state.ongoingLoadPatternsCounter +=
                        Object.keys(state.pendingTerritoryUpdatePatterns[userIds[i]] || {}).length;
                    patternPaths = Object.keys(state.pendingTerritoryUpdatePatterns[userIds[i]] || {});
                    for (j = 0; j < patternPaths.length; j += 1) {
                        patternsToLoad.push({
                            id: patternPaths[j],
                            pattern: copy(state.pendingTerritoryUpdatePatterns[userIds[i]][patternPaths[j]])
                        });
                    }
                }

                //empty load check
                if (state.ongoingLoadPatternsCounter === 0) {
                    if (canSwitchStates()) {
                        switchStates();
                        reLaunchUsers();
                    }
                    return;
                }

                for (i = 0; i < patternsToLoad.length; i += 1) {
                    loadPatternThrottled(state.core,
                        patternsToLoad[i].id, patternsToLoad[i].pattern, state.loadNodes, loadingPatternFinished);
                }
            });
        }

        function cleanUsersTerritories() {
            //look out as the user can remove itself at any time!!!
            var userIds = Object.keys(state.users),
                i,
                j,
                events;

            for (i = 0; i < userIds.length; i++) {
                if (state.users[userIds[i]]) {
                    events = [{eid: null, etype: 'complete'}];
                    for (j in state.users[userIds[i]].PATHS) {
                        events.push({etype: 'unload', eid: j});
                    }
                    state.users[userIds[i]].PATTERNS = {};
                    state.users[userIds[i]].PATHS = {};
                    state.users[userIds[i]].SENDEVENTS = true;
                    state.users[userIds[i]].FN(events); //eslint-disable-line new-cap
                }
            }
        }

        function logState(level, msg) {
            var indent = gmeConfig.debug ? 2 : 0;

            if (level === 'console') {
                /*eslint-disable no-console*/
                console.log('state at ' + msg,
                    stateLogHelpers.getStateLogString(self, state, gmeConfig.debug, indent));
                /*eslint-enable no-console*/
            } else {
                logger[level]('state at ' + msg,
                    stateLogHelpers.getStateLogString(self, state, gmeConfig.debug, indent));
            }
        }

        function getNewToken(callback) {
            if (state.renewingToken === false) {
                state.renewingToken = true;
                (new superagent.Request('GET', gmeConfig.client.mountedPath + '/api/user/token'))
                    .end(function (err, res) {
                        state.renewingToken = false;
                        callback(err, res.body.webgmeToken);
                    });
            } else {
                logger.debug('Awaiting token renewal..');
            }
        }

        // Forwarded functions
        function saveRoot(msg, callback) {
            var persisted,
                numberOfPersistedObjects,
                wrappedCallback,
                callbacks;

            logger.debug('saveRoot msg', msg);

            if (!state.viewer && !state.readOnlyProject && state.nodes[ROOT_PATH]) {
                if (state.msg && msg) {
                    state.msg += '\n' + msg;
                } else {
                    state.msg = msg;
                }

                if (state.transactions.opened === 0) {
                    ASSERT(state.project && state.core && state.branchName);

                    callbacks = state.transactions.callbacks;
                    state.transactions.callbacks = [];

                    wrappedCallback = function (err, result) {
                        if (err) {
                            logger.error('saveRoot failure', err);
                        } else {
                            logger.debug('saveRoot', result);
                        }

                        callbacks.forEach(function (cb) {
                            cb(err, result);
                        });
                    };

                    logger.debug('is NOT in transaction - will persist.');
                    // console.time('persist');
                    persisted = state.core.persist(state.nodes[ROOT_PATH].node);
                    // console.timeEnd('persist');
                    logger.debug('persisted', persisted);
                    numberOfPersistedObjects = Object.keys(persisted.objects).length;
                    if (numberOfPersistedObjects === 0) {
                        logger.warn('No changes after persist will return from saveRoot.');
                        wrappedCallback(null);
                        return;
                    } else if (numberOfPersistedObjects > 200) {
                        //This is just for debugging
                        logger.warn('Lots of persisted objects', numberOfPersistedObjects);
                    }

                    // Make the commit on the storage (will emit hashUpdated)
                    storage.makeCommit(
                        state.project.projectId,
                        state.branchName,
                        [state.commitHash],
                        persisted.rootHash,
                        persisted.objects,
                        state.msg,
                        wrappedCallback
                    );

                    state.msg = '';
                } else {
                    logger.debug('is in transaction - will NOT persist.');

                }
            } else {
                //TODO: Why is this set to empty here?
                state.msg = '';
                callback && callback(null);
            }
        }

        function storeNode(node /*, basic */) {
            var path;
            //basic = basic || true;
            if (node) {
                path = state.core.getPath(node);
                //state.metaNodes[path] = node;
                if (state.nodes[path]) {
                    //TODO we try to avoid this
                } else {
                    state.nodes[path] = {
                        node: node
                    };
                    //TODO this only needed when real eventing will be reintroduced
                    //_inheritanceHash[path] = getInheritanceChain(node);
                }
                return path;
            }
            return null;
        }

        // Plugin Manager
        pluginManager = new PluginManager(self, storage, state, logger, gmeConfig);
        this.getCurrentPluginContext = pluginManager.getCurrentPluginContext;
        this.runBrowserPlugin = pluginManager.runBrowserPlugin;
        this.runServerPlugin = pluginManager.runServerPlugin;
        this.filterPlugins = pluginManager.filterPlugins;
        this.dispatchPluginNotification = pluginManager.dispatchPluginNotification;
        this.getRunningPlugins = pluginManager.getRunningPlugins;
        this.abortPlugin = pluginManager.abortPlugin;
        this.sendMessageToPlugin = pluginManager.sendMessageToPlugin;

        function printCoreError(error) {
            logger.error('Faulty core usage raised an error', error);
            self.dispatchEvent(CONSTANTS.NOTIFICATION, {
                type: 'CORE',
                severity: 'error',
                message: error.message
            });
        }

        // Node setters and getters.

        nodeSetterFunctions = getNodeSetters(logger, state, saveRoot, storeNode, printCoreError);

        for (monkeyPatchKey in nodeSetterFunctions) {
            if (nodeSetterFunctions.hasOwnProperty(monkeyPatchKey)) {
                self[monkeyPatchKey] = nodeSetterFunctions[monkeyPatchKey];
            }
        }

        coreLibraryFunctions = getLibraryFunctions(logger, state, storage, saveRoot);

        for (monkeyPatchKey in coreLibraryFunctions) {
            if (coreLibraryFunctions.hasOwnProperty(monkeyPatchKey)) {
                self[monkeyPatchKey] = coreLibraryFunctions[monkeyPatchKey];
            }
        }

        serverRequests = getServerRequests(self, logger, state, storage);

        for (monkeyPatchKey in serverRequests) {
            if (serverRequests.hasOwnProperty(monkeyPatchKey)) {
                self[monkeyPatchKey] = serverRequests[monkeyPatchKey];
            }
        }

        // Main API functions (with helpers) for connecting, selecting project and branches etc.

        function closeProject(projectId, callback) {
            var prevBranchName = state.branchName;
            state.project = null;
            state.projectAccess = null;
            state.projectInfo = null;
            state.readOnlyProject = false;
            //TODO what if for some reason we are in transaction?
            storage.closeProject(projectId, function (err) {
                if (err) {
                    callback(err);
                    return;
                }

                state.core = null;
                state.branchName = null;
                state.commitHash = null;
                //self.dispatchEvent(null);
                state.patterns = {};
                //state.gHash = 0;
                state.nodes = {};
                state.loadNodes = {};
                state.loadError = 0;
                state.rootHash = null;
                //state.rootObject = null;
                state.transactions.opened = 0;
                state.transactions.callbacks = [];
                state.msg = '';

                cleanUsersTerritories();
                if (prevBranchName) {
                    self.dispatchEvent(CONSTANTS.BRANCH_CLOSED, prevBranchName);
                }

                self.dispatchEvent(CONSTANTS.BRANCH_CHANGED, null);
                self.dispatchEvent(CONSTANTS.PROJECT_CLOSED, projectId);

                callback(null);
            });
        }

        /**
         * Closes the currently open project.
         * @param {function} callback
         */
        this.closeProject = function (callback) {
            if (state.project && state.project.projectId) {
                closeProject(state.project.projectId, callback);
            } else {
                callback(new Error('There is no open project.'));
            }
        };

        this.connectToDatabase = function (callback) {
            if (self.isConnected()) {
                logger.warn('connectToDatabase - already connected');
                callback(null);
                return;
            }
            storage.open(function (connectionState) {
                state.connection = connectionState;
                if (connectionState === CONSTANTS.STORAGE.CONNECTED) {
                    //N.B. this event will only be triggered once.
                    self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, connectionState);
                    storage.webSocket.addEventListener(CONSTANTS.STORAGE.NOTIFICATION,
                        function (emitter, eventData) {
                            logger.debug('received notification', eventData);
                            if (eventData.type === CONSTANTS.STORAGE.BRANCH_ROOM_SOCKETS) {
                                self.dispatchConnectedUsersChanged(eventData);
                                // If a new socket joined our branch -> emit to the branch room letting
                                // any newly connected users know that we are in this branch too.
                                // If a socket with the same userId as us disconnected -> emit to
                                // make sure we're not deleted from the other users.
                                self.emitStateNotification();

                            } else if (eventData.type === CONSTANTS.STORAGE.PLUGIN_NOTIFICATION) {
                                self.dispatchPluginNotification(eventData);
                            } else if (eventData.type === CONSTANTS.STORAGE.ADD_ON_NOTIFICATION) {
                                self.dispatchAddOnNotification(eventData);
                            } else if (eventData.type === CONSTANTS.STORAGE.CLIENT_STATE_NOTIFICATION) {
                                self.dispatchConnectedUsersChanged(eventData);
                            } else {
                                logger.error('Unknown notification type', eventData.type, eventData);
                            }
                        }
                    );
                    reLaunchUsers();
                    callback(null);
                } else if (connectionState === CONSTANTS.STORAGE.DISCONNECTED) {
                    if (state.connection !== CONSTANTS.STORAGE.INCOMPATIBLE_CONNECTION) {
                        self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, connectionState);
                    }
                } else if (connectionState === CONSTANTS.STORAGE.RECONNECTED) {
                    self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, connectionState);
                } else if (connectionState === CONSTANTS.STORAGE.INCOMPATIBLE_CONNECTION) {
                    self.disconnectFromDatabase(function (err) {
                        if (err) {
                            logger.error(err);
                        }

                        self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, connectionState);
                    });
                } else if (connectionState === CONSTANTS.STORAGE.JWT_ABOUT_TO_EXPIRE) {
                    logger.warn('Token about is about to expire');
                    getNewToken(function (err, newToken) {
                        if (err) {
                            logger.error('Failed to renew token', err);
                            // Token will probably expire soon
                        } else {
                            storage.setToken(newToken);
                        }
                    });
                } else if (connectionState === CONSTANTS.STORAGE.JWT_EXPIRED) {
                    self.disconnectFromDatabase(function (err) {
                        if (err) {
                            logger.error(err);
                        }

                        self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, CONSTANTS.STORAGE.JWT_EXPIRED);
                    });
                } else {
                    logger.error(new Error('Connection failed error ' + connectionState));
                    self.disconnectFromDatabase(function (err) {
                        if (err) {
                            logger.error(err);
                        }

                        self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, CONSTANTS.STORAGE.CONNECTION_ERROR);
                        callback(new Error('Connection failed! ' + connectionState));
                    });
                }
            });
        };

        this.disconnectFromDatabase = function (callback) {

            function closeStorage(err) {
                storage.close(function (err2) {
                    if (state.connection !== CONSTANTS.STORAGE.INCOMPATIBLE_CONNECTION &&
                        state.connection !== CONSTANTS.STORAGE.CONNECTION_ERROR) {
                        state.connection = CONSTANTS.STORAGE.DISCONNECTED;
                    }

                    callback(err || err2);
                });
            }

            if (state.project) {
                closeProject(state.project.projectId, closeStorage);
            } else {
                closeStorage(null);
            }
        };

        /**
         * If branchName is given and it does not exist, the project will be closed and callback resolved with an error.
         * If branchName NOT given it will attempt the following in order and break if successful at any step:
         *  1) Select the master if available.
         *  2) Select any available branch.
         *  3) Select the latest commit.
         *  4) Close the project and resolve with error.
         * @param {string} projectId
         * @param {string} [branchName='master']
         * @param {function} callback
         */
        this.selectProject = function (projectId, branchName, callback) {
            if (callback === undefined && typeof branchName === 'function') {
                callback = branchName;
                branchName = undefined;
            }
            if (self.isConnected() === false) {
                callback(new Error('There is no open database connection!'));
            }
            var prevProjectId,
                branchToOpen = branchName || 'master';

            logger.debug('selectProject', projectId, branchToOpen);

            function projectOpened(err, project, branches, access) {
                if (err) {
                    callback(err);
                    return;
                }

                project.getProjectInfo(function (err, projectInfo) {
                    if (err) {
                        callback(err);
                        return;
                    }

                    state.project = project;
                    state.projectAccess = access;
                    state.projectInfo = projectInfo;
                    state.readOnlyProject = access.write === false;
                    state.core = new Core(project, {
                        globConf: gmeConfig,
                        logger: logger.fork('core')
                    });

                    logState('info', 'projectOpened');
                    logger.debug('projectOpened, branches: ', branches);
                    self.dispatchEvent(CONSTANTS.PROJECT_OPENED, projectId);

                    if (branches.hasOwnProperty(branchToOpen) === false) {
                        if (branchName) {
                            logger.error('Given branch does not exist "' + branchName + '"');
                            closeProject(projectId, function (err) {
                                if (err) {
                                    logger.error('closeProject after missing branch failed with err', err);
                                }
                                callback(new Error('Given branch does not exist "' + branchName + '"'));
                            });
                            return;
                        }
                        logger.warn('Project "' + projectId + '" did not have branch', branchToOpen);
                        branchToOpen = Object.keys(branches)[0] || null;
                        logger.debug('Picked "' + branchToOpen + '".');
                    }

                    if (branchToOpen) {
                        self.selectBranch(branchToOpen, null, function (err) {
                            if (err) {
                                callback(err);
                                return;
                            }
                            logState('info', 'selectBranch');
                            reLaunchUsers();
                            callback(null);
                        });
                    } else {
                        logger.warn('No branches available in project, will attempt to select latest commit.');
                        self.getCommits(projectId, Date.now(), 1, function (err, commitObjects) {
                            if (err || commitObjects.length === 0) {
                                logger.error(err);
                                closeProject(projectId, function (err) {
                                    if (err) {
                                        logger.error('closeProject after missing any commits failed with err', err);
                                    }
                                    callback(new Error('Project does not have any commits.'));
                                });
                                return;
                            }
                            self.selectCommit(commitObjects[0]._id, function (err) {
                                if (err) {
                                    logger.error(err);
                                    closeProject(projectId, function (err) {
                                        if (err) {
                                            logger.error('closeProject after missing any commits failed with err', err);
                                        }
                                        callback(new Error('Failed selecting commit when opening project.'));
                                    });
                                    return;
                                }
                                reLaunchUsers();
                                callback(null);
                            });
                        });
                    }
                });
            }

            if (state.project) {
                prevProjectId = state.project.projectId;
                logger.debug('A project was open, closing it', prevProjectId);

                if (prevProjectId === projectId) {
                    logger.warn('projectId is already opened', projectId);
                    callback(null);
                    return;
                }
                closeProject(prevProjectId, function (err) {
                    if (err) {
                        logger.error('problems closing previous project', err);
                        callback(err);
                        return;
                    }
                    storage.openProject(projectId, projectOpened);
                });
            } else {
                storage.openProject(projectId, projectOpened);
            }
        };

        function addModification(commitObject, clear) {
            var newItem,
                commitHash = commitObject[CONSTANTS.STORAGE.MONGO_ID],
                currItem;
            if (clear) {
                logger.debug('foreign modification clearing undo-redo chain');
                state.undoRedoChain = {
                    commitHash: commitHash,
                    rootHash: commitObject.root,
                    previous: null,
                    next: null
                };
                return;
            }

            // Check if the modification already exist, i.e. commit is from undoing or redoing.
            currItem = state.undoRedoChain;
            while (currItem) {
                if (currItem.commitHash === commitHash) {
                    return;
                }
                currItem = currItem.previous;
            }

            currItem = state.undoRedoChain;
            while (currItem) {
                if (currItem.commitHash === commitHash) {
                    return;
                }
                currItem = currItem.next;
            }

            newItem = {
                commitHash: commitHash,
                rootHash: commitObject.root,
                previous: state.undoRedoChain,
                next: null
            };
            state.undoRedoChain.next = newItem;
            state.undoRedoChain = newItem;
        }

        function canUndo() {
            var result = false;
            if (state.undoRedoChain && state.undoRedoChain.previous && state.undoRedoChain.previous.commitHash) {
                result = true;
            }

            return result;
        }

        function canRedo() {
            var result = false;
            if (state.undoRedoChain && state.undoRedoChain.next) {
                result = true;
            }

            return result;
        }

        function getBranchStatusHandler() {
            return function (branchStatus, commitQueue, updateQueue) {
                logger.debug('branchStatus changed', branchStatus, commitQueue, updateQueue);
                logState('debug', 'branchStatus');
                state.branchStatus = branchStatus;
                self.dispatchEvent(CONSTANTS.BRANCH_STATUS_CHANGED,
                    {
                        status: branchStatus,
                        commitQueue: commitQueue,
                        updateQueue: updateQueue
                    }
                );
            };
        }

        function getHashUpdateHandler() {
            return function (data, commitQueue, updateQueue, callback) {
                var commitData = data.commitData,
                    clearUndoRedo = data.local !== true,
                    commitHash = commitData.commitObject[CONSTANTS.STORAGE.MONGO_ID];
                logger.debug('hashUpdateHandler invoked. project, branch, commitHash',
                    commitData.projectId, commitData.branchName, commitHash);

                if (state.transactions.opened > 0) {
                    logger.warn('Is in transaction, will not load in changes');
                    callback(null, false); // proceed: false
                    return;
                }

                logger.debug('loading commitHash, local?', commitHash, data.local);
                loading(commitData.commitObject.root, commitHash, commitData.changedNodes, function (err, aborted) {
                    if (err) {
                        logger.error('hashUpdateHandler invoked loading and it returned error',
                            commitData.commitObject.root, err);
                        logState('error', 'hashUpdateHandler');
                        callback(err, false); // proceed: false
                    } else if (aborted === true) {
                        logState('warn', 'hashUpdateHandler');
                        callback(null, false); // proceed: false
                    } else {
                        logger.debug('loading complete for incoming rootHash', commitData.commitObject.root);
                        logState('debug', 'hashUpdateHandler');
                        //undo-redo
                        addModification(commitData.commitObject, clearUndoRedo);
                        self.dispatchEvent(CONSTANTS.UNDO_AVAILABLE, canUndo());
                        self.dispatchEvent(CONSTANTS.REDO_AVAILABLE, canRedo());
                        self.dispatchEvent(CONSTANTS.NEW_COMMIT_STATE, {
                            data: data,
                            uiState: typeof self.uiStateGetter === 'function' ? self.uiStateGetter() : null
                        });
                        callback(null, true); // proceed: true
                    }
                });
            };
        }

        /**
         * Opens the given branch and closes any open branch (even though the same branch is opened)
         * @param {string} branchName - name of branch to open.
         * @param {function} [branchStatusHandler=getDefaultCommitHandler()] - Handles returned statuses after commits.
         * @param callback
         */
        this.selectBranch = function (branchName, branchStatusHandler, callback) {
            var prevBranchName = state.branchName;
            logger.debug('selectBranch', branchName);
            if (self.isConnected() === false) {
                callback(new Error('There is no open database connection!'));
                return;
            }
            if (!state.project) {
                callback(new Error('selectBranch invoked without an opened project'));
                return;
            }

            if (branchStatusHandler) {
                logger.warn('passing branchStatusHandler is deprecated, use addHashUpdateHandler or' +
                    ' addBranchStatusHandler on the branch object instead (getProjectObject().branches[branchName]).');
            }

            function openBranch() {
                logger.debug('openBranch, calling storage openBranch', state.project.projectId, branchName);
                storage.openBranch(state.project.projectId, branchName,
                    getHashUpdateHandler(), getBranchStatusHandler(),
                    function (err /*, latestCommit*/) {
                        if (err) {
                            logger.error('storage.openBranch returned with error', err);
                            self.dispatchEvent(CONSTANTS.BRANCH_CHANGED, null);
                            callback(err);
                            return;
                        }

                        state.viewer = false;
                        state.branchName = branchName;
                        self.dispatchEvent(CONSTANTS.BRANCH_OPENED, branchName);
                        self.dispatchEvent(CONSTANTS.BRANCH_CHANGED, branchName);
                        logState('info', 'openBranch');
                        callback(null);
                    }
                );
            }

            if (prevBranchName !== null) {
                logger.debug('Branch was open, closing it first', prevBranchName);
                storage.closeBranch(state.project.projectId, prevBranchName, function (err) {
                    if (err) {
                        logger.error('Problems closing existing branch', err);
                        callback(err);
                        return;
                    }

                    state.branchName = null;
                    self.dispatchEvent(CONSTANTS.BRANCH_CLOSED, prevBranchName);
                    openBranch();
                });
            } else {
                openBranch();
            }
        };

        this.selectCommit = function (commitHash, callback) {
            self._selectCommitFilteredEvents(commitHash, null, callback);
        };

        this._selectCommitFilteredEvents = function (commitHash, changedNodes, callback) {
            var prevBranchName;

            logger.debug('selectCommit', commitHash);
            if (self.isConnected() === false) {
                callback(new Error('There is no open database connection!'));
                return;
            }
            if (!state.project) {
                callback(new Error('selectCommit invoked without open project'));
                return;
            }

            function openCommit() {
                state.viewer = true;

                state.project.loadObject(commitHash, function (err, commitObj) {
                    if (!err && commitObj) {
                        logState('info', 'selectCommit loaded commit');
                        self.dispatchEvent(CONSTANTS.BRANCH_CHANGED, null);
                        loading(commitObj.root, commitHash, changedNodes, function (err, aborted) {
                            if (err) {
                                logger.error('loading returned error', commitObj.root, err);
                                logState('error', 'selectCommit loading');
                                callback(err);
                            } else if (aborted === true) {
                                logState('warn', 'selectCommit loading');
                                callback(new Error('Loading selected commit was aborted'));
                            } else {
                                logger.debug('loading complete for selectCommit rootHash', commitObj.root);
                                logState('info', 'selectCommit loading');
                                self.dispatchEvent(CONSTANTS.BRANCH_CHANGED, null);
                                callback(null);
                            }
                        });
                    } else {
                        logger.error('Cannot view given ' + commitHash + ' commit as it\'s root cannot be loaded! [' +
                            JSON.stringify(err) + ']');
                        callback(err || new Error('commit object cannot be found!'));
                    }
                });
            }

            if (state.branchName !== null) {
                logger.debug('Branch was open, closing it first', state.branchName);
                prevBranchName = state.branchName;

                storage.closeBranch(state.project.projectId, prevBranchName, function (err) {
                    if (err) {
                        logger.error('Problems closing existing branch', err);
                        callback(err);
                        return;
                    }

                    state.branchName = null;
                    self.dispatchEvent(CONSTANTS.BRANCH_CLOSED, prevBranchName);
                    openCommit();
                });
            } else {
                openCommit();
            }
        };

        this.forkCurrentBranch = function (newName, commitHash, callback) {
            var self = this,
                activeBranchName = self.getActiveBranchName(),
                activeProjectId = self.getActiveProjectId(),
                forkName;

            logger.debug('forkCurrentBranch', newName, commitHash);
            if (!state.project) {
                callback('Cannot fork without an open project!');
                return;
            }
            if (activeBranchName === null) {
                callback('Cannot fork without an open branch!');
                return;
            }
            forkName = newName || activeBranchName + '_' + Date.now();
            storage.forkBranch(activeProjectId, activeBranchName, forkName, commitHash,
                function (err, forkHash) {
                    if (err) {
                        logger.error('Could not fork branch:', newName, err);
                        callback(err);
                        return;
                    }
                    callback(null, forkName, forkHash);
                }
            );
        };

        // State getters.
        this.isConnected = function () {
            return state.connection === CONSTANTS.STORAGE.CONNECTED ||
                state.connection === CONSTANTS.STORAGE.RECONNECTED;
        };

        this.getNetworkStatus = function () {
            return state.connection;
        };

        this.getConnectedStorageVersion = function () {
            // This is the version of the server the storage is currently connected to.
            return storage.serverVersion;
        };

        this.getBranchStatus = function () {
            return state.branchStatus;
        };

        this.getActiveProjectId = function () {
            return state.project && state.project.projectId;
        };

        this.getActiveProjectName = function () {
            return state.project && state.project.projectName;
        };

        this.getActiveProjectKind = function () {
            return state.projectInfo && state.projectInfo.info && state.projectInfo.info.kind;
        };

        this.getActiveBranchName = function () {
            return state.branchName;
        };

        this.getActiveCommitHash = function () {
            return state.commitHash;
        };

        this.getActiveRootHash = function () {
            return state.rootHash;
        };

        this.isProjectReadOnly = function () {
            return state.readOnlyProject;
        };

        this.isCommitReadOnly = function () {
            // This means that a specific commit is selected w/o regards to any branch.
            return state.viewer;
        };

        this.isReadOnly = function () {
            return state.viewer || state.readOnlyProject;
        };

        this.getProjectAccess = function () {
            return state.projectAccess;
        };

        this.getProjectInfo = function () {
            return state.projectInfo;
        };

        this.getProjectObject = function () {
            return state.project;
        };

        /**
         * Creates a new core instance using the state of the client and loads the root node.
         * @param {object} [options]
         * @param {string} [options.commitHash=%state.commitHash%] - If a different commit-hash should be loaded.
         * @param {GmeLogger} [options.logger=%clientLogger%] - Logger passed to the core instance.
         * @param {function} callback
         * @param {Error|null} callback.error - Non-null if failed to retrieve result.
         * @param {object} callback.result - The result object
         * @param {Core} callback.result.core - Newly created core instance
         * @param {Core~Node} callback.result.rootNode - The root-node that was loaded.
         * @param {string} callback.result.commitHash - The commitHash used as basis for loading root-node.
         * @param {Project} callback.result.project - A reference to the project.
         */
        this.getCoreInstance = function (options, callback) {
            options = options || {};
            options.logger = options.logger || logger.fork('core');

            var result = {
                core: null,
                rootNode: null,
                project: state.project,
                commitHash: options.commitHash || state.commitHash
            };

            function loadRootNode(rootHash) {
                result.core = new Core(state.project, {
                    globConf: gmeConfig,
                    logger: options.logger
                });

                result.core.loadRoot(rootHash)
                    .then(function (rootNode) {
                        result.rootNode = rootNode;
                        return result;
                    })
                    .nodeify(callback);
            }

            if (!state.project) {
                callback(new Error('Cannot get a core instance without an open project.'));
            } else if (options.commitHash && options.commitHash !== state.commitHash) {
                state.project.loadObject(options.commitHash, function (err, commitObj) {
                    if (err) {
                        callback(err);
                    } else if (!commitObj || commitObj.type !== CONSTANTS.STORAGE.COMMIT_TYPE) {
                        callback(new Error('Object at given commit-hash is not a commit-object.'));
                    } else {
                        loadRootNode(commitObj.root);
                    }
                });
            } else if (state.rootHash) {
                loadRootNode(state.rootHash);
            } else {
                callback(new Error('No root-hash available in state.'));
            }
        };

        this.getCommitQueue = function () {
            if (state.project && state.branchName && state.project.branches.hasOwnProperty(state.branchName)) {
                return state.project.branches[state.branchName].getCommitQueue();
            }

            return [];
        };

        this.downloadCommitQueue = function () {
            var commitQueue = self.getCommitQueue();

            if (commitQueue.length > 0) {
                stateLogHelpers.downloadCommitQueue(self, commitQueue);
                return true;
            }

            return false;
        };

        this.downloadError = function () {
            stateLogHelpers.downloadStateDump(self, state);
        };

        this.canUndo = function (branchName) {
            return branchName === state.branchName && canUndo();
        };

        this.canRedo = function (branchName) {
            return branchName === state.branchName && canRedo();
        };

        // Undo/Redo functionality
        this.undo = function (branchName, callback) {
            if (self.canUndo(branchName) === false) {
                callback(new Error('unable to make undo'));
                return;
            }

            state.undoRedoChain = state.undoRedoChain.previous;

            logState('info', 'undo [before setBranchHash]');
            storage.setBranchHash(state.project.projectId, branchName, state.undoRedoChain.commitHash, state.commitHash,
                function (err, commitResult) {
                    if (err) {
                        //TODO do we need to handle this? How?
                        callback(err);
                        return;
                    }
                    logState('info', 'undo [after setBranchHash]');
                    callback(null, commitResult);
                }
            );

        };

        this.redo = function (branchName, callback) {
            if (self.canRedo(branchName) === false) {
                callback(new Error('unable to make redo'));
                return;
            }

            state.undoRedoChain = state.undoRedoChain.next;

            logState('info', 'redo [before setBranchHash]');
            storage.setBranchHash(state.project.projectId, branchName, state.undoRedoChain.commitHash, state.commitHash,
                function (err, commitResult) {
                    if (err) {
                        //TODO do we need to handle this? How?
                        callback(err);
                        return;
                    }
                    logState('info', 'redo [after setBranchHash]');
                    callback(null, commitResult);
                }
            );
        };

        /**
         * Persists all commits in commitQueue and optionally tries to fast-forward the current branch.
         * If not fast-forwarding or it fails to do that - a new branch will be created.
         *
         * @param {commitQueue} commitQueue -
         * @param {object} [options] - optional parameters
         * @param {object} [options.fastForward] - If true will attempt to setBranchHash from current
         * branch to last in queue.
         * @param {object} [options.newBranchName=%currentBranch_time-now%] - Name of new branch if needed.
         */
        this.applyCommitQueue = function (commitQueue, options, callback) {
            var branchName = self.getActiveBranchName(),
                projectId = commitQueue[0].projectId,
                firstCommitsParents = commitQueue[0].commitObject.parents,
                lastCommitHash = commitQueue[commitQueue.length - 1].commitObject._id;

            options = options || {};
            options.newBranchName = options.newBranchName || self.getActiveBranchName() + '_' + Date.now();

            function createNewBranch() {
                storage.createBranch(projectId, options.newBranchName, lastCommitHash, callback);
            }

            storage.persistCommits(commitQueue, function (err) {
                if (err) {
                    callback(err);
                    return;
                }

                if (options.fastForward && firstCommitsParents.indexOf(self.getActiveCommitHash()) > -1) {
                    storage.setBranchHash(projectId, branchName, lastCommitHash, self.getActiveCommitHash(),
                        function (err, result) {
                            if (err) {
                                callback(err);
                            } else if (result.status !== CONSTANTS.STORAGE.SYNCED) {
                                createNewBranch();
                            } else {
                                callback();
                            }
                        }
                    );
                } else {
                    createNewBranch();
                }
            });
        };

        // REST-like functions and forwarded to storage TODO: add these to separate base class

        //  Getters
        this.getProjects = function (options, callback) {
            var asObject;
            if (self.isConnected()) {
                if (options.asObject) {
                    asObject = true;
                    delete options.asObject;
                }
                storage.getProjects(options, function (err, result) {
                    var i,
                        resultObj = {};
                    if (err) {
                        callback(err);
                        return;
                    }
                    if (asObject === true) {
                        for (i = 0; i < result.length; i += 1) {
                            resultObj[result[i]._id] = result[i];
                        }
                        callback(null, resultObj);
                    } else {
                        callback(null, result);
                    }
                });
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.getProjectsAndBranches = function (asObject, callback) {
            //This is kept for the tests.
            self.getProjects({rights: true, branches: true, asObject: asObject}, callback);
        };

        this.getBranches = function (projectId, callback) {
            if (self.isConnected()) {
                storage.getBranches(projectId, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.getTags = function (projectId, callback) {
            if (self.isConnected()) {
                storage.getTags(projectId, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.getCommits = function (projectId, before, number, callback) {
            if (self.isConnected()) {
                storage.getCommits(projectId, before, number, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.getHistory = function (projectId, start, number, callback) {
            if (self.isConnected()) {
                storage.getHistory(projectId, start, number, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.getLatestCommitData = function (projectId, branchName, callback) {
            if (self.isConnected()) {
                storage.getLatestCommitData(projectId, branchName, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        //  Setters
        this.createProject = function (projectName, parameters, callback) {
            if (self.isConnected()) {
                storage.createProject(projectName, parameters, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.deleteProject = function (projectId, callback) {
            if (self.isConnected()) {
                storage.deleteProject(projectId, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.transferProject = function (projectId, newOwnerId, callback) {
            if (self.isConnected()) {
                storage.transferProject(projectId, newOwnerId, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.duplicateProject = function (projectId, projectName, newOwnerId, callback) {
            if (self.isConnected()) {
                storage.duplicateProject(projectId, projectName, newOwnerId, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.createBranch = function (projectId, branchName, newHash, callback) {
            if (self.isConnected()) {
                storage.createBranch(projectId, branchName, newHash, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.deleteBranch = function (projectId, branchName, oldHash, callback) {
            if (self.isConnected()) {
                storage.deleteBranch(projectId, branchName, oldHash, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.createTag = function (projectId, tagName, commitHash, callback) {
            if (self.isConnected()) {
                storage.createTag(projectId, tagName, commitHash, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.deleteTag = function (projectId, tagName, callback) {
            if (self.isConnected()) {
                storage.deleteTag(projectId, tagName, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.squashCommits = function (projectId, fromCommit, toCommitOrBranch, msg, callback) {
            // logger.debug('squashing latest commits of branch: ', parameters);
            storage.squashCommits(projectId, fromCommit, toCommitOrBranch, msg, callback);
        };

        // Watchers (used in e.g. ProjectNavigator).
        /**
         * Triggers eventHandler(storage, eventData) on PROJECT_CREATED and PROJECT_DELETED.
         *
         * eventData = {
         *    etype: PROJECT_CREATED||DELETED,
         *    projectId: %id of project%
         * }
         *
         * @param {function} eventHandler
         * @param {function} [callback]
         */
        this.watchDatabase = function (eventHandler, callback) {
            callback = callback || function (err) {
                if (err) {
                    logger.error('Problems watching database room');
                }
            };
            storage.watchDatabase(eventHandler, callback);
        };

        this.unwatchDatabase = function (eventHandler, callback) {
            callback = callback || function (err) {
                if (err) {
                    logger.error('Problems unwatching database room');
                }
            };
            storage.unwatchDatabase(eventHandler, callback);
        };

        /**
         * Triggers eventHandler(storage, eventData) on BRANCH_CREATED, BRANCH_DELETED and BRANCH_HASH_UPDATED
         * for the given projectId.
         *
         *
         * eventData = {
         *    etype: BRANCH_CREATED||DELETED||HASH_UPDATED,
         *    projectId: %id of project%,
         *    branchName: %name of branch%,
         *    newHash: %new commitHash (='' when DELETED)%
         *    oldHash: %previous commitHash (='' when CREATED)%
         * }
         *
         * @param {string} projectId
         * @param {function} eventHandler
         * @param {function} [callback]
         */
        this.watchProject = function (projectId, eventHandler, callback) {
            callback = callback || function (err) {
                if (err) {
                    logger.error('Problems watching project room', projectId);
                }
            };
            storage.watchProject(projectId, eventHandler, callback);
        };

        this.unwatchProject = function (projectId, eventHandler, callback) {
            callback = callback || function (err) {
                if (err) {
                    logger.error('Problems unwatching project room', projectId);
                }
            };
            storage.unwatchProject(projectId, eventHandler, callback);
        };

        // Document handling
        this.watchDocument = storage.watchDocument.bind(storage);
        this.unwatchDocument = storage.unwatchDocument.bind(storage);
        this.sendDocumentOperation = storage.sendDocumentOperation.bind(storage);
        this.sendDocumentSelection = storage.sendDocumentSelection.bind(storage);

        // Node handling
        this.getNode = function (nodePath) {
            return getNode(nodePath, logger, state, storeNode);
        };

        this.getAllMetaNodes = function (asObject) {
            var result = asObject ? {} : [];
            if (state && state.core && state.nodes && state.nodes[ROOT_PATH]) {
                var metaNodes = state.core.getAllMetaNodes(state.nodes[ROOT_PATH].node),
                    gmeNode,
                    keys = Object.keys(metaNodes || {}),
                    i;

                for (i = 0; i < keys.length; i += 1) {
                    gmeNode = self.getNode(storeNode(metaNodes[keys[i]]), logger, state, storeNode);
                    if (asObject) {
                        result[keys[i]] = gmeNode;
                    } else {
                        result.push(gmeNode);
                    }
                }
            }

            return result;
        };

        this.checkMetaConsistency = function () {
            var result;

            if (state && state.core && state.nodes && state.nodes[ROOT_PATH]) {
                result = metaRules.checkMetaConsistency(state.core, state.nodes[ROOT_PATH].node);
            } else {
                result = [];
            }

            return result;
        };

        this.startTransaction = function (msg) {
            if (state.core) {
                state.transactions.opened += 1;
                msg = typeof msg === 'string' ? msg : '[';
                saveRoot(msg);
            } else {
                logger.error('Can not start transaction with no core available.');
            }
        };

        this.completeTransaction = function (msg, callback) {
            state.transactions.opened -= 1;
            if (callback) {
                state.transactions.callbacks.push(callback);
            }

            if (state.transactions.opened < 0) {
                state.transactions.opened = 0;
                logger.error(new Error('More calls to completeTransaction than transactions started!'));
            }

            if (state.core) {
                msg = msg || ']';
                saveRoot(msg, callback);
            }
        };

        //territory functions
        this.addUI = function (ui, fn, guid) {
            ASSERT(fn);
            ASSERT(typeof fn === 'function');
            guid = guid || GUID();
            state.users[guid] = {type: 'notused', UI: ui, PATTERNS: {}, PATHS: {}, SENDEVENTS: true, FN: fn};
            return guid;
        };

        this.removeUI = function (guid) {
            logger.debug('removeUI', guid);
            delete state.users[guid];
        };

        this._removeAllUIs = function () {
            // This is mainly intended for clean up during testing.
            logger.debug('_removeAllUIs called');
            state.users = {};
        };

        this.updateTerritory = function (guid, patterns) {
            var loadRequestCounter = 0,
                updateRequestId = GUID(),
                error = null,
                keys = Object.keys(patterns || {}),
                i,
                patternLoaded = function (err) {
                    error = error || err;
                    if (--loadRequestCounter === 0) {
                        delete state.pendingTerritoryUpdatePatterns[updateRequestId];
                        _updateTerritoryAllDone(guid, patterns, error);
                        state.ongoingTerritoryUpdateCounter -= 1;
                        if (state.ongoingTerritoryUpdateCounter < 0) {
                            logger.error('patternLoaded callback have been called multiple times!!');
                            state.ongoingTerritoryUpdateCounter = 0; //FIXME
                        }
                        if (canSwitchStates()) {
                            switchStates();
                        }
                    }
                };

            logger.debug('updatingTerritory', {
                metadata: {
                    userId: guid,
                    patterns: patterns
                }
            });

            if (!state.nodes[ROOT_PATH]) {
                if (state.users[guid]) {
                    logger.debug('early updateTerritory for user[' + guid + ']. No loaded project state yet.');
                    state.users[guid].PATTERNS = copy(patterns);
                }
                return;
            }

            //empty territory check
            if (keys.length === 0) {
                _updateTerritoryAllDone(guid, patterns, null);
                return;
            }

            state.ongoingTerritoryUpdateCounter += 1;

            //first we have to set the internal counter as the actual load can get synchronous :(
            loadRequestCounter = keys.length;

            for (i = 0; i < keys.length; i += 1) {
                if (state.inLoading) {
                    state.ongoingLoadPatternsCounter += 1;
                    loadPatternThrottled(state.core,
                        keys[i], patterns[keys[i]], state.loadNodes, loadingPatternFinished);
                } else {
                    //we should save the patterns to a pending directory
                    state.pendingTerritoryUpdatePatterns[updateRequestId] = patterns;
                }
                loadPatternThrottled(state.core, keys[i], patterns[keys[i]], state.nodes, patternLoaded);
            }

        };

        this.dispatchAddOnNotification = function (data) {
            var notification = {
                severity: data.notification.severity || 'info',
                message: '[AddOn] ' + data.addOnName + ' - ' + data.notification.message
            };

            logger.debug('addOn notification', data);
            self.dispatchEvent(CONSTANTS.NOTIFICATION, notification);
            self.dispatchEvent(CONSTANTS.ADD_ON_NOTIFICATION, data);
        };

        // Constraints
        this.setConstraint = function (path, name, constraintObj) {
            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {
                state.core.setConstraint(state.nodes[path].node, name, constraintObj);
                saveRoot('setConstraint(' + path + ',' + name + ')');
            }
        };

        this.delConstraint = function (path, name) {
            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {
                state.core.delConstraint(state.nodes[path].node, name);
                saveRoot('delConstraint(' + path + 'name' + ')');
            }
        };

        this.emitStateNotification = function () {
            var data = {
                type: CONSTANTS.STORAGE.CLIENT_STATE_NOTIFICATION,
                state: null,
                projectId: self.getActiveProjectId(),
                branchName: self.getActiveBranchName()
            };

            if (!data.projectId || !data.branchName) {
                // No need to send event if we're not a branch.
                return;
            }

            if (typeof self.uiStateGetter === 'function') {
                data.state = self.uiStateGetter();
            }
            logger.info('Sending state notification...');
            storage.sendNotification(data, function (err) {
                if (err) {
                    logger.error('Sending state notification failed', data, err);
                }

                logger.info('Sending state notification succeeded');
            });
        };

        this.dispatchConnectedUsersChanged = function (eventData) {
            self.dispatchEvent(CONSTANTS.CONNECTED_USERS_CHANGED, eventData);
        };

        this.registerUIStateGetter = function (uiStateGetter) {
            self.uiStateGetter = uiStateGetter;
        };

        //generic notification
        this.notifyUser = function (notification) {
            if (typeof notification === 'string') {
                notification = {
                    message: notification
                };
            }

            notification.severity = notification.severity || 'info';

            if (notification.message) {
                logger.debug('generic notification', notification);
                self.dispatchEvent(CONSTANTS.NOTIFICATION, notification);
            } else {
                logger.debug('cannot set empty notification');
            }
        };

        this.gmeConfig = gmeConfig;

        this.getUserId = function () {
            return storage.userId;
        };

        this.getWebsocketRouterAccess = (new WebsocketRouterAccess(
            logger.fork('websocketRouterAccess'),
            this,
            storage)).getWebsocketRouterAccess;
        
        
        window.addEventListener('error', function (evt) {
            var errorType;
            state.exception = {};
            if (evt.error) {
                state.exception.message = evt.error.message;
                state.exception.stack = evt.error.stack;
                errorType = evt.error.name;
            } else {
                state.exception = 'No error on event - check browser';
            }

            if (errorType === 'CoreIllegalOperationError') {
                // Do not propagate these errors (for now)
                self.dispatchEvent(CONSTANTS.NOTIFICATION, {
                    severity: 'error',
                    message: evt.error.message
                });

                return true;
            }

            self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, CONSTANTS.UNCAUGHT_EXCEPTION);
        });
    }

    // Inherit from the EventDispatcher
    Client.prototype = Object.create(EventDispatcher.prototype);
    Client.prototype.constructor = Client;

    return Client;
});

/*globals define, WebGMEGlobal*/
/*eslint-env node, browser*/

/**
 * Client module for creating, monitoring executor jobs.
 *
 * @author lattmann / https://github.com/lattmann
 * @author ksmyth / https://github.com/ksmyth
 * @author pmeijer / https://github.com/pmeijer
 */


define('executor/ExecutorClient',['superagent', 'q'], function (superagent, Q) {
    'use strict';

    /**
     * Client for creating, monitoring, and receiving output executor jobs.
     * This client is used by the Executor Workers and some of the API calls are not
     * meant to be used by "end users".
     *
     * @param {object} parameters
     * @param {object} parameters.logger
     * @constructor
     * @alias ExecutorClient
     */
    var ExecutorClient = function (parameters) {
        parameters = parameters || {};
        if (parameters.logger) {
            this.logger = parameters.logger;
        } else {
            /*eslint-disable no-console*/
            var doLog = function () {
                console.log.apply(console, arguments);
            };
            this.logger = {
                debug: doLog,
                log: doLog,
                info: doLog,
                warn: doLog,
                error: doLog
            };
            console.warn('Since v1.3.0 ExecutorClient requires a logger, falling back on console.log.');
            /*eslint-enable no-console*/
        }

        this.logger.debug('ctor', {metadata: parameters});

        this.isNodeJS = (typeof window === 'undefined') && (typeof process === 'object');
        this.isNodeWebkit = (typeof window === 'object') && (typeof process === 'object');
        //console.log(isNode);
        if (this.isNodeJS) {
            this.logger.debug('Running under node');
            this.server = '127.0.0.1';
            this.httpsecure = false;
        }

        this.server = parameters.server || this.server;
        this.serverPort = parameters.serverPort || this.serverPort;
        this.httpsecure = (parameters.httpsecure !== undefined) ? parameters.httpsecure : this.httpsecure;
        if (this.isNodeJS) {
            this.http = this.httpsecure ? require('https') : require('http');
        }

        this.origin = '';
        if (this.httpsecure !== undefined && this.server && this.serverPort) {
            this.origin = (this.httpsecure ? 'https://' : 'http://') + this.server + ':' + this.serverPort;
        }
        if (parameters && typeof parameters.relativeUrl === 'string') {
            this.relativeUrl = parameters.relativeUrl;
        } else if (typeof WebGMEGlobal !== 'undefined' && WebGMEGlobal.gmeConfig &&
            typeof WebGMEGlobal.gmeConfig.client.mountedPath === 'string') {
            this.relativeUrl = WebGMEGlobal.gmeConfig.client.mountedPath + '/rest/executor/';
        } else {
            this.relativeUrl = '/rest/executor/';
        }
        this.executorUrl = this.origin + this.relativeUrl;

        this.executorNonce = parameters.executorNonce;
        this.apiToken = parameters.apiToken;
        this.webgmeToken = parameters.webgmeToken;

        this.logger.debug('origin', this.origin);
        this.logger.debug('executorUrl', this.executorUrl);
    };

    /**
     * Creates a new configuration object for the job execution.
     *
     * To make the worker post output either the outputInterval and/or outputSegmentSize must be specified.
     * <br> - If both are negative (or falsy) no output will be given.
     * <br> - When both are specified a timeout will be set at start (and after each posted output).
     * If the number of lines exceeds outputSegmentSize during that timeout, the output will be posted and a
     * new timeout will be triggered.
     * <br>
     * N.B. even though a short outputInterval is set, the worker won't post new output until the responses from
     * previous posts have returned. Before the job returns with a "completed" status code, all queued outputs will be
     * posted (and the responses will be ensured to have returned).
     *
     * @param {string} cmd - command to execute.
     * @param {string[]} [args] - command arguments.
     * @param {number} [outputInterval=-1] - max time [ms] between (non-empty) output posts from worker.
     * @param {number} [outputSegmentSize=-1] - number of lines before new output is posted from worker. (N.B. posted
     * segments can still contain more number of lines).
     * @return {object}
     */
    ExecutorClient.prototype.getNewExecutorConfig = function (cmd, args, outputInterval, outputSegmentSize) {
        var config = {
            cmd: cmd,
            resultArtifacts: [],
            outputSegmentSize: typeof outputSegmentSize === 'number' ? outputSegmentSize : -1,
            outputInterval: typeof outputInterval === 'number' ? outputInterval : -1
        };

        if (args) {
            config.args = args;
        }

        /**
         *
         * @param {string} name - name of the artifact.
         * @param {string[]} [patterns=[]] - inclusive pattern for files to be returned in this artifact.
         */
        config.defineResultArtifact = function (name, patterns) {
            this.resultArtifacts.push({
                name: name,
                resultPatterns: patterns || []
            });
        };

        return config;
    };

    /**
     * Creates a new job.
     *
     * @param {object} jobInfo - initial information about the job must contain the hash.
     * @param {object} jobInfo.hash - a unique id for the job (e.g. the hash of the artifact
     * containing the executor_config.json).
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {@link JobInfo} <b>result</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    ExecutorClient.prototype.createJob = function (jobInfo, callback) {
        var deferred = Q.defer(),
            self = this;
        if (typeof jobInfo === 'string') {
            jobInfo = {hash: jobInfo}; // old API
        }

        this.logger.debug('createJob', {metadata: jobInfo});
        this.sendHttpRequestWithData('POST', this.getCreateURL(jobInfo.hash), jobInfo, function (err, response) {
            if (err) {
                deferred.reject(err);
                return;
            }

            self.logger.debug('createJob - result', response);

            deferred.resolve(JSON.parse(response));
        });

        return deferred.promise.nodeify(callback);
    };

    ExecutorClient.prototype.cancelJob = function (jobInfoOrHash, secret, callback) {
        var deferred = Q.defer(),
            hash = typeof jobInfoOrHash === 'string' ? jobInfoOrHash : jobInfoOrHash.hash,

            self = this;

        this.logger.debug('cancel', hash);
        this.sendHttpRequestWithData('POST', this.executorUrl + 'cancel/' + hash, {secret: secret},
            function (err, response) {
                if (err) {
                    deferred.reject(err);
                    return;
                }

                self.logger.debug('cancel - result', response);
                deferred.resolve(response);
            }
        );

        return deferred.promise.nodeify(callback);
    };

    ExecutorClient.prototype.updateJob = function (jobInfo, callback) {
        var deferred = Q.defer(),
            self = this;
        this.logger.debug('updateJob', {metadata: jobInfo});
        this.sendHttpRequestWithData('POST', this.executorUrl + 'update/' + jobInfo.hash, jobInfo,
            function (err, response) {
                if (err) {
                    deferred.reject(err);
                    return;
                }

                self.logger.debug('updateJob - result', response);
                deferred.resolve(response);
            }
        );

        return deferred.promise.nodeify(callback);
    };

    /**
     * Retrieves the current state of the job in form of a {@link JobInfo}
     * @param {string} hash - unique id for the job (e.g. the hash of the artifact containing the executor_config.json).
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {@link JobInfo} <b>jobInfo</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    ExecutorClient.prototype.getInfo = function (hash, callback) {
        var deferred = Q.defer(),
            self = this;
        this.logger.debug('getInfo', hash);
        this.sendHttpRequest('GET', this.getInfoURL(hash), function (err, response) {
            if (err) {
                deferred.reject(err);
                return;
            }

            self.logger.debug('getInfo - result', response);
            deferred.resolve(JSON.parse(response));
        });

        return deferred.promise.nodeify(callback);
    };

    ExecutorClient.prototype.getAllInfo = function (callback) {
        var deferred = Q.defer(),
            self = this;
        this.logger.debug('getAllInfo');
        this.sendHttpRequest('GET', this.executorUrl, function (err, response) {
            if (err) {
                deferred.reject(err);
                return;
            }

            self.logger.debug('getAllInfo - result', response);
            deferred.resolve(JSON.parse(response));
        });

        return deferred.promise.nodeify(callback);
    };

    ExecutorClient.prototype.getInfoByStatus = function (status, callback) {
        var deferred = Q.defer(),
            self = this;
        this.logger.debug('getInfoByStatus', status);
        this.sendHttpRequest('GET', this.executorUrl + '?status=' + status, function (err, response) {
            if (err) {
                deferred.reject(err);
                return;
            }
            self.logger.debug('getInfoByStatus - result', response);
            deferred.resolve(JSON.parse(response));
        });

        return deferred.promise.nodeify(callback);
    };

    ExecutorClient.prototype.getWorkersInfo = function (callback) {
        var deferred = Q.defer(),
            self = this;
        this.logger.debug('getWorkersInfo');
        this.sendHttpRequest('GET', this.executorUrl + 'worker', function (err, response) {
            if (err) {
                deferred.reject(err);
                return;
            }
            self.logger.debug('getWorkersInfo - result', response);
            deferred.resolve(JSON.parse(response));
        });

        return deferred.promise.nodeify(callback);
    };

    /**
     * Retrieves the output associated with jobHash, to limit the output pass start and/or end.
     * The outputs are identified by 0, 1, 2, ...
     * @param {string} hash - hash of job related to output.
     * @param {number} [start] - number/id of the output segment to start from (inclusive).
     * @param {number} [end] - number/id of segment to end at (exclusive).
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {@link OutputInfo} <b>result</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    ExecutorClient.prototype.getOutput = function (hash, start, end, callback) {
        var deferred = Q.defer(),
            url = this.executorUrl + 'output/' + hash,
            query = '';

        if (typeof start === 'number') {
            query += '?start=' + start;
        }

        if (typeof end === 'number') {
            if (query) {
                query += '&end=' + end;
            } else {
                query += '?end=' + end;
            }
        }

        url += query;

        this.logger.debug('getOutput, url=', url);

        this.sendHttpRequest('GET', url, function (err, response) {
            if (err) {
                deferred.reject(err);
            } else {
                deferred.resolve(JSON.parse(response));
            }
        });

        return deferred.promise.nodeify(callback);
    };

    ExecutorClient.prototype.sendOutput = function (outputInfo, callback) {
        var deferred = Q.defer(),
            url = this.executorUrl + 'output/' + outputInfo.hash;

        this.logger.debug('sendOutput', outputInfo._id);

        this.sendHttpRequestWithData('POST', url, outputInfo, function (err) {
            if (err) {
                deferred.reject(err);
            } else {
                deferred.resolve();
            }
        });

        return deferred.promise.nodeify(callback);
    };

    //<editor-fold desc="Helper methods">
    ExecutorClient.prototype.getInfoURL = function (hash) {
        return this.origin + this.getRelativeInfoURL(hash);
    };

    ExecutorClient.prototype.getRelativeInfoURL = function (hash) {
        var metadataBase = this.relativeUrl + 'info';
        if (hash) {
            return metadataBase + '/' + hash;
        } else {
            return metadataBase;
        }
    };

    ExecutorClient.prototype.getCreateURL = function (hash) {
        return this.origin + this.getRelativeCreateURL(hash);
    };

    ExecutorClient.prototype.getRelativeCreateURL = function (hash) {
        var metadataBase = this.relativeUrl + 'create';
        if (hash) {
            return metadataBase + '/' + hash;
        } else {
            return metadataBase;
        }
    };

    ExecutorClient.prototype.sendHttpRequest = function (method, url, callback) {
        return this.sendHttpRequestWithData(method, url, null, callback);
    };

    ExecutorClient.prototype.sendHttpRequestWithData = function (method, url, data, callback) {
        var req = new superagent.Request(method, url);
        if (this.executorNonce) {
            req.set('x-executor-nonce', this.executorNonce);
        }
        if (this.apiToken) {
            req.set('x-api-token', this.apiToken);
        }
        if (this.webgmeToken) {
            req.set('Authorization', 'Bearer ' + this.webgmeToken);
        }
        if (data) {
            req.send(data);
        }
        req.end(function (err, res) {
            if (err) {
                callback(err);
                return;
            }
            if (res.status > 399) {
                callback(res.status, res.text);
            } else {
                callback(null, res.text);
            }
        });
    };

    ExecutorClient.prototype._ensureAuthenticated = function (options, callback) {
        //this function enables the session of the client to be authenticated
        //TODO currently this user does not have a session, so it has to upgrade the options always!!!
        //        if (options.headers) {
        //            options.headers.webgmeclientsession = this._clientSession;
        //        } else {
        //            options.headers = {
        //                'webgmeclientsession': this._clientSession
        //            }
        //        }
        callback(null, options);
    };
    //</editor-fold>

    return ExecutorClient;
});

/*globals define, GME*/
/*eslint-env browser*/
/*eslint no-console: 0*/

/**
 * @author kecso / https://github.com/kecso
 * @author lattmann / https://github.com/lattmann
 * @author nabana / https://github.com/nabana
 * @author ksmyth / https://github.com/ksmyth
 * @author pmeijer / https://github.com/pmeijer
 */

define('webgme.classes', [
    'client/client',
    'blob/BlobClient',
    'executor/ExecutorClient',
    'common/core/core',
    'common/storage/browserstorage',
    'client/logger',
    'superagent',
    'q',
    'chance'
], function (Client,
             BlobClient,
             ExecutorClient,
             Core,
             Storage,
             logger,
             superagent,
             Q,
             chance) {

    'use strict';
    // Setting global classes
    GME.classes.Client = Client;
    GME.classes.BlobClient = BlobClient;
    GME.classes.ExecutorClient = ExecutorClient;
    GME.classes.Core = Core;
    GME.classes.Storage = Storage;
    GME.classes.logger = logger;

    // Exposing built in libraries
    GME.utils.superagent = superagent;
    GME.utils.Q = Q;
    GME.utils.chance = chance;

    // Pure JavaScript equivalent to jQuery's $.ready() from https://github.com/jfriend00/docReady

    (function (funcName, baseObj) {
        // The public function name defaults to window.docReady
        // but you can pass in your own object and own function name and those will be used
        // if you want to put them in a different namespace
        funcName = funcName || 'docReady';
        baseObj = baseObj || window;
        var readyList = [];
        var readyFired = false;
        var readyEventHandlersInstalled = false;

        // call this when the document is ready
        // this function protects itself against being called more than once
        function ready() {
            if (!readyFired) {
                // this must be set to true before we start calling callbacks
                readyFired = true;
                for (var i = 0; i < readyList.length; i++) {
                    // if a callback here happens to add new ready handlers,
                    // the docReady() function will see that it already fired
                    // and will schedule the callback to run right after
                    // this event loop finishes so all handlers will still execute
                    // in order and no new ones will be added to the readyList
                    // while we are processing the list
                    readyList[i].fn.call(window, readyList[i].ctx);
                }
                // allow any closures held by these functions to free
                readyList = [];
            }
        }

        function readyStateChange() {
            if (document.readyState === 'complete') {
                ready();
            }
        }

        // This is the one public interface
        // docReady(fn, context);
        // the context argument is optional - if present, it will be passed
        // as an argument to the callback
        baseObj[funcName] = function (callback, context) {
            // if ready has already fired, then just schedule the callback
            // to fire asynchronously, but right away
            if (readyFired) {
                setTimeout(function () {
                    callback(context);
                }, 1);
                return;
            } else {
                // add the function and context to the list
                readyList.push({fn: callback, ctx: context});
            }
            // if document already ready to go, schedule the ready function to run
            if (document.readyState === 'complete') {
                setTimeout(ready, 1);
            } else if (!readyEventHandlersInstalled) {
                // otherwise if we don't have event handlers installed, install them
                if (document.addEventListener) {
                    // first choice is DOMContentLoaded event
                    document.addEventListener('DOMContentLoaded', ready, false);
                    // backup is window load event
                    window.addEventListener('load', ready, false);
                } else {
                    // must be IE
                    document.attachEvent('onreadystatechange', readyStateChange);
                    window.attachEvent('onload', ready);
                }
                readyEventHandlersInstalled = true;
            }
        };
    })('docReady', window);

    // See if there is handler attached to body tag when ready

    var evalOnGmeInit = function () {
        if (document.body.getAttribute('on-gme-init')) {
            eval(document.body.getAttribute('on-gme-init'));
        } else {
            console.warn('To use GME, define a javascript function and set the body ' +
            'element\'s on-gme-init property.');
        }
    };

    // wait for document.readyState !== 'loading' and getGmeConfig
    var stillLoading = 2;
    var somethingFinishedLoading = function () {
        if (--stillLoading === 0) {
            evalOnGmeInit();
        }
    };

    if (document.readyState === 'loading') {
        // eslint-disable-next-line
        docReady(function () {
            somethingFinishedLoading();
            requestGmeConfig();
        });
    } else {
        somethingFinishedLoading();
        requestGmeConfig();
    }

    function requestGmeConfig() {
        var http = new XMLHttpRequest(),
            mountPath = '',
            mountElm = document.getElementById('mounted-path'),
            configUrl;

        if (mountElm && mountElm.getAttribute('content')) {
            mountPath = mountElm.getAttribute('content');
        }

        configUrl = window.location.origin + mountPath + '/gmeConfig.json';
        http.onreadystatechange = function () {
            if (http.readyState === 4 && http.status === 200) {
                GME.gmeConfig = JSON.parse(http.responseText);
                somethingFinishedLoading();
            } else if (http.readyState === 4 && http.status !== 200) {
                console.warn('Could not load gmeConfig at', configUrl);
                somethingFinishedLoading();
            }
        };
        http.open('GET', configUrl, true);
        http.send();
    }
});


require(["webgme.classes"]);
}());

//# sourceMappingURL=webgme.classes.build.js.map